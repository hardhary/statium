#!/usr/bin/env python

import sys, os, math, tempfile, string, random, time, pickle
try: from numpy import *
except: builder = True
#from scipy import interpolate
try: from scipy import stats
except: builder = True
#sys.path.insert(0,'/home/secoops/noops/lib/python/')
#from Bio.PDB import *
#from Bio.PDB.Fold import *
#import re
#import StringIO, linecache, re
#from scipy.stats import *

##### SERVER PAGES #####

def TSP_rama_generate_form():
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'Model refinement analysis')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    ##### SEQUENCE INFO #####
    sequence_string = '<p>WARNING: This site might not work on older Internet Explorer or Safari; it\'s best to try Firefox, Chrome, or other. Thanks! P.S. You need Java!</p><p>Please cite the following:</p><p>Automated real-space refinement of protein crystal structures using a realistic backbone move set. *(unpublished) Esmael J. Haddadian, Haipeng Gong, Abhishek K. Jha, Xiaojing Yang, Joe DeBartolo, James Hinshaw, Phoebe A. Rice, Tobin R. Sosnick and Karl F. Freed<p>\n<H3>Upload two models for quality comparison (if you don\'t have two, upload the same one twice):<br></H3<form action = "energy.cgi" method = "POST" enctype = "multipart/form-data">\n<input type="file" name="file_1">\n<br>\n<br>\n<input type="file" name="file_2">\n<br>\n<br>\n<br>\n<input type="submit" value=\"evaluate!\" onClick=\"progress_update()\">\n</form><br>\n' + progress_bar()
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def psi_phi_mirror_generate_form(img_str):
  
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'psi phi map')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    ##### SEQUENCE INFO #####
    sequence_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<H3>Upload a pdb model to view the psi phi map:<br></H3<form action = "psi_phi_map.cgi" method = "POST" enctype = "multipart/form-data">\n<input type="file" name="file_1">\n<br>\n<br>\n<input type="submit" value=\"get map!\">\n</form>\n<br>\n<img src = \"' + img_str + '\" style=\"float:left\" />'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def refine_generate_form():
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'Crystallographic structure refinement')
    header_string = header_string.replace('REPLACETITLE', 'structure refinement')
    
    ##### SEQUENCE INFO #####
    sequence_string = '<p><font color=\"red\"> All submitted data are kept confidential and all records are deleted after completion</font>\n<br>\nAutomated real-space refinement of protein crystal structures using a realistic backbone move set. *(unpublished) Esmael J. Haddadian, Haipeng Gong, Abhishek K. Jha, Xiaojing Yang, Joe DeBartolo, James Hinshaw, Phoebe A. Rice, Tobin R. Sosnick and Karl F. Freed\n<br>\n<a href=\"http://godzilla.uchicago.edu/pages/refinement_details.html\">click here for method description</a>\n<p>\n<H2><font color="blue">STEP 1:</font> Backbone refinement stage\n<br>\n</H2>\n<H3><dd>Upload a PDB model:\n</dd></H3><form action = "refine.cgi" method = "POST" enctype = "multipart/form-data">\n<p><dd><input type="file" name="file_1"><a href=\"#\" class=\"hintanchor\" onMouseover=\"showhint(\'Upload a PDB-formatted file that contains the 3D coordinates of the protein you want to refine. Non-protein atoms will be removed from the model.\', this, event, \'150px\')\"><font color="red" size=5>?</font></a></dd></p>\n<br>\n<br>\n<H2><font color="blue">STEP 2: </font>Refinement against electron density<H2>\n<H3><dd>Upload a CNS or SITUS file for density fitting of Step 1 results:\n</dd></H3>\n<p><dd><input type="file" name="file_3"><a href=\"#\" class=\"hintanchor\" onMouseover=\"showhint(\'Loading a CNS-formatted electron density file here will cause your protein to be fit into that density after the optimization of the backbone torsional angles in step 1. If you do not upload a file here, your backbone angles will be improved, but your 3d coordinates may deviate from what your experimental data suggest.\', this, event, \'150px\')\"><font color="red" size=5>?</font></a></dd></p>\n<br>\n<dd><font size=3 style=bold >Mask ligands from the density map, automatically?</font></dd>\n<dd><INPUT TYPE="radio" NAME="mask_ligands" VALUE="1" CHECKED>yes</dd>\n<dd><INPUT TYPE="radio" NAME="mask_ligands" VALUE="0">no, I would prefer to do this myself</dd><br><br>\n<H2><font color="blue">STEP 3:</font> Enter your email address here</H2>\n<INPUT Name=\"email\">\n<br>\n<br><br><br>\n<input type="submit" style="height: 50px; width: 200px; font-size:120%; color:blue" value=\"submit refine job!\">\n<br>\n<br><br><p><font color="red"> &#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95&#95</font></p>\n<H2><font color="red">Only change the following parameters if you are an advanced user</font></H2>\n<a href=\"http://godzilla.uchicago.edu/pages/refinement_details.html\">click here for a description of advanced parameters</a>\n<H4>stage1 energy weights:</H4>\ndope<INPUT Name=\"dope1\" SIZE="3" MAXLENGTH="7" VALUE="0.0">&#160&#160&#160&#160&#160tsp<INPUT Name=\"tsp1\" SIZE="3" MAXLENGTH="7" VALUE="5.0">&#160&#160&#160&#160&#160tspNN<INPUT Name=\"tspNN1\" SIZE="3" MAXLENGTH="7" VALUE="20.0">&#160&#160&#160&#160&#160contact energy<INPUT Name=\"nce1\" SIZE="3" MAXLENGTH="7" VALUE="2.0">&#160&#160&#160&#160&#160hbonds<INPUT Name=\"bmk1\" SIZE="3" MAXLENGTH="7" VALUE="50.0">\n<H4>stage1 move set:</H4><select name="dc1">\n<option value="yes">double crank</option>\n<option value="no">single pivot</option>\n</select>\n<br>\n' + '<H4>stage2 energy weights:</H4>\ndope<INPUT Name=\"dope2\" SIZE="3" MAXLENGTH="7" VALUE="1.0">&#160&#160&#160&#160&#160tsp<INPUT Name=\"tsp2\" SIZE="3" MAXLENGTH="7" VALUE="10.0">&#160&#160&#160&#160&#160tspNN<INPUT Name=\"tspNN2\" SIZE="3" MAXLENGTH="7" VALUE="10.0">&#160&#160&#160&#160&#160contact energy<INPUT Name=\"nce2\" SIZE="3" MAXLENGTH="7" VALUE="1.0">&#160&#160&#160&#160&#160hbonds<INPUT Name=\"bmk2\" SIZE="3" MAXLENGTH="7" VALUE="100.0">\n<H4>stage2 move set:</H4><select name="dc2">\n<option value="yes">double crank</option>\n<option value="no">single pivot</option>\n</select>\n<br>\n' + '<H4>stage3 energy weights:</H4>\ndope<INPUT Name=\"dope3\" SIZE="3" MAXLENGTH="7" VALUE="1.0">&#160&#160&#160&#160&#160tsp<INPUT Name=\"tsp3\" SIZE="3" MAXLENGTH="7" VALUE="10.0">&#160&#160&#160&#160&#160tspNN<INPUT Name=\"tspNN3\" SIZE="3" MAXLENGTH="7" VALUE="20.0">&#160&#160&#160&#160&#160contact energy<INPUT Name=\"nce3\" SIZE="3" MAXLENGTH="7" VALUE="1.0">&#160&#160&#160&#160&#160hbonds<INPUT Name=\"bmk3\" SIZE="3" MAXLENGTH="7" VALUE="200.0">\n<H4>stage3 move set:</H4><select name="dc3">\n<option value="yes">double crank</option>\n<option value="no">single pivot</option>\n</select>\n<br>\n<br>\n</form>'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def ItFix_generate_form():
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'ItFix protein folding')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    ##### GRATUITOUS GRAPHICS #####
    graphics_string = '\t<img src = \"../img/T1c8c_movie.gif\" height=\"250\" width=\"200\" style=\"float:right\" />\n'
    
    ##### PASSWORD FIELD #####
    password_string = '\t<H3>Username and password</H3>\n\t<TABLE BORDER = 0>\n\t\t<FORM METHOD = post ACTION = \"oops.cgi\">\n\t\t<TR><TH>Username:</TH><TD><INPUT TYPE = text NAME = \"username\"></TD><TR>\n\t\t<TR><TH>Password:</TH><TD><INPUT TYPE = password NAME = \"password\"></TD></TR>\n\t</TABLE>\n\t<br><br>\n'
    
    ##### SEQUENCE INFO #####
    sequence_string = '\t<H3>Enter sequence Information for secondary and tertiary structure prediction</H3>\nname of protein: <INPUT Name=\"target\">\n\t<br><br>\nPaste your sequence data here:<br>\n\t<TEXTAREA NAME=\"seq\" ROWS=8 COLS=60 ALIGN=TOP></TEXTAREA><br>\n\t<br><br>\n'
  
    ##### EMAIL AND SUBMISSION #####
    email_string = '\t<H3>Email address</H3>\nEmail: <INPUT Name=\"email\">\n\t<INPUT TYPE = hidden NAME = \"action\" VALUE = \"display\">\n\t<pre><INPUT TYPE=\"submit\" VALUE=\"fold!\"></pre>\n\t</FORM>\n'
    
    sequence_string = graphics_string + password_string + sequence_string + email_string
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def unfolded_generate_form():
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'unfolded state')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')

    sequence_string = '<br><FORM METHOD = post ACTION = \
    \"unfolded.cgi\">\n\t<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<H3>Sequence Information</H3>\ngive a name to your AA sequence (no spaces!): <INPUT Name=\"target\">\n\t<br><br>\nPaste your AA sequence data here (400 aa limit, standard 20 aa only, single letter FASTA format, single line with no header!):<br>\n\t<TEXTAREA NAME=\"seq\" ROWS=8 COLS=60 ALIGN=TOP></TEXTAREA><br>\n\t<br><br>\n\thow many models do you want?: <INPUT Name=\"n_jobs\" SIZE="6" MAXLENGTH="10">\n\t<br><br>\n<H3>Email address</H3>\nEmail: <INPUT Name=\"email\">\n\t<INPUT TYPE = hidden NAME = \"action\" VALUE = \
    \"display\">\n\t<pre><INPUT TYPE=\"submit\" VALUE=\"unfold!\"></pre>\n\t</FORM><br><br>'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def bcl2_generate_form():
  
    sequence_string = '<FORM METHOD = post ACTION = \
    \"energy.cgi\">\n\t<H3>Enter BH3 sequence Information</H3>\n<br>\nPaste your BH3 AA sequence data here using the exact Bim frame PEIWIAQELRRIGDEFNAYYARR (Standard 20 aa only, single letter FASTA format, separate line each) The following example works:<br><br>PEIWIAQELRRIGDEFNAYYARR<br>PEIWIAQEIDRIGDETNAYYARR<br><br>\n\t<TEXTAREA NAME=\"seq\" ROWS=8 COLS=60 ALIGN=TOP></TEXTAREA><br>\n\t<br>\n\t<INPUT TYPE = hidden NAME = \"action\" VALUE = \
    \"display\">\n\t<pre><INPUT TYPE=\"submit\" VALUE=\"Evaluate\"></pre>\n\t</FORM><br><br>'
    print sequence_string
    
def DOPE_PW_generate_form():
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'dope-PW pair energy')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    ##### SEQUENCE INFO #####
    sequence_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<H4>Choose the interaction type:</H4>\n<form action = "pair_energy.cgi" method = "POST" enctype = "multipart/form-data">\nChoose Amino Acid 1:\n<br>\n<select name="AA1">\n<option value="A">ALA</option>\n<option value="C">CYS</option>\n<option value="D">ASP</option>\n<option value="E">GLU</option>\n<option value="F">PHE</option>\n<option value="G">GLY</option>\n<option value="H">HIS</option>\n<option value="I">ILE</option>\n<option value="K">LYS</option>\n<option value="L">LEU</option>\n<option value="M">MET</option>\n<option value="N">ASN</option>\n<option value="P">PRO</option>\n<option value="Q">GLN</option>\n<option value="R">ARG</option>\n<option value="S">SER</option>\n<option value="T">THR</option>\n<option value="V">VAL</option>\n<option value="W">TRP</option>\n<option value="Y">TYR</option>\n</select>\n<br>\nChoose Atom 1:\n<br>\n<select name="Atom1">\n<option value="N">N</option>\n<option value="CA">C-alpha</option>\n<option value="CB">C-beta</option>\n<option value="C">carbonyl C</option>\n<option value="O">carbonyl O</option>\n</select>\n<br>\nChoose SecStr of residue 1:\n<br>\n<select name="SecStr1">\n<option value="H">Helix</option>\n<option value="E">Strand</option>\n<option value="C">Coil</option>\n</select>\n<br><br><br>\nChoose Amino Acid 2:\n<br>\n<select name="AA2">\n<option value="A">ALA</option>\n<option value="C">CYS</option>\n<option value="D">ASP</option>\n<option value="E">GLU</option>\n<option value="F">PHE</option>\n<option value="G">GLY</option>\n<option value="H">HIS</option>\n<option value="I">ILE</option>\n<option value="K">LYS</option>\n<option value="L">LEU</option>\n<option value="M">MET</option>\n<option value="N">ASN</option>\n<option value="P">PRO</option>\n<option value="Q">GLN</option>\n<option value="R">ARG</option>\n<option value="S">SER</option>\n<option value="T">THR</option>\n<option value="V">VAL</option>\n<option value="W">TRP</option>\n<option value="Y">TYR</option>\n</select>\n<br>\nChoose Atom 2:\n<br>\n<select name="Atom2">\n<option value="N">N</option>\n<option value="CA">C-alpha</option>\n<option value="CB">C-beta</option>\n<option value="C">carbonyl C</option>\n<option value="O">carbonyl O</option>\n</select>\n<br>\nChoose SecStr of residue 2:\n<br>\n<select name="SecStr2">\n<option value="H">Helix</option>\n<option value="E">Strand</option>\n<option value="C">Coil</option>\n</select>\n<br><br>\n<H4>Is this interaction in one contiguous unit of SecStr?</H4>\n<br>\n<INPUT TYPE="radio" NAME="continuity" VALUE="contiguous" CHECKED> contiguous\n<INPUT TYPE="radio" NAME="continuity" VALUE="noncontiguous"> non-contiguous\n<br><br>\n<H4>Is the Prop wash of the two side chains small, intermediate, or large?</H4>\n<br>\n<INPUT TYPE="radio" NAME="propwash" VALUE="0" CHECKED> small\n<INPUT TYPE="radio" NAME="propwash" VALUE="1"> intermediate\n<INPUT TYPE="radio" NAME="propwash" VALUE="2"> large\n<br><br>\n<H4>If the two residues are in h-bonded beta strands, are the strands parallel or anti-parallel?</H4>\n<br>\n<INPUT TYPE="radio" NAME="parallel" VALUE="1" CHECKED> parallel\n<INPUT TYPE="radio" NAME="parallel" VALUE="2"> anti-parallel\n<br><br><br>\n<input type="submit" value=\"get profile!\">\n</form><br>'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    print ItFix_server_string
    
def rama_map_generate_form(date_label, aa0, aa1, aa2, ss0, ss1, ss2, res, part):
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'rama map')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    aa0 = aa0.strip()
    aa1 = aa1.strip()
    aa2 = aa2.strip()
    
    ss0 = ss0.strip()
    ss1 = ss1.strip()
    ss2 = ss2.strip()

    res = res.strip()
    
    A0_sel = C0_sel = D0_sel = E0_sel = F0_sel = G0_sel = H0_sel = I0_sel = K0_sel = L0_sel = M0_sel = N0_sel = P0_sel = Q0_sel = R0_sel = S0_sel = T0_sel = V0_sel = W0_sel = Y0_sel = ''
    
    H0_sec = E0_sec = C0_sec = O0_sec = Q0_sec = A0_sec = ''
    
    A1_sel = C1_sel = D1_sel = E1_sel = F1_sel = G1_sel = H1_sel = I1_sel = K1_sel = L1_sel = M1_sel = N1_sel = P1_sel = Q1_sel = R1_sel = S1_sel = T1_sel = V1_sel = W1_sel = Y1_sel = ''
    
    H1_sec = E1_sec = C1_sec = O1_sec = Q1_sec = A1_sec = ''
    
    A2_sel = C2_sel = D2_sel = E2_sel = F2_sel = G2_sel = H2_sel = I2_sel = K2_sel = L2_sel = M2_sel = N2_sel = P2_sel = Q2_sel = R2_sel = S2_sel = T2_sel = V2_sel = W2_sel = Y2_sel = ''
    
    H2_sec = E2_sec = C2_sec = O2_sec = Q2_sec = A2_sec = ''

    res_20_sel = res_10_sel = res_5_sel = ''

    if res == '20': res_20_sel = 'selected'
    elif res == '10': res_10_sel = 'selected'
    elif res == '5': res_5_sel = 'selected' 
    
    if aa0 == 'A': A0_sel = 'selected'
    elif aa0 == 'C': C0_sel = 'selected'
    elif aa0 == 'D': D0_sel = 'selected'
    elif aa0 == 'E': E0_sel = 'selected'
    elif aa0 == 'F': F0_sel = 'selected'
    elif aa0 == 'G': G0_sel = 'selected'
    elif aa0 == 'H': H0_sel = 'selected'
    elif aa0 == 'I': I0_sel = 'selected'
    elif aa0 == 'K': K0_sel = 'selected'
    elif aa0 == 'L': L0_sel = 'selected'
    elif aa0 == 'M': M0_sel = 'selected'
    elif aa0 == 'N': N0_sel = 'selected'
    elif aa0 == 'P': P0_sel = 'selected'
    elif aa0 == 'Q': Q0_sel = 'selected'
    elif aa0 == 'R': R0_sel = 'selected'
    elif aa0 == 'S': S0_sel = 'selected'
    elif aa0 == 'T': T0_sel = 'selected'
    elif aa0 == 'V': V0_sel = 'selected'
    elif aa0 == 'W': W0_sel = 'selected'
    elif aa0 == 'Y': Y0_sel = 'selected'
    
    if aa1 == 'A': A1_sel = 'selected'
    elif aa1 == 'C': C1_sel = 'selected'
    elif aa1 == 'D': D1_sel = 'selected'
    elif aa1 == 'E': E1_sel = 'selected'
    elif aa1 == 'F': F1_sel = 'selected'
    elif aa1 == 'G': G1_sel = 'selected'
    elif aa1 == 'H': H1_sel = 'selected'
    elif aa1 == 'I': I1_sel = 'selected'
    elif aa1 == 'K': K1_sel = 'selected'
    elif aa1 == 'L': L1_sel = 'selected'
    elif aa1 == 'M': M1_sel = 'selected'
    elif aa1 == 'N': N1_sel = 'selected'
    elif aa1 == 'P': P1_sel = 'selected'
    elif aa1 == 'Q': Q1_sel = 'selected'
    elif aa1 == 'R': R1_sel = 'selected'
    elif aa1 == 'S': S1_sel = 'selected'
    elif aa1 == 'T': T1_sel = 'selected'
    elif aa1 == 'V': V1_sel = 'selected'
    elif aa1 == 'W': W1_sel = 'selected'
    elif aa1 == 'Y': Y1_sel = 'selected'
    
    if aa2 == 'A': A2_sel = 'selected'
    elif aa2 == 'C': C2_sel = 'selected'
    elif aa2 == 'D': D2_sel = 'selected'
    elif aa2 == 'E': E2_sel = 'selected'
    elif aa2 == 'F': F2_sel = 'selected'
    elif aa2 == 'G': G2_sel = 'selected'
    elif aa2 == 'H': H2_sel = 'selected'
    elif aa2 == 'I': I2_sel = 'selected'
    elif aa2 == 'K': K2_sel = 'selected'
    elif aa2 == 'L': L2_sel = 'selected'
    elif aa2 == 'M': M2_sel = 'selected'
    elif aa2 == 'N': N2_sel = 'selected'
    elif aa2 == 'P': P2_sel = 'selected'
    elif aa2 == 'Q': Q2_sel = 'selected'
    elif aa2 == 'R': R2_sel = 'selected'
    elif aa2 == 'S': S2_sel = 'selected'
    elif aa2 == 'T': T2_sel = 'selected'
    elif aa2 == 'V': V2_sel = 'selected'
    elif aa2 == 'W': W2_sel = 'selected'
    elif aa2 == 'Y': Y2_sel = 'selected'
    
    if ss0 == 'H': H0_sec = 'selected'
    elif ss0 == 'E': E0_sec = 'selected'
    elif ss0 == 'C': C0_sec = 'selected'
    elif ss0 == 'O': O0_sec = 'selected'
    elif ss0 == 'Q': Q0_sec = 'selected'
    elif ss0 == 'A': A0_sec = 'selected'
    
    if ss1 == 'H': H1_sec = 'selected'
    elif ss1 == 'E': E1_sec = 'selected'
    elif ss1 == 'C': C1_sec = 'selected'
    elif ss1 == 'O': O1_sec = 'selected'
    elif ss1 == 'Q': Q1_sec = 'selected'
    elif ss1 == 'A': A1_sec = 'selected'
    
    if ss2 == 'H': H2_sec = 'selected'
    elif ss2 == 'E': E2_sec = 'selected'
    elif ss2 == 'C': C2_sec = 'selected'
    elif ss2 == 'O': O2_sec = 'selected'
    elif ss2 == 'Q': Q2_sec = 'selected'
    elif ss2 == 'A': A2_sec = 'selected'
    
    if part == 1: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<a href=\"http://godzilla.uchicago.edu/user/' + date_label + '.log\">download data here</a>\n<br>\n<img src = \"../img/' + date_label + '.gif\" style=\"float:left\" />\n'
    else: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<img src = \"../img/rama.gif\" style=\"float:left\" />\n'
    
    
    ##### SEQUENCE INFO #####
    sequence_string = front_string + '<br><br><br><form action = "rama.cgi" method = "POST" enctype = "multipart/form-data">\nN-terminal neighbor:\n<br>\n<select name="AA0">\n<option ' + A0_sel + ' value="A">ALA</option>\n<option ' + C0_sel + ' value ="C">CYS</option>\n<option ' + D0_sel + ' value ="D">ASP</option>\n<option ' + E0_sel + ' value="E">GLU</option>\n<option ' + F0_sel + ' value ="F">PHE</option>\n<option ' + G0_sel + ' value ="G">GLY</option>\n<option ' + H0_sel + ' value ="H">HIS</option>\n<option ' + I0_sel + ' value ="I">ILE</option>\n<option ' + K0_sel + ' value ="K">LYS</option>\n<option ' + L0_sel + ' value ="L">LEU</option>\n<option ' + M0_sel + ' value ="M">MET</option>\n<option ' + N0_sel + ' value ="N">ASN</option>\n<option ' + P0_sel + ' value ="P">PRO</option>\n<option ' + Q0_sel + ' value ="Q">GLN</option>\n<option ' + R0_sel + ' value ="R">ARG</option>\n<option ' + S0_sel + ' value ="S">SER</option>\n<option ' + T0_sel + ' value ="T">THR</option>\n<option ' + V0_sel + ' value ="V">VAL</option>\n<option ' + W0_sel + ' value ="W">TRP</option>\n<option ' + Y0_sel + ' value ="Y">TYR</option>\n</select>\n<br>\nN-terminal SecStr:\n<br>\n<select name="SecStr0">\n<option ' + H0_sec + ' value ="H">Helix</option>\n<option ' + E0_sec + ' value ="E">Strand</option>\n<option ' + C0_sec + ' value ="C">Coil</option>\n<option ' + O0_sec + ' value ="O">NotHelix</option>\n<option ' + Q0_sec + ' value ="Q">NotStrand</option>\n<option ' + A0_sec + ' value ="A">Everything</option>\n</select>\n<br><br>\ncentral residue:\n<br>\n<select name="AA1">\n<option ' + A1_sel + ' value ="A">ALA</option>\n<option ' + C1_sel + ' value ="C">CYS</option>\n<option ' + D1_sel + ' value ="D">ASP</option>\n<option ' + E1_sel + ' value ="E">GLU</option>\n<option ' + F1_sel + ' value ="F">PHE</option>\n<option ' + G1_sel + ' value ="G">GLY</option>\n<option ' + H1_sel + ' value ="H">HIS</option>\n<option ' + I1_sel + ' value ="I">ILE</option>\n<option ' + K1_sel + ' value ="K">LYS</option>\n<option ' + L1_sel + ' value ="L">LEU</option>\n<option ' + M1_sel + ' value ="M">MET</option>\n<option ' + N1_sel + ' value ="N">ASN</option>\n<option ' + P1_sel + ' value ="P">PRO</option>\n<option ' + Q1_sel + ' value ="Q">GLN</option>\n<option ' + R1_sel + ' value ="R">ARG</option>\n<option ' + S1_sel + ' value ="S">SER</option>\n<option ' + T1_sel + ' value ="T">THR</option>\n<option ' + V1_sel + ' value ="V">VAL</option>\n<option ' + W1_sel + ' value ="W">TRP</option>\n<option ' + Y1_sel + ' value ="Y">TYR</option>\n</select>\n<br>\ncentral SecStr:\n<br>\n<select name="SecStr1">\n<option ' + H1_sec + ' value ="H">Helix</option>\n<option ' + E1_sec + ' value ="E">Strand</option>\n<option ' + C1_sec + ' value ="C">Coil</option>\n<option ' + O1_sec + ' value ="O">NotHelix</option>\n<option ' + Q1_sec + ' value ="Q">NotStrand</option>\n<option ' + A1_sec + ' value ="A">Everything</option>\n</select>\n<br><br>\nC-terminal neighbor:\n<br>\n<select name="AA2">\n<option ' + A2_sel + ' value ="A">ALA</option>\n<option ' + C2_sel + ' value ="C">CYS</option>\n<option ' + D2_sel + ' value ="D">ASP</option>\n<option ' + E2_sel + ' value ="E">GLU</option>\n<option ' + F2_sel + ' value ="F">PHE</option>\n<option ' + G2_sel + ' value ="G">GLY</option>\n<option ' + H2_sel + ' value ="H">HIS</option>\n<option ' + I2_sel + ' value ="I">ILE</option>\n<option ' + K2_sel + ' value ="K">LYS</option>\n<option ' + L2_sel + ' value ="L">LEU</option>\n<option ' + M2_sel + ' value ="M">MET</option>\n<option ' + N2_sel + ' value ="N">ASN</option>\n<option ' + P2_sel + ' value ="P">PRO</option>\n<option ' + Q2_sel + ' value ="Q">GLN</option>\n<option ' + R2_sel + ' value ="R">ARG</option>\n<option ' + S2_sel + ' value ="S">SER</option>\n<option ' + T2_sel + ' value ="T">THR</option>\n<option ' + V2_sel + ' value ="V">VAL</option>\n<option ' + W2_sel + ' value ="W">TRP</option>\n<option ' + Y2_sel + ' value ="Y">TYR</option>\n</select>\n<br>\nC-terminal SecStr:\n<br>\n<select name="SecStr2">\n<option ' + H2_sec + ' value ="H">Helix</option>\n<option ' + E2_sec + ' value ="E">Strand</option>\n<option ' + C2_sec + ' value ="C">Coil</option>\n<option ' + O2_sec + ' value ="O">NotHelix</option>\n<option ' + Q2_sec + ' value ="Q">NotStrand</option>\n<option ' + A2_sec + ' value ="A">Everything</option>\n</select>\n<br><br>\nbin resolution (degrees):\n<br>\n<select name="resolution">\n<option ' + res_20_sel + ' value ="20">20</option>\n<option ' + res_10_sel + ' value ="10">10</option>\n<option ' + res_5_sel + ' value ="5">5</option>\n</select>\n<br><br><br>\n<input type="submit" value=\"get rama!\">\n</form><br>'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    
    print ItFix_server_string
    
def rama_all_generate_form(date_label, aa0, aa1, aa2, ss0, ss1, ss2, part):
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'Ramachandran distributions')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    aa0 = aa0.strip()
    aa1 = aa1.strip()
    aa2 = aa2.strip()
    
    ss0 = ss0.strip()
    ss1 = ss1.strip()
    ss2 = ss2.strip()
    
    A0_sel = C0_sel = D0_sel = E0_sel = F0_sel = G0_sel = H0_sel = I0_sel = K0_sel = L0_sel = M0_sel = N0_sel = P0_sel = Q0_sel = R0_sel = S0_sel = T0_sel = V0_sel = W0_sel = Y0_sel = X0_sel = ''
    
    H0_sec = E0_sec = C0_sec = O0_sec = Q0_sec = A0_sec = S0_sec = T0_sec = G0_sec = N0_sec = ''
    
    A1_sel = C1_sel = D1_sel = E1_sel = F1_sel = G1_sel = H1_sel = I1_sel = K1_sel = L1_sel = M1_sel = N1_sel = P1_sel = Q1_sel = R1_sel = S1_sel = T1_sel = V1_sel = W1_sel = Y1_sel = X1_sel = ''
    
    H1_sec = E1_sec = C1_sec = O1_sec = Q1_sec = A1_sec = S1_sec = T1_sec = G1_sec = N1_sec = ''
    
    A2_sel = C2_sel = D2_sel = E2_sel = F2_sel = G2_sel = H2_sel = I2_sel = K2_sel = L2_sel = M2_sel = N2_sel = P2_sel = Q2_sel = R2_sel = S2_sel = T2_sel = V2_sel = W2_sel = Y2_sel = X2_sel = ''
    
    H2_sec = E2_sec = C2_sec = O2_sec = Q2_sec = A2_sec = S2_sec = T2_sec = G2_sec = N2_sec = ''
    
    if aa0 == 'A': A0_sel = 'selected'
    elif aa0 == 'C': C0_sel = 'selected'
    elif aa0 == 'D': D0_sel = 'selected'
    elif aa0 == 'E': E0_sel = 'selected'
    elif aa0 == 'F': F0_sel = 'selected'
    elif aa0 == 'G': G0_sel = 'selected'
    elif aa0 == 'H': H0_sel = 'selected'
    elif aa0 == 'I': I0_sel = 'selected'
    elif aa0 == 'K': K0_sel = 'selected'
    elif aa0 == 'L': L0_sel = 'selected'
    elif aa0 == 'M': M0_sel = 'selected'
    elif aa0 == 'N': N0_sel = 'selected'
    elif aa0 == 'P': P0_sel = 'selected'
    elif aa0 == 'Q': Q0_sel = 'selected'
    elif aa0 == 'R': R0_sel = 'selected'
    elif aa0 == 'S': S0_sel = 'selected'
    elif aa0 == 'T': T0_sel = 'selected'
    elif aa0 == 'V': V0_sel = 'selected'
    elif aa0 == 'W': W0_sel = 'selected'
    elif aa0 == 'Y': Y0_sel = 'selected'
    elif aa0 == 'X': X0_sel = 'selected'
    
    if aa1 == 'A': A1_sel = 'selected'
    elif aa1 == 'C': C1_sel = 'selected'
    elif aa1 == 'D': D1_sel = 'selected'
    elif aa1 == 'E': E1_sel = 'selected'
    elif aa1 == 'F': F1_sel = 'selected'
    elif aa1 == 'G': G1_sel = 'selected'
    elif aa1 == 'H': H1_sel = 'selected'
    elif aa1 == 'I': I1_sel = 'selected'
    elif aa1 == 'K': K1_sel = 'selected'
    elif aa1 == 'L': L1_sel = 'selected'
    elif aa1 == 'M': M1_sel = 'selected'
    elif aa1 == 'N': N1_sel = 'selected'
    elif aa1 == 'P': P1_sel = 'selected'
    elif aa1 == 'Q': Q1_sel = 'selected'
    elif aa1 == 'R': R1_sel = 'selected'
    elif aa1 == 'S': S1_sel = 'selected'
    elif aa1 == 'T': T1_sel = 'selected'
    elif aa1 == 'V': V1_sel = 'selected'
    elif aa1 == 'W': W1_sel = 'selected'
    elif aa1 == 'Y': Y1_sel = 'selected'
    elif aa1 == 'X': X1_sel = 'selected'
    
    if aa2 == 'A': A2_sel = 'selected'
    elif aa2 == 'C': C2_sel = 'selected'
    elif aa2 == 'D': D2_sel = 'selected'
    elif aa2 == 'E': E2_sel = 'selected'
    elif aa2 == 'F': F2_sel = 'selected'
    elif aa2 == 'G': G2_sel = 'selected'
    elif aa2 == 'H': H2_sel = 'selected'
    elif aa2 == 'I': I2_sel = 'selected'
    elif aa2 == 'K': K2_sel = 'selected'
    elif aa2 == 'L': L2_sel = 'selected'
    elif aa2 == 'M': M2_sel = 'selected'
    elif aa2 == 'N': N2_sel = 'selected'
    elif aa2 == 'P': P2_sel = 'selected'
    elif aa2 == 'Q': Q2_sel = 'selected'
    elif aa2 == 'R': R2_sel = 'selected'
    elif aa2 == 'S': S2_sel = 'selected'
    elif aa2 == 'T': T2_sel = 'selected'
    elif aa2 == 'V': V2_sel = 'selected'
    elif aa2 == 'W': W2_sel = 'selected'
    elif aa2 == 'Y': Y2_sel = 'selected'
    elif aa2 == 'X': X2_sel = 'selected'
    
    if ss0 == 'H': H0_sec = 'selected'
    elif ss0 == 'E': E0_sec = 'selected'
    elif ss0 == 'C': C0_sec = 'selected'
    elif ss0 == 'O': O0_sec = 'selected'
    elif ss0 == 'Q': Q0_sec = 'selected'
    elif ss0 == 'A': A0_sec = 'selected'
    elif ss0 == 'S': S0_sec = 'selected'
    elif ss0 == 'T': T0_sec = 'selected'
    elif ss0 == 'G': G0_sec = 'selected'
    elif ss0 == 'N': N0_sec = 'selected'
    
    if ss1 == 'H': H1_sec = 'selected'
    elif ss1 == 'E': E1_sec = 'selected'
    elif ss1 == 'C': C1_sec = 'selected'
    elif ss1 == 'O': O1_sec = 'selected'
    elif ss1 == 'Q': Q1_sec = 'selected'
    elif ss1 == 'A': A1_sec = 'selected'
    elif ss1 == 'S': S1_sec = 'selected'
    elif ss1 == 'T': T1_sec = 'selected'
    elif ss1 == 'G': G1_sec = 'selected'
    elif ss1 == 'N': N1_sec = 'selected'
    
    if ss2 == 'H': H2_sec = 'selected'
    elif ss2 == 'E': E2_sec = 'selected'
    elif ss2 == 'C': C2_sec = 'selected'
    elif ss2 == 'O': O2_sec = 'selected'
    elif ss2 == 'Q': Q2_sec = 'selected'
    elif ss2 == 'A': A2_sec = 'selected'
    elif ss2 == 'S': S2_sec = 'selected'
    elif ss2 == 'T': T2_sec = 'selected'
    elif ss2 == 'G': G2_sec = 'selected'
    elif ss2 == 'N': N2_sec = 'selected'
    
    if part == 1: front_string = '\n<p>Calculate the Rama distribution of an amino acid tripeptide!</p>\n<a href=\"http://godzilla.uchicago.edu/user/' + date_label + '.log\">download data here</a>\n<br>\n<img src = \"../img/' + date_label + '.gif\" style=\"float:left\" />\n'
    else: front_string = '\n<p>Calculate the Rama distribution of an amino acid tripeptide!</p>\n<img src = \"../img/rama.gif\" style=\"float:left\" />\n'
    
    
    ##### SEQUENCE INFO #####
    sequence_string = front_string + '<br><br><br><form action = "rama_all.cgi" method = "POST" enctype = "multipart/form-data">\nN-terminal neighbor:\n<br>\n<select name="AA0">\n<option ' + A0_sel + ' value="A">ALA</option>\n<option ' + C0_sel + ' value ="C">CYS</option>\n<option ' + D0_sel + ' value ="D">ASP</option>\n<option ' + E0_sel + ' value="E">GLU</option>\n<option ' + F0_sel + ' value ="F">PHE</option>\n<option ' + G0_sel + ' value ="G">GLY</option>\n<option ' + H0_sel + ' value ="H">HIS</option>\n<option ' + I0_sel + ' value ="I">ILE</option>\n<option ' + K0_sel + ' value ="K">LYS</option>\n<option ' + L0_sel + ' value ="L">LEU</option>\n<option ' + M0_sel + ' value ="M">MET</option>\n<option ' + N0_sel + ' value ="N">ASN</option>\n<option ' + P0_sel + ' value ="P">PRO</option>\n<option ' + Q0_sel + ' value ="Q">GLN</option>\n<option ' + R0_sel + ' value ="R">ARG</option>\n<option ' + S0_sel + ' value ="S">SER</option>\n<option ' + T0_sel + ' value ="T">THR</option>\n<option ' + V0_sel + ' value ="V">VAL</option>\n<option ' + W0_sel + ' value ="W">TRP</option>\n<option ' + Y0_sel + ' value ="Y">TYR</option>\n<option ' + X0_sel + ' value ="X">ALL</option>\n</select>\n<br>\nN-terminal SecStr:\n<br>\n<select name="SecStr0">\n<option ' + H0_sec + ' value ="H">Helix</option>\n<option ' + E0_sec + ' value ="E">Strand</option>\n<option ' + C0_sec + ' value ="C">Coil:All</option>\n<option ' + N0_sec + ' value ="N">Coil:Unfolded</option>\n<option ' + S0_sec + ' value ="S">Coil:bend</option>\n<option ' + T0_sec + ' value ="T">Coil:Turn</option>\n<option ' + G0_sec + ' value ="G">Coil:3-10</option>\n<option ' + O0_sec + ' value ="O">NotHelix</option>\n<option ' + Q0_sec + ' value ="Q">NotStrand</option>\n<option ' + A0_sec + ' value ="A">Everything</option>\n</select>\n<br><br>\ncentral residue:\n<br>\n<select name="AA1">\n<option ' + A1_sel + ' value ="A">ALA</option>\n<option ' + C1_sel + ' value ="C">CYS</option>\n<option ' + D1_sel + ' value ="D">ASP</option>\n<option ' + E1_sel + ' value ="E">GLU</option>\n<option ' + F1_sel + ' value ="F">PHE</option>\n<option ' + G1_sel + ' value ="G">GLY</option>\n<option ' + H1_sel + ' value ="H">HIS</option>\n<option ' + I1_sel + ' value ="I">ILE</option>\n<option ' + K1_sel + ' value ="K">LYS</option>\n<option ' + L1_sel + ' value ="L">LEU</option>\n<option ' + M1_sel + ' value ="M">MET</option>\n<option ' + N1_sel + ' value ="N">ASN</option>\n<option ' + P1_sel + ' value ="P">PRO</option>\n<option ' + Q1_sel + ' value ="Q">GLN</option>\n<option ' + R1_sel + ' value ="R">ARG</option>\n<option ' + S1_sel + ' value ="S">SER</option>\n<option ' + T1_sel + ' value ="T">THR</option>\n<option ' + V1_sel + ' value ="V">VAL</option>\n<option ' + W1_sel + ' value ="W">TRP</option>\n<option ' + Y1_sel + ' value ="Y">TYR</option>\n<option ' + X1_sel + ' value ="X">ALL</option>\n</select>\n<br>\ncentral SecStr:\n<br>\n<select name="SecStr1">\n<option ' + H1_sec + ' value ="H">Helix</option>\n<option ' + E1_sec + ' value ="E">Strand</option>\n<option ' + C1_sec + ' value ="C">Coil:All</option>\n<option ' + N1_sec + ' value ="N">Coil:Unfolded</option>\n<option ' + S1_sec + ' value ="S">Coil:bend</option>\n<option ' + T1_sec + ' value ="T">Coil:Turn</option>\n<option ' + G1_sec + ' value ="G">Coil:3-10</option>\n<option ' + O1_sec + ' value ="O">NotHelix</option>\n<option ' + Q1_sec + ' value ="Q">NotStrand</option>\n<option ' + A1_sec + ' value ="A">Everything</option>\n</select>\n<br><br>\nC-terminal neighbor:\n<br>\n<select name="AA2">\n<option ' + A2_sel + ' value ="A">ALA</option>\n<option ' + C2_sel + ' value ="C">CYS</option>\n<option ' + D2_sel + ' value ="D">ASP</option>\n<option ' + E2_sel + ' value ="E">GLU</option>\n<option ' + F2_sel + ' value ="F">PHE</option>\n<option ' + G2_sel + ' value ="G">GLY</option>\n<option ' + H2_sel + ' value ="H">HIS</option>\n<option ' + I2_sel + ' value ="I">ILE</option>\n<option ' + K2_sel + ' value ="K">LYS</option>\n<option ' + L2_sel + ' value ="L">LEU</option>\n<option ' + M2_sel + ' value ="M">MET</option>\n<option ' + N2_sel + ' value ="N">ASN</option>\n<option ' + P2_sel + ' value ="P">PRO</option>\n<option ' + Q2_sel + ' value ="Q">GLN</option>\n<option ' + R2_sel + ' value ="R">ARG</option>\n<option ' + S2_sel + ' value ="S">SER</option>\n<option ' + T2_sel + ' value ="T">THR</option>\n<option ' + V2_sel + ' value ="V">VAL</option>\n<option ' + W2_sel + ' value ="W">TRP</option>\n<option ' + Y2_sel + ' value ="Y">TYR</option>\n<option ' + X2_sel + ' value ="X">ALL</option>\n</select>\n<br>\nC-terminal SecStr:\n<br>\n<select name="SecStr2">\n<option ' + H2_sec + ' value ="H">Helix</option>\n<option ' + E2_sec + ' value ="E">Strand</option>\n<option ' + C2_sec + ' value ="C">Coil:All</option>\n<option ' + N2_sec + ' value ="N">Coil:Unfolded</option>\n<option ' + S2_sec + ' value ="S">Coil:bend</option>\n<option ' + T2_sec + ' value ="T">Coil:Turn</option>\n<option ' + G2_sec + ' value ="G">Coil:3-10</option>\n<option ' + O2_sec + ' value ="O">NotHelix</option>\n<option ' + Q2_sec + ' value ="Q">NotStrand</option>\n<option ' + A2_sec + ' value ="A">Everything</option>\n</select>\n<br>\n<br><br><br>\n<input type="submit" value=\"get rama!\"onClick=\"progress_update()\">\n</form><br>\n' + progress_bar()
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    
    print ItFix_server_string
    
def psi_phi_map_generate_form(date_label, aa0, aa1, part):
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'psi-phi map')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    aa0 = aa0.strip()
    aa1 = aa1.strip()
    
    A0_sel = C0_sel = D0_sel = E0_sel = F0_sel = G0_sel = H0_sel = I0_sel = K0_sel = L0_sel = M0_sel = N0_sel = P0_sel = Q0_sel = R0_sel = S0_sel = T0_sel = V0_sel = W0_sel = Y0_sel = ''
    
    A1_sel = C1_sel = D1_sel = E1_sel = F1_sel = G1_sel = H1_sel = I1_sel = K1_sel = L1_sel = M1_sel = N1_sel = P1_sel = Q1_sel = R1_sel = S1_sel = T1_sel = V1_sel = W1_sel = Y1_sel = ''
    
    if aa0 == 'A': A0_sel = 'selected'
    elif aa0 == 'C': C0_sel = 'selected'
    elif aa0 == 'D': D0_sel = 'selected'
    elif aa0 == 'E': E0_sel = 'selected'
    elif aa0 == 'F': F0_sel = 'selected'
    elif aa0 == 'G': G0_sel = 'selected'
    elif aa0 == 'H': H0_sel = 'selected'
    elif aa0 == 'I': I0_sel = 'selected'
    elif aa0 == 'K': K0_sel = 'selected'
    elif aa0 == 'L': L0_sel = 'selected'
    elif aa0 == 'M': M0_sel = 'selected'
    elif aa0 == 'N': N0_sel = 'selected'
    elif aa0 == 'P': P0_sel = 'selected'
    elif aa0 == 'Q': Q0_sel = 'selected'
    elif aa0 == 'R': R0_sel = 'selected'
    elif aa0 == 'S': S0_sel = 'selected'
    elif aa0 == 'T': T0_sel = 'selected'
    elif aa0 == 'V': V0_sel = 'selected'
    elif aa0 == 'W': W0_sel = 'selected'
    elif aa0 == 'Y': Y0_sel = 'selected'
    
    if aa1 == 'A': A1_sel = 'selected'
    elif aa1 == 'C': C1_sel = 'selected'
    elif aa1 == 'D': D1_sel = 'selected'
    elif aa1 == 'E': E1_sel = 'selected'
    elif aa1 == 'F': F1_sel = 'selected'
    elif aa1 == 'G': G1_sel = 'selected'
    elif aa1 == 'H': H1_sel = 'selected'
    elif aa1 == 'I': I1_sel = 'selected'
    elif aa1 == 'K': K1_sel = 'selected'
    elif aa1 == 'L': L1_sel = 'selected'
    elif aa1 == 'M': M1_sel = 'selected'
    elif aa1 == 'N': N1_sel = 'selected'
    elif aa1 == 'P': P1_sel = 'selected'
    elif aa1 == 'Q': Q1_sel = 'selected'
    elif aa1 == 'R': R1_sel = 'selected'
    elif aa1 == 'S': S1_sel = 'selected'
    elif aa1 == 'T': T1_sel = 'selected'
    elif aa1 == 'V': V1_sel = 'selected'
    elif aa1 == 'W': W1_sel = 'selected'
    elif aa1 == 'Y': Y1_sel = 'selected'
    
    if part == 1: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<a href=\"http://godzilla.uchicago.edu/user/' + date_label + '.log\">download data here</a>\n<br>\n<img src = \"../img/' + date_label + '.gif\" style=\"float:left\" />\n'
    else: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<img src = \"../img/psi_phi.gif\" style=\"float:left\" />\n'
    
    
    ##### SEQUENCE INFO #####
    sequence_string = front_string + '<br><br><br><form action = "psi_phi.cgi" method = "POST" enctype = "multipart/form-data">\nResidue 1:\n<br>\n<select name="AA0">\n<option ' + A0_sel + ' value="A">ALA</option>\n<option ' + C0_sel + ' value ="C">CYS</option>\n<option ' + D0_sel + ' value ="D">ASP</option>\n<option ' + E0_sel + ' value="E">GLU</option>\n<option ' + F0_sel + ' value ="F">PHE</option>\n<option ' + G0_sel + ' value ="G">GLY</option>\n<option ' + H0_sel + ' value ="H">HIS</option>\n<option ' + I0_sel + ' value ="I">ILE</option>\n<option ' + K0_sel + ' value ="K">LYS</option>\n<option ' + L0_sel + ' value ="L">LEU</option>\n<option ' + M0_sel + ' value ="M">MET</option>\n<option ' + N0_sel + ' value ="N">ASN</option>\n<option ' + P0_sel + ' value ="P">PRO</option>\n<option ' + Q0_sel + ' value ="Q">GLN</option>\n<option ' + R0_sel + ' value ="R">ARG</option>\n<option ' + S0_sel + ' value ="S">SER</option>\n<option ' + T0_sel + ' value ="T">THR</option>\n<option ' + V0_sel + ' value ="V">VAL</option>\n<option ' + W0_sel + ' value ="W">TRP</option>\n<option ' + Y0_sel + ' value ="Y">TYR</option>\n</select>\n<br><br>\nResidue 2:\n<br>\n<select name="AA1">\n<option ' + A1_sel + ' value ="A">ALA</option>\n<option ' + C1_sel + ' value ="C">CYS</option>\n<option ' + D1_sel + ' value ="D">ASP</option>\n<option ' + E1_sel + ' value ="E">GLU</option>\n<option ' + F1_sel + ' value ="F">PHE</option>\n<option ' + G1_sel + ' value ="G">GLY</option>\n<option ' + H1_sel + ' value ="H">HIS</option>\n<option ' + I1_sel + ' value ="I">ILE</option>\n<option ' + K1_sel + ' value ="K">LYS</option>\n<option ' + L1_sel + ' value ="L">LEU</option>\n<option ' + M1_sel + ' value ="M">MET</option>\n<option ' + N1_sel + ' value ="N">ASN</option>\n<option ' + P1_sel + ' value ="P">PRO</option>\n<option ' + Q1_sel + ' value ="Q">GLN</option>\n<option ' + R1_sel + ' value ="R">ARG</option>\n<option ' + S1_sel + ' value ="S">SER</option>\n<option ' + T1_sel + ' value ="T">THR</option>\n<option ' + V1_sel + ' value ="V">VAL</option>\n<option ' + W1_sel + ' value ="W">TRP</option>\n<option ' + Y1_sel + ' value ="Y">TYR</option>\n</select>\n<br><br><br>\n<input type="submit" value=\"get rama!\" onClick=\"progress_update()\">\n</form><br>\n' + progress_bar()
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    
    print ItFix_server_string
    
def general_rama_generate_form(date_label, aa0, aa1, part):
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'psi-phi map')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    aa0 = aa0.strip()
    aa1 = aa1.strip()
    
    A0_sel = C0_sel = D0_sel = E0_sel = F0_sel = G0_sel = H0_sel = I0_sel = K0_sel = L0_sel = M0_sel = N0_sel = P0_sel = Q0_sel = R0_sel = S0_sel = T0_sel = V0_sel = W0_sel = Y0_sel = ''
    
    A1_sel = C1_sel = D1_sel = E1_sel = F1_sel = G1_sel = H1_sel = I1_sel = K1_sel = L1_sel = M1_sel = N1_sel = P1_sel = Q1_sel = R1_sel = S1_sel = T1_sel = V1_sel = W1_sel = Y1_sel = ''
    
    if aa0 == 'A': A0_sel = 'selected'
    elif aa0 == 'C': C0_sel = 'selected'
    elif aa0 == 'D': D0_sel = 'selected'
    elif aa0 == 'E': E0_sel = 'selected'
    elif aa0 == 'F': F0_sel = 'selected'
    elif aa0 == 'G': G0_sel = 'selected'
    elif aa0 == 'H': H0_sel = 'selected'
    elif aa0 == 'I': I0_sel = 'selected'
    elif aa0 == 'K': K0_sel = 'selected'
    elif aa0 == 'L': L0_sel = 'selected'
    elif aa0 == 'M': M0_sel = 'selected'
    elif aa0 == 'N': N0_sel = 'selected'
    elif aa0 == 'P': P0_sel = 'selected'
    elif aa0 == 'Q': Q0_sel = 'selected'
    elif aa0 == 'R': R0_sel = 'selected'
    elif aa0 == 'S': S0_sel = 'selected'
    elif aa0 == 'T': T0_sel = 'selected'
    elif aa0 == 'V': V0_sel = 'selected'
    elif aa0 == 'W': W0_sel = 'selected'
    elif aa0 == 'Y': Y0_sel = 'selected'
    
    if aa1 == 'A': A1_sel = 'selected'
    elif aa1 == 'C': C1_sel = 'selected'
    elif aa1 == 'D': D1_sel = 'selected'
    elif aa1 == 'E': E1_sel = 'selected'
    elif aa1 == 'F': F1_sel = 'selected'
    elif aa1 == 'G': G1_sel = 'selected'
    elif aa1 == 'H': H1_sel = 'selected'
    elif aa1 == 'I': I1_sel = 'selected'
    elif aa1 == 'K': K1_sel = 'selected'
    elif aa1 == 'L': L1_sel = 'selected'
    elif aa1 == 'M': M1_sel = 'selected'
    elif aa1 == 'N': N1_sel = 'selected'
    elif aa1 == 'P': P1_sel = 'selected'
    elif aa1 == 'Q': Q1_sel = 'selected'
    elif aa1 == 'R': R1_sel = 'selected'
    elif aa1 == 'S': S1_sel = 'selected'
    elif aa1 == 'T': T1_sel = 'selected'
    elif aa1 == 'V': V1_sel = 'selected'
    elif aa1 == 'W': W1_sel = 'selected'
    elif aa1 == 'Y': Y1_sel = 'selected'
    
    if part == 1: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<a href=\"http://godzilla.uchicago.edu/user/' + date_label + '.log\">download data here</a>\n<br>\n<img src = \"../img/' + date_label + '.gif\" style=\"float:left\" />\n'
    else: front_string = '<p>WARNING: This site might not work on Internet Explorer; it\'s best to try Firefox, Safari, or other. Thanks!</p>\n<br>\n<img src = \"../img/psi_phi.gif\" style=\"float:left\" />\n'
    
    
    ##### SEQUENCE INFO #####
    sequence_string = front_string + '<br><br><br><form action = "general_rama.cgi" method = "POST" enctype = "multipart/form-data">\nResidue 1:\n<br>\n<select name="AA0">\n<option ' + A0_sel + ' value="A">ALA</option>\n<option ' + C0_sel + ' value ="C">CYS</option>\n<option ' + D0_sel + ' value ="D">ASP</option>\n<option ' + E0_sel + ' value="E">GLU</option>\n<option ' + F0_sel + ' value ="F">PHE</option>\n<option ' + G0_sel + ' value ="G">GLY</option>\n<option ' + H0_sel + ' value ="H">HIS</option>\n<option ' + I0_sel + ' value ="I">ILE</option>\n<option ' + K0_sel + ' value ="K">LYS</option>\n<option ' + L0_sel + ' value ="L">LEU</option>\n<option ' + M0_sel + ' value ="M">MET</option>\n<option ' + N0_sel + ' value ="N">ASN</option>\n<option ' + P0_sel + ' value ="P">PRO</option>\n<option ' + Q0_sel + ' value ="Q">GLN</option>\n<option ' + R0_sel + ' value ="R">ARG</option>\n<option ' + S0_sel + ' value ="S">SER</option>\n<option ' + T0_sel + ' value ="T">THR</option>\n<option ' + V0_sel + ' value ="V">VAL</option>\n<option ' + W0_sel + ' value ="W">TRP</option>\n<option ' + Y0_sel + ' value ="Y">TYR</option>\n</select>\n<br><br>\nResidue 2:\n<br>\n<select name="AA1">\n<option ' + A1_sel + ' value ="A">ALA</option>\n<option ' + C1_sel + ' value ="C">CYS</option>\n<option ' + D1_sel + ' value ="D">ASP</option>\n<option ' + E1_sel + ' value ="E">GLU</option>\n<option ' + F1_sel + ' value ="F">PHE</option>\n<option ' + G1_sel + ' value ="G">GLY</option>\n<option ' + H1_sel + ' value ="H">HIS</option>\n<option ' + I1_sel + ' value ="I">ILE</option>\n<option ' + K1_sel + ' value ="K">LYS</option>\n<option ' + L1_sel + ' value ="L">LEU</option>\n<option ' + M1_sel + ' value ="M">MET</option>\n<option ' + N1_sel + ' value ="N">ASN</option>\n<option ' + P1_sel + ' value ="P">PRO</option>\n<option ' + Q1_sel + ' value ="Q">GLN</option>\n<option ' + R1_sel + ' value ="R">ARG</option>\n<option ' + S1_sel + ' value ="S">SER</option>\n<option ' + T1_sel + ' value ="T">THR</option>\n<option ' + V1_sel + ' value ="V">VAL</option>\n<option ' + W1_sel + ' value ="W">TRP</option>\n<option ' + Y1_sel + ' value ="Y">TYR</option>\n</select>\n<br><br><br>\n<input type="submit" value=\"get rama!\">\n</form><br>'
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    ItFix_server_string = header_string + sequence_string + foot_string
    
    #ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', Date_Time_str())
    ItFix_server_string = ItFix_server_string.replace('DATE_UPDATED', 'problems? contact godzilla-help@lists.uchicago.edu')
    
    print ItFix_server_string
    
def rama_comp_str(root_label, name1, name2):
    
    web_str = '<win1>\n<H3>' + name1 + ' viewer</H3>\n<script src=\"/applet/Jmol.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\njmolInitialize(\"/applet\");\njmolApplet(350, \"load /' + root_label + '_tsp_1.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\")\njmolHtml(\"<br>\");\njmolRadioGroup([[\"load /' + root_label + '_tsp_1.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name1 + ' colored by TSP3\", \"selected\"], [\"load /' + root_label + '_tsp_diff_1.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name1 + ' colored by TSP3 difference\"], [\"load /' + root_label + '_phi_psi_diff_1.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name1 + ' colored by phi/psi difference\"]], \"<br>\");\n</script>\n</win1>\n<br>\n<br>\n<win2 class=\"pos_abs\">\n<H3>' + name2 + ' viewer</H3>\n<script src=\"/applet/Jmol.js\" type=\"text/javascript\"></script>\n<script type=\"text/javascript\">\njmolInitialize(\"/applet\");\njmolApplet(350, \"load /' + root_label + '_tsp_2.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\")\njmolHtml(\"<br>\");\njmolRadioGroup([[\"load /' + root_label + '_tsp_2.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name2 + ' colored by TSP3\", \"selected\"], [\"load /' + root_label + '_tsp_diff_2.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name2 + ' colored by TSP3 difference\"], [\"load /' + root_label + '_phi_psi_diff_2.pdb ; cpk off ; cartoon on ; wireframe off ; color structure ; color cartoon fixedTemperature ; frame all ; spin on\", \"' + name2 + ' colored by phi/psi difference\"]], \"<br>\");\n</script>\n</win2>\n' + HTML_table('Model quality statistics', refinement_table_vec(root_label, name1, name2)) + '\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_1.gif\" alt=\"energy profile\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_2.gif\" alt=\"energy profile\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_1_hist.gif\" alt=\"tsp3_histogram\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_2_hist.gif\" alt=\"tsp3_histogram\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_1_bar.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_2_bar.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_1_bar1.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_2_bar1.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_1_bar0.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_2_bar0.gif\" alt=\"tsp_bar\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_rmsd_profile.gif\" alt=\"rmsd_profile\" style=\"float:left\" />\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_diff.gif\" alt=\"tsp_difference\" style=\"float:left\" />\n<br>\n<br>\n<img  src=\"http://godzilla.uchicago.edu/' + root_label + '_phi_psi_diff.gif\" alt=\"phi_psi_diff\" style=\"float:left\" />\n<br>\n<br>\n<br>\n<H3>Downloadable text files</H3>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1.pdb\">' + name1 + '</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2.pdb\">' + name2 + '</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1_tsp.txt\">' + name1 + ' TSP3 by position</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2_tsp.txt\">' + name1 + ' TSP3 by position</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1_tsp1.txt\">' + name1 + ' TSP1 by position</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2_tsp1.txt\">' + name1 + ' TSP1 by position</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1_tsp0.txt\">' + name1 + ' TSP0 by position</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2_tsp0.txt\">' + name1 + ' TSP0 by position</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1_phi.txt\">' + name1 + ' phi</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2_phi.txt\">' + name2 + ' phi</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1_psi.txt\">' + name1 + ' psi</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2_psi.txt\">' + name2 + ' psi</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_phi_psi_diff.txt\">phi_psi difference</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_diff.txt\">TSP3 difference</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_1.pdb\">' + name1 + ' tsp3 pdb file</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_2.pdb\">' + name2 + ' tsp3 pdb file</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_diff_1.pdb\">' + name1 + ' tsp3 difference pdb file</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_tsp_diff_2.pdb\">' + name2 + ' tsp3 difference pdb file</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_phi_psi_diff_1.pdb\">' + name1 + ' phi/psi difference pdb file</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_phi_psi_diff_2.pdb\">' + name2 + ' phi/psi difference pdb file</a>\n<br>\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_1.hmatrix\">' + name1 + ' hbond matrix</a>\n*\n<a href=\"http://godzilla.uchicago.edu/' + root_label + '_2.hmatrix\">' + name2 + ' hbond matrix</a>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<br>\n<p>Please cite the following:</p><p>Automated real-space refinement of protein crystal structures using a realistic backbone move set. *(unpublished) Esmael J. Haddadian, Haipeng Gong, Abhishek K. Jha, Xiaojing Yang, Joe DeBartolo, James Hinshaw, Phoebe A. Rice, Tobin R. Sosnick and Karl F. Freed<p>'
    
    return web_str
    
def refine_log(pdb_path, ref_path, email_address, name1, name2, dope1, dope2, dope3, tsp1, tsp2, tsp3, tspNN1, tspNN2, tspNN3, nce1, nce2, nce3, bmk1, bmk2, bmk3, dc1, dc2, dc3, job_type_flag, mask_ligands_flag, density_path):
    
    rand_label = 'r' + str(random.randint(1, 1000000))
    web_dir = os.path.join('/var/www/refine', rand_label)
    os.mkdir(web_dir)
    for i in range(3): os.mkdir(os.path.join(web_dir, str(i + 1)))
    os.system('chmod g+w ' + web_dir + ' -R')
    os.system('chmod g+x ' + web_dir + ' -R')
    html_path = os.path.join(web_dir, rand_label + '.html')
    
    #### MAKE CFG FILES ####
    cfg_dir = os.path.join('/home/secoops/web/REFINE_CFG', rand_label)
    if not os.path.exists(cfg_dir): os.mkdir(cfg_dir)

    c1_path = '/home/secoops/web/REFINE_CFG/template/refineFold1.cfg'
    c2_path = '/home/secoops/web/REFINE_CFG/template/refineFold4.cfg'
    c3_path = '/home/secoops/web/REFINE_CFG/template/refineFold6.cfg'
    t1_path = '/home/secoops/web/REFINE_CFG/template/refine1.cfg'
    t2_path = '/home/secoops/web/REFINE_CFG/template/refine4.cfg'
    t3_path = '/home/secoops/web/REFINE_CFG/template/refine6.cfg'
    e1_path = '/home/secoops/web/REFINE_CFG/template/energy-stage1.cfg'
    e2_path = '/home/secoops/web/REFINE_CFG/template/energy-stage4.cfg'
    e3_path = '/home/secoops/web/REFINE_CFG/template/energy-stage6.cfg'

    c1_new_path = os.path.join(cfg_dir, 'refineFold1.cfg')
    c2_new_path = os.path.join(cfg_dir, 'refineFold4.cfg')
    c3_new_path = os.path.join(cfg_dir, 'refineFold6.cfg')
    t1_new_path = os.path.join(cfg_dir, 'refine1.cfg')
    t2_new_path = os.path.join(cfg_dir, 'refine4.cfg')
    t3_new_path = os.path.join(cfg_dir, 'refine6.cfg')
    e1_new_path = os.path.join(cfg_dir, 'energy-stage1.cfg')
    e2_new_path = os.path.join(cfg_dir, 'energy-stage4.cfg')
    e3_new_path = os.path.join(cfg_dir, 'energy-stage6.cfg')
    
    
    c1_file = open(c1_path, 'r')
    c1_str = c1_file.read()
    c1_file.close()
    c1_str = c1_str.replace('/home/secoops/web/haipeng/refine//cfg/refine1.cfg', t1_new_path)
    c1_new_file = open(c1_new_path, 'w')
    c1_new_file.write(c1_str)
    c1_new_file.close()
    
    c2_file = open(c2_path, 'r')
    c2_str = c2_file.read()
    c2_file.close()
    c2_str = c2_str.replace('/home/secoops/web/haipeng/refine//cfg/refine4.cfg', t2_new_path)
    c2_new_file = open(c2_new_path, 'w')
    c2_new_file.write(c2_str)
    c2_new_file.close()
    
    c3_file = open(c3_path, 'r')
    c3_str = c3_file.read()
    c3_file.close()
    c3_str = c3_str.replace('/home/secoops/web/haipeng/refine//cfg/refine6.cfg', t3_new_path)
    c3_new_file = open(c3_new_path, 'w')
    c3_new_file.write(c3_str)
    c3_new_file.close()
    
    t1_file = open(t1_path, 'r')
    t1_str = t1_file.read()
    t1_file.close()
    t1_str = t1_str.replace('/home/secoops/web/haipeng/refine//cfg/energy-stage1.cfg', e1_new_path)
    t1_str = t1_str.replace('COUNTER MOVE = yes', 'COUNTER MOVE = ' + dc1)
    t1_new_file = open(t1_new_path, 'w')
    t1_new_file.write(t1_str)
    t1_new_file.close()
    
    t2_file = open(t2_path, 'r')
    t2_str = t2_file.read()
    t2_file.close()
    t2_str = t2_str.replace('/home/secoops/web/haipeng/refine//cfg/energy-stage4.cfg', e2_new_path)
    t2_str = t2_str.replace('COUNTER MOVE = yes', 'COUNTER MOVE = ' + dc2)
    t2_new_file = open(t2_new_path, 'w')
    t2_new_file.write(t2_str)
    t2_new_file.close()
    
    t3_file = open(t3_path, 'r')
    t3_str = t3_file.read()
    t3_file.close()
    t3_str = t3_str.replace('/home/secoops/web/haipeng/refine//cfg/energy-stage6.cfg', e3_new_path)
    t3_str = t3_str.replace('COUNTER MOVE = yes', 'COUNTER MOVE = ' + dc3)
    t3_new_file = open(t3_new_path, 'w')
    t3_new_file.write(t3_str)
    t3_new_file.close()
    
    e1_file = open(e1_path, 'r')
    e1_str = e1_file.read()
    e1_file.close()
    e1_str = e1_str.replace('/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, 0.0', '/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, ' + dope1)
    e1_str = e1_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, 25.0', '/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, ' + tsp1)
    e1_str = e1_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, 5.0', '/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, ' + tspNN1)
    e1_str = e1_str.replace('/home/secoops/web/haipeng/refine//cfg/nce-exp1-b0.5.cfg, 4.0', '/home/secoops/web/haipeng/refine//cfg/nce-exp1-b0.5.cfg, ' + nce1)
    e1_str = e1_str.replace('/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, 0.0', '/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, ' + bmk1)
    e1_new_file = open(e1_new_path, 'w')
    e1_new_file.write(e1_str)
    e1_new_file.close()
    
    e2_file = open(e2_path, 'r')
    e2_str = e2_file.read()
    e2_file.close()
    e2_str = e2_str.replace('/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, 1.0', '/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, ' + dope2)
    e2_str = e2_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, 12.5', '/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, ' + tsp2)
    e2_str = e2_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, 5.0', '/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, ' + tspNN2)
    e2_str = e2_str.replace('/home/secoops/web/haipeng/refine//cfg/nce-exp0-b0.5.cfg, 5.0', '/home/secoops/web/haipeng/refine//cfg/nce-exp0-b0.5.cfg, ' + nce2)
    e2_str = e2_str.replace('/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, 10.0', '/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, ' + bmk2)
    e2_new_file = open(e2_new_path, 'w')
    e2_new_file.write(e2_str)
    e2_new_file.close()
    
    e3_file = open(e3_path, 'r')
    e3_str = e3_file.read()
    e3_file.close()
    e3_str = e3_str.replace('/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, 1.0', '/home/secoops/web/haipeng/refine//cfg/rdope-bb.cfg, ' + dope3)
    e3_str = e3_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, 25.0', '/home/secoops/web/haipeng/refine//cfg/tsp1-1.cfg, ' + tsp3)
    e3_str = e3_str.replace('/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, 10.0', '/home/secoops/web/haipeng/refine//cfg/tsp1-3A.cfg, ' + tspNN3)
    e3_str = e3_str.replace('/home/secoops/web/haipeng/refine//cfg/nce-exp0-b0.5.cfg, 8.0', '/home/secoops/web/haipeng/refine//cfg/nce-exp0-b0.5.cfg, ' + nce3)
    e3_str = e3_str.replace('/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, 10.0', '/home/secoops/web/haipeng/refine//cfg/BMKhbond-B.cfg, ' + bmk3)
    e3_new_file = open(e3_new_path, 'w')
    e3_new_file.write(e3_str)
    e3_new_file.close()
    
    submit_str = '\tYour model, ' + name1 + ', has been submitted to the queue:\n\t<br>\n\tWhen it is running, notification will be sent to ' + email_address + '\n<br><br>\nCome back to this page at a later time for updated results\n'
    title = 'Refinement status of ' + name1
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(title, submit_str, foot_message, html_path)
    
    response_str = '\t' + name1 + ' has been submitted to the structure refinement server. A 100 residue protein will typically complete within 12 hours. Significantly faster versions are under development.\n\t<br>Notification will be sent to ' + email_address + '\n<br><br>\nYou can check the status of ' + name1 + ' at any time at the following page:\n<br><br>\n<a href=\"http://godzilla.uchicago.edu/refine/' + rand_label + '/' + rand_label + '.html\">' + name1 + ' status</a>'
   
    foot_message = 'problems? send ref. # ' + str(rand_label) + ' godzilla-help@lists.uchicago.edu'
    display_page(response_str, name1 + ' submitted to the queue', foot_message, 'refinement')
    
    queue_log_label = rand_label + '.qlog'
    queue_pdb_label = rand_label + '.pdb'
    queue_density_label = rand_label + '.situs'
    queue_log_dir_path = '/home/secoops/web/REFINE_QUEUE'
    queue_pdb_dir_path = '/home/secoops/web/REFINE_MODELS'
    queue_initial_pdb_dir_path = '/home/secoops/web/REFINE_INITIAL'
    queue_ref_dir_path = '/home/secoops/web/REFINE_REF'
    
    queue_log_path = os.path.join(queue_log_dir_path, queue_log_label)
    queue_pdb_path = os.path.join(queue_pdb_dir_path, queue_pdb_label)
    queue_initial_pdb_path = os.path.join(queue_initial_pdb_dir_path, queue_pdb_label)
    queue_ref_path = os.path.join(queue_ref_dir_path, queue_pdb_label)
    queue_density_path = os.path.join(queue_ref_dir_path, queue_density_label)
    os.system('cp ' + density_path + ' ' + queue_density_path)
    os.system('cp ' + pdb_path + ' ' + queue_initial_pdb_path)
    
    MSE_to_MET(pdb_path, queue_pdb_path)
    if name2 != "": MSE_to_MET(ref_path, queue_ref_path)
    else: MSE_to_MET(pdb_path, queue_ref_path)
    os.remove(pdb_path)
    if ref_path != "" and os.path.exists(ref_path): os.remove(ref_path)
    if density_path != "" and os.path.exists(density_path): os.remove(density_path)
    
    queue_log_file = open(queue_log_path, 'w')
    queue_log_file.write('EMAIL = ' + email_address)
    queue_log_file.write('\nNAME = ' + name1)
    queue_log_file.write('\njob_type = ' + str(job_type_flag))
    queue_log_file.write('\nmask_ligands = ' + str(mask_ligands_flag))
    message = 'Your model ' + name1 + ' has been submitted to the refinement server. Notification will be sent when your submission status has changed. You can check the status of your job at the following page: http://godzilla.uchicago.edu/refine/' + rand_label + '/' + rand_label + '.html'
    email_subject = name1 + '_refinement'
    os.system('echo ' + message + ' | mail -s ' + email_subject + ' ' + email_address)
    os.system('echo ' + email_address + ' - ' + rand_label+ ' | mail -s refine_job jhinshaw@uchicago.edu')
    os.system('echo ' + email_address + ' - ' + rand_label+ ' | mail -s refine_job haddadian@uchicago.edu')
    queue_log_file.close()
    os.system('chmod g+w ' + html_path)

def Make_HTML_fileWEB(title, contents_string, foot_message, out_path):
    header_file = open('/var/www/includes/head_oops', 'r')
    html_head_string = header_file.read()
    html_head_string = html_head_string.replace('HEADERHERE', title)
    html_head_string = html_head_string.replace('REPLACETITLE', 'ItFix server')
    header_file.close()
    
    tail_file = open('/var/www/includes/foot', 'r')
    html_tail_string = tail_file.read()
    tail_file.close()
     
    html_string = html_head_string + contents_string + html_tail_string
    #html_string = html_string.replace('DATE_UPDATED', Date_Time_str())
    html_string = html_string.replace('DATE_UPDATED', foot_message)
    out_file = open(out_path, 'w')
    out_file.write(html_string)
    out_file.close()
    
def progress_bar():
    
  progress_bar = '<script language="javascript">\nvar progressEnd = 9;\nvar progressColor = \'green\';\nvar progressInterval = 1000;\n\nvar progressAt = progressEnd;\nvar progressTimer;\nfunction progress_clear() {\nfor (var i = 1; i <= progressEnd; i++)\n document.getElementById(\'progress\'+i).style.backgroundColor = \'transparent\';\nprogressAt = 0;\n}\nfunction progress_update() {\ndocument.getElementById(\'showbar\').style.visibility = \'visible\';\nprogressAt++;\nif (progressAt > progressEnd) progress_clear();\nelse document.getElementById(\'progress\'+progressAt).style.backgroundColor = progressColor;\nprogressTimer = setTimeout(\'progress_update()\',progressInterval);\n}\nfunction progress_stop() {\nclearTimeout(progressTimer);\nprogress_clear();\ndocument.getElementById(\'showbar\').style.visibility = \'hidden\';\n}\n\n</script>\n'
  
  progress_bar += '<table ><tr><td>\n<div id=\"showbar\" style=\"font-size:8pt;padding:2px;border:solid black 1px;visibility:hidden\">\n<span id=\"progress1\">&nbsp; &nbsp;</span>\n<span id=\"progress2\">&nbsp; &nbsp;</span>\n<span id=\"progress3\">&nbsp; &nbsp;</span>\n<span id=\"progress4\">&nbsp; &nbsp;</span>\n<span id=\"progress5\">&nbsp; &nbsp;</span>\n<span id=\"progress6\">&nbsp; &nbsp;</span>\n<span id=\"progress7\">&nbsp; &nbsp;</span>\n<span id=\"progress8\">&nbsp; &nbsp;</span>\n<span id=\"progress9\">&nbsp; &nbsp;</span>\n</div>\n</td></tr></table>\n<p>\n<br>\n'
  
  return progress_bar
    
def psi_phi_map_server_main(f1_path, date_label, name1):
    
    pickle_path = '/home/secoops/web/psi_phi/psi_phi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    probs = [None] * 20
    for i in range(20):
        probs[i] = [None] * 20
    for j in range(20):
        probs[i][j] = [0.0] * 324
        
    for j in range(20):
        count = 0
        for k in range(324): count += rama_bins[i][j][k]
        for k in range(324): probs[i][j][k] = float(rama_bins[i][j][k]) / float(count)
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web')
    back_path = tempfile.mktemp('.txt')
    psi_path = tempfile.mktemp('.txt')
    phi_path = tempfile.mktemp('.txt')
    energy_path = tempfile.mktemp('.txt')
    psi_file = open(psi_path, 'w')
    phi_file = open(phi_path, 'w')
    energy_file = open(energy_path, 'w')
    os.system('./backbone ' + f1_path + ' > ' + back_path)
    os.chdir(current_dir)
    
    back_lines = readlines(back_path)
    for i in range(len(back_lines) - 1):
        split0 = back_lines[i].split()
    split1 = back_lines[i + 1].split()
    if len(split0) < 4 or len(split1) < 4: continue
    psi = split0[4]
    phi = split1[3]
    
    psi_bin = int((float(psi) + 180.00) / 20.0)
    phi_bin = int((float(phi) + 180.00) / 20.0)
    psi_phi_bin = psi_bin + 18 * phi_bin
        
    pair_prob = probs[AACode(split0[2])][AACode(split1[2])][psi_phi_bin]
    if pair_prob > 0.0: energy_file.write(str(math.log(pair_prob) * -1.0) + '\n')
    else: energy_file.write(str(10.0) + '\n')
    
    psi_file.write(psi + '\n')
    phi_file.write(phi + '\n')
    
    psi_file.close()
    phi_file.close()
    energy_file.close()
    
    color_scatterplot(psi_path, phi_path, energy_path, name1, '/var/www/img/' + date_label + '.gif')
    #PY_scatterplot(psi_path, phi_path, 'psi-phi map for ' + name1, 'psi', 'phi', '/var/www/img/' + date_label + '.gif')
    psi_phi_mirror_generate_form('../img/' + date_label + '.gif')
    
    os.remove(back_path)
    os.remove(psi_path)
    os.remove(phi_path)
    os.remove(energy_path)
    os.remove(f1_path)
    
def total_trajectory(pdb_list, total_path):
    
    pred_dir = os.path.split(pdb_list[0])[0]
    total_file = open(total_path, 'w')
    
    for i in range(len(pdb_list)):
        total_file.write('MODEL ' + os.path.split(pdb_list[i])[1] + '\n')
    pdb_lines = readlines(pdb_list[i])
    for j in range(len(pdb_lines)):
        total_file.write(pdb_lines[j])
    total_file.write('ENDMDL\n')
    total_file.close()
    
def verify_situs_map(file):
    #checks if map contains a valid situs header. not foolproof, but will prevent any other file format being uploaded
    #requires linecache and re libraries
    situs_regex = re.compile("^\d+[.]?\d* " + "-?\d+[.]?\d* "*3) #+ "\d+ \d+ \d+")
    header = linecache.getline(file,1) 
    if(situs_regex.search(header)):
        return True
    else:
        return False
    
def cns2situs(in_path, out_path):

    situs_command = '/home/jhinshaw/lib/Situs_2.5/bin/map2map ' + in_path + ' ' + out_path + ' << five\n5\nfive\n'
    os.system(situs_command)
    
def dist_array(model_path):
    
    model_lines = readlines(model_path)
    coord_vec = []
    for line in model_lines:
        if line[0:4] == 'ATOM':
            if line[13:15] == 'CA':
                coord_vec += [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    dist_list = []
    for i in range(len(coord_vec) - 3):
        for j in range(i + 2, len(coord_vec)):
            dist = math.sqrt(((coord_vec[i][0] - coord_vec[j][0]) ** 2) + ((coord_vec[i][1] - coord_vec[j][1]) ** 2) + ((coord_vec[i][2] - coord_vec[j][2]) ** 2))
            dist_list += [dist]
        
    return array(dist_list)
    
def coord_vec(model_path):

    model_lines = readlines(model_path)
    coord_vec = []
    for line in model_lines:
        if line[0:4] == 'ATOM':
            if line[13:15] == 'CA':
                coord_vec += [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    return coord_vec
        
def CB_coord_vec(model_path):

    model_lines = readlines(model_path)
    coord_vec = []
    for line in model_lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CB' or (line[13:15] == 'CA' and line[17:20] == 'GLY'):
        coord_vec += [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    return coord_vec
        
def distance(c1, c2):
    
    return math.sqrt(((c1[0] - c2[0]) ** 2) + ((c1[1] - c2[1]) ** 2) + ((c1[2] - c2[2]) ** 2))
                    
def dist_bin(dist, min_dist, max_dist, bin_width, num_bins):
    
    temp_dist = min_dist
    for i in range(num_bins):
        if dist > temp_dist and dist <= temp_dist + bin_width:
        return i
    temp_dist = temp_dist + bin_width
    
def bin_dist(bin, min_dist, max_dist, bin_width, num_bins):
    
    temp_dist = min_dist
    for i in range(num_bins):
        if i == bin:
        return temp_dist + bin_width
    temp_dist = temp_dist + bin_width
        
def AtomCode(atom_name):
    if atom_name == 'CA': return 0
    if atom_name == 'CB': return 1
    if atom_name == 'N': return 2
    if atom_name == 'C': return 3
    if atom_name == 'O': return 4
    if atom_name == 'HN': return 5
    else: return 6
    
def AtomName(atom_num):
    if atom_num == 0: return 'CA'
    if atom_num == 1: return 'CB'
    if atom_num == 2: return 'N'
    if atom_num == 3: return 'C'
    if atom_num == 4: return 'O'
    if atom_num == 5: return 'HN'
    else: return '?'
    
def hydrophobic_RGcalc(pdb_path):
    
    coord_vec = []
    CA_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if line[13:15] == 'CB' and hydrophobic(AAChar_fasta(AACode(line[17:20].strip()))) == 1:
                coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
            if line[13:15] == 'CA':
                CA_vec = CA_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    L = len(coord_vec)
    if L == 0: return 1000.0
        
    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(CA_vec)):
        x = x + CA_vec[i][0]
        y = y + CA_vec[i][1]
        z = z + CA_vec[i][2]
    x = x / (float(len(CA_vec)))
    y = y / (float(len(CA_vec)))
    z = z / (float(len(CA_vec)))

    x_dev = 0.0
    y_dev = 0.0
    z_dev = 0.0
    for i in range(len(coord_vec)):
        x_dev = x_dev + ((coord_vec[i][0] - x) * (coord_vec[i][0] - x))
    y_dev = y_dev + ((coord_vec[i][1] - y) * (coord_vec[i][1] - y))
    z_dev = z_dev + ((coord_vec[i][2] - z) * (coord_vec[i][2] - z))
    Rg = math.sqrt((x_dev + y_dev + z_dev) / float(len(coord_vec)))
    return Rg
    
def hydrophobic_RGcalc(pdb_path):
    
    coord_vec = []
    CA_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if line[13:15] == 'CB' and hydrophobic(AAChar_fasta(AACode(line[17:20].strip()))) == 1:
                coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
            if line[13:15] == 'CA':
                CA_vec = CA_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    L = len(coord_vec)
    if L == 0: return 1000.0
        
    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(CA_vec)):
        x = x + CA_vec[i][0]
        y = y + CA_vec[i][1]
        z = z + CA_vec[i][2]
    x = x / (float(len(CA_vec)))
    y = y / (float(len(CA_vec)))
    z = z / (float(len(CA_vec)))

    x_dev = 0.0
    y_dev = 0.0
    z_dev = 0.0
    for i in range(len(coord_vec)):
        x_dev = x_dev + ((coord_vec[i][0] - x) * (coord_vec[i][0] - x))
    y_dev = y_dev + ((coord_vec[i][1] - y) * (coord_vec[i][1] - y))
    z_dev = z_dev + ((coord_vec[i][2] - z) * (coord_vec[i][2] - z))
    Rg = math.sqrt((x_dev + y_dev + z_dev) / float(len(coord_vec)))
    return Rg
    
def hydrophilic_RGcalc(pdb_path):
    
    coord_vec = []
    CA_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if line[13:15] == 'CB' and hydrophobic(AAChar_fasta(AACode(line[17:20].strip()))) == 0:
                coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
            if line[13:15] == 'CA':
                CA_vec = CA_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    L = len(coord_vec)
    if L == 0: return 1000.0
        
    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(CA_vec)):
        x = x + CA_vec[i][0]
        y = y + CA_vec[i][1]
        z = z + CA_vec[i][2]
    x = x / (float(len(CA_vec)))
    y = y / (float(len(CA_vec)))
    z = z / (float(len(CA_vec)))

    x_dev = 0.0
    y_dev = 0.0
    z_dev = 0.0
    for i in range(len(coord_vec)):
        x_dev = x_dev + ((coord_vec[i][0] - x) * (coord_vec[i][0] - x))
    y_dev = y_dev + ((coord_vec[i][1] - y) * (coord_vec[i][1] - y))
    z_dev = z_dev + ((coord_vec[i][2] - z) * (coord_vec[i][2] - z))
    Rg = math.sqrt((x_dev + y_dev + z_dev) / float(len(coord_vec)))
    return Rg
    
def sequence_length(pdb_path):

    sequence_length = 0
    coord_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if line[13:15] == 'CA': sequence_length += 1
    return sequence_length   
    
def burial_ratio(pdb_path):
    return hydrophobic_RGcalc(pdb_path) / hydrophilic_RGcalc(pdb_path)

def stripH(in_path, out_path):

    out_file = open(out_path, 'w')
    coord_vec = []
    pdb_lines = readlines(in_path)
    for i in range(len(pdb_lines)):
        line = pdb_lines[i]
        print_line = True
        if 'H' in line[12:16] and line[13:15] != 'HN': print_line = False
    if print_line: out_file.write(line)

    out_file.close()

def cluster_pdb_list(cluster_path, cluster_int):

    in_dir = os.path.split(cluster_path)[0]
    lines = readlines(cluster_path)
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break
    
    return pdb_list
    
def cluster_std(cluster_path, cluster_int):

    in_dir = os.path.split(cluster_path)[0]
    lines = readlines(cluster_path)
    select = False
    rmsd_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: rmsd_list.append(float(lines[j].split()[1]))
        else:
            select = True 
            break
    if select: break
    
    rmsd_array = array(rmsd_list)
    print rmsd_list
    print std(rmsd_array)
    
def cluster_contacts(in_dir, native_path):

    #lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    #select = False
    #pdb_list = []
    #for i in range(len(lines)):
#    if len(lines[i].split()) < 2: continue
#    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
#        for j in range(i + 1 , len(lines)):
#            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
#        else:
#            select = True 
#            break
#    if select: break

    pdb_list = []
    in_list = os.listdir(in_dir)
    for i in range(len(in_list)):
    if in_list[i].split('.')[1] == 'pdb': pdb_list.append(os.path.join(in_dir, in_list[i]))

    N = len(pdb_list)
    
    native_coord = coord_vec(native_path)
    L = len(native_coord)
    
    cmatrix = []
    for i in range(L):
    cmatrix.append([])
    for j in range(L): cmatrix[i].append(0)
    
    pmatrix = []
    for i in range(L):
    pmatrix.append([])
    for j in range(L): pmatrix[i].append(0.0)
    
    count = 0
    for i in range(L):
    for j in range(i + 1, L):
        if distance(native_coord[i], native_coord[j]) < 8.0:
            cmatrix[i][j] += 1
        count += 1
    for i in range(L):
    for j in range(i + 1, L):
        pmatrix[i][j] = float(cmatrix[i][j]) / float(count) 
    
    count = 0
    for i in range(N):
        
    coords = coord_vec(pdb_list[i])
    
    for k in range(L):
        for l in range(k + 1, L):
        if distance(coords[l], coords[k]) < 8.0:
            cmatrix[l][k] += 1
            count += 1

    cpath = tempfile.mktemp('.txt')
    cfile = open(cpath, 'w')

    for i in range(L):
    for j in range(i + 1, L):
        pmatrix[j][i] = float(cmatrix[j][i]) / float(count)
        
    for i in range(L):
    for j in range(L):
        cfile.write(str(pmatrix[i][j]) + '\t')
    cfile.write('\n')
    
    cfile.close()
   
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
         
    cdata = pylab.load(cpath)
    os.remove(cpath)
    
    pylab.contour(cdata)

    png_path = os.path.join(in_dir, 'contacts.png')
    pylab.savefig(png_path)
    gif_path = os.path.join(in_dir, 'contacts.gif')
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
    
def native_contacts(native_path):
    
    native_coord = coord_vec(native_path)
    L = len(native_coord)
    
    cmatrix = []
    for i in range(L):
    cmatrix.append([])
    for j in range(L): cmatrix[i].append(0)
    
    pmatrix = []
    for i in range(L):
    pmatrix.append([])
    for j in range(L): pmatrix[i].append(0.0)
    
    count = 0
    for i in range(L):
    for j in range(L):
        if distance(native_coord[i], native_coord[j]) < 8.0:
            cmatrix[i][j] += 1
        count += 1
    for i in range(L):
    for j in range(L):
        pmatrix[i][j] = float(cmatrix[i][j]) / float(count) 


    cpath = tempfile.mktemp('.txt')
    cfile = open(cpath, 'w')

    for i in range(L):
    for j in range(i + 1, L):
        pmatrix[j][i] = float(cmatrix[j][i]) / float(count)
        
    for i in range(L):
    for j in range(L):
        cfile.write(str(pmatrix[i][j]) + '\t')
    cfile.write('\n')
    
    cfile.close()
   
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
         
    cdata = pylab.load(cpath)
    os.remove(cpath)
    
    pylab.contour(cdata)

    png_path = '/home/secoops/contacts.png'
    pylab.savefig(png_path)
    gif_path = '/home/secoops/contacts.gif'
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
 
def BMK_contacts(pdb_path, gif_path, name):
    matrix_path = pdb_path.split('.')[0] + '.hmatrix'
    current_dir = os.getcwd()
    os.chdir('/home/secoops/test/clOOPS-0.9.6-BETA1-src/bin')
    bmk_path = tempfile.mktemp('.txt')
    pdbr_path = tempfile.mktemp('.pdb')
    Renumber(1, 1, pdb_path, pdbr_path)
    pdbh_path = tempfile.mktemp('.pdb')
    os.system('./sconv ' + pdbr_path + ' ' + pdbh_path + ' -in /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/io/libPDBread.so -out /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/io/libPDBwrite.so -H')
    os.system('./scalc -cfg /home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/scalc.cfg -calc /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/calc/libEHBOND.so,/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/BMK.cfg -str ' + pdbh_path + ' > ' + bmk_path)
    os.system('cp ' + bmk_path + ' ' + matrix_path)
    bmk_lines = readlines(bmk_path)
    os.remove(bmk_path)
    os.remove(pdbh_path)
    os.remove(pdbr_path)
    
    cpath = tempfile.mktemp('.txt')
    cfile = open(cpath, 'w')
    for i in range(len(bmk_lines) - 2):
    line = bmk_lines[i].strip().split()
    for j in range(len(line)): cfile.write(line[j] + '\t')
    cfile.write('\n')
    cfile.close()
    
 
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.xlabel('Acceptor position', fontsize=20)
    pylab.ylabel('Donor position', fontsize=20)
    pylab.title('hbond matrix for ' + name, fontsize=20)
             
    cdata = pylab.load(cpath)
    
    os.remove(cpath)
    
    pylab.contour(cdata)

    png_path = tempfile.mktemp('.png')
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
 
def cluster_contacts2(in_dir, cluster_int, native_path):

    lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break

    N = len(pdb_list)
    
    native_coord = coord_vec(native_path)
    L = len(native_coord)
    
    cmatrix = []
    for i in range(L):
    cmatrix.append([])
    for j in range(L): cmatrix[i].append(0)
    
    pmatrix = []
    for i in range(L):
    pmatrix.append([])
    for j in range(L): pmatrix[i].append(0.0)
    
    count = 0
    for i in range(L):
    for j in range(i + 1, L):
        if distance(native_coord[i], native_coord[j]) < 10.0:
            cmatrix[i][j] += 1
        count += 1
    for i in range(L):
    for j in range(i + 1, L):
        pmatrix[i][j] = float(cmatrix[i][j]) / float(count) 
    
    count = 0
    for i in range(N):
        
    coords = coord_vec(pdb_list[i])
    
    for k in range(L):
        for l in range(k + 1, L):
        if distance(coords[l], coords[k]) < 10.0:
            cmatrix[l][k] += 1
            count += 1

    cpath = tempfile.mktemp('.txt')
    cfile = open(cpath, 'w')

    for i in range(L):
    for j in range(i + 1, L):
        pmatrix[j][i] = float(cmatrix[j][i]) / float(count)
        
    for i in range(L):
    for j in range(L):
        cfile.write(str(pmatrix[i][j]) + '\t')
    cfile.write('\n')
    
    cfile.close()
   
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
             
    cdata = pylab.load(cpath)
    os.remove(cpath)
    
    pylab.contour(cdata)

    png_path = os.path.join(in_dir, 'contacts_' + str(cluster_int) + '.png')
    pylab.savefig(png_path)
    gif_path = os.path.join(in_dir, 'contacts_' + str(cluster_int) + '.gif')
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
    
def burial_count(pdb_path):
    
    coord_vec = []
    CB_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
            coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        if line[13:15] == 'CB' and hydrophobic(AAChar_fasta(AACode(line[17:20].strip()))) == 1:
            CB_vec = CB_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    L = len(coord_vec)
    if L == 0: return 1000.0
        
    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(coord_vec)):
        x = x + coord_vec[i][0]
        y = y + coord_vec[i][1]
        z = z + coord_vec[i][2]
    x = x / (float(len(coord_vec)))
    y = y / (float(len(coord_vec)))
    z = z / (float(len(coord_vec)))

    x_dev = 0.0
    y_dev = 0.0
    z_dev = 0.0
    for i in range(len(coord_vec)):
        x_dev = x_dev + ((coord_vec[i][0] - x) * (coord_vec[i][0] - x))
    y_dev = y_dev + ((coord_vec[i][1] - y) * (coord_vec[i][1] - y))
    z_dev = z_dev + ((coord_vec[i][2] - z) * (coord_vec[i][2] - z))
    Rg = math.sqrt((x_dev + y_dev + z_dev) / float(len(coord_vec)))
    
    total_HPBIC = float(len(CB_vec))
    buried = 0.0
    for i in range(len(CB_vec)):
    for j in range(len(CB_vec)):
            buried += (CB_vec[i][0] - CB_vec[j][0]) ** 2 + (CB_vec[i][1] - CB_vec[j][1]) ** 2 + (CB_vec[i][2] - CB_vec[j][2]) ** 2
    
    print 'burial count:', math.sqrt(buried)
    return Rg
    
def RGcalc(pdb_path):
    
    coord_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
            coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
        
    L = len(coord_vec)
    if L == 0: return 1000.0
        
    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(coord_vec)):
        x = x + coord_vec[i][0]
        y = y + coord_vec[i][1]
        z = z + coord_vec[i][2]
    x = x / (float(len(coord_vec)))
    y = y / (float(len(coord_vec)))
    z = z / (float(len(coord_vec)))

    x_dev = 0.0
    y_dev = 0.0
    z_dev = 0.0
    for i in range(len(coord_vec)):
        x_dev = x_dev + ((coord_vec[i][0] - x) * (coord_vec[i][0] - x))
    y_dev = y_dev + ((coord_vec[i][1] - y) * (coord_vec[i][1] - y))
    z_dev = z_dev + ((coord_vec[i][2] - z) * (coord_vec[i][2] - z))
    Rg = math.sqrt((x_dev + y_dev + z_dev) / float(len(coord_vec)))
    return Rg
    
def RUcalc(pdb_path):

    rg = RGcalc(pdb_path)

    coord_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
            coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
    L = len(coord_vec)

    x = 0.0
    y = 0.0
    z = 0.0
    for i in range(len(coord_vec)):
        x = x + coord_vec[i][0]
        y = y + coord_vec[i][1]
        z = z + coord_vec[i][2]
    x = x / (float(len(coord_vec)))
    y = y / (float(len(coord_vec)))
    z = z / (float(len(coord_vec)))

    cm_count = 0
    total_dist = 0.0
    for i in range(len(coord_vec)):
        x_dev = (coord_vec[i][0] - x)
    y_dev = (coord_vec[i][1] - y)
    z_dev = (coord_vec[i][2] - z)
    total_dist += math.sqrt(x_dev ** 2 + y_dev ** 2 + z_dev ** 2)
    if math.sqrt(x_dev ** 2 + y_dev ** 2 + z_dev ** 2) > rg: cm_count += 1
    mean_dist = total_dist / len(coord_vec)

    print float(cm_count) / float(L)
    
    diff_sum = 0.0
    for i in range(len(coord_vec)):
        x_dev = (coord_vec[i][0] - x)
    y_dev = (coord_vec[i][1] - y)
    z_dev = (coord_vec[i][2] - z)
    diff_sum += ((math.sqrt(x_dev ** 2 + y_dev ** 2 + z_dev ** 2) - mean_dist) ** 2)
    
    return math.sqrt(diff_sum / (len(coord_vec) - 1))

def CCcalc(pdb_path):
    
    txt_path = tempfile.mktemp('.txt')
    os.system('./scalc -cfg ../prj/SECsamplerSC/cfg/scalc.cfg -calc calc/libCROSS.so,../prj/SECsamplerSC/cfg/dope.cfg -str ' + pdb_path + ' > ' + txt_path)
    cc = int(readline(txt_path, 1))
    os.remove(txt_path)
    return cc

def CClist(pdb_dir):
    
    secseq_path = os.path.join(os.path.split(pdb_dir)[0], os.path.split(os.path.split(pdb_dir)[0])[1] + '.secseq')
    pred_path = os.path.join(pdb_dir, 'prediction.txt')
    pred_lines = readlines(pred_path)
    for i in range(len(pred_lines)):
    items = pred_lines[i].split()
    pdb_path = os.path.join(pdb_dir, items[0] + '.pdb')
    if CCcalc(pdb_path) == 0 and IsolatedStrand(pdb_path, secseq_path) == 0: print items[0], items[1]
    
def IsolatedStrand(pdb_path, secseq_path):
    
    CA_vec = coord_vec(pdb_path)
    secseq = readline(secseq_path, 1)
    
    if len(CA_vec) == len(secseq): L = len(secseq)
    else: return
    
    for i in range(L):
    if secseq[i] == 'E':
        partner = False
        for j in range(L):
        if secseq[j] in 'EOA':
            if absolute(i - j) > 3:
            dist = math.sqrt(((CA_vec[i][0] - CA_vec[j][0]) ** 2) + ((CA_vec[i][1] - CA_vec[j][1]) ** 2) + ((CA_vec[i][2] - CA_vec[j][2]) ** 2))
            if dist < 8.0:
                partner = True
                break
        if not partner:
        print i + 1
            return 1
            
      
    return 0
    
def SortLists(pdb_dir):
    
    cross_path = os.path.join(pdb_dir, 'cross.txt')
    pred_path = os.path.join(pdb_dir, 'prediction.txt')
    sort_path = os.path.join(pdb_dir, 'sort.txt')
    
    cross_lines = readlines(cross_path)
    pred_lines = readlines(pred_path)

    pred_vec = []
    
    for i in range(len(pred_lines)):
    itemsi = pred_lines[i].split()
    use = True
    for j in range(len(cross_lines)):
        itemsj = cross_lines[j].split()
        if itemsi[0] == itemsj[0]:
        use = False
        break
    if use:
        pred_vec.append([float(itemsi[2]), float(itemsi[1]), itemsi[0]])
        
    pred_vec.sort()
    
    L = len(pred_vec)
    
    sortL = int(float(L) / 2.0)
    
    sort_file = open(sort_path, 'w')
    for i in range(sortL):
    sort_file.write(pred_vec[i][2] + '\t' + str(pred_vec[i][1]) + '\t' + str(pred_vec[i][0]) + '\n')
    sort_file.close()
    
def bottom_half(in_dir, secseq_path):
    
    name = os.path.split(in_dir)[1]
    final_dir = os.path.join(in_dir, 'Final')
    pred_path = os.path.join(final_dir, 'prediction.txt')
    sort_path = os.path.join(final_dir, 'prediction_lower.txt')
    
    pred_lines = readlines(pred_path)

    pred_vec = []
    
    for i in range(len(pred_lines)):
    itemsi = pred_lines[i].split()
    pdb_path = os.path.join(final_dir, itemsi[0] + '.pdb')
    if IsolatedStrand(pdb_path, secseq_path) == 0: pred_vec.append([float(itemsi[2]), float(itemsi[1]), itemsi[0]])

    
    L = len(pred_vec)
    
    sort_file = open(sort_path, 'w')
    for i in range(L):
    sort_file.write(pred_vec[i][2] + '\t' + str(pred_vec[i][1]) + '\t' + str(pred_vec[i][0]) + '\n')
    sort_file.close()
    
def AddSideChains(final_dir, side_chain_dir):

    scwrl_dir = '/home/secoops/scwrl4'
    pwd = os.getcwd()
    if not os.path.exists(side_chain_dir): os.mkdir(side_chain_dir)
    os.chdir(scwrl_dir)
    final_list = os.listdir(final_dir)
    for pdb_name in final_list:
        pdb_path = os.path.join(final_dir, pdb_name)
    side_chain_path = os.path.join(side_chain_dir, pdb_name)
    os.system('./Scwrl4 -i ' + pdb_path + ' -o ' + side_chain_path)
    os.chdir(pwd)
    
def ReturnDSSP(pdb_path):
    
    renumber_tmp_fn = tempfile.mktemp('.renumber')
    Renumber(1, 1, pdb_path, renumber_tmp_fn)
    tmp_fn = tempfile.mktemp('.dssp')
    os.system('./dssp ' + renumber_tmp_fn + ' > ' + tmp_fn)
    dssp_output_file = open(tmp_fn, 'r')
    native_dssp = ''
    start_reading = 'no'
    found_index = 'no'
    SecStr_string = 'HESTBG'
    subunit_string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    line = dssp_output_file.readline()
    index = 3
    while line:
        line = line.strip()
    line = line.split()
    if start_reading == 'yes':
        if found_index == 'no':
        line_2 = 'no'
        line_3 = 'no'
            for i in range(len(subunit_string)):
            if line[2] == subunit_string[i]:
            line_2 = 'yes'
        for i in range(len(subunit_string)):
            if line[3] == subunit_string[i]:
            line_3 = 'yes'
        if line_2 == 'yes' and line_3 == 'yes':
            index = 4
        found_index = 'yes'
        found_a_SecStr = 'no'
        for i in range(len(SecStr_string)):
            if line[index] == SecStr_string[i]:
            SecStr_char = SecStr_string[i]
            found_a_SecStr = 'yes'
            if found_a_SecStr == 'no': 
                SecStr_char = 'N'
        native_dssp = native_dssp + SecStr_char
    if line[0] == '#' and line[1] == 'RESIDUE':
        start_reading = 'yes'
    line = dssp_output_file.readline()
    os.remove(tmp_fn)
    os.remove(renumber_tmp_fn)
    
    return native_dssp
    
def AssignSecStr(pdb_path, dssp_out_path):
    
    renumber_tmp_fn = tempfile.mktemp('.renumber')
    Renumber(1, 1, pdb_path, renumber_tmp_fn)
    tmp_fn = tempfile.mktemp('.dssp')
    os.system('./dssp ' + renumber_tmp_fn + ' > ' + tmp_fn)
    dssp_output_file = open(tmp_fn, 'r')
    native_dssp = ''
    start_reading = 'no'
    found_index = 'no'
    SecStr_string = 'HESTBG'
    subunit_string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    line = dssp_output_file.readline()
    index = 3
    while line:
        line = line.strip()
    line = line.split()
    if start_reading == 'yes':
        if found_index == 'no':
        line_2 = 'no'
        line_3 = 'no'
            for i in range(len(subunit_string)):
            if line[2] == subunit_string[i]:
            line_2 = 'yes'
        for i in range(len(subunit_string)):
            if line[3] == subunit_string[i]:
            line_3 = 'yes'
        if line_2 == 'yes' and line_3 == 'yes':
            index = 4
        found_index = 'yes'
        found_a_SecStr = 'no'
        for i in range(len(SecStr_string)):
            if line[index] == SecStr_string[i]:
            SecStr_char = SecStr_string[i]
            found_a_SecStr = 'yes'
            if found_a_SecStr == 'no': 
                SecStr_char = 'N'
        native_dssp = native_dssp + SecStr_char
    if line[0] == '#' and line[1] == 'RESIDUE':
        start_reading = 'yes'
    line = dssp_output_file.readline()
    os.remove(tmp_fn)
    os.remove(renumber_tmp_fn)
    
    dssp_out_file = open(dssp_out_path, 'w')
    dssp_out_file.write(native_dssp)
    dssp_out_file.close()
    
def SASAfromDSSP(pdb_path):

    pwd = os.getcwd()
    os.chdir('/home/bartolo/web/haipeng/web')
    
    tmp_path = tempfile.mktemp('.dssp')
    
    os.system('./dssp ' + pdb_path + ' > ' + tmp_path)
    
    dssp_lines = readlines(tmp_path)
    
    start = False
    sasa = []
    ss = []
    for i in range(len(dssp_lines)):
        line0 = dssp_lines[i].split()
        line = []
        for thing1 in range(len(line0)):
        piece = line0[thing1].split(',')
        for thing2 in range(len(piece)):
            line.append(piece[thing2])
        if start:
        count = 0
        #print line
        #print len(line)
        for item in line:
            #if ',' in item:
         #   sasa.append(float(line[count - 1]))
          #  break
            count += 1
        if line[0] == '#' and line[1] == 'RESIDUE': start = True
    
    os.remove(tmp_path)
    os.chdir(pwd)
    
#    for i in range(len(sasa)): print i + 1, sasa[i]
    
def SecStrAccuracyFile(Name, round_sub_dir, native_dssp, accuracy_path):
    
    ##### ANALYSIS SECONDARY STRUCTURE ACCURACY #####
    final_dir = os.path.join(round_sub_dir, 'Final')
    SecStr_consensus_path = os.path.join(final_dir, 'protein.SecStr')
    origins_path = os.path.join(final_dir, 'protein.SecStrAlign')
    secseq_path = os.path.join(round_sub_dir, Name + '.secseq')
      
    
    if native_dssp != '':
    secseq_file = open(secseq_path, 'r')
        secseq_line = secseq_file.readline()
        secseq_line = secseq_line.strip()
    
        l = len(secseq_line)
        secseq_file.close()
        
        turn_counts = [None] * (l - 1)
        for i in range(l - 1):
            turn_counts[i] = [0, 0]
        
    basin_counts = [None] * l
        for i in range(l):
            basin_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]
        
    origins_counts = [None] * l
        for i in range(l):
            origins_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]
        
    if SecStr_consensus_path != "":
        ifile = open(SecStr_consensus_path, 'r')
        line = ifile.readline()
        while line:
            line = line.strip()
        for i in range(l):
            if line[i] == 'H': basin_counts[i][0] = basin_counts[i][0] + 1
            if line[i] == 'E': basin_counts[i][1] = basin_counts[i][1] + 1
            if line[i] == 'S': basin_counts[i][2] = basin_counts[i][2] + 1
            if line[i] == 'B': basin_counts[i][3] = basin_counts[i][3] + 1
            if line[i] == 'G': basin_counts[i][4] = basin_counts[i][4] + 1
            if line[i] == 'T': basin_counts[i][5] = basin_counts[i][5] + 1
            if line[i] == 'N': basin_counts[i][6] = basin_counts[i][6] + 1
        for i in range(l - 1):
        if (line[i] == 'T' and line[i + 1] == 'T') or (line[i] == 'S' and line[i + 1] == 'S'):
            turn_counts[i][0] = turn_counts[i][0] + 1
        else: turn_counts[i][1] = turn_counts[i][1] + 1
            
        line = ifile.readline()
        for i in range(l):
            Total = 0
            for j in range(7):
            Total = Total + basin_counts[i][j]
        basin_counts[i][7] = Total

        basin_probs = [None] * l
        for i in range(l):
            basin_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
        
        turn_probs = [0.0] * (l - 1)
    for i in range(l - 1):
        total = turn_counts[i][0] + turn_counts[i][1]
        turn_probs[i] = float(turn_counts[i][0]) / float(total)
        
        for i in range(l):
            for j in range(7):
            basin_probs[i][j] = float(basin_counts[i][j]) / float(basin_counts[i][7])
            basin_probs[i][8] = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5]  + basin_probs[i][6]
        
    if origins_path != "":
        ifile = open(origins_path, 'r')
        line = ifile.readline()
        while line:
            line = line.strip()
        for i in range(l):
            if line[i] == 'H': origins_counts[i][0] = origins_counts[i][0] + 1
            if line[i] == 'E': origins_counts[i][1] = origins_counts[i][1] + 1
            if line[i] == 'S': origins_counts[i][2] = origins_counts[i][2] + 1
            if line[i] == 'B': origins_counts[i][3] = origins_counts[i][3] + 1
            if line[i] == 'G': origins_counts[i][4] = origins_counts[i][4] + 1
            if line[i] == 'T': origins_counts[i][5] = origins_counts[i][5] + 1
            if line[i] == 'N': origins_counts[i][6] = origins_counts[i][6] + 1
            
        line = ifile.readline()
        for i in range(l):
            Total = 0
            for j in range(7):
            Total = Total + origins_counts[i][j]
        origins_counts[i][7] = Total

        origins_probs = [None] * l
        for i in range(l):
            origins_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
        for i in range(l):
            for j in range(7):
            origins_probs[i][j] = float(origins_counts[i][j]) / float(origins_counts[i][7])
            origins_probs[i][8] = origins_probs[i][2] + origins_probs[i][3] + origins_probs[i][4] + origins_probs[i][5] + origins_probs[i][6]
        
    print_stuff = 'N'
    if print_stuff == 'Y':
        if origins_path != '':
        for i in range(l):
                print i + 1,
                print 'H: ' + str(basin_probs[i][0]) + '  ',
                print 'E: ' + str(basin_probs[i][1]) + '  ',
                print 'S: ' + str(basin_probs[i][2]) + '  ',
                #print 'B: ' + str(basin_probs[i][3]) + '  ',
                print 'G: ' + str(basin_probs[i][4]) + '  ',
                print 'T: ' + str(basin_probs[i][5]) + '  ',
                print 'N: ' + str(basin_probs[i][6]) + '  '

        #print 'C: ' + str(origins_probs[i][8]) + '  ',

            for i in range(l):
            print str(i + 1),
        print 'H: ' + str(origins_probs[i][0]) + '  ',
        print 'E: ' + str(origins_probs[i][1]) + '  ',
        print 'S: ' + str(origins_probs[i][2]) + '  ',
            print 'B: ' + str(origins_probs[i][3]) + '  ',
            print 'G: ' + str(origins_probs[i][4]) + '  ',
            print 'T: ' + str(origins_probs[i][5]) + '  ',
            print 'N: ' + str(origins_probs[i][6]) + '  '
        
        for i in range(l - 1):
        print i + 1, turn_probs[i], native_dssp[i]
        
        for i in range(l):
        C_probs = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5] + basin_probs[i][6]
                print i + 1,
                print 'H: ' + str(basin_probs[i][0]) + '  ',
                print 'E: ' + str(basin_probs[i][1]) + '  ',
        #print 'HB ' + str(basin_probs[i][3] + basin_probs[i][1]) + '  ',
        print native_dssp[i] + '  ',
        #C_probs = origins_probs[i][2] + origins_probs[i][3] + origins_probs[i][4] + origins_probs[i][5] + origins_probs[i][6]
        #print 'H: ' + str(origins_probs[i][0]) + '  ',
        print 'H: ' + str(origins_probs[i][0]) + '  ',
                print 'E: ' + str(origins_probs[i][1]) + '  '
        
    if secseq_path != "":
        secseq_vec = []
        new_secseq_vec = []
    new_lib_secseq_vec = []
        for i in range(l):
            secseq_vec = secseq_vec + [secseq_line[i]]
        new_secseq_vec = new_secseq_vec + [secseq_line[i]]
        new_lib_secseq_vec = new_lib_secseq_vec + [secseq_line[i]]
       
    if native_dssp != '':
        
    Q8_dash = ''
        for i in range(l):
        if native_dssp[i] == 'N': Q8_dash = Q8_dash + '-'
        else: Q8_dash = Q8_dash + native_dssp[i]
    native_dssp = Q8_dash

    #### Q3 ACCURACY CALCULATION ######    
        Q3_vec = ['X'] * l
    Q3_vec[0] = 'C'
    Q3_vec[l - 1] = 'C'
    Q3_native = '' 
    for i in range(l):
        if native_dssp[i] == 'E' or native_dssp[i] == 'H':
                Q3_native = Q3_native + native_dssp[i]
        else: Q3_native = Q3_native + 'C'
        
    Q3_vec[0] = 'C'
    Q3_vec[l - 1] = 'C'
        for i in range(1, l - 1):
            if (Q3_vec[i] == 'X' and ((basin_probs[i][0] > basin_probs[i][1] and basin_probs[i][0] > basin_probs[i][8]))):
            j = 0
            while ((i + j < l - 1) and Q3_vec[i + j] == 'X' and ((basin_probs[i + j][0] > basin_probs[i + j][1] and basin_probs[i + j][0] > basin_probs[i + j][8]))):
                j = j + 1
            if j > 3:
                for k in range(j):
                        Q3_vec[i + k] = 'H'
            
    for i in range(l):
            if (Q3_vec[i] == 'X' and origins_probs[i][1] > 0.50):
            j = 0
            while ((i + j < l) and Q3_vec[i + j] == 'X' and origins_probs[i + j][1] > 0.50):
                j = j + 1
            if j > 2:
                for k in range(j):
                        Q3_vec[i + k] = 'E'
            
    for i in range(1, l - 1):
            if (Q3_vec[i] == 'X'):
            Q3_vec[i] = 'C'
        
        Q3_string = ''
        for i in range(l):
            Q3_string = Q3_string + Q3_vec[i]
        
    print Q3_string
        
    ##### Q3 ACCURACY CALCULATION #####
    Q3_percent = '0.000000'
        total_res = float(l)
    Q3_correct = 0
    for i in range(l):
        if Q3_string[i] == Q3_native[i]: Q3_correct = Q3_correct + 1
    Q3_correct = float(Q3_correct)
    Q3_percent = str((Q3_correct / total_res) * 100.00)
    Q3_accuracy = Q3_percent[0:5]

        Q3_fix_percent = '0.000000'
        Q3_fix_correct = 0
    Total_fixed = 0
    for i in range(l):
        if secseq_vec[i] != 'A':
        Total_fixed = Total_fixed + 1
            if Q3_string[i] == Q3_native[i]: Q3_fix_correct = Q3_fix_correct + 1
    Q3_fix_correct = float(Q3_fix_correct)
    if Total_fixed > 0:
        Q3_fix_percent = str((Q3_fix_correct / float(Total_fixed)) * 100.00)
        Q3_fix_accuracy = Q3_fix_percent[0:5]
    else: Q3_fix_accuracy = 'N/A' 
    
    Percent_Fixed = str((float(Total_fixed) / total_res) * 100.00)
    Percent_Fixed = Percent_Fixed[0:5]
        
     
##### Q8 ACCURACY CALCULATION #####

        Q8_vec = ['X'] * l
    Q8_vec[0] = '-'
    Q8_vec[l - 1] = '-'
    for i in range(1, l - 1):
        if Q3_string[i] == 'E' or Q3_string[i] == 'H':
        Q8_vec[i] = Q3_string[i]
        if Q3_string[i] == 'C':
        Q8_index = 0
        Q8_hold = 0.0
        if basin_probs[i][5] > 0.25: Q8_char = 'T'
        elif origins_probs[i][5] > 0.50: Q8_char = 'T'
        elif basin_probs[i][2] > basin_probs[i][6] and basin_probs[i][2] > basin_probs[i][5] and origins_probs[i][2] > origins_probs[i][5]: Q8_char = 'S'
        elif origins_probs[i][1] > 0.50 and basin_probs[i][1] > 0.10: Q8_char = 'B'
        else: Q8_char = '-'
        Q8_vec[i] = Q8_char
    Q8_string = ''
    for i in range(l):
        Q8_string = Q8_string + Q8_vec[i]
    
     Q8_percent = '0.000000'
        total_res = float(l)
    Q8_correct = 0
    for i in range(l):
        if Q8_string[i] == native_dssp[i]: Q8_correct = Q8_correct + 1
    Q8_correct = float(Q8_correct)
    Q8_percent = str((Q8_correct / total_res) * 100.00)
    Q8_accuracy = Q8_percent[0:5]

        Q8_fix_percent = '0.000000'
        Q8_fix_correct = 0
    Total_fixed = 0
    for i in range(l):
        if secseq_vec[i] != 'A':
        Total_fixed = Total_fixed + 1
            if Q8_string[i] == native_dssp[i]: Q8_fix_correct = Q8_fix_correct + 1
    Q8_fix_correct = float(Q8_fix_correct)
    if Total_fixed > 0:
        Q8_fix_percent = str((Q8_fix_correct / float(Total_fixed)) * 100.00)
        Q8_fix_accuracy = Q8_fix_percent[0:5]
    else: Q8_fix_accuracy = 'N/A'
    
    if accuracy_path != '':
        accuracy_out_file = open(accuracy_path, 'w')
        accuracy_out_file.write('PERCENT_FIXED ' + Percent_Fixed + '\n')
        accuracy_out_file.write('Q3_NATIVE ' + Q3_native + '\n')
        accuracy_out_file.write('Q3_STRING ' + Q3_string + '\n')
        accuracy_out_file.write('Q3_ACCURACY ' + Q3_accuracy + '\n')
        accuracy_out_file.write('Q3_FIX_ACCURACY ' + Q3_fix_accuracy + '\n')
        accuracy_out_file.write('Q8_STRING ' + Q8_string + '\n')
        accuracy_out_file.write('Q8_ACCURACY ' + Q8_accuracy + '\n')
        accuracy_out_file.write('Q8_FIX_ACCURACY ' + Q8_fix_accuracy + '\n')
        accuracy_out_file.close()
        
def SecStrAccuracyHTML(SecStr_accuracy_path, native_dssp, secseq_path, html_out_path, Name):
    
    Q8_dash = ''
    for i in range(len(native_dssp)):
    if native_dssp[i] == 'N': Q8_dash = Q8_dash + '-'
    else: Q8_dash = Q8_dash + native_dssp[i]
    native_dssp = Q8_dash
    
    SecStr_accuracy_file = open(SecStr_accuracy_path, 'r')
    line = SecStr_accuracy_file.readline()
    while line:
        line = line.strip()
    line = line.split()
    if line[0] == 'PERCENT_FIXED': Percent_Fixed = line[1]
    if line[0] == 'Q3_NATIVE': Q3_native = line[1]
    if line[0] == 'Q3_STRING': Q3_string = line[1]
    if line[0] == 'Q3_ACCURACY': Q3_accuracy = line[1]
    if line[0] == 'Q3_FIX_ACCURACY': Q3_fix_accuracy = line[1]
    if line[0] == 'Q8_STRING': Q8_string = line[1]
    if line[0] == 'Q8_ACCURACY': Q8_accuracy = line[1]
    if line[0] == 'Q8_FIX_ACCURACY': Q8_fix_accuracy = line[1]
    line = SecStr_accuracy_file.readline()
    SecStr_accuracy_file.close()
    
    secseq_file = open(secseq_path, 'r')
    secseq = secseq_file.readline()
    secseq = secseq.strip()
    secseq_file.close()
    
    html_table_string = '<body>\n<b>Current library restrictions (A = Sample all, O = No H, Q = No E, H = Only H, E = Only E, C = No H or E</b>\n<br>\n<font size="3" face="Courier">\n<code>' + secseq + '</code>\n</font>\n<br><br>\n<b>Native Q3 secondary structure</b>\n<br>\n<font size="3" face="Courier">\n<code>' + Q3_native + '</code>\n</font>\n<br>\n<b>Predicted Q3 secondary structure</b>\n<br>\n<font size="3" face="Courier">\n<code>' + Q3_string + '</code>\n</font>\n<br>\n<br>\n<b>Native Q8 secondary structure</b>\n<br>\n<font size="3" face="Courier">\n<code>' + native_dssp + '</code>\n</font>\n\n<br>\n<b>Predicted Q8 secondary structure</b>\n<br>\n<font size="3" face="Courier">\n<code>' + Q8_string + '</code>\n</font>\n</body>\n<br>\n<br>\n<table border="1">\n<tr>\n<td>% Fixed</td>\n<td>Q3 Accuracy</td>\n<td>Q3 Fixed Accuracy</td>\n<td>Q8 Accuracy</td>\n<td>Q8 Fixed Accuracy</td>\n</tr>\n<tr>\n<td>' + Percent_Fixed + '</td>\n<td>' + Q3_accuracy + '</td>\n<td>' + Q3_fix_accuracy + '</td>\n<td>' + Q8_accuracy + '</td>\n<td>' + Q8_fix_accuracy + '</td>\n</tr>\n</table>'
    
    table_html_out_file = open(html_out_path, 'w')
    table_html_out_file.write(html_table_string)
    table_html_out_file.close()
    
def RMSD_ENERGY_HTML(html_out_path, Name, iteration):
    
    html_string = '<H3>PDB files from round ' + iteration + ':</H3>\n<a href=\"sstart' + iteration + '/' + Name + '/' + Name + '_lowest_energy.pdb\">lowest energy structure</a>\n<br>\n<a href=\"sstart' + iteration + '/' + Name + '/' + Name + '_lowest_rmsd.pdb\">lowest rmsd structure</a>\n<br>\n'

    
    html_out_file = open(html_out_path, 'w')
    html_out_file.write(html_string)
    html_out_file.close()
    
def TotalStructureAnalysis(trj_dir_path, native_path):
    
    all_structures_path = os.path.join(trj_dir_path, 'all_structures')
    if not os.path.exists(all_structures_path): os.mkdir(all_structures_path)
    
    log_path = os.path.join(trj_dir_path, 'all_structures.rmsd_energy')
    log_file = open(log_path, 'w')
    pdt_list = os.listdir(trj_dir_path)
    for pdt in pdt_list:
    pdt_path = os.path.join(trj_dir_path, pdt) 
        zip_state = 0
    use_file = 'no'
        pdt_name = os.path.split(pdt_path)[1]
        pdt_ext = pdt_name.split('.')
        dir_path = os.path.split(pdt_path)[0]
    if len(pdt_ext) == 2:
        if pdt_ext[1] == 'pdt': use_file = 'no'
        if len(pdt_ext) == 3 and pdt_ext[2] == 'gz':
            zip_state = 1
        use_file = 'yes'
        os.system('gunzip ' + pdt_path)
        pdt_path = os.path.join(dir_path, pdt_ext[0] + '.' + pdt_ext[1])
    if use_file == 'yes':
        print pdt
        SplitTrajectory(pdt_path, all_structures_path)
        temp_rmsd_path = tempfile.mktemp('.rmsd')
        os.system('./scalc -cfg scalc.cfg -calc libRMSDcalc.so -trj ' + pdt_path + ' -str ' + native_path + ' > ' + temp_rmsd_path)
        rmsd_file = open(temp_rmsd_path, 'r')
        rmsd_lines = rmsd_file.readlines()
        rmsd_file.close()
        os.remove(temp_rmsd_path)
    
        energy_path = os.path.join(dir_path, pdt_ext[0] + '.Energy')
        energy_file = open(energy_path, 'r')
        energy_lines = energy_file.readlines()
        energy_file.close()
        
        if len(rmsd_lines) == len(energy_lines):
    
            l = len(rmsd_lines)
            for i in range(l):
                rmsd = rmsd_lines[i].strip()
                energy = energy_lines[i].strip()
                place_holder = len(str(i + 1))
                num_place_holder = 5 - place_holder
                place_str = ''
                for j in range(num_place_holder): place_str = place_str + '0'
                pdb_name = pdt_ext[0] + '-' + place_str + str(i + 1)
                log_file.write(pdb_name + '\t' + rmsd + '\t' + energy + '\n')
        
            if zip_state == 1:
                os.system('gzip ' + pdt_path)
    log_file.close()
    
def TotalRMSDAnalysis(trj_dir_path, native_path):
    
    log_path = os.path.join(trj_dir_path, 'all_structures.rmsd')
    log_file = open(log_path, 'w')
    pdt_list = os.listdir(trj_dir_path)
    for pdt in pdt_list:
    pdt_path = os.path.join(trj_dir_path, pdt) 
        zip_state = 0
    use_file = 'no'
        pdt_name = os.path.split(pdt_path)[1]
        pdt_ext = pdt_name.split('.')
        dir_path = os.path.split(pdt_path)[0]
    if len(pdt_ext) == 2:
        if pdt_ext[1] == 'pdt': use_file = 'no'
        if len(pdt_ext) == 3 and pdt_ext[2] == 'gz':
            zip_state = 1
        use_file = 'yes'
        os.system('gunzip ' + pdt_path)
        pdt_path = os.path.join(dir_path, pdt_ext[0] + '.' + pdt_ext[1])
    if use_file == 'yes':
        print pdt
        temp_rmsd_path = tempfile.mktemp('.rmsd')
        os.system('./scalc -cfg ../prj/SECsamplerSC/cfg/scalc.cfg -calc calc/libRMSDcalc.so -trj ' + pdt_path + ' -str ' + native_path + ' > ' + temp_rmsd_path)
        rmsd_file = open(temp_rmsd_path, 'r')
        rmsd_lines = rmsd_file.readlines()
        rmsd_file.close()
        os.remove(temp_rmsd_path)
    
        #energy_path = os.path.join(dir_path, pdt_ext[0] + '.Energy')
        #energy_file = open(energy_path, 'r')
        #energy_lines = energy_file.readlines()
        #energy_file.close()
        
        if len(rmsd_lines) == len(rmsd_lines):
    
            l = len(rmsd_lines)
            for i in range(l):
                rmsd = rmsd_lines[i].strip()
                #energy = energy_lines[i].strip()
                place_holder = len(str(i + 1))
                num_place_holder = 5 - place_holder
                place_str = ''
                for j in range(num_place_holder): place_str = place_str + '0'
                pdb_name = pdt_ext[0] + '-' + place_str + str(i + 1)
                log_file.write(pdb_name + '\t' + rmsd + '\n')
        
            if zip_state == 1:
                os.system('gzip ' + pdt_path)
    log_file.close()
    
def lowest_rmsd(rmsd_path):
    
    rmsd_lines = readlines(rmsd_path)
    
    min_rmsd = 10000.0
    min_idx = 0
    
    for i in range(len(rmsd_lines) - 1):
    if float(rmsd_lines[i].split()[1]) < min_rmsd: 
        min_rmsd = float(rmsd_lines[i].split()[1])
        min_idx = i
    print rmsd_lines[min_idx].split()[0], min_rmsd
    
def FinalStructure(pdt_path, pdb_path):
    
    zip_state = 0
    pdt_name = os.path.split(pdt_path)[1]
    pdt_ext = pdt_name.split('.')
    dir_path = os.path.split(pdt_path)[0]
    if len(pdt_ext) == 3 and pdt_ext[2] == 'gz':
        zip_state = 1
    os.system('gunzip ' + pdt_path)
    pdt_path = os.path.join(dir_path, pdt_ext[0] + '.' + pdt_ext[1])
    pdt_file = open(pdt_path, 'r')
    pdt_lines = pdt_file.readlines()
    pdt_file.close()
    if pdt_lines[-1].strip() == 'ENDMDL':
        l = len(pdt_lines)
        found_end = 0
        start_index = 0
        end_index = 0
        for i in range(l):
        index = l - i - 1
        if pdt_lines[index][0:6] == 'ENDMDL':
            found_end = 1
            end_index = l - i - 1
        if pdt_lines[index][0:5] == 'MODEL' and found_end == 1:
            start_index = l - i - 1
            break
        if start_index > 0 and end_index > 0:
            pdb_file = open(pdb_path, 'w')
            for i in range(start_index + 1, end_index):
            pdb_file.write(pdt_lines[i])
            pdb_file.close()
    
    if zip_state == 1:
        os.system('gzip ' + pdt_path)
    
def GetStructures(in_path):
    
    final_dir = os.path.join(in_path, '../Final')
    if not os.path.exists(final_dir):
        os.mkdir(final_dir)
    file_list = os.listdir(in_path)
    
    for i in file_list:
    print i
        pdt_path = os.path.join(in_path, i)
        pdt_name = os.path.split(pdt_path)[1]
        pdt_ext = pdt_name.split('.')
        if len(pdt_ext) == 2:
            if pdt_ext[1] == 'pdt' and pdt_ext[0] != 'total':
        pdb_path = os.path.join(final_dir, pdt_ext[0] + '.pdb')
        if not os.path.exists(pdb_path):
            FinalStructure(pdt_path, pdb_path)
            
    total_pdt_path = os.path.join(in_path, 'total.pdt')
    total_pdt_file = open(total_pdt_path, 'w')
            
    for i in file_list:
        pdt_path = os.path.join(in_path, i)
        pdt_name = os.path.split(pdt_path)[1]
        pdt_ext = pdt_name.split('.')
        if len(pdt_ext) == 2:
            if pdt_ext[1] == 'pdt' and pdt_ext[0] != 'total':
        pdb_path = os.path.join(final_dir, pdt_ext[0] + '.pdb')
        if os.path.exists(pdb_path):
            number = pdt_ext[0][(pdt_ext[0].find('-') + 1):(len(pdt_ext[0]))]
            pdb_file = open(pdb_path, 'r')
            pdb_lines = pdb_file.readlines()
            pdb_file.close()
            total_pdt_file.write('MODEL ' + number + '\n')
            for j in range(len(pdb_lines)):
                total_pdt_file.write(pdb_lines[j])
            total_pdt_file.write('ENDMDL\n')
    total_pdt_file.close()
    
def total_traj(final_dir):
    
    pdb_list = []
    file_list = os.listdir(final_dir)
    for file in file_list:
    if file.split('.')[1] == 'pdb':
        pdb_list += [os.path.join(final_dir, file)]
        
    total_path = os.path.join(final_dir, 'total.pdt')
    total_file = open(total_path, 'w')
    for i in range(len(pdb_list)):
        pdb_name = os.path.split(pdb_list[i])[1].split('.')[0]
    pdb_lines = readlines(pdb_list[i])
    total_file.write('MODEL ' + pdb_name + '\n')
    for j in range(len(pdb_lines)):
        total_file.write(pdb_lines[j])
    total_file.write('ENDMDL\n')
    total_file.close()
             
def total_traj_list(pdb_list, total_path):
    
    total_file = open(total_path, 'w')
    for i in range(len(pdb_list)):
        pdb_name = os.path.split(pdb_list[i])[1].split('.')[0]
    pdb_lines = readlines(pdb_list[i])
    total_file.write('MODEL ' + pdb_name + '\n')
    for j in range(len(pdb_lines)):
        total_file.write(pdb_lines[j])
    total_file.write('ENDMDL\n')
    total_file.close()
    
def pred_parse(pred_path):
    
    pred_lines = readlines(pred_path)
    pdb_dir = os.path.split(pred_path)[0]
    out_path = os.path.join(pdb_dir, os.path.split(pred_path)[1].split('.')[0] + '_parse.txt')
    print out_path
    out_file = open(out_path, 'w')
    for i in range(len(pred_lines)):
    out_file.write(os.path.join(pdb_dir, pred_lines[i].split()[0]) + '\n')
    out_file.close()
    
def cluster_traj(pdb_path, list_path, out_path):
    
    pdb_list = readlines(list_path)
    rand_label = 'c' + str(random.randint(1, 1000000))
    total_path = '/local/' + rand_label + '.pdt'
    total_file = open(total_path, 'w')
    for i in range(len(pdb_list)):
        pdb_name = os.path.split(pdb_list[i].strip())[1].split('.')[0]
    pdb_lines = readlines(pdb_list[i].strip())
    total_file.write('MODEL ' + pdb_name + '\n')
    for j in range(len(pdb_lines)):
        total_file.write(pdb_lines[j])
    total_file.write('ENDMDL\n')
    total_file.close()

    scalc_path = '/local/' + rand_label + '.txt'
    os.system('./scalc -cfg /home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/scalc.cfg -calc /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/calc/libRMSDcalc.so -str ' + pdb_path + ' -trj ' + total_path + ' > ' + scalc_path)
    scalc_lines = readlines(scalc_path)
    
    temp_out_path = '/local/' + rand_label + '_temp.pdt'
    temp_out_file = open(temp_out_path, 'w')
    for i in range(len(scalc_lines)):
    if float(scalc_lines[i].strip()) < 7.0:
        temp_out_file.write(pdb_path + '\t' + pdb_list[i].strip() + '\t' + scalc_lines[i].strip() + '\n')
    temp_out_file.close()
    os.system('cp ' + temp_out_path + ' ' + out_path)

    os.remove(total_path)
    os.remove(temp_out_path)
    os.remove(scalc_path)
    os.remove(list_path)
    
def cluster_job(pdb_path, pdb_list, out_path):
    
    cluster_dir = os.path.split(out_path)[0]
    name = os.path.split(out_path)[1].split('.')[0]
    script_path = os.path.join(cluster_dir, name + '.sh')
    
    list_path = os.path.join(cluster_dir, name + '_list.txt')
    list_file = open(list_path, 'w')
    for i in range(len(pdb_list)): list_file.write(pdb_list[i])
    list_file.close()
    
    script_file = open(script_path, 'w')
    script_file.write('./build.py -cluster_traj ' + pdb_path + ' ' + list_path + ' ' + out_path)
    script_file.close()
    os.system('chmod u+x ' + script_path)
    os.system('qsub -cwd ' + script_path)
    
def rmsd_matrix(in_dir):
    
    pred_parse(os.path.join(in_dir, 'Final/prediction.txt'))
    out_dir = os.path.join(in_dir, 'cluster')
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    list_path = os.path.join(in_dir, 'Final/prediction_parse.txt')
    
    lines = readlines(list_path)
    L = len(lines)
    
    for i in range(L - 1):
    pdb_path = lines[i].strip()
    pdb_list = []
    for j in range(i + 1, L):
        pdb_list.append(lines[j])
    out_path = os.path.join(out_dir, 'clust_' + str(i) + '.txt')

    while True:
        status_path = tempfile.mktemp('.txt')
        os.system('qstat | grep clust_ | wc -l > ' + status_path)
        N_jobs = int(readline(status_path, 1).strip())
        os.remove(status_path)
        
        if N_jobs < 150:
        print 'submitting job ', i + 1, 'of', L
            cluster_job(pdb_path, pdb_list, out_path)
        break
        else:
        print 'waiting on job ', i + 1, 'of', L
            time.sleep(10)
    
def GDT(model_dir, native_fn):
    global Name
    
    GDT_dir = os.path.join(model_dir, 'GDT')
    if not os.path.exists(GDT_dir): os.mkdir(GDT_dir)
    
    native_tmp_fn = '/tmp/native_gdt.pdb'
    Renumber(1, 1, native_fn, native_tmp_fn)
    
    pdb_list = os.listdir(model_dir)
    for pdb in pdb_list:
    if os.path.splitext(pdb)[1] == '.pdb':
            pdb_path = os.path.join(model_dir, pdb)
            renumber_tmp_fn = '/tmp/gdt.pdb'
            Renumber(1, 1, pdb_path, renumber_tmp_fn)
        pdb_name = os.path.splitext(pdb)[0]
        gdt_path = os.path.join(GDT_dir, pdb_name + '.gdt')
        os.system('./GDTscore ' + native_tmp_fn + ' ' + renumber_tmp_fn + ' | grep GDToutput | awk \'{print $2,$3}\' > ' + gdt_path)
    
    plot_out_path = os.path.join(model_dir, Name + '-GDT.gnu')
    gif_out_path = os.path.join(model_dir, Name + '-GDT.gif')
    Make_GNU_PLOT_Script_GDT(GDT_dir, plot_out_path, gif_out_path)
    
def ItFixAnalysis(rounds_dir_path, native_path, web_dir_path):
    
    ################ CREATE FILES #######################
    Name = os.path.split(rounds_dir_path)[1]
    
    native_dssp = ReturnDSSP(native_path)
    seq_length = len(native_dssp)
    native_dssp_path = os.path.join(rounds_dir_path, Name + '.dssp')
    native_dssp_file = open(native_dssp_path, 'w')
    native_dssp_file.write(native_dssp)
    native_dssp_file.close()
    
    in_dir_list = os.listdir(rounds_dir_path)
    iterations = 0
    for item in in_dir_list:
    if item[0:6] == 'sstart':
        iterations = iterations + 1
        
    for i in range(iterations):
        
        html_round_dir = os.path.join(web_dir_path, 'sstart' + str(i + 1))
    html_round_sub_dir = os.path.join(html_round_dir, Name)
    if not os.path.exists(html_round_dir): os.mkdir(html_round_dir)
    if not os.path.exists(html_round_sub_dir): os.mkdir(html_round_sub_dir)
    
        round_dir = os.path.join(rounds_dir_path, 'sstart' + str(i + 1))
    round_sub_dir = os.path.join(round_dir, Name)
    
    final_dir = os.path.join(round_sub_dir, 'Final')
    
    print "Making contact maps for round " + str(i + 1) + "..."
    gif_out_path = os.path.join(html_round_sub_dir, Name + '_average_contacts.gif')
    AverageContacts(final_dir, native_path, gif_out_path)
    
    print "Making SecStr plots for round " + str(i + 1) + "..."
    SecStr_path = os.path.join(final_dir, 'protein.SecStrAlign')
    gif_out_path = os.path.join(html_round_sub_dir, Name + '_SecStr.gif')
    SecStrProbsPlot(SecStr_path, gif_out_path)
    
    print "Making scatter plots for round " + str(i + 1) + "..."
    all_structures_path = os.path.join(round_sub_dir, 'all_structures')
    all_structures_log_path = os.path.join(round_sub_dir, 'all_structures.rmsd_energy')
    if (not os.path.exists(all_structures_path)) or (not os.path.exists(all_structures_path)):
        TotalStructureAnalysis(round_sub_dir, native_path)
    prediction_vec = PredictionStats(all_structures_log_path)
    yminimum = prediction_vec[1][2]
    lowest_rmsd_path = os.path.join(all_structures_path, prediction_vec[0][0] + '.pdb')
    lowest_energy_path = os.path.join(all_structures_path, prediction_vec[1][0] + '.pdb')
    lowest_rmsd_web_path = os.path.join(html_round_sub_dir, Name + '_lowest_rmsd.pdb')
    lowest_energy_web_path = os.path.join(html_round_sub_dir, Name + '_lowest_energy.pdb')
    os.system('cp ' + lowest_rmsd_path + ' ' + lowest_rmsd_web_path)
    os.system('cp ' + lowest_energy_path + ' ' + lowest_energy_web_path)
    gif_out_path = os.path.join(html_round_sub_dir, Name + '_rmsd_energy.gif')
    GNUPLOT_scatter(all_structures_log_path, '2', '3', '0.00', '15.00', yminimum, '0.00', 'rmsd', 'energy', gif_out_path)
    scatter_add_path = os.path.join(html_round_sub_dir, Name + '_rmsd_energy_add.html')
    RMSD_ENERGY_HTML(scatter_add_path, Name, str(i + 1))
    
    print "Calculating secondary structure accuracy..."
    secseq_path = os.path.join(round_sub_dir, Name + '.secseq')
    accuracy_path = os.path.join(html_round_sub_dir, Name + '_accuracy.txt')
    accuracy_html_path = os.path.join(html_round_sub_dir, Name + '_SecStr_add.html')
        SecStrAccuracyFile(Name, round_sub_dir, native_dssp, accuracy_path)
    SecStrAccuracyHTML(accuracy_path, native_dssp, secseq_path, accuracy_html_path, Name)
    
    extension = '_SecStr'
    html_out_path = os.path.join(web_dir_path, Name + extension +'.html')
    image_height = ''
    image_width = ''
    title = 'Secondary structure probabilities for ' + Name + ': Currently on round ' + str(iterations + 1)
    html_string = Make_HTML_contents_string(web_dir_path, extension, iterations, image_height, image_width, Name)
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(title, html_string, foot_message, html_out_path)
    
    extension = '_rmsd_energy'
    html_out_path = os.path.join(web_dir_path, Name + extension +'.html')
    image_height = ''
    image_width = ''
    title = 'Energy versus RMSD for ' + Name + ': Currently on round ' + str(iterations + 1)
    html_string = Make_HTML_contents_string(web_dir_path, extension, iterations, image_height, image_width, Name)
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(title, html_string, foot_message, html_out_path)
    
    extension = '_average_contacts'
    html_out_path = os.path.join(web_dir_path, Name + extension +'.html')
    image_height = ''
    image_width = ''
    title = 'Average contacts for ' + Name + ': Currently on round ' + str(iterations + 1)
    html_string = Make_HTML_contents_string(web_dir_path, extension, iterations, image_height, image_width, Name)
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(title, html_string, foot_message, html_out_path)
    
    main_html_path = os.path.join(web_dir_path, Name + '.html')
    main_html_title = 'Results for ' + Name
    main_html_contents = '<a href=\"' + Name + '_SecStr.html\">secondary structure prediction</a><br>\n<a href=\"' + Name + '_rmsd_energy.html\">tertiary structure prediction</a><br>\n<a href=\"' + Name + '_average_contacts.html\">contact maps</a><br>\n'
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(main_html_title, main_html_contents, foot_message, main_html_path)

def NonNaturalConversion(code):
    if code == 'MSE': return 'MET'
    else: return code
    
def TrajectoryAnalysis(trj_dir_path, native_fn):
    
    final_dir = os.path.join(trj_dir_path, 'Final')
    if not os.path.exists(final_dir):
    os.mkdir(final_dir) 
        GetStructures(trj_dir_path)
    StandardScatterPlot(final_dir, native_fn)
        
def Renumber(start_res_num, start_atom_num, pdb_path, renumber_path):
    
    renumber_file =  open(renumber_path, 'w')
    pdb_file =  open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    
    res_num = int(start_res_num)
    atom_num = start_atom_num
    
    atom_count = 0
    
    l_1 = 'false'
    for i in range(len(pdb_lines)):
    pdb_lines[i] = pdb_lines[i].strip()
    if len(pdb_lines[i]) < 61: pdb_lines[i] = pdb_lines[i] + '                \n'
    else: pdb_lines[i] = pdb_lines[i] + '\n'
    line_list = list(pdb_lines[i])
    
    if (line_list[0] == 'A' and line_list[1] == 'T' and line_list[2] == 'O' and line_list[3] == 'M') or (line_list[0] == 'H' and line_list[1] == 'E' and line_list[2] == 'T' and line_list[3] == 'A' and line_list[4] == 'T' and line_list[5] == 'M' and line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E'):
        if l_1 == 'false':
            hold_res_num = int(pdb_lines[i][23:26])
        l_1 = 'true'
        current_res_num = int(pdb_lines[i][23:26])
        if current_res_num == hold_res_num:
            res_size = len(str(int(res_num)))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
        else: 
            res_num = res_num + 1
            hold_res_num = current_res_num
            res_size = len(str(res_num))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
    
        atom_size = len(str(int(atom_num) + atom_count))
        for j in range(5):
            line_list[10 - j] = ' '
        for j in range(atom_size):
            line_list[10 - j] = str(int(atom_num) + atom_count)[atom_size - j - 1]
        
        if line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E':
        line_list[18] = 'E'
        line_list[19] = 'T'
        
        line_list[0] = 'A'
        line_list[1] = 'T'
        line_list[2] = 'O'
        line_list[3] = 'M'
        line_list[4] = ' '
        line_list[5] = ' '

       # line_list[21] = 'A'
        
        line_list[56] = '1'
        line_list[57] = '.'
        line_list[58] = '0'
        line_list[59] = '0'
        line_list[60] = ' '
        line_list[61] = ' '        
        line_list[62] = '0'
        line_list[63] = '.'
        line_list[64] = '0'
        line_list[65] = '0'
        joined_list = string.join(line_list, '')
        renumber_file.write(joined_list)
        atom_count = atom_count + 1
    renumber_file.write('TER\n')
    renumber_file.write('END')

    pdb_file.close()
    renumber_file.close()
    
def RenumberChnAB(start_res_num, start_atom_num, pdb_path, renumber_path, chainbreak):
    
    renumber_file =  open(renumber_path, 'w')
    pdb_file =  open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    
    res_num = int(start_res_num)
    atom_num = start_atom_num
    
    atom_count = 0
    
    l_1 = 'false'
    for i in range(len(pdb_lines)):
    pdb_lines[i] = pdb_lines[i].strip()
    if len(pdb_lines[i]) < 61: pdb_lines[i] = pdb_lines[i] + '                \n'
    else: pdb_lines[i] = pdb_lines[i] + '\n'
    line_list = list(pdb_lines[i])
    
    if (line_list[0] == 'A' and line_list[1] == 'T' and line_list[2] == 'O' and line_list[3] == 'M') or (line_list[0] == 'H' and line_list[1] == 'E' and line_list[2] == 'T' and line_list[3] == 'A' and line_list[4] == 'T' and line_list[5] == 'M' and line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E'):
        if l_1 == 'false':
            hold_res_num = int(pdb_lines[i][23:26])
        l_1 = 'true'
        current_res_num = int(pdb_lines[i][23:26])
        if current_res_num == hold_res_num:
            res_size = len(str(int(res_num)))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
        else: 
            res_num = res_num + 1
            hold_res_num = current_res_num
            res_size = len(str(res_num))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
    
        atom_size = len(str(int(atom_num) + atom_count))
        for j in range(5):
            line_list[10 - j] = ' '
        for j in range(atom_size):
            line_list[10 - j] = str(int(atom_num) + atom_count)[atom_size - j - 1]
        
        if line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E':
        line_list[18] = 'E'
        line_list[19] = 'T'
        
        line_list[0] = 'A'
        line_list[1] = 'T'
        line_list[2] = 'O'
        line_list[3] = 'M'
        line_list[4] = ' '
        line_list[5] = ' '
        
        endpos = int(pdb_lines[i][23:27])
        if endpos <= chainbreak: line_list[21] = 'A'
        else: line_list[21] = 'B'
        
        line_list[56] = '1'
        line_list[57] = '.'
        line_list[58] = '0'
        line_list[59] = '0'
        line_list[60] = ' '
        line_list[61] = ' '        
        line_list[62] = '0'
        line_list[63] = '.'
        line_list[64] = '0'
        line_list[65] = '0'
        joined_list = string.join(line_list, '')
        renumber_file.write(joined_list)
        atom_count = atom_count + 1
    renumber_file.write('TER\n')
    renumber_file.write('END')

    pdb_file.close()
    renumber_file.close()
    
def RenumberChnA(start_res_num, start_atom_num, pdb_path, renumber_path):
    
    renumber_file =  open(renumber_path, 'w')
    pdb_file =  open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    
    res_num = int(start_res_num)
    atom_num = start_atom_num
    
    atom_count = 0
    
    l_1 = 'false'
    for i in range(len(pdb_lines)):
    pdb_lines[i] = pdb_lines[i].strip()
    if len(pdb_lines[i]) < 61: pdb_lines[i] = pdb_lines[i] + '                \n'
    else: pdb_lines[i] = pdb_lines[i] + '\n'
    line_list = list(pdb_lines[i])
    
    if (line_list[0] == 'A' and line_list[1] == 'T' and line_list[2] == 'O' and line_list[3] == 'M') or (line_list[0] == 'H' and line_list[1] == 'E' and line_list[2] == 'T' and line_list[3] == 'A' and line_list[4] == 'T' and line_list[5] == 'M' and line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E'):
        if l_1 == 'false':
            hold_res_num = int(pdb_lines[i][23:26])
        l_1 = 'true'
        current_res_num = int(pdb_lines[i][23:26])
        if current_res_num == hold_res_num:
            res_size = len(str(int(res_num)))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
        else: 
            res_num = res_num + 1
            hold_res_num = current_res_num
            res_size = len(str(res_num))
            for j in range(5):
                line_list[25 - j] = ' '
            for j in range(res_size):
                line_list[25 - j] = str(res_num)[res_size - j - 1]
    
        atom_size = len(str(int(atom_num) + atom_count))
        for j in range(5):
            line_list[10 - j] = ' '
        for j in range(atom_size):
            line_list[10 - j] = str(int(atom_num) + atom_count)[atom_size - j - 1]
        
        if line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E':
        line_list[18] = 'E'
        line_list[19] = 'T'
        
        line_list[0] = 'A'
        line_list[1] = 'T'
        line_list[2] = 'O'
        line_list[3] = 'M'
        line_list[4] = ' '
        line_list[5] = ' '

        line_list[21] = 'A'
        
        line_list[56] = '1'
        line_list[57] = '.'
        line_list[58] = '0'
        line_list[59] = '0'
        line_list[60] = ' '
        line_list[61] = ' '        
        line_list[62] = '0'
        line_list[63] = '.'
        line_list[64] = '0'
        line_list[65] = '0'
        joined_list = string.join(line_list, '')
        renumber_file.write(joined_list)
        atom_count = atom_count + 1
    renumber_file.write('TER\n')
    renumber_file.write('END')

    pdb_file.close()
    renumber_file.close()
    
def back_renumber(back_path, renumber_path):
    
    renumber_file =  open(renumber_path, 'w')
    back_lines = readlines(back_path)
    
    count = 1
    for line in back_lines:
    if len(line.split()) < 2: continue
        line_vec = []
    for i in range(len(line)): line_vec.append(line[i])
    line_vec[0] = 'A'
    count_str = str(count)
    L = len(count_str)
    for i in range(L):
        line_vec[5 - i] = count_str[-i - 1]
    for i in range(5 - L): line_vec[1 + i] = ' '
    count += 1
    for i in range(len(line_vec)): renumber_file.write(line_vec[i])
    renumber_file.close()
    
def MSE_to_MET(pdb_path, renumber_path):
    
    renumber_file =  open(renumber_path, 'w')
    pdb_file =  open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    models = 0
    
    for i in range(len(pdb_lines)):
       
    if pdb_lines[i][0:5] == "MODEL": models += 1
        if (pdb_lines[i][0:4] == 'ATOM' and (ResidueVerify(pdb_lines[i][17:20]) == 1 or pdb_lines[i][17:20] == 'MSE')) or (pdb_lines[i][0:6] == 'HETATM' and pdb_lines[i][17:20] == 'MSE'):
        pdb_lines[i] = pdb_lines[i].strip()
        if len(pdb_lines[i]) < 61: pdb_lines[i] = pdb_lines[i] + '                \n'
        else: pdb_lines[i] = pdb_lines[i] + '\n'
        line_list = list(pdb_lines[i])

        if (line_list[0] == 'A' and line_list[1] == 'T' and line_list[2] == 'O' and line_list[3] == 'M') or (line_list[0] == 'H' and line_list[1] == 'E' and line_list[2] == 'T' and line_list[3] == 'A' and line_list[4] == 'T' and line_list[5] == 'M' and line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E'):
    
        if line_list[17] == 'M' and line_list[18] == 'S' and line_list[19] == 'E':
            line_list[18] = 'E'
            line_list[19] = 'T'
    
            line_list[0] = 'A'
            line_list[1] = 'T'
            line_list[2] = 'O'
            line_list[3] = 'M'
            line_list[4] = ' '
            line_list[5] = ' '
        
        line_list[56] = '1'
        line_list[57] = '.'
        line_list[58] = '0'
        line_list[59] = '0'
        line_list[60] = ' '
        line_list[61] = ' '        
        line_list[62] = '0'
        line_list[63] = '.'
        line_list[64] = '0'
        line_list[65] = '0'
    
        joined_list = string.join(line_list, '')
        renumber_file.write(joined_list)

    pdb_file.close()
    renumber_file.close()

def AtomPos(atom):
    if atom == 'N': return 0
    elif atom == 'CA': return 1
    elif atom == 'C': return 2
    elif atom == 'O': return 3
    elif atom == 'CB': return 4
    else: return 5
    
def AtomChar(atom):
    if atom == 0: return 'N'
    elif atom == 1: return 'CA'
    elif atom == 2: return 'C'
    elif atom == 3: return 'O'
    elif atom == 4: return 'CB'
    else: return ''
    
def ResidueVerify(code):
    if code == 'ALA': return 1
    elif code == 'CYS': return 1
    elif code == 'ASP': return 1
    elif code == 'GLU': return 1
    elif code == 'PHE': return 1
    elif code == 'GLY': return 1
    elif code == 'HIS': return 1
    elif code == 'ILE': return 1
    elif code == 'LYS': return 1
    elif code == 'LEU': return 1
    elif code == 'MET': return 1
    elif code == 'ASN': return 1
    elif code == 'PRO': return 1
    elif code == 'GLN': return 1
    elif code == 'ARG': return 1
    elif code == 'SER': return 1
    elif code == 'THR': return 1
    elif code == 'VAL': return 1
    elif code == 'TRP': return 1
    elif code == 'TYR': return 1
    elif code == 'MSE': return 1
    else: return 0
    
def StructureValidation(pdb_path):

    pdb_lines = readlines(pdb_path)
    residues = 0
    
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == 'ATOM':
        if ResidueVerify(pdb_lines[i][17:20].strip()) == 0: return 0
        else: residues += 1
    if residues > 20:
        return 1
    else: return 0

def StructuresValidation(pdb1_path, pdb2_path, name1, name2):

    if pdb1_path != "":
        pdb1_vec = []

        pdb_file = open(pdb1_path, 'r')
        pdb1_lines = pdb_file.readlines()
        pdb_file.close()
    
        for i in range(len(pdb1_lines)):
            if pdb1_lines[i][0:4] == 'ATOM':
        #if ResidueVerify(pdb1_lines[i][17:20].strip()) == 0:
            #return '\n<br>\n<H3>Sorry, ' + name1 + ' has an unknown amino acid \"' + pdb1_lines[i][17:20].strip() + '\" at residue ' + pdb1_lines[i][22:29].strip() + '. Only the 20 naturally ocurring amino acid types are allowed under the \"ATOM\" field. Please correct and resubmit.</H3><br>\n' + pdb1_lines[i] + '<br>\n'
                if AtomPos(pdb1_lines[i][13:15].strip()) == 1:
                pdb1_vec += [pdb1_lines[i]]
                
    if len(pdb1_vec) == 0: return '\n<br>\n<H3>Sorry, ' + name1 + ' has no valid atoms. Please correct and resubmit.</H3>\n'
    
    if pdb2_path != "":
        
    pdb2_vec = []

        pdb_file = open(pdb2_path, 'r')
        pdb2_lines = pdb_file.readlines()
        pdb_file.close()

        for i in range(len(pdb2_lines)):
            if pdb2_lines[i][0:4] == 'ATOM':
        #if ResidueVerify(pdb2_lines[i][17:20].strip()) == 0: return '\n<br>\n<H3>Sorry, ' + name2 + ' has an unknown amino acid \"' + pdb2_lines[i][17:20].strip() + '\" at residue ' + pdb2_lines[i][22:29].strip() + '. Only the 20 naturally ocurring amino acid types are allowed under the \"ATOM\" field. Please correct and resubmit.</H3>\n'
                if AtomPos(pdb2_lines[i][13:15].strip()) == 1:
                pdb2_vec += [pdb2_lines[i]]
 
        if len(pdb2_vec) == 0: return '\n<br>\n<H3>Sorry, ' + name2 + ' has no valid atoms. Please correct and resubmit.</H3>\n' 

    if pdb1_path != "" and pdb2_path != "":

        if len(pdb1_vec) != len(pdb2_vec):
            return '\n<br>\n<H3>Sorry, the input structures have different sizes. ' + name1 + ' has ' + str(len(pdb1_vec)) + ' residues, and ' + name2 + ' has ' + str(len(pdb2_vec)) + '. Please resubmit models that are the same size.</H3>\n'

        for i in range(len(pdb1_vec)):
            if pdb1_vec[i][17:20] != pdb2_vec[i][17:20]:
            return '\n<br>\n<H3>Sorry, at postion ' + str(i + 1) + ' ' + name1 + ' has a ' + pdb1_vec[i][17:20] + ' and ' + name2 + ' has a ' + pdb2_vec[i][17:20] + '</H3>\n'

    return ""
    
def Sequence(pdb_path):
    
    pdb_file =  open(pdb_path, 'r')   
    pdb_lines = pdb_file.readlines()
    
    seq = ''
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if pdb_lines[i][13:15] == 'CA':
            seq += AAConvertTS(pdb_lines[i][17:20])
    print seq
    
def PDB_vec(pdb_path):
    
    renumber_path = tempfile.mktemp('renumber.pdb')
    Renumber(1, 1, pdb_path, renumber_path)
    pdb_path = renumber_path
    
    pdb_file =  open(pdb_path, 'r')   
    pdb_lines = pdb_file.readlines()
    
    N = 0
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if pdb_lines[i][13:15] == 'CA':
            N = N + 1
    pdb_vec = [None] * N
    
    i = 0
    res_num = 0
    while i < len(pdb_lines) - 1:
        if pdb_lines[i][0:4] == "ATOM":
        if AtomPos(pdb_lines[i][13:15].strip()) < 5:
            if pdb_lines[i][17:20] == "GLY": atoms_in_res0 = 4
        else: atoms_in_res0 = 5
        pdb_vec[res_num] = [""] * atoms_in_res0
        atoms_in_res = 1
        while (atoms_in_res0 > atoms_in_res):
            hold_res_num = int(pdb_lines[i][23:26])
                   if pdb_lines[i][0:4] == "ATOM":
                if AtomPos(pdb_lines[i][13:15].strip()) < 5:
                    pdb_vec[res_num][atoms_in_res - 1] = pdb_lines[i]
                atoms_in_res = atoms_in_res + 1
            i = i + 1
        res_num = res_num + 1        
        else: i = i + 1        
    else: i = i + 1
    pdb_file.close()
    os.remove(renumber_path)
    return pdb_vec
    
def CircularPermutate(pdb_path, circ_perm_path, cut_pos):
    
    renumber_path = tempfile.mktemp('.pdb')
    Renumber(1, 1, pdb_path, renumber_path)
    pdb_path = renumber_path
    
    pdb_file =  open(pdb_path, 'r')   
    pdb_lines = pdb_file.readlines()
    
    flip_path = tempfile.mktemp('.pdb')
    flip_file = open(flip_path, 'w')
    
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if int(pdb_lines[i][23:26]) > cut_pos:
        flip_file.write(pdb_lines[i])
            
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if int(pdb_lines[i][23:26]) <= cut_pos:
        flip_file.write(pdb_lines[i])
            
    flip_file.close()
    Renumber(1, 1, flip_path, circ_perm_path)
    os.remove(flip_path)
    os.remove(renumber_path)
    

def Ligate(position1, position2):
    global pdb1_path
    global pdb2_path
    global ligation_path
    
    ligation_file =  open(ligation_path, 'w')
    pdb1_file =  open(pdb1_path, 'r')
    pdb1_lines = pdb1_file.readlines()

    pdb2_file =  open(pdb2_path, 'r')
    pdb2_lines = pdb2_file.readlines()
    
    hold_res_num = 0

    pdb1_vec = []
    pdb2_vec = []
    
    position = 0
    i = 0
    while ('true' == 'true'):
    pdb1_lines[i] = pdb1_lines[i].strip()
    
    if pdb1_lines[i][0:4] == "ATOM":
            pdb1_vec = pdb1_vec + [[None] * 5]
            for k in range(5): 
            hold_res_num = int(pdb1_lines[i][23:26])
            while (int(pdb1_lines[i][23:26]) == hold_res_num):
                    if int(pdb1_lines[i][13:15]) < 5:
                        pdb1_vec[position][AtomPos(int(pdb1_lines[i][13:15].strip()))]
                    
        pdb1_lines[i][13:15] = 1.0
                
def Truncate(pdb_path, truncate_path):
    
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    
    truncate_file = open(truncate_path, 'w')
    
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if AtomPos(pdb_lines[i][13:15].strip()) < 5:
        truncate_file.write(pdb_lines[i])
    truncate_file.close()
    
def TruncatePolar(pdb_path, truncate_path):
    
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    
    truncate_file = open(truncate_path, 'w')
    
    for i in range(len(pdb_lines)):
        if pdb_lines[i][0:4] == "ATOM":
        if pdb_lines[i][17:20] in ['ALA', 'PHE', 'ILE', 'LEU', 'VAL', 'TRP', 'TYR']:
            truncate_file.write(pdb_lines[i])
        else:
            if AtomPos(pdb_lines[i][13:15].strip()) < 4:
            truncate_file.write(pdb_lines[i])
    truncate_file.close()
            
def CircularPermutateTrajectory(traj_path, circ_perm_traj_path, cut_pos):
    
    traj_file = open(traj_path, 'r')
    traj_lines = traj_file.readlines()
    
    circ_perm_traj_file = open(circ_perm_traj_path, 'w')
    
    i = 1
    count = 1
    while (traj_lines[i][0:6] != 'ENDMDL'):
    i = i + 1
    count = count + 1
         
    num_mdls = int(len(traj_lines) / count)
        
    for i in range(num_mdls):
    pdb_path = tempfile.mktemp('.pdb')
    circ_perm_path = tempfile.mktemp('.pdb')
    pdb_file = open(pdb_path, 'w')
        for j in range(i * count, ((i * count) + count)):
        pdb_file.write(traj_lines[j + 1])
    pdb_file.close()
    CircularPermutate(pdb_path, circ_perm_path, cut_pos)
    circ_perm_file = open(circ_perm_path, 'r')
    circ_perm_traj_file.write('MODEL ' + str(i + 1) + '\n')
    circ_line = circ_perm_file.readline()
    while (circ_line[0:3] != 'TER'):
        circ_perm_traj_file.write(circ_line)
        circ_line = circ_perm_file.readline()
    circ_perm_traj_file.write('ENDMDL\n')
    circ_perm_file.close()
    os.remove(pdb_path)
    os.remove(circ_perm_path)
        
    circ_perm_traj_file.close()
    
############################ RUNNING SIMULATIONS ###############################

def run_oops(project_dir):
    
    run_path = os.path.join(project_dir, 'run.oops')
    run_file = open(run_path, 'r')
    line = run_file.readline()
    while line:
        line = line.strip()
        if line and (line[0] != '#'):
            v = line.split('=')
            var_name = v[0].strip()
            if len(v) == 2: var_value = v[1].strip()
            else: var_value = ''

            if var_name == 'OOPS_DIR': oops_dir = var_value
            if var_name == 'PL_DIR': pl_dir = var_value
            if var_name == 'PAR_DIR': par_dir = var_value
            if var_name == 'TLIB_DIR': tlib_dir = var_value
            if var_name == 'SECSEQ_DIR': secseq_dir = var_value
        if var_name == 'STORAGE_DIR': storage_dir = var_value
        if var_name == 'ANALYSIS_DIR': analysis_dir = var_value
            if var_name == 'TEMP_DIR': temp_dir = var_value
            if var_name == 'GZIP_BIN': gzip_bin = var_value
            if var_name == 'PLG_EXT': plg_ext = var_value
            if var_name == 'CFG_FILE': cfg_file = var_value
            if var_name == 'CFG_DIR': cfg_dir = var_value
            if var_name == 'IN_DIR': in_dir = var_value
            if var_name == 'OUT_DIR': out_dir = var_value
            if var_name == 'OUT_FORMAT': out_format = var_value
            if var_name == 'N_RUN0': n_run0 = int(var_value)
            if var_name == 'N_RUN1': n_run1 = int(var_value)
            if var_name == 'CMD_PARAMS': cmd_params = var_value
            if var_name == 'ZIP_TRJ': zip_trj = var_value == 'yes'
            if var_name == 'N_STEPS': n_steps = int(var_value)
            if var_name == 'DUMP_INT': dump_int = int(var_value)
            if var_name == 'SEP_TRJ': sep_trj = var_value == 'yes'
            if var_name == 'JOB_SYS': job_sys = var_value
            if var_name == 'JOB_TITLE': job_title = var_value
            if var_name == 'WALL_TIME': wall_time = var_value
            if var_name == 'MAX_MEM': max_mem = var_value
            if var_name == 'AGGREGATE_JOBS':  aggregate_jobs = var_value == 'yes'
            if var_name == 'USER_NAME': user_name = var_value
            if var_name == 'MAX_NJOBS': max_njobs = int(var_value)
            if var_name == 'SLEEP_TIME': sleep_time = int(var_value)
            if var_name == 'MAX_RETRY': max_retry = int(var_value)

        line = run_file.readline()
    run_file.close()
                                                                                                                                                                              
    filelist = os.listdir(in_dir)
    for file_name in filelist:
        
    #### SET PATHS AND MAKE DIRECTORIES #####
        in_file = os.path.join(in_dir, file_name)
    name = os.path.splitext(file_name)[0]
    traj_dir = os.path.join(out_dir, name)
    if not os.path.exists(traj_dir): os.mkdir(traj_dir)
    job_dir = os.path.join(traj_dir, 'job')
    if not os.path.exists(job_dir): os.mkdir(job_dir)
    log_dir = os.path.join(traj_dir, 'log')
    if not os.path.exists(log_dir): os.mkdir(log_dir)
    final_dir = os.path.join(traj_dir, 'Final')
    if not os.path.exists(final_dir): os.mkdir(final_dir)

        print 'PROCESSING', in_file

        for current_run in range(n_run0, n_run1 + 1):
        
            traj_path = os.path.join(traj_dir, name + '-' + str(current_run) + '.' + out_format)
        temp_traj_path = os.path.join('/local', name + '-' + str(current_run) + '.' + out_format)
        temp_log_path = os.path.join('/local', name + '-oops-' + str(current_run) + '.log')
        rand_path = os.path.join('/local', name + '-' + str(current_run) + '.random')
        final_path = os.path.join(final_dir, name + '-' + str(current_run) + '.pdb')
        log_fn = os.path.join(log_dir, name + '-oops-' + str(current_run) + '.log')
            log_str = ' > "' + temp_log_path + '"'
        
        ##### ESCRIBA LA PUESTA #####
            job_name = name + '-oops-' + str(current_run)
            sh_fn = os.path.join(job_dir, job_name + '.sh')
            sh_file = open(sh_fn, 'w')
            sh_file.write('cd "' + oops_dir + '"\n')
        sh_file.write('echo ' + str(random.randint(1, 1000000000)) + ' > ' + rand_path + '\n')
            sh_file.write(oops_dir + '/oops -c "' + cfg_file + '" -i "' + in_file + '" -o "' + temp_traj_path + '" -n ' + str(n_steps) + ' -s ' + str(dump_int) + ' ' + cmd_params + log_str + '\n')
        sh_file.write('./build.py -final_structure ' + temp_traj_path + ' ' + final_path + '\n')
        #if zip_trj: sh_file.write(gzip_bin + ' "' + temp_traj_path + '" -f\n')
        sh_file.write('rm ' + temp_traj_path + '\n')
        sh_file.write('mv ' + temp_log_path + ' ' + log_fn + '\n')
        sh_file.write('rm ' + rand_path + '\n')
            sh_file.close()
            os.system('chmod +x "' + sh_fn + '"')
        
            if job_sys == 'pbs':
                pbs_fn = os.path.join(job_dir, job_name + '.pbs')
                pbs_file = open(pbs_fn, 'w')
                pbs_file.write('#PBS -l nodes=1:ppn=1\n')
                pbs_file.write('#PBS -l cput=' + wall_time + '\n')
                pbs_file.write('#PBS -l walltime=' + wall_time + '\n')
                pbs_file.write('#PBS -l mem=' + max_mem + '\n')
                pbs_file.write('#PBS -N ' + job_title  + '\n')
                pbs_file.write('#PBS -o ' + job_title + '.out\n')
                pbs_file.write('#PBS -e ' + job_title + '.err\n')
                pbs_file.write('#PBS -q short' + '\n')
                pbs_file.write(sh_fn + '\n')
                pbs_file.close()
        
        submit_pbs_job(pbs_fn, user_name, max_njobs, sleep_time, max_retry)

            elif job_sys == 'sge': submit_sge_job(sh_fn, user_name, max_njobs, sleep_time, max_retry)
            else: print 'Error: unsupported job scheduling system.'
        
    #check_jobs_running(in_dir, out_dir, user_name, sleep_time, max_retry)

def submit_pbs_job(pbs_fn, user_name, max_njobs, sleep_time, max_retry):

    dir0 = os.path.abspath('.')
    pbs_dir = os.path.split(pbs_fn)[0]
    pbs_file = os.path.split(pbs_fn)[1]

    tmp_fn = tempfile.mktemp('.njobs')
    n = 0
    while n <= max_retry:
        n = n + 1

        os.system('qstat | grep ' + user_name + ' | wc -l > ' + tmp_fn)

        ifile = open(tmp_fn, 'r')
        line = ifile.readline()
        ifile.close()

        njobs = int(line.strip())

        if njobs < max_njobs:
            os.remove(tmp_fn)
            os.chdir(pbs_dir)
            os.system('qsub ' + pbs_file)
            os.chdir(dir0)
            return
        else:
            print 'Error: Too many jobs on the queue. Waiting...'
            time.sleep(sleep_time)

    print 'Error: Job could not be submitted.'
    
def submit_sge_job(sge_fn, user_name, max_njobs, sleep_time, max_retry):

    dir0 = os.path.abspath('.')
    sge_dir = os.path.split(sge_fn)[0] 
    sge_file = os.path.split(sge_fn)[1]

    tmp_fn = tempfile.mktemp('.njobs')
    n = 0
    while n <= max_retry:
        n = n + 1

        os.system('qstat | grep ' + user_name + ' | wc -l > ' + tmp_fn)

        ifile = open(tmp_fn, 'r')
        line = ifile.readline()
        ifile.close()

        njobs = int(line.strip())

        if njobs < max_njobs:
            os.remove(tmp_fn)
            os.chdir(sge_dir)
            os.system('qsub -cwd ' + sge_file )
            os.chdir(dir0)
            return
        else:
            print 'Error: Too many jobs on the queue. Waiting...'
            time.sleep(sleep_time)

    print 'Error: Job could not be submitted.'
    
def number_of_jobs_running(user_name):
    
    tmp_fn = tempfile.mktemp('.checknjobs')

    os.system('qstat | grep ' + user_name + ' | wc -l > ' + tmp_fn)

    ifile = open(tmp_fn, 'r')
    line = ifile.readline()
    ifile.close()
    os.remove(tmp_fn)

    return int(line.strip())
    
    
def check_jobs_running(in_dir, out_dir, user_name, sleep_time, max_retry):
    
    n = 0
    while n <= max_retry:
        n = n + 1
    tmp_fn = tempfile.mktemp('.checknjobs')
    tmp_fn2 = tempfile.mktemp('.check_unfolded')

        os.system('qstat | grep submit.sh | wc -l > ' + tmp_fn2)
        os.system('qstat | grep ' + user_name + ' | wc -l > ' + tmp_fn)

        ifile = open(tmp_fn, 'r')
        line = ifile.readline()
        ifile.close()
    
    ifile = open(tmp_fn2, 'r')
        line2 = ifile.readline()
        ifile.close()
    
    os.remove(tmp_fn)
    os.remove(tmp_fn2)

        n_unfolded_jobs = int(line2.strip())
        njobs = int(line.strip())
    if (njobs - n_unfolded_jobs) == 0: break
    else: 
        print 'Waiting for ' + str(njobs - n_unfolded_jobs) + ' to finish...'
        in_list = os.listdir(in_dir)
        for file in in_list:
            target_name = os.path.splitext(file)[0]
            out_dir = os.path.join(out_dir, target_name)
        if os.path.exists(out_dir): GetStructures(out_dir)
        time.sleep(sleep_time)
        
def ClearDirectory(dir_path):

    for root, dirs, files in os.walk(dir_path, topdown=False):
        for name in files:
            os.remove(os.path.join(root, name))
        for name in dirs:
            os.rmdir(os.path.join(root, name))
        
def GetSequenceLength(fasta_path):
    fasta_file = open(fasta_path, 'r')
    line = fasta_file.readline()
    line = fasta_file.readline()
    line = line.strip()
    seq_length = len(line)
    fasta_file.close()
    return seq_length

def MakeTrajectory(in_path, out_path):
    
    in_file_list = os.listdir(in_path)
    traj_out = open(out_path, 'w')
    
    for file in in_file_list:
    name_ext = os.path.splitext(file)[0]
    model_number = string.split(name_ext, '-')[1]
        pdb_path = os.path.join(in_path, file)
        pdb_file = open(pdb_path, 'r')
    traj_out.write('MODEL ' + str(model_number) + '\n')
        pdb_line = pdb_file.readline()
    pdb_line = pdb_file.readline()
    while pdb_line:
        pdb_line = pdb_line.strip()
        traj_out.write(pdb_line + '\n')
        pdb_line = pdb_file.readline()
        pdb_file.close()
    traj_out.close()
    
def DOPE_energy_log(pred_path):
    
    pred_dir = os.path.split(pred_path)[0]
    pred_lines = readlines(pred_path)
    total_path = os.path.join(pred_dir, 'total.pdt')
    total_file = open(total_path, 'w')
    
    for i in range(len(pred_lines)):
    total_file.write('MODEL ' + pred_lines[i].split()[0] + '\n')
    pdb_lines = readlines(os.path.join(pred_dir, pred_lines[i].split()[0] + '.pdb'))
    for j in range(len(pdb_lines)):
        total_file.write(pdb_lines[j])
    total_file.write('ENDMDL\n')
    total_file.close() 
    
def CheckCompletion(secseq_path, prev_secseq_path):
    
    secseq_file = open(secseq_path, 'r')
    secseq_line = secseq_file.readline()
    secseq_line = secseq_line.strip()
    secseq_file.close()
    prev_secseq_file = open(prev_secseq_path, 'r')
    prev_secseq_line = prev_secseq_file.readline()
    prev_secseq_line = prev_secseq_line.strip()
    prev_secseq_file.close()

    l = len(secseq_line)
    load_int = int(l * 0.10)
    load_float = float(l) * float(0.10)
    load_diff = load_float - float(load_int)
    if load_diff > 0.50: load = load_int + 1
    else: load = load_int
    Total_open = 0
    same_secseq = 0
    for i in range(l):
        if secseq_line[i] == 'A' or secseq_line[i] == 'O' or secseq_line[i] == 'Q':
        Total_open = Total_open + 1
    if secseq_line[i] == prev_secseq_line[i]:
        same_secseq = same_secseq + 1
    if Total_open < load:
        return 0
    else: return 1
    
def MakeNewSecseq(fasta_path, out_path):
    
    name_ext = os.path.split(fasta_path)[1]
    name = os.path.splitext(name_ext)[1]
    in_fasta_file = open(fasta_path, 'r')
    fasta_header = in_fasta_file.readline()
    fasta_sequence = in_fasta_file.readline()
    in_fasta_file.close()
    fasta_sequence = fasta_sequence.strip()
    l = len(fasta_sequence)
    out_secseq_file = open(out_path, 'w')
    for j in range(l):
    out_secseq_file.write('A')
    out_secseq_file.close()
    
def run_itfix(project_dir, iteration):
    
    storage_dir = os.path.join(project_dir, 'storage')
    in_dir = os.path.join(project_dir, 'in')
    secseq_dir = os.path.join(project_dir, 'secseq')
    out_dir = os.path.join(project_dir, 'trj')
    homology_dir = os.path.join(project_dir, 'homology')
    in_list = os.listdir(in_dir)

    if iteration == 1:
    
        ##### MAKING STORAGE DIRECTORIES AND SECSEQ FILES #####
    for file in in_list:
        target_name = os.path.splitext(file)[0]
        storage_path = os.path.join(storage_dir, target_name)
        if not os.path.exists(storage_path): os.mkdir(storage_path)
        
        fasta_path = os.path.join(in_dir, file)
         start_secseq_path = os.path.join(secseq_dir, target_name + '.secseq') 
            MakeNewSecseq(fasta_path, start_secseq_path)
        
    ##### BEGIN ITERATION #####
    stop_iteration = 1
    while (stop_iteration == 1):
        
    in_list = os.listdir(in_dir)
        
        ##### SUBMITTING JOBS FOR CURRENT ROUND #####
        run_oops(project_dir)
    
    #### PROCESSING RESULTS OF CURRENT ROUND #####
    for fasta_name in in_list:
        name = os.path.splitext(fasta_name)[0]
        traj_dir = os.path.join(out_dir, name)
         
        ##### GETTING THE SEQUENCE LENGTH #####
        fasta_path = os.path.join(in_dir, name + '.fasta')
        seq_length = GetSequenceLength(fasta_path)
        
        ##### GENERATING DSSP LIBRARY FOR MODELS #####
        final_dir = os.path.join(traj_dir, 'Final')
        SecStrConsenus(final_dir)    

        ##### GENERATING DSSP ORIGINS LIBRARY FOR MODELS #####
        SecStrAlignFinal(final_dir)
        
        ##### GENERATING A NEW SECSEQ FILE #####
        write_secseq = 'Y'
        print_probs = 'N'
        NewSecseq(traj_dir, write_secseq, print_probs)
        
        ##### MOVING OUT DIR TO THE STORAGE DIR #####
        storage_path = os.path.join(storage_dir, name)
        storage_sub_path = os.path.join(storage_path, 'sstart' + str(iteration))
        if not os.path.exists(storage_sub_path):
            os.mkdir(storage_sub_path)
        os.system('mv ' + traj_dir + ' ' + storage_sub_path)
        
        ##### CHECKING COMPLETION STATUS OF TARGET #####
        if iteration > 1:
        secseq_path = os.path.join(secseq_dir, name + '.secseq')
        prev_traj_dir = os.path.join(storage_sub_path, name)
        prev_secseq_path = os.path.join(prev_traj_dir, name + '.secseq')
            if CheckCompletion(secseq_path, prev_secseq_path) == 0:
                os.remove(fasta_path)
            
    iteration = iteration + 1
    input_file_list = os.listdir(in_dir)
    if len(input_file_list) == 0: stop_iteration = 0
    
def SecStrConsenus(SecStr_consensus_path):
    SecStr_consensus_out_path = os.path.join(SecStr_consensus_path, "protein.SecStr")
    SecStr_consensus_out_file = open(SecStr_consensus_out_path, 'w')
    in_list = os.listdir(SecStr_consensus_path)
    for pdb_name in in_list:
    if os.path.splitext(pdb_name)[1] == '.pdb':
        pdb_path = os.path.join(SecStr_consensus_path, pdb_name)
        tmp_dssp_path = tempfile.mktemp('.dssp')
        AssignSecStr(pdb_path, tmp_dssp_path)
        tmp_dssp_file = open(tmp_dssp_path, 'r')
        SecStr_line = tmp_dssp_file.readline()
        tmp_dssp_file.close()
        os.remove(tmp_dssp_path)
        SecStr_consensus_out_file.write(SecStr_line + '\n')
    SecStr_consensus_out_file.close()
    
def SecStrProbsPlot(SecStr_path, out_path):
    
    SecStr_file = open(SecStr_path, 'r')
    SecStr_lines = SecStr_file.readlines()
    l = len(SecStr_lines[0].strip())
    SecStr_file.close()
    print len(SecStr_lines)
    
    basin_counts = [None] * l
    for i in range(l):
        basin_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]

    basin_probs = [None] * l
    for i in range(l):
        basin_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
    
    for j in range(len(SecStr_lines)):
    line = SecStr_lines[j].strip()
    for i in range(l):
        if line[i] == 'H': basin_counts[i][0] = basin_counts[i][0] + 1
        if line[i] == 'E': basin_counts[i][1] = basin_counts[i][1] + 1
        if line[i] == 'S': basin_counts[i][2] = basin_counts[i][2] + 1
        if line[i] == 'B': basin_counts[i][3] = basin_counts[i][3] + 1
        if line[i] == 'G': basin_counts[i][4] = basin_counts[i][4] + 1
        if line[i] == 'T': basin_counts[i][5] = basin_counts[i][5] + 1
        if line[i] == 'N': basin_counts[i][6] = basin_counts[i][6] + 1

    for i in range(l):
        Total = 0
        for j in range(7):
        Total = Total + basin_counts[i][j]
    basin_counts[i][7] = Total
    
    print basin_counts[42][1]
    
    for i in range(l):
        for j in range(7):
        basin_probs[i][j] = float(basin_counts[i][j]) / float(basin_counts[i][7])
            basin_probs[i][8] = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5]  + basin_probs[i][6]
    
    probs_dir = os.path.split(out_path)[0]
    name_ext = os.path.split(out_path)[1]
    name = name_ext.split('.')[0] + '.probs'
    probs_path = os.path.join(probs_dir, name)
    probsoutfile = open(probs_path, 'w')
    probsoutfile.write('Position H E C\n')
    for i in range(l):
        probsoutfile.write(str(i + 1) + ' ' + str(basin_probs[i][0]) + ' ' + str(basin_probs[i][1]) + ' ' + str(basin_probs[i][8]) + '\n')
    probsoutfile.close()
       
    plot_out_path = tempfile.mktemp('.plot')
    Make_GNU_PLOT_Script_Probs(probs_path, plot_out_path, out_path)
    
    os.remove(plot_out_path)
    print l
    
def PrintSecStrProbs(SecStr_path, SecStr_dssp_path, old_secseq_path, new_secseq_path, dssp_path):
    
    dssp_file = open(dssp_path, 'r')
    native_dssp = dssp_file.readline()
    native_dssp = native_dssp.strip()
    dssp_file.close()
    
    SecStr_lines = readlines(SecStr_path)
    l = len(SecStr_lines[0].strip())
    
    dssp_lines = readlines(SecStr_dssp_path)
    
    basin_counts = [None] * l
    for i in range(l):
        basin_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]

    basin_probs = [None] * l
    for i in range(l):
        basin_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
    
    dssp_counts = [None] * l
    for i in range(l):
        dssp_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]

    dssp_probs = [None] * l
    for i in range(l):
        dssp_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
    
    for j in range(len(SecStr_lines)):
    line = SecStr_lines[j].strip()
    for i in range(l):
        if line[i] == 'H': basin_counts[i][0] = basin_counts[i][0] + 1
        if line[i] == 'E': basin_counts[i][1] = basin_counts[i][1] + 1
        if line[i] == 'S': basin_counts[i][2] = basin_counts[i][2] + 1
        if line[i] == 'B': basin_counts[i][3] = basin_counts[i][3] + 1
        if line[i] == 'G': basin_counts[i][4] = basin_counts[i][4] + 1
        if line[i] == 'T': basin_counts[i][5] = basin_counts[i][5] + 1
        if line[i] == 'N': basin_counts[i][6] = basin_counts[i][6] + 1

    for i in range(l):
        Total = 0
        for j in range(7):
        Total = Total + basin_counts[i][j]
    basin_counts[i][7] = Total
    
    for i in range(l):
        for j in range(7):
        basin_probs[i][j] = float(basin_counts[i][j]) / float(basin_counts[i][7])
        basin_probs[i][8] = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5]  + basin_probs[i][6]
    
    for j in range(len(dssp_lines)):
    line = dssp_lines[j].strip()
    for i in range(l):
        if line[i] == 'H': dssp_counts[i][0] = dssp_counts[i][0] + 1
        if line[i] == 'E': dssp_counts[i][1] = dssp_counts[i][1] + 1
        if line[i] == 'S': dssp_counts[i][2] = dssp_counts[i][2] + 1
        if line[i] == 'B': dssp_counts[i][3] = dssp_counts[i][3] + 1
        if line[i] == 'G': dssp_counts[i][4] = dssp_counts[i][4] + 1
        if line[i] == 'T': dssp_counts[i][5] = dssp_counts[i][5] + 1
        if line[i] == 'N': dssp_counts[i][6] = dssp_counts[i][6] + 1

    for i in range(l):
        Total = 0
        for j in range(7):
        Total = Total + dssp_counts[i][j]
    dssp_counts[i][7] = Total
    
    for i in range(l):
        for j in range(7):
        dssp_probs[i][j] = float(dssp_counts[i][j]) / float(dssp_counts[i][7])
        dssp_probs[i][8] = dssp_probs[i][2] + dssp_probs[i][3] + dssp_probs[i][4] + dssp_probs[i][5]  + dssp_probs[i][6]
    
    old_secseq_file = open(old_secseq_path, 'r')
    old_secseq = list(old_secseq_file.readline().strip())
    new_secseq = [''] * l
    for i in range(l): new_secseq[i] = old_secseq[i]
    
    ##### FIX Q #####
    i = 0
    count = 0
    count2 = 0
    while True:
    if old_secseq[i] == 'A' and basin_probs[i][0] > 0.40 and basin_probs[i][1] < 0.04:
        count += 1
        if basin_probs[i][0] > 0.50: count2 += 1
    else:
        if count > 6:
        if count2 > 3:
                for j in range(i - count, i): 
                new_secseq[j] = 'Q'
        count = 0 
    i += 1
    if i > l - 1: break
    
    i = 0
    count = 0
    while True:
    if old_secseq[i] == 'A' and basin_probs[i][0] > 0.40 and (basin_probs[i][1] < 0.03 or (basin_probs[i][0] > 0.50 and basin_probs[i][1] < 0.04)): count += 1
    else:
        if count > 6:
            for j in range(i - count, i): 
            new_secseq[j] = 'Q'
        count = 0 
    i += 1
    if i > l - 1: break
    
    i = 0
    count = 0
    while True:
    if old_secseq[i] == 'A' and basin_probs[i][0] > 0.60: count += 1
    else:
        if count > 2:
            for j in range(i - count, i): new_secseq[j] = 'Q'
        count = 0 
    i += 1
    if i > l - 1: break
    
    for i in range(1, l - 1):
    if old_secseq[i] == 'Q' and old_secseq[i - 1] == 'A':
        j = 1
        while i - j > 0:
        if (basin_probs[i - j][1] < 0.01 or (basin_probs[i - j][0] > 0.40 and basin_probs[i - j][1] < 0.02)) and new_secseq[i - j] == 'A': new_secseq[i - j] = 'Q'
            else: break
        j += 1
        
    for i in range(1, l - 1):
    if old_secseq[i] == 'Q' and old_secseq[i + 1] == 'A':
        j = 1
        while i + j < l - 1:
        if (basin_probs[i + j][1] < 0.01 or (basin_probs[i + j][0] > 0.40 and basin_probs[i + j][1] < 0.02)) and new_secseq[i + j] == 'A': new_secseq[i + j] = 'Q'
            else: break
        j += 1
        
    ##### FIX H #####
    for i in range(l):
    if new_secseq[i] == 'H':
        j = 0
        while i + j + 3 < l:
        if new_secseq[i + j + 1] == 'Q' and new_secseq[i + j + 2] == 'Q' and new_secseq[i + j + 3] == 'Q' and dssp_probs[i + j + 2][0] > 0.50 and dssp_probs[i + j + 3][0] > 0.50:
            new_secseq[i + j + 1] = 'H'
        else: break
        j += 1
        
    for i in range(l):
    if new_secseq[i] == 'H':
        j = 0
        while i - j - 3 > 0:
        if new_secseq[i - j - 1] == 'Q' and new_secseq[i - j - 2] == 'Q' and dssp_probs[i - j - 2][0] > 0.50: new_secseq[i - j - 1] = 'H'
        else: break
        j += 1
    
    for i in range(2, l - 2):
    if dssp_probs[i - 2][0] > 0.50 and dssp_probs[i - 1][0] > 0.50 and dssp_probs[i][0] > 0.85 and dssp_probs[i + 1][0] > 0.50 and dssp_probs[i + 2][0] > 0.50 and old_secseq[i - 2] == 'Q' and old_secseq[i - 1] == 'Q' and old_secseq[i] == 'Q' and old_secseq[i + 1] == 'Q' and old_secseq[i + 2] == 'Q': new_secseq[i] = 'H'
    
    for i in range(2, l - 2):
    if dssp_probs[i][0] > 0.90 and dssp_probs[i - 1][0] > 0.50 and dssp_probs[i - 2][0] > 0.50 and dssp_probs[i + 1][0] > 0.50 and dssp_probs[i + 2][0] > 0.50 and new_secseq[i] == 'Q':
         new_secseq[i] = 'H'
         
    for i in range(l - 9):
    count = 0
    for j in range(9):
        if old_secseq[i + j + 1] == 'Q' and new_secseq[i + j + 1] == 'Q' and basin_probs[i + j + 1][0] > 0.50: count += 1
    if count == 9: new_secseq[i + 5] = 'H'
    
    for i in range(1, l - 1):
    if i < 10 or i > l - 10:
        if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.50: new_secseq[i] = 'H'
    
    ##### FIX O #####
    strands = 0
    i = 0
    while i < l:
    if basin_probs[i][1] >= 0.05:
         strands += 1
         i += 1
         while basin_probs[i][1] >= 0.04 and i < l - 1: i += 1
    i += 1
       
    
    for i in range(15, l - 15):
    H_free = 'True' 
    for j in range(1, 15):
        if (old_secseq[i + j] == 'A' and new_secseq[i + j] == 'Q') or (old_secseq[i + j] == 'Q' and new_secseq[i + j] == 'H'):
        H_free = 'False'
        break
    if H_free == 'True' and new_secseq[i] == 'A' and basin_probs[i][0] < 0.10: new_secseq[i] = 'O'
    
    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and old_secseq[i - 1] == 'A':
        j = 1
        while i - j > 0:
        if basin_probs[i - j][0] < 0.10 and old_secseq[i - j] == 'A' and new_secseq[i - j] == 'A': new_secseq[i - j] = 'O'
            else: break
        j += 1
        
    for i in range(l - 11, l - 1):
        if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j < l - 1:
        if basin_probs[i + j][0] < 0.10 and new_secseq[i + j] == 'A': new_secseq[i + j] = 'O'
            else: break
        j += 1
        
    if strands > 1:
        for i in range(l):
            if new_secseq[i] == 'A' and basin_probs[i][1] >= 0.05: new_secseq[i] = 'O'
         
    ##### FIX E #####
    
    for i in range(l):
    if new_secseq[i] == 'E':
        j = 0
        while i + j + 2 < l:
        if new_secseq[i + j + 1] == 'O' and new_secseq[i + j + 2] == 'O' and basin_probs[i + j + 1][1] > 0.1 and basin_probs[i + j + 2][1] > 0.10:
            new_secseq[i + j + 1] = 'E'
        else: break
        j += 1
        
    for i in range(l):
    if new_secseq[i] == 'E':
        j = 0
        while i - j - 2 < l:
        if new_secseq[i - j - 1] == 'O' and new_secseq[i - j - 2] == 'O' and basin_probs[i - j - 1][1] > 0.1 and basin_probs[i - j - 2][1] > 0.10:
            new_secseq[i - j - 1] = 'E'
        else: break
        j += 1
         
    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and (new_secseq[i - 1] == 'O' and old_secseq[i - 1] == 'O') and (new_secseq[i + 1] == 'O' and old_secseq[i + 1] == 'O') and basin_probs[i][1] > 0.10: new_secseq[i] = 'E'
    
    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and new_secseq[i - 1] == 'E' and new_secseq[i + 1] == 'E' and basin_probs[i][1] > 0.10: new_secseq[i] = 'E'
    
    for i in range(2, l - 2):
    if new_secseq[i] == 'E' and old_secseq[i] == 'E' and new_secseq[i - 1] == 'O' and old_secseq[i - 1] == 'O':
        j = 0
        while (i + j < l - 1 and j < 5):
        if new_secseq[i + j] == 'E' and old_secseq[i + j] == 'E': j += 1
        else: break
        if j < 5 and new_secseq[i + j] == 'O' and old_secseq[i + j] == 'O':
            
        left = 'no'
        right = 'no'
        if basin_probs[i - 1][1] > 0.05 and basin_probs[i - 1][1] > basin_probs[i + j][1]:
            if i - 2 > 0:
                if new_secseq[i - 2] == 'O':
                    new_secseq[i - 1] = 'E'
            else: left = 'yes'
            else: new_secseq[i - 1] = 'E'
        if basin_probs[i + j][1] > 0.05 and basin_probs[i - 1][1] < basin_probs[i + j][1]:
            if i + j + 1 < l - 1:
                if new_secseq[i + j + 1] == 'O':
                    new_secseq[i + j] = 'E'
            else: right = 'yes'
            else: new_secseq[i + j] = 'E'
        if basin_probs[i - 1][1] > 0.05 and basin_probs[i - 1][1] == basin_probs[i + j][1]:
            new_secseq[i - 1] = 'E'
            new_secseq[i + j] = 'E'
        if basin_probs[i - 1][1] > 0.05 and right == 'yes' and left == 'no': new_secseq[i - 1] = 'E'
        if basin_probs[i + j][1] > 0.05 and left == 'yes' and right == 'no': new_secseq[i + j] = 'E'
    
    ##### FIX C #####
    
    for i in range(l - 2):
    if old_secseq[i] == 'E' and new_secseq[i + 1] == 'O':
        j = 1
        while i + j + 1 < l - 1 and j <= 8:
        if new_secseq[i + j + 1] != 'O': break
        j += 1
        if j <= 8 and old_secseq[i + j + 1] == 'E':
        for k in range(j):
            if ((dssp_probs[i + k + 1][2] > 0.45 or dssp_probs[i + k + 1][5] > 0.25) or ((dssp_probs[i + k + 1][2] + dssp_probs[i + k + 1][5]) > 0.50)): new_secseq[i + k + 1] = 'C'
            
    for i in range(1, l - 1):
    if new_secseq[i] == 'O' and (new_secseq[i - 1] == 'O' or new_secseq[i - 1] == 'C') and (new_secseq[i + 1] == 'O' or new_secseq[i + 1] == 'C') and ((dssp_probs[i][2] + dssp_probs[i][5]) > 0.70): new_secseq[i] = 'C'
            
    for i in range(10, l - 10):
    if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and (old_secseq[i - 1] == 'Q' or old_secseq[i - 1] == 'O') and (old_secseq[i + 1] == 'Q' or old_secseq[i + 1] == 'O') and dssp_probs[i][0] < 0.15: new_secseq[i] = 'C'
    
    for i in range(10, l - 10):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and old_secseq[i - 1] != 'C' and new_secseq[i - 1] != 'C' and old_secseq[i + 1] != 'C' and new_secseq[i + 1] != 'C' and dssp_probs[i][5] > 0.25: new_secseq[i] = 'C'
    
    for i in range(1, l):
    if new_secseq[i] == 'C' and old_secseq[i] == 'C' and (new_secseq[i - 1] == 'Q' or new_secseq[i - 1] == 'O') and (old_secseq[i - 1] == 'Q' or old_secseq[i - 1] == 'O') and dssp_probs[i - 1][5] > 0.20 and dssp_probs[i - 1][0] < 0.60: new_secseq[i - 1] = 'C'
    
    for i in range(l - 1):
    if new_secseq[i] == 'C' and old_secseq[i] == 'C' and (new_secseq[i + 1] == 'Q' or new_secseq[i + 1] == 'O') and (old_secseq[i + 1] == 'Q' or old_secseq[i + 1] == 'O') and dssp_probs[i + 1][5] > 0.20 and  dssp_probs[i + 1][0] < 0.60: new_secseq[i + 1] = 'C'
    
    ##### CLEANUP #####
    
    for i in range(1, 9):
    if new_secseq[i] == 'O' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(1, 9):
    if new_secseq[i] == 'Q' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'O':
        for k in range(j): new_secseq[i + k + 1] = 'O'
        
    for i in range(l - 2):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'Q':
        for k in range(j): new_secseq[i + k + 1] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'C' and new_secseq[i + 1] == 'O':
        j = 1
        while i + j + 1 < l - 1 and j <= 5:
        if new_secseq[i + j + 1] != 'O': break
        j += 1
        if j <= 5 and new_secseq[i + j + 1] == 'C':
        for k in range(j): new_secseq[i + k + 1] = 'C'
        
    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and new_secseq[i - 1] == 'E' and new_secseq[i + 1] == 'E': new_secseq[i] = 'E'
            
    fixed = 0
    HCE_fixed = 0
    fixed_EO = 0
    changed = 0
    changed_O = 0
    for i in range(l):
    if new_secseq[i] != old_secseq[i]: changed += 1
    if new_secseq[i] == 'O' and old_secseq[i] == 'A': changed_O += 1
    if new_secseq[i] != 'A': fixed += 1
    if new_secseq[i] == 'H' or new_secseq[i] == 'C' or new_secseq[i] == 'E': HCE_fixed += 1
    if basin_probs[i][1] >= 0.03: fixed_EO += 1
    prc_fixed = float(fixed) / float(l)
    prc_HCE_fixed = float(HCE_fixed) / float(l)
    prc_changed = float(changed) / float(l)
    prc_fixed_EO = float(fixed_EO) / float(l)
    prc_changed_O = float(changed_O) / float(l)
    
    if prc_fixed_EO < 0.10 and prc_changed_O < 0.05:
    strand = 0
    for i in range(l):
        if basin_probs[i][1] >= 0.05:
        strand += 1
    if strand < 2:
        for i in range(l):
            if new_secseq[i] == 'A' or new_secseq[i] == 'O': new_secseq[i] = 'Q'
    for i in range(l):
        j = 0
        while i + j < l - 1:
        if new_secseq[i + j] == 'A' and basin_probs[i + j][0] > 0.40 and basin_probs[i + j][1] < 0.02: j += 1
        else: break
        if j > 3:
        for k in range(j): new_secseq[i + k] = 'Q'
        
    if prc_changed == 0.0 and strands < 2:
        for i in range(2, l - 2):
        if basin_probs[i - 2][0] > 0.50 and basin_probs[i - 1][0] > 0.50 and basin_probs[i][0] > 0.50 and basin_probs[i + 1][0] > 0.50 and basin_probs[i + 2][0] > 0.50 and old_secseq[i - 2] == 'Q' and old_secseq[i - 1] == 'Q' and old_secseq[i] == 'Q' and old_secseq[i + 1] == 'Q' and old_secseq[i + 2] == 'Q': new_secseq[i] = 'H'    
        
    if prc_fixed == 1.0 and strands == 0:
        
    for i in range(l):
        if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and dssp_probs[i][5] > 0.40:
        new_secseq[i] = 'C'
        
    for i in range(10, l - 10):
        if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and old_secseq[i - 1] == 'Q' and old_secseq[i + 1] == 'Q' and dssp_probs[i][0] < 0.25:
        new_secseq[i] = 'C'
        
    for i in range(3, l - 3):
        if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.50 and dssp_probs[i - 1][0] > 0.50 and dssp_probs[i - 2][0] > 0.50 and dssp_probs[i + 1][0] > 0.50 and dssp_probs[i + 2][0] > 0.50: new_secseq[i] = 'H'
        
    for i in range(1, l - 1):
        if i < 10 or i > l - 10:
            if old_secseq[i] == 'Q' and new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.40: new_secseq[i] = 'H'

        for i in range(2, l - 2):
        if new_secseq[i] == 'H' and new_secseq[i + 1] == 'Q' and dssp_probs[i + 1][0] > 0.90 and dssp_probs[i + 2][0] > 0.50: new_secseq[i + 1] = 'H'

        for i in range(2, l - 2):
        if new_secseq[i] == 'H' and new_secseq[i - 1] == 'Q' and dssp_probs[i - 1][0] > 0.90 and dssp_probs[i - 2][0] > 0.50: new_secseq[i - 1] = 'H'
        
    if prc_changed == 0.0 and strands >= 2:
    for i in range(l):
        j = 0
        while i + j < l - 1:
        if new_secseq[i + j] == 'O' and basin_probs[i + j][1] > 0.05: j += 1
        else: break
        if j > 2:
        for k in range(j - 2): new_secseq[i + k + 1] = 'E'
        
    if prc_changed == 0.0 and prc_HCE_fixed < 0.75:
        for i in range(l):
        if new_secseq[i] == 'Q' or new_secseq[i] == 'O':
            if basin_probs[i][1] < 0.01 and (dssp_probs[i][5] + dssp_probs[i][2] > 0.60): new_secseq[i] = 'C'
     

    ##### CLEANUP #####
    
    for i in range(1, 9):
    if new_secseq[i] == 'O' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(1, 9):
    if new_secseq[i] == 'Q' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'O':
        for k in range(j): new_secseq[i + k + 1] = 'O'
        
    for i in range(l - 2):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'Q':
        for k in range(j): new_secseq[i + k + 1] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'C' and (new_secseq[i + 1] == 'O'):
        j = 1
        while i + j + 1 < l - 1 and j <= 5:
        if new_secseq[i + j + 1] != 'O': break
        j += 1
        if j <= 5 and new_secseq[i + j + 1] == 'C':
        for k in range(j): new_secseq[i + k + 1] = 'C'
        
    for i in range(l - 2):
    if new_secseq[i] == 'C' and (new_secseq[i + 1] == 'Q'):
        j = 1
        while i + j + 1 < l - 1 and j <= 5:
        if new_secseq[i + j + 1] != 'Q': break
        j += 1
        if j <= 5 and new_secseq[i + j + 1] == 'C':
        for k in range(j): new_secseq[i + k + 1] = 'C'

    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and new_secseq[i - 1] == 'E' and new_secseq[i + 1] == 'E': new_secseq[i] = 'E'
    
    for i in range(l):
    print i + 1, native_dssp[i], '    H:', str(basin_probs[i][0])[0:min(5, len(str(basin_probs[i][0])))], 'E:', str(basin_probs[i][1])[0:min(5, len(str(basin_probs[i][1])))], 'T:', str(dssp_probs[i][5])[0:min(5, len(str(dssp_probs[i][5])))], 'S:', str(dssp_probs[i][2])[0:min(5, len(str(dssp_probs[i][2])))], 'N:', str(dssp_probs[i][6])[0:min(5, len(str(dssp_probs[i][6])))], 'H:', str(dssp_probs[i][0])[0:min(5, len(str(dssp_probs[i][0])))]
    
    num_str = ''
    for i in range(l): num_str += str(i + 1)[-1]
    print num_str
    
    print string.join(old_secseq, '')
    print string.join(new_secseq, '')
    print native_dssp
    print strands, prc_fixed_EO, prc_changed_O
    
    if new_secseq_path != 'no':
        new_secseq_file = open(new_secseq_path, 'w')
    new_secseq_file.write(string.join(new_secseq, ''))
    new_secseq_file.close()
    
def new_secseq(SecStr_path, fasta_path, old_secseq_path, new_secseq_path, dssp_path):
    
    native_dssp = readline(dssp_path, 1)
    fasta = readline(fasta_path, 2)
    
    dssp_lines = readlines(SecStr_path)
    l = len(dssp_lines[0].strip())
    
    dssp_counts = [None] * l
    for i in range(l):
        dssp_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]

    dssp_probs = [None] * l
    for i in range(l):
        dssp_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
    
    for j in range(len(dssp_lines)):
    line = dssp_lines[j].strip()
    if len(line) != l: continue
    for i in range(l):
        if line[i] == 'H': dssp_counts[i][0] = dssp_counts[i][0] + 1
        if line[i] == 'E': dssp_counts[i][1] = dssp_counts[i][1] + 1
        if line[i] == 'S': dssp_counts[i][2] = dssp_counts[i][2] + 1
        if line[i] == 'B': dssp_counts[i][3] = dssp_counts[i][3] + 1
        if line[i] == 'G': dssp_counts[i][4] = dssp_counts[i][4] + 1
        if line[i] == 'T': dssp_counts[i][5] = dssp_counts[i][5] + 1
        if line[i] == 'N': dssp_counts[i][6] = dssp_counts[i][6] + 1

    for i in range(l):
        Total = 0
        for j in range(7):
        Total = Total + dssp_counts[i][j]
    dssp_counts[i][7] = Total
    
    for i in range(l):
        for j in range(7):
        dssp_probs[i][j] = float(dssp_counts[i][j]) / float(dssp_counts[i][7])
        dssp_probs[i][8] = dssp_probs[i][2] + dssp_probs[i][3] + dssp_probs[i][4] + dssp_probs[i][5]  + dssp_probs[i][6]
    
    
    if old_secseq_path != 'no':
        old_secseq_file = open(old_secseq_path, 'r')
        old_secseq = list(old_secseq_file.readline().strip())
    else:
    old_secseq = []
    for i in range(l): old_secseq.append('A')
    new_secseq = [''] * l
    for i in range(l): new_secseq[i] = old_secseq[i]
    
    ##### FIX Q #####
    i = 0
    count = 0
    while True:
    if new_secseq[i] == 'A' and ((dssp_probs[i][0] > 0.25 and dssp_probs[i][1] < 0.005) or dssp_probs[i][0] > 0.50):
        count += 1
    else:
        if count > 3:
            for j in range(i - count, i): 
            new_secseq[j] = 'Q'
        count = 0 
    i += 1
    if i > l - 1: break
    
    E_count = 0
    low_H = 0
    for i in range(l):
    if (dssp_probs[i][1] >= 0.005) and new_secseq[i] != 'Q' and new_secseq[i] != 'H':
        E_count += 1
    if dssp_probs[i][0] < 0.25:
        low_H += 1
    low_H_prob = float(low_H) / float(l)
    if E_count == 0 and low_H_prob < 0.50:
    for i in range(l):
        if new_secseq[i] == 'A': new_secseq[i] = 'Q'
        if dssp_probs[i][0] < 0.02 and i > 0 and i < l - 1: new_secseq[i] = 'C'
        
    for i in range(l):
    if new_secseq[i] == 'Q':
        j = 0
        while i + j + 1 < l:
        if new_secseq[i + j + 1] == 'A' and dssp_probs[i + j + 1][0] > 0.25:
            new_secseq[i + j + 1] = 'Q'
        else: break
        j += 1
        
    for i in range(l):
    if new_secseq[i] == 'Q':
        j = 0
        while i - j - 1 > 0:
        if new_secseq[i - j - 1] == 'A' and (dssp_probs[i - j - 1][0] > 0.25 or (fasta[i - j - 1] == 'P' and dssp_probs[i - j - 1][0] > 0.10)): 
            new_secseq[i - j - 1] = 'Q'
        else: break
        j += 1
        
    for i in range(1, l - 1):
    if new_secseq[i] == 'A' and new_secseq[i + 1] == 'Q' and fasta[i + 1] == 'P' and dssp_probs[i][0] > 0.10: new_secseq[i] = 'Q'
    
        
    ##### FIX H #####
    
    i = 0
    count = 0
    while True:
    if new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.40: count += 1
    else:
        if count > 4:
            for j in range(i - count + 2, i - 2): 
            new_secseq[j] = 'H'
        count = 0 
    i += 1
    if i > l - 1: break
    
    count = 0
    for i in range(7):
    if new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.40: count += 1
    else:
        if count > 3:
            for j in range(i - count + 1, i - 2): 
            new_secseq[j] = 'H'
        break
    
    count = 0
    for i in range(l - 7, l):
    if new_secseq[i] == 'Q' and dssp_probs[i][0] > 0.40:
        count += 1
    else:
        if count > 3:
            for j in range(i - count + 1, i - 2): 
            if new_secseq[j] == 'Q' and new_secseq[j + 1] == 'Q': new_secseq[j] = 'H'
            print j
    
    for i in range(l):
    if new_secseq[i] == 'H':
        j = 0
        while i + j + 3 < l:
        if new_secseq[i + j + 1] == 'Q' and new_secseq[i + j + 2] == 'Q' and new_secseq[i + j + 3] == 'Q' and dssp_probs[i + j + 2][0] > 0.50 and dssp_probs[i + j + 3][0] > 0.50:
            new_secseq[i + j + 1] = 'H'
        else: break
        j += 1
        
    for i in range(l):
    if new_secseq[i] == 'H':
        j = 0
        while i - j - 3 > 0:
        if new_secseq[i - j - 1] == 'Q' and new_secseq[i - j - 2] == 'Q' and new_secseq[i - j - 3] == 'Q' and dssp_probs[i - j - 2][0] > 0.50 and dssp_probs[i - j - 3][0] > 0.50: new_secseq[i - j - 1] = 'H'
        else: break
        j += 1
        
    for i in range(1, l - 1):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'Q' and new_secseq[i - 1] == 'Q' and old_secseq[i] == 'Q' and dssp_probs[i][0] > 0.90: new_secseq[i] = 'H'
    
    for i in range(1, l - 1):
    if fasta[i] == 'P' and new_secseq[i] == 'Q' and new_secseq[i - 1] != 'A' and new_secseq[i + 1] != 'A' and new_secseq[i - 1] != 'O' and new_secseq[i + 1] != 'O' and dssp_probs[i][0] > 0.25: new_secseq[i] = 'H'
    
    for i in range(1, l - 1):
    if (i < 7 or i > l -7) and new_secseq[i] == 'Q' and new_secseq[i - 1] != 'A' and new_secseq[i + 1] != 'A' and dssp_probs[i][0] > 0.40: new_secseq[i] = 'H'
    
    ##### FIX O #####
    
    i = 0
    count = 0
    while True:
    if new_secseq[i] == 'A' and dssp_probs[i][0] < 0.02: count += 1
    else:
        if count > 4:
            for j in range(i - count, i): 
            new_secseq[j] = 'O'
        count = 0 
    i += 1
    if i > l - 1: break

    for i in range(2, l - 2):
        near_Q = False
        if i > 4 and i < l - 5:
            if (new_secseq[i] == 'Q' and old_secseq[i] == 'A') or (new_secseq[i - 1] == 'Q' and old_secseq[i - 1] == 'A') or (new_secseq[i - 2] == 'Q' and old_secseq[i - 2] == 'A') or (new_secseq[i + 1] == 'Q' and old_secseq[i + 1] == 'A') or (new_secseq[i + 2] == 'Q' and old_secseq[i + 2] == 'A'): near_Q = True  
    if dssp_probs[i][1] > 0.01 and dssp_probs[i][0] < 0.10 and new_secseq[i] == 'A' and not near_Q: new_secseq[i] = 'O'
    
    i = 0
    count = 0
    while True:
    if new_secseq[i] == 'A' and dssp_probs[i][0] < 0.20 and (dssp_probs[i][1] + dssp_probs[i][3]) > 0.05: count += 1
    else:
        if count > 3:
            for j in range(i - count, i): 
            new_secseq[j] = 'O'
        count = 0 
    i += 1
    if i > l - 1: break
    
    for i in range(1, l - 1):
    if dssp_probs[i][0] < 0.01 and new_secseq[i] == 'A': new_secseq[i] = 'O'
    
    for i in range(5, l - 5):
    if dssp_probs[i][0] < 0.05 and dssp_probs[i][5] > 0.30 and new_secseq[i] == 'A': new_secseq[i] = 'O'
         
    ##### FIX E #####
    
    for i in range(l):
    if new_secseq[i] == 'O' and old_secseq[i] == 'O' and (dssp_probs[i][1] + dssp_probs[i][3]) > 0.10: new_secseq[i] = 'E'
    if i > 0 and i < l - 1:
        if new_secseq[i] == 'O' and old_secseq[i] == 'O' and (dssp_probs[i][1] + dssp_probs[i][3]) > 0.05 and (dssp_probs[i - 1][1] + dssp_probs[i - 1][3]) > 0.05 and (dssp_probs[i + 1][1] + dssp_probs[i + 1][3]) > 0.05: new_secseq[i] = 'E'
    
    ##### FIX C #####

    for i in range(7, l - 7):
    if new_secseq[i] == 'Q' and old_secseq[i] == 'Q' and dssp_probs[i][5] > 0.25 and dssp_probs[i][0] < 0.30 and new_secseq[i - 1] != 'A' and new_secseq[i + 1] != 'A': new_secseq[i] = 'C'

    if new_secseq[i] == 'Q' and old_secseq[i] == 'Q' and dssp_probs[i][0] < 0.05 and new_secseq[i - 1] != 'A' and new_secseq[i + 1] != 'A': new_secseq[i] = 'C'
    
    for i in range(7, l - 7):
        if new_secseq[i] == 'O' and old_secseq[i] == 'O' and dssp_probs[i][1] == 0.0 and dssp_probs[i][5] > 0.25 and new_secseq[i - 1] != 'A' and new_secseq[i + 1] != 'A': new_secseq[i] = 'C'

    
    ##### CLEANUP #####
    
    for i in range(1, 9):
    if new_secseq[i] == 'O' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'O'
        
    for i in range(1, 9):
    if new_secseq[i] == 'Q' and new_secseq[i - 1] == 'A':
        for j in range(i):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        for j in range(i, l):
        if new_secseq[j] == 'A': new_secseq[j] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'O' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'O':
        for k in range(j): new_secseq[i + k + 1] = 'O'
        
    for i in range(l - 2):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'A':
        j = 1
        while i + j + 1 < l - 1 and j <= 7:
        if new_secseq[i + j + 1] != 'A': break
        j += 1
        if j <= 7 and new_secseq[i + j + 1] == 'Q':
        for k in range(j): new_secseq[i + k + 1] = 'Q'
        
    for i in range(l - 2):
    if new_secseq[i] == 'C' and new_secseq[i + 1] == 'O':
        j = 1
        while i + j + 1 < l - 1 and j <= 3:
        if new_secseq[i + j + 1] != 'O': break
        j += 1
        if j <= 3 and new_secseq[i + j + 1] == 'C':
        for k in range(j): new_secseq[i + k + 1] = 'C'

    for i in range(l - 2):
    if new_secseq[i] == 'C' and new_secseq[i + 1] == 'Q':
        j = 1
        while i + j + 1 < l - 1 and j <= 5:
        if new_secseq[i + j + 1] != 'Q': break
        j += 1
        if j <= 5 and new_secseq[i + j + 1] == 'C':
        for k in range(j): new_secseq[i + k + 1] = 'C'
        
    for i in range(l - 2):
    if new_secseq[i] == 'H' and new_secseq[i + 1] == 'Q':
        j = 1
        while i + j + 1 < l - 1 and j <= 3:
        if new_secseq[i + j + 1] != 'Q': break
        j += 1
        if j <= 3 and new_secseq[i + j + 1] == 'H':
        for k in range(j): new_secseq[i + k + 1] = 'H'

    for i in range(1, 9):
    if new_secseq[i] == 'Q' and new_secseq[i - 1] == 'O':
        for j in range(i):
        if new_secseq[j] == 'O': new_secseq[j] = 'Q'
        
    for i in range(l - 9, l - 1):
    if new_secseq[i] == 'Q' and new_secseq[i + 1] == 'O':
        for j in range(i, l):
        if new_secseq[j] == 'O': new_secseq[j] = 'Q'
        
    for i in range(1, l - 1):
    if old_secseq[i] == 'O' and new_secseq[i] == 'O' and new_secseq[i - 1] == 'E' and new_secseq[i + 1] == 'E': new_secseq[i] = 'E'
    
    for i in range(l):
    pos_str = str(i + 1)
    if len(pos_str) < 2: pos_str += ' '
    H_str = str(dssp_probs[i][0])[0:min(4, len(str(dssp_probs[i][0])))]
    if len(H_str) < 4: H_str += (' ' *(4 - len(H_str)))
    E_str = str(dssp_probs[i][1])[0:min(5, len(str(dssp_probs[i][1])))]
    if len(E_str) < 5: E_str += (' ' *(5 - len(E_str)))
    T_str = str(dssp_probs[i][5])[0:min(4, len(str(dssp_probs[i][5])))]
    if len(T_str) < 4: T_str += (' ' *(4 - len(T_str)))
    S_str = str(dssp_probs[i][2])[0:min(4, len(str(dssp_probs[i][2])))]
    if len(S_str) < 4: S_str += (' ' *(4 - len(S_str)))
    H_str = str(dssp_probs[i][0])[0:min(4, len(str(dssp_probs[i][0])))]
    if len(H_str) < 4: H_str += (' ' *(4 - len(H_str)))
    N_str = str(dssp_probs[i][6])[0:min(4, len(str(dssp_probs[i][6])))]
    if len(N_str) < 4: N_str += (' ' *(4 - len(N_str)))
    G_str = str(dssp_probs[i][4])[0:min(4, len(str(dssp_probs[i][4])))]
    if len(G_str) < 4: G_str += (' ' *(4 - len(G_str)))
    B_str = str(dssp_probs[i][3])[0:min(5, len(str(dssp_probs[i][3])))]
    if len(B_str) < 5: B_str += (' ' *(5 - len(B_str)))

    print pos_str, native_dssp[i], '    H:', H_str, 'E:', E_str, 'T:', T_str, 'S:', S_str, 'N:', N_str, 'G:', G_str, 'B:', B_str
    
    num_str = ''
    for i in range(l): num_str += str(i + 1)[-1]
    print num_str
    
    print string.join(old_secseq, '')
    print string.join(new_secseq, '')
    print native_dssp
    print fasta
    
    if new_secseq_path != 'no':
        new_secseq_file = open(new_secseq_path, 'w')
    new_secseq_file.write(string.join(new_secseq, ''))
    new_secseq_file.close()
    
def GetDate():
    tmp_fn = tempfile.mktemp('.date')
    os.system('date > ' + tmp_fn)
    date_file = open(tmp_fn, 'r')
    date_line = date_file.readline()
    date_line = date_line.strip()
    date_line = date_line.split()
    time = date_line[3]
    time_string = ''
    for i in range(len(time)):
        if time[i] == ':':
        time_string = time_string + 's'
    else:
        time_string = time_string + time[i]
    label = date_line[0] + time_string + date_line[1] + date_line[2]

    date_file.close()
    os.remove(tmp_fn)

    return label
    
def Date_Time_str():
    tmp_fn = tempfile.mktemp('.date')
    os.system('date > ' + tmp_fn)
    date_file = open(tmp_fn, 'r')
    date_line = date_file.readline()
    date_line = date_line.strip()

    date_file.close()
    os.remove(tmp_fn)

    return date_line
    
def test(id, passwd):
    passwd_file = open('passwords.txt', 'r')
    line = passwd_file.readline()
    passwd_file.close()
    combo = string.split(line, ":")
    encrypted_pw = md5crypt.unix_md5_crypt(passwd, 'ab')
    if ((id == combo[0]) and (encrypted_pw[0:20] == combo[1][0:20])): 
         return "passed"
    else:
         return "failed"
    
def bin_dist(bin, min_dist, max_dist, bin_width, num_bins):
    
    temp_dist = min_dist
    for i in range(num_bins):
        if i == bin:
        return temp_dist + bin_width
    temp_dist = temp_dist + bin_width
    
def display_page(contents_string, page_title, foot_message, window_label):
    header_file = open('/var/www/includes/head_oops', 'r')
    html_head_string = header_file.read()
    html_head_string = html_head_string.replace('HEADERHERE', page_title)
    html_head_string = html_head_string.replace('REPLACETITLE', window_label)
    header_file.close()
    
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    html_string = html_head_string + contents_string + foot_string
    html_string = html_string.replace('DATE_UPDATED', foot_message)
    print html_string
    
def plot_profile(min_dist, max_dist, bin_width, AA1, AA2, Atom1, Atom2, par_path, gif_path):
    
    num_bins = int((float(max_dist) - float(min_dist)) / float(bin_width))
    
    data_path = tempfile.mktemp('plotprof')
    data_file = open(data_path, 'w')
    par_file = open(par_path, 'r')
    par_line = par_file.readline()
    while par_line:
    line = par_line.strip()
    line = line.split()
    if line[1] == Atom1 and line[3] == Atom2 and line[0] == AA1 and line[2] == AA2:
        for k in range(num_bins):
        data_file.write(str(bin_dist(k, min_dist, max_dist, bin_width, num_bins)) + ' ' + line[4 +  k] + '\n')
        break
    par_line = par_file.readline() 
    data_file.close()
    
    gnu_path = tempfile.mktemp('.gnu')
    gnu_file = open(gnu_path, 'w')
    gnu_file.write('reset\nset terminal gif\nset output \"' + gif_path + '\"\nset xlabel \"distance (A)\"\nset ylabel \"energy\"\nplot \"' + data_path + '\" u 1:2 w l notitle')
    gnu_file.close()
    os.system('gnuplot ' + gnu_path)
    os.remove(data_path)
    os.remove(gnu_path)
    
def DOPE_PW_Server(date_label, AA1, AA2, Atom1, Atom2, SecStr1, SecStr2, continuity, parallel, prop_wash):
        
    if continuity == 'contiguous' and SecStr1 == 'E': 
        par_file = "/home/secoops/web/par_PW/dope-PW_EE_cont.par"
    max_dist = '15.0'
    bin_width = '0.5'
    elif continuity == 'contiguous' and SecStr1 == 'H': 
    par_file = "/home/secoops/web/par_PW/dope-PW_HH_cont.par"
    max_dist = '15.0'
    bin_width = '0.5'
    elif continuity == 'contiguous' and SecStr1 == 'C': 
    par_file = "/home/secoops/web/par_PW/dope-PW_CC_cont.par"
    max_dist = '15.0'
    bin_width = '0.5'
    elif continuity == 'noncontiguous' and SecStr1 == 'E' and SecStr2 == 'E' and (int(prop_wash) == 0 or int(prop_wash) == 1) and int(parallel) == 1: 
    par_file = "/home/secoops/web/par_PW/dope-PW_0EEp_ncont.par"
    max_dist = '15.0'
    bin_width = '0.5'
    elif continuity == 'noncontiguous' and SecStr1 == 'E' and SecStr2 == 'E' and (int(prop_wash) == 0 or int(prop_wash) == 1) and int(parallel) == 2: 
    par_file = "/home/secoops/web/par_PW/dope-PW_0EEap_ncont.par"
    max_dist = '15.0'
    bin_width = '0.5'
    elif continuity == 'noncontiguous' and (SecStr1 != 'E' or SecStr2 != 'E') and int(prop_wash) == 0: 
    max_dist = '30.0'
    bin_width = '1.0'
    par_file = "/home/secoops/web/par_PW/dope-PW_0A_ncont.par"
    elif continuity == 'noncontiguous' and (SecStr1 != 'E' or SecStr2 != 'E') and int(prop_wash) == 1: 
    max_dist = '30.0'
    bin_width = '1.0'
    par_file = "/home/secoops/web/par_PW/dope-PW_1A_ncont.par"
    elif continuity == 'noncontiguous' and int(prop_wash) == 2:
        max_dist = '30.0'
    bin_width = '1.0'
    par_file = "/home/secoops/web/par_PW/dope-PW_2A_ncont.par"
        
    gif_path = '/var/www/user/' + date_label + '.gif'
    plot_profile(0.0, float(max_dist), float(bin_width), AA1, AA2, Atom1, Atom2, par_file, gif_path)
       
    contents_string = '<img  src=\"http://godzilla.uchicago.edu/user/' + date_label + '.gif\" alt=\"energy profile\"</a>\n<br /><br />\n<a href=\"http://godzilla.uchicago.edu/user/' + date_label + '.gif\">download image here\n'
        
    if prop_wash == '0': pw_string = 'small prop wash'
    if prop_wash == '1': pw_string = 'intermediate prop wash'
    if prop_wash == '2': pw_string = 'large prop wash'
        
    foot_message = 'problems? send email godzilla-help@lists.uchicago.edu'
    display_page(contents_string, 'Residuepair: ' + AA1 + '-' + AA2 + ';   ' + continuity + ' SecStr: ' + SecStr1 + '-' + SecStr2 + ';   ' + pw_string, foot_message, 'ItFix')
    
def unfolded_log(fasta_sequence, sequence_name, email_address, num_jobs_str):
    
    response_str = '\tThe following sequence has been submitted to the Unfolded server:\n\t<br><br>\n' + fasta_sequence + '\t<br><br>\n\tThe results will be sent to '+ email_address + '\n<br><br>'

    foot_message = 'problems? email godzilla-help@lists.uchicago.edu'
    display_page(response_str, sequence_name + ' submitted to the queue', foot_message, 'ItFix')
    date_label = GetDate()
    queue_log_label = sequence_name + date_label + '.qlog'
    queue_log_dir_path = '/home/secoops/web/UNFOLDED_QUEUE'
    queue_log_path = os.path.join(queue_log_dir_path, queue_log_label)
    queue_log_file = open(queue_log_path, 'w')
    fasta_name = 'T' + sequence_name 
    queue_log_file.write('NAME = ' + fasta_name)
    queue_log_file.write('\nSEQUENCE = ' + fasta_sequence)
    queue_log_file.write('\nEMAIL = ' + email_address)
    queue_log_file.write('\nN_JOBS = ' + num_jobs_str)
    message = 'Your sequence ' + sequence_name + ' has been submitted to the unfolded server. Results will be mailed to ' + email_address + ' as soon as possible'
    email_subject = fasta_name + '_unfolded'
    os.system('echo ' + email_address + ' | mail -s unfolded_job bartolo@uchicago.edu')
    os.system('echo ' + message + ' | mail -s ' + email_subject + ' ' + email_address)
    queue_log_file.close()
    
def rama_server_main(aa0, aa1, aa2, ss0, ss1, ss2, res, date_label):
    
    if res == '5': pickle_path = os.path.join('/home/secoops/web/rama_5x5_pickles', aa0 + aa1 + aa2 + '.pickle')
    elif res == '10': pickle_path = os.path.join('/home/secoops/web/rama_10x10_pickles', aa0 + aa1 + aa2 + '.pickle')
    elif res == '20': pickle_path = os.path.join('/home/secoops/web/rama_pickles', aa0 + aa1 + aa2 + '.pickle')
    gif_path = '/var/www/img/' + date_label + '.gif'
    data_path = '/var/www/user/' + date_label + '.txt'
    log_path = '/var/www/user/' + date_label + '.log'
    rama_contour_plot_PYLAB(ss0, ss1, ss2, res, pickle_path, gif_path, data_path, log_path)
    rama_map_generate_form(date_label, aa0, aa1, aa2, ss0, ss1, ss2, res, 1)
    
def rama_all_main(aa0, aa1, aa2, ss0, ss1, ss2, date_label):
    
    pickle_path = os.path.join('/home/secoops/web/rama_all_pickles', aa0 + aa1 + aa2 + '.pickle')
    gif_path = '/var/www/img/' + date_label + '.gif'
    data_path = '/var/www/user/' + date_label + '.txt'
    log_path = '/var/www/user/' + date_label + '.log'
    rama_contour_plot_PYLAB_all(ss0, ss1, ss2, 10, pickle_path, gif_path, data_path, log_path)
    rama_all_generate_form(date_label, aa0, aa1, aa2, ss0, ss1, ss2, 1)
    
def psi_phi_server_main(aa0, aa1, date_label):

    gif_path = '/var/www/img/' + date_label + '.gif'
    data_path = '/var/www/user/' + date_label + '.txt'
    log_path = '/var/www/user/' + date_label + '.log'
    psi_phi_contour_plot_PYLAB(aa0, aa1, gif_path, data_path, log_path)
    psi_phi_map_generate_form(date_label, aa0, aa1, 1)
    
def general_rama_server_main(aa0, aa1, date_label):

    gif_path = '/var/www/img/' + date_label + '.gif'
    data_path = '/var/www/user/' + date_label + '.txt'
    log_path = '/var/www/user/' + date_label + '.log'
    psi_phi_contour_plot_PYLAB(aa0, aa1, gif_path, data_path, log_path)
    general_rama_map_generate_form(date_label, aa0, aa1, 1)
    
def TSP_hist_plot(tsp_path, label1_path, name):
    
    hibin = array([-6.0, -4.22, -2.44, -0.66, 1.11, 2.88, 4.66, 6.444, 8.22, 10.0])
    hip = array([0.079348, 0.178953, 0.0938, 0.0545, 0.049889, 0.03079, 0.0168998868, 0.0147, 0.0118, 0.03177])
    
    tsp_BFact_path = label1_path + '_tsp_BFact.txt'
    tsp_BFact_file = open(tsp_BFact_path, 'w')
    
    info_lines = readlines(label1_path + '.info')
    
    tsp_file = open(tsp_path, 'r')
    tsp_lines = tsp_file.readlines()
    tsp_file.close()
    tsp_vec = []
    for i in range(len(tsp_lines)):
    if int(info_lines[i].split()[3]) == 0: tsp_vec += [float(tsp_lines[i])]
    tsp_BFact_file.write(str(tsp_BFactor(float(tsp_lines[i]))) + '\n')
    tsp_BFact_file.close()
    
    gif_path = label1_path + '_hist.gif'
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    high_res_vec = pylab.load('/home/secoops/web/haipeng/web/tsp_hist_new.txt')
    h1 = pylab.hist(high_res_vec, normed=1, bins = pylab.linspace(high_res_vec.min() - 1, 10.0, 10))
    h1_0 = h1[0].tolist()
    h1_1 = h1[1].tolist()
    h1_0.append(h1[0][-1])
    h1_1.append(11.0)
    h2 = (pylab.array(h1_0), pylab.array(h1_1))
    h2_vec = density(h2, high_res_vec.min() - 1, 10.0, 100)
    reload(pylab)
    pylab.close()
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'

    pylab.plot(h2_vec[0], h2_vec[1], 'b', label='high-res PDB library', lw=2)
    hist1 = pylab.hist(tsp_vec, normed=1, facecolor='white', edgecolor='black', lw=2, label='_nolegend_')
    pylab.ylim([0.0, 0.25])
    pylab.legend()
    pylab.xlabel('TSP3', fontsize=20)
    pylab.title('histogram of TSP3 for ' + name, fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)

def pyHistogram(data1_path, data2_path, png_path):
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    data1_vec = pylab.load(data1_path)
    data2_vec = pylab.load(data2_path)
    #pylab.hist(data1_vec, normed=1, facecolor='blue', alpha=0.45)
    #pylab.hist(data2_vec, normed=1, facecolor='red', alpha=0.45)
    hist1 = pylab.hist(data1_vec, normed=1, bins = pylab.linspace(-6.0, 10.0, 10), facecolor='blue')
    hist2 = pylab.hist(data2_vec, normed=1, bins = pylab.linspace(-6.0, 10.0, 10), facecolor='red')
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    
    print 'hi res hist (< 0.9)'
    for i in range(10):
    print hist1[0][i], hist1[1][i]
    
    print
    print 'low res hist (> 0.9)'
    for i in range(10):
    print hist2[0][i], hist2[1][i]
    

    pylab.savefig(png_path)
    pylab.close()
    
def pyhist(data_path, png_path):
  
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    data_lines = readlines(data_path)
    dvec = []
    for line in data_lines:
        try: dvec.append(float(line.strip()))
        except: break
    darray = pylab.array(dvec)
    pylab.hist(darray, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.savefig(png_path)
    pylab.close()
    
def superpose_structures(f1_path, f2_path):
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/refine/bin')
    tmp1 = tempfile.mktemp('.txt')
    
    superpose_path = tempfile.mktemp('.pdb')
    
    rmsd_cfg_new_path = tempfile.mktemp('.cfg')
    rmsd_cfg2_new_path = tempfile.mktemp('.cfg')
    rmsd_cfg_new_file = open(rmsd_cfg_new_path, 'w')
    rmsd_cfg_old_file = open('/home/secoops/web/haipeng/refine/cfg/scalc-superpose.cfg', 'r')
    rmsd_cfg_old_lines = rmsd_cfg_old_file.readlines()
    rmsd_cfg_old_file.close()
    for i in range(len(rmsd_cfg_old_lines)):
        rmsd_cfg_new_file.write(rmsd_cfg_old_lines[i].replace('/home/secoops/web/haipeng/refine/cfg/superpose.cfg', rmsd_cfg2_new_path))
    rmsd_cfg_new_file.close()
    
    rmsd_cfg2_new_file = open(rmsd_cfg2_new_path, 'w')
    rmsd_cfg2_old_file = open('/home/secoops/web/haipeng/refine/cfg/superpose.cfg', 'r')
    rmsd_cfg2_old_lines = rmsd_cfg2_old_file.readlines()
    rmsd_cfg2_old_file.close()
    for i in range(len(rmsd_cfg2_old_lines)):
        rmsd_cfg2_new_file.write(rmsd_cfg2_old_lines[i].replace('temp_superpose.pdb', superpose_path))
    rmsd_cfg2_new_file.close()
    
    os.system('/home/secoops/web/haipeng/refine/bin/scalc -cmp -str ' + f1_path + ' -str ' + f2_path + ' -cfg ' + rmsd_cfg_new_path + ' > ' + tmp1)
    os.system('cp ' + superpose_path + ' ' + f2_path)
    os.remove(tmp1)
    os.remove(superpose_path)
    os.remove(rmsd_cfg_new_path)
    os.remove(rmsd_cfg2_new_path)
    os.chdir(current_dir)
    
def RMSD_profile_plot(lpath):
    
    f1_path = lpath + '_1.pdb'
    f2_path = lpath + '_2.pdb'
    gif_path = lpath + '_rmsd_profile.gif'
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/refine/bin')
    profile_path = tempfile.mktemp('.txt')
    os.system('/home/secoops/web/haipeng/refine/bin/scalc -cmp -str ' + f1_path + ' -str ' + f2_path + ' -cfg /home/secoops/web/haipeng/refine/cfg/scalc-superpose_profile.cfg > ' + profile_path)
    profile_file = open(profile_path, 'r')
    lines = profile_file.readlines()
    profile_file.close()
    os.remove(profile_path)
    
    info_lines = readlines(lpath + '_1.info')
    inc = int(len(info_lines) / 10)
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(info_lines)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]

    rmsd_vec = [''] * len(lines)
    for i in range(len(lines)):
    line = lines[i].strip()
    line = line.split()
    rmsd_vec[i] = line[2]
    rmsd_path = tempfile.mktemp('.txt')
    os.system('/home/secoops/web/haipeng/refine/bin/scalc -cmp -str ' + f1_path + ' -str ' + f2_path + ' -cfg /home/secoops/web/haipeng/refine/cfg/scalc-superpose_rmsd.cfg > ' + rmsd_path)
    rmsd_file = open(rmsd_path, 'r')
    rmsd = rmsd_file.readline()
    rmsd_file.close()
    os.remove(rmsd_path)
    rmsd = rmsd.strip()
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['figure.figsize'] = (16, 6)
    pylab.plot(pylab.arange(1, len(rmsd_vec) + 1), rmsd_vec, 'r', lw=2)
    pylab.xticks(pos_vec, label_vec)
    pylab.title(rmsd + ' Angs. rmsd alignment of models', fontsize=20)
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('CA distance (Angstroms)', fontsize=20)

    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    os.chdir(current_dir)

def position_rmsd(f1_path, f2_path):
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/refine/bin')
    profile_path = tempfile.mktemp('.txt')
    os.system('/home/secoops/web/haipeng/refine/bin/scalc -cmp -str ' + f1_path + ' -str ' + f2_path + ' -cfg /home/secoops/web/haipeng/refine/cfg/scalc-superpose_profile.cfg > ' + profile_path)
    lines = readlines(profile_path)
    os.remove(profile_path)
    rmsd_vec = []
    for i in range(len(lines)):
    rmsd_vec.append(float(lines[i].split()[2]))
    os.chdir(current_dir)

    return rmsd_vec
    
def TSP_diff_plot(lpath):
    
    file1_path = lpath + '_1_tsp.txt'
    file2_path = lpath + '_2_tsp.txt'
    tsp_diff_path = lpath + '_tsp_diff.txt'
    tsp_diff_Bfact_path = lpath + '_tsp_diff_BFact.txt'
    gif_path = lpath + '_tsp_diff.gif'
    
    info_lines = readlines(lpath + '_1.info')
    inc = int(len(info_lines) / 10)
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(info_lines)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]
    
    file1 = open(file1_path, 'r')
    file1_lines = file1.readlines()
    l = len(file1_lines)
    file2 = open(file2_path, 'r')
    file2_lines = file2.readlines()
    tsp_diff_file = open(tsp_diff_path, 'w')
    tsp_diff_Bfact_file = open(tsp_diff_Bfact_path, 'w')
    diff_vec = [0.00] * l
    for i in range(l):
    diff_vec[i] = float(file2_lines[i].strip()) - float(file1_lines[i].strip())
    tsp_diff_file.write(str(diff_vec[i]) + '\n')
    tsp_diff_Bfact_file.write(str(tsp_diff_BFactor(diff_vec[i])) + '\n')
    tsp_diff_file.close()
    tsp_diff_Bfact_file.close()
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.bar(pylab.arange(1, len(diff_vec) + 1), diff_vec, color='b')
    pylab.xticks(pos_vec, label_vec)
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('change in TSP3', fontsize=20)
    pylab.title('Change in TSP3 by position', fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def phi_psi_diff_plot(lpath):
    
    file_path = lpath + '_phi_psi_diff.txt'
    gif_path = lpath + '_phi_psi_diff.gif'
    
    info_lines = readlines(lpath + '_1.info')
    inc = int(len(info_lines) / 10)
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(info_lines)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]
    
    file1 = open(file_path, 'r')
    file1_lines = file1.readlines()
    l = len(file1_lines)
    diff_vec = [0.00] * (l - 1)
    for i in range(l - 1):
    diff_vec[i] = float(file1_lines[i].strip())
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.bar(arange(1, len(diff_vec) + 1), diff_vec, color='g')
    pylab.xticks(pos_vec, label_vec)
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('sqrt(phi_diff^2 + psi_diff^2)', fontsize=20)
    pylab.title('Change in phi/psi before and after refinement', fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def TSP_bar_plot(tsp_path, label_path, name):
    
    tsp_file = open(tsp_path, 'r')
    tsp_lines = tsp_file.readlines()
    tsp_file.close()
    tsp_vec = []
    for i in range(len(tsp_lines)): tsp_vec += [float(tsp_lines[i])]
    
    inc = int(len(tsp_vec) / 10)
    
    info_lines = readlines(label_path + '.info')
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(tsp_vec)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]
    
    gif_path = label_path + '_bar.gif'
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['figure.figsize'] = (16, 6)
    pylab.bar(pylab.arange(1, len(tsp_vec) + 1, 1), tsp_vec, color='r')
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('TSP3', fontsize=20)
    pylab.title('TSP3 by position for ' + name, fontsize=20)
    pylab.xticks(pos_vec, label_vec)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def TSP1_bar_plot(tsp_path, label_path, name):
    
    tsp_file = open(tsp_path, 'r')
    tsp_lines = tsp_file.readlines()
    tsp_file.close()
    tsp_vec = []
    for i in range(len(tsp_lines)): tsp_vec += [float(tsp_lines[i])]
    
    inc = int(len(tsp_vec) / 10)
    
    info_lines = readlines(label_path + '.info')
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(tsp_vec)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]
    
    gif_path = label_path + '_bar1.gif'
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['figure.figsize'] = (16, 6)
    pylab.bar(pylab.arange(1, len(tsp_vec) + 1, 1), tsp_vec, color='r')
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('TSP1', fontsize=20)
    pylab.title('TSP1 by position for ' + name, fontsize=20)
    pylab.xticks(pos_vec, label_vec)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def TSP0_bar_plot(tsp_path, label_path, name):
    
    tsp_file = open(tsp_path, 'r')
    tsp_lines = tsp_file.readlines()
    tsp_file.close()
    tsp_vec = []
    for i in range(len(tsp_lines)): tsp_vec += [float(tsp_lines[i])]
    
    inc = int(len(tsp_vec) / 10)
    
    info_lines = readlines(label_path + '.info')
    label_vec = []
    pos_vec = []
    label_vec += [str(info_lines[0].split()[1]) + ('_' * len(info_lines[0].split()[2].strip())) + info_lines[0].split()[2].strip()]
    pos_vec += [int(info_lines[0].split()[0])]
    for i in range(len(tsp_vec)):
    if ((i + 1) % inc) == 0: 
            label_vec += [str(info_lines[i].split()[1]) + ('_' * len(info_lines[i].split()[2].strip())) + info_lines[i].split()[2].strip()]
        pos_vec += [int(info_lines[i].split()[0])]
    
    gif_path = label_path + '_bar0.gif'
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['figure.figsize'] = (16, 6)
    pylab.bar(pylab.arange(1, len(tsp_vec) + 1, 1), tsp_vec, color='r')
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('TSP0', fontsize=20)
    pylab.title('TSP0 by position for ' + name, fontsize=20)
    pylab.xticks(pos_vec, label_vec)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def phi_psi_diff(lpath):
    
    phi1_path = lpath + '_1_phi.txt'
    phi2_path = lpath + '_2_phi.txt'
    psi1_path = lpath + '_1_psi.txt'
    psi2_path = lpath + '_2_psi.txt'
    phi_psi_diff_path = lpath + '_phi_psi_diff.txt'
    
    phi1_file = open(phi1_path, 'r')
    phi1_lines = phi1_file.readlines()
    phi1_file.close()
    
    phi2_file = open(phi2_path, 'r')
    phi2_lines = phi2_file.readlines()
    phi2_file.close()
    
    psi1_file = open(psi1_path, 'r')
    psi1_lines = psi1_file.readlines()
    psi1_file.close()
    
    psi2_file = open(psi2_path, 'r')
    psi2_lines = psi2_file.readlines()
    psi2_file.close()
    
    phi_psi_diff_file = open(phi_psi_diff_path, 'w')
    
    for i in range(len(phi1_lines)):
    phi_diff = abs(float(phi2_lines[i].strip()) - float(phi1_lines[i].strip()))
    psi_diff = abs(float(psi2_lines[i].strip()) - float(psi1_lines[i].strip()))
    if phi_diff > 180.0: phi_diff = 360.0 - phi_diff
    if psi_diff > 180.0: psi_diff = 360.0 - psi_diff
    
    if ((phi_diff ** 2) + (psi_diff ** 2)) > 0:
        diff = math.sqrt((phi_diff ** 2) + (psi_diff ** 2))
    else: diff = 0.0
    phi_psi_diff_file.write(str(diff) + '\n')
    phi_psi_diff_file.close()
    
def BFactorSubstitution(pdb_path, data_out_path, replace_path):
    
    replace_lines = readlines(replace_path)
    replace_vec = []
    for line in replace_lines:
        replace_vec += [line.strip()]
    
    pdb_redo_lines = readlines(pdb_path)
    
    count = -1
    index = 1000000
    pdb_redo_file = open(data_out_path, 'w')
    for line in pdb_redo_lines:
    if line[0:4] == 'ATOM' or (line[0:6] == 'HETATM' and line[17:20] == 'MSE'):
        
        index_new = int(line[24:27].strip()) - 1
        if index_new != index:
        count += 1
        index = index_new
        line_list = list(line)
        replace_str = str(replace_vec[count])[0:min(5, len(str(replace_vec[count])))]
        line_list[60] = ' '
        for j in range(len(replace_str)):
            line_list[61 + j] = replace_str[j]
        
        pdb_redo_file.write(string.join(line_list, ''))
    else: pdb_redo_file.write(line)
    pdb_redo_file.close()
    
def TSP_Energy(pdb_in_path, label_path):
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/web')
    
    #### SET TEMP PATHS ####
    phi_psi_path = tempfile.mktemp('.txt')
    AA_path = tempfile.mktemp('.txt')
    labeling_path = tempfile.mktemp('.txt')
    pdb_path = tempfile.mktemp('.pdb')
    backbone_path = tempfile.mktemp('.txt')
    
    #### SET HARD PATHS ####
    phi_path = label_path + '_phi.txt'
    psi_path = label_path + '_psi.txt'
    tsp_path = label_path + '_tsp.txt'
    tsp_BFact_path = label_path + '_tsp_BFact.txt'
    
    Renumber(1, 1, pdb_in_path, pdb_path)
    phi_psi_list(pdb_in_path, phi_psi_path, AA_path, labeling_path)
    
    backbone_vec = []
    os.system('./backbone ' + pdb_path + ' > ' + backbone_path)
    backbone_file = open(backbone_path, 'r')
    backbone_line = backbone_file.readline()
    while backbone_line:
    backbone_line = backbone_line.split()
    if len(backbone_line) > 2:
        backbone_vec = backbone_vec + [[backbone_line[2], backbone_line[3], backbone_line[4], backbone_line[5]]]
        backbone_line = backbone_file.readline()
    backbone_file.close()
    os.remove(backbone_path)

    list_path = tempfile.mktemp('.list')
    tsp_cfg_new_path = tempfile.mktemp('.cfg')
    tsp_cfg_new_file = open(tsp_cfg_new_path, 'w')
    tsp_cfg_old_file = open('/home/secoops/web/haipeng/web/tsp1-3A.cfg', 'r')
    tsp_cfg_old_lines = tsp_cfg_old_file.readlines()
    tsp_cfg_old_file.close()
    for i in range(6): tsp_cfg_new_file.write(tsp_cfg_old_lines[i])
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-2].replace('phi_psi.txt', phi_psi_path))
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-1].replace('AA.txt', AA_path))
    tsp_cfg_new_file.close()
    
    os.system('nice ./scalc -cfg scalc.cfg -calc libTSP1.so,' + tsp_cfg_new_path + ' -str ' + pdb_path + ' > ' + list_path)
    os.remove(tsp_cfg_new_path)
    
    list_file = open(list_path, 'r')
    list_vec = list_file.readlines()
    
    phi_file = open(phi_path, 'w')
    psi_file = open(psi_path, 'w')
    tsp_file = open(tsp_path, 'w')
    tsp_BFact_file = open(tsp_BFact_path, 'w')
    
    for i in range(len(list_vec) - 1):
    line = list_vec[i].strip()
    line = line.split()
    tsp_file.write(line[1] + '\n')
    phi_file.write(backbone_vec[i][1] + '\n')
    psi_file.write(backbone_vec[i][2] + '\n')
    tsp_BFact_file.write(str(tsp_BFactor(float(line[1]))) + '\n')
    
    list_file.close()
    phi_file.close()
    psi_file.close()
    tsp_file.close()
    tsp_BFact_file.close()

    os.remove(pdb_path)
    os.remove(list_path)
    os.remove(labeling_path)
    os.remove(AA_path)
    os.remove(phi_psi_path)
    
    os.chdir(current_dir)
    
def TSP1_Energy(pdb_in_path, label_path):
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/web')
    
    #### SET TEMP PATHS ####
    phi_psi_path = tempfile.mktemp('.txt')
    AA_path = tempfile.mktemp('.txt')
    labeling_path = tempfile.mktemp('.txt')
    pdb_path = tempfile.mktemp('.pdb')
    backbone_path = tempfile.mktemp('.txt')
    
    #### SET HARD PATHS ####
    phi_path = label_path + '_phi.txt'
    psi_path = label_path + '_psi.txt'
    tsp_path = label_path + '_tsp1.txt'
    tsp_BFact_path = label_path + '_tsp1_BFact.txt'
    
    Renumber(1, 1, pdb_in_path, pdb_path)
    phi_psi_list(pdb_in_path, phi_psi_path, AA_path, labeling_path)
    
    backbone_vec = []
    os.system('./backbone ' + pdb_path + ' > ' + backbone_path)
    backbone_file = open(backbone_path, 'r')
    backbone_line = backbone_file.readline()
    while backbone_line:
    backbone_line = backbone_line.split()
    if len(backbone_line) > 2:
        backbone_vec = backbone_vec + [[backbone_line[2], backbone_line[3], backbone_line[4], backbone_line[5]]]
        backbone_line = backbone_file.readline()
    backbone_file.close()
    os.remove(backbone_path)

    list_path = tempfile.mktemp('.list')
    tsp_cfg_new_path = tempfile.mktemp('.cfg')
    tsp_cfg_new_file = open(tsp_cfg_new_path, 'w')
    tsp_cfg_old_file = open('/home/secoops/web/haipeng/web/tsp1-1.cfg', 'r')
    tsp_cfg_old_lines = tsp_cfg_old_file.readlines()
    tsp_cfg_old_file.close()
    for i in range(6): tsp_cfg_new_file.write(tsp_cfg_old_lines[i])
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-2].replace('phi_psi.txt', phi_psi_path))
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-1].replace('AA.txt', AA_path))
    tsp_cfg_new_file.close()
    
    os.system('nice ./scalc -cfg scalc.cfg -calc libTSP1.so,' + tsp_cfg_new_path + ' -str ' + pdb_path + ' > ' + list_path)
    os.remove(tsp_cfg_new_path)
    
    list_file = open(list_path, 'r')
    list_vec = list_file.readlines()
    
    #phi_file = open(phi_path, 'w')
    #psi_file = open(psi_path, 'w')
    tsp_file = open(tsp_path, 'w')
    #tsp_BFact_file = open(tsp_BFact_path, 'w')
    
    for i in range(len(list_vec) - 1):
    line = list_vec[i].strip()
    line = line.split()
    tsp_file.write(line[1] + '\n')
    #phi_file.write(backbone_vec[i][1] + '\n')
    #psi_file.write(backbone_vec[i][2] + '\n')
    #tsp_BFact_file.write(str(tsp_BFactor(float(line[1]))) + '\n')
    
    list_file.close()
    #phi_file.close()
    #psi_file.close()
    #tsp_file.close()
    #tsp_BFact_file.close()

    os.remove(pdb_path)
    os.remove(list_path)
    os.remove(labeling_path)
    os.remove(AA_path)
    os.remove(phi_psi_path)
    
    os.chdir(current_dir)
    
def TSP0_Energy(pdb_in_path, label_path):
    
    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/web')
    
    #### SET TEMP PATHS ####
    phi_psi_path = tempfile.mktemp('.txt')
    AA_path = tempfile.mktemp('.txt')
    labeling_path = tempfile.mktemp('.txt')
    pdb_path = tempfile.mktemp('.pdb')
    backbone_path = tempfile.mktemp('.txt')
    
    #### SET HARD PATHS ####
    phi_path = label_path + '_phi.txt'
    psi_path = label_path + '_psi.txt'
    tsp_path = label_path + '_tsp0.txt'
    tsp_BFact_path = label_path + '_tsp0_BFact.txt'
    
    Renumber(1, 1, pdb_in_path, pdb_path)
    phi_psi_list(pdb_in_path, phi_psi_path, AA_path, labeling_path)
    
    backbone_vec = []
    os.system('./backbone ' + pdb_path + ' > ' + backbone_path)
    backbone_file = open(backbone_path, 'r')
    backbone_line = backbone_file.readline()
    while backbone_line:
    backbone_line = backbone_line.split()
    if len(backbone_line) > 2:
        backbone_vec = backbone_vec + [[backbone_line[2], backbone_line[3], backbone_line[4], backbone_line[5]]]
        backbone_line = backbone_file.readline()
    backbone_file.close()
    os.remove(backbone_path)

    list_path = tempfile.mktemp('.list')
    tsp_cfg_new_path = tempfile.mktemp('.cfg')
    tsp_cfg_new_file = open(tsp_cfg_new_path, 'w')
    tsp_cfg_old_file = open('/home/secoops/web/haipeng/web/tsp1-0.cfg', 'r')
    tsp_cfg_old_lines = tsp_cfg_old_file.readlines()
    tsp_cfg_old_file.close()
    for i in range(6): tsp_cfg_new_file.write(tsp_cfg_old_lines[i])
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-2].replace('phi_psi.txt', phi_psi_path))
    tsp_cfg_new_file.write(tsp_cfg_old_lines[-1].replace('AA.txt', AA_path))
    tsp_cfg_new_file.close()
    
    os.system('nice ./scalc -cfg scalc.cfg -calc libTSP1.so,' + tsp_cfg_new_path + ' -str ' + pdb_path + ' > ' + list_path)
    os.remove(tsp_cfg_new_path)
    
    list_file = open(list_path, 'r')
    list_vec = list_file.readlines()
    
    #phi_file = open(phi_path, 'w')
    #psi_file = open(psi_path, 'w')
    tsp_file = open(tsp_path, 'w')
    #tsp_BFact_file = open(tsp_BFact_path, 'w')
    
    for i in range(len(list_vec) - 1):
    line = list_vec[i].strip()
    line = line.split()
    tsp_file.write(line[1] + '\n')
    #phi_file.write(backbone_vec[i][1] + '\n')
    #psi_file.write(backbone_vec[i][2] + '\n')
    #tsp_BFact_file.write(str(tsp_BFactor(float(line[1]))) + '\n')
    
    list_file.close()
    #phi_file.close()
    #psi_file.close()
    #tsp_file.close()
    #tsp_BFact_file.close()

    os.remove(pdb_path)
    os.remove(list_path)
    os.remove(labeling_path)
    os.remove(AA_path)
    os.remove(phi_psi_path)
    
    os.chdir(current_dir)
    
def BMK(pdb_path):
    current_dir = os.getcwd()
    os.chdir('/home/secoops/test/clOOPS-0.9.6-BETA1-src/bin')
    bmk_path = tempfile.mktemp('.txt')
    pdbr_path = tempfile.mktemp('.pdb')
    Renumber(1, 1, pdb_path, pdbr_path)
    pdbh_path = tempfile.mktemp('.pdb')
    os.system('./sconv ' + pdbr_path + ' ' + pdbh_path + ' -in /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/io/libPDBread.so -out /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/io/libPDBwrite.so -H')
    os.system('./scalc -cfg /home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/scalc.cfg -calc /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/calc/libEHBOND.so,/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/BMK.cfg -str ' + pdbh_path + ' > ' + bmk_path)
    bmk_lines = readlines(bmk_path)
    os.remove(bmk_path)
    os.remove(pdbh_path)
    os.remove(pdbr_path)
    
    v1 = []
    v1.append(float(bmk_lines[-1].strip()))
    v1.append(int(bmk_lines[-2].strip()))
    return v1

def tot_hbonds(pdb_path):
    current_dir = os.getcwd()
    os.chdir('/home/secoops/test/clOOPS-0.9.6-BETA1-src/bin')
    bmk_path = tempfile.mktemp('.txt')
    os.system('./scalc -cfg /home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/scalc.cfg -calc /home/secoops/test/clOOPS-0.9.6-BETA1-src/bin/calc/libEHBOND.so,/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/cfg/BMK.cfg -str ' + pdb_path + ' > ' + bmk_path)
    bmk_lines = readlines(bmk_path)
    os.remove(bmk_path)
    return int(bmk_lines[-2].strip())
    
def TSP_server_main(lpath, name1, name2, title, server_state):

    TSP_Energy(lpath + '_1.pdb', lpath + '_1')
    TSP_Energy(lpath + '_2.pdb', lpath + '_2')
    TSP1_Energy(lpath + '_1.pdb', lpath + '_1')
    TSP1_Energy(lpath + '_2.pdb', lpath + '_2')
    TSP0_Energy(lpath + '_1.pdb', lpath + '_1')
    TSP0_Energy(lpath + '_2.pdb', lpath + '_2')
    TSP_hist_plot(lpath + '_1_tsp.txt', lpath + '_1', name1)
    TSP_hist_plot(lpath + '_2_tsp.txt', lpath + '_2', name2)
    BMK_contacts(lpath + '_1.pdb', lpath + '_1_bmk.gif', name1)
    BMK_contacts(lpath + '_2.pdb', lpath + '_2_bmk.gif', name2)
    TSP_bar_plot(lpath + '_1_tsp.txt', lpath + '_1', name1)
    TSP_bar_plot(lpath + '_2_tsp.txt', lpath + '_2', name2)
    TSP1_bar_plot(lpath + '_1_tsp1.txt', lpath + '_1', name1)
    TSP1_bar_plot(lpath + '_2_tsp1.txt', lpath + '_2', name2)
    TSP0_bar_plot(lpath + '_1_tsp0.txt', lpath + '_1', name1)
    TSP0_bar_plot(lpath + '_2_tsp0.txt', lpath + '_2', name2)
    TSP_scatterplot(lpath + '_1', name1)
    TSP_scatterplot(lpath + '_2', name2)
    
    superpose_structures(lpath + '_1.pdb', lpath + '_2.pdb')
    RMSD_profile_plot(lpath)
    TSP_diff_plot(lpath)
    phi_psi_diff(lpath)
    phi_psi_diff_plot(lpath)
    
    BFactorSubstitution(lpath + '_1.pdb', lpath + '_tsp_1.pdb', lpath + '_1_tsp_BFact.txt')
    BFactorSubstitution(lpath + '_2.pdb', lpath + '_tsp_2.pdb', lpath + '_2_tsp_BFact.txt')
    BFactorSubstitution(lpath + '_1.pdb', lpath + '_tsp_diff_1.pdb', lpath + '_tsp_diff_BFact.txt')
    BFactorSubstitution(lpath + '_2.pdb', lpath + '_tsp_diff_2.pdb', lpath + '_tsp_diff_BFact.txt')
    BFactorSubstitution(lpath + '_1.pdb', lpath + '_phi_psi_diff_1.pdb', lpath + '_phi_psi_diff.txt')
    BFactorSubstitution(lpath + '_2.pdb', lpath + '_phi_psi_diff_2.pdb', lpath + '_phi_psi_diff.txt')

    root_label = lpath[(lpath.find('www') + 4):len(lpath)]
    num = -1
    s2 = ''
    while True:
        if lpath[num] == 'a' or lpath[num] == 'r': break
        s2 += lpath[num]
        num = num - 1
    ref_num = ''
    for i in range(len(s2)):
        ref_num += s2[len(s2) - i - 1]

    contents_string = rama_comp_str(root_label, name1, name2)
    foot_message = 'problems? send ref. # ' + ref_num + ' to godzilla-help@lists.uchicago.edu'
    if server_state == 0:
        display_page(contents_string, 'Model quality comparision of ' + name1 + ' and ' + name2, foot_message, 'ItFix')
    Make_HTML_fileWEB(title, contents_string, foot_message, lpath + '.html')
    
    
def refinement_table_vec(root_label, name1, name2):
    lpath = '/var/www/' + root_label
    tsp1_path = lpath + '_1_tsp.txt'
    tsp2_path = lpath + '_2_tsp.txt'
    
    pdb1_path = lpath + '_1.pdb'
    pdb2_path = lpath + '_2.pdb'
    hbond1 = BMK(pdb1_path)
    hbond2 = BMK(pdb2_path)
    bmk1 = str(hbond1[0])
    bmk2 = str(hbond2[0])
    hbonds1 = str(hbond1[1])
    hbonds2 = str(hbond2[1])
    
    file = open(tsp1_path, 'r')
    lines1 = file.readlines()
    file.close()
    file = open(tsp2_path, 'r')
    lines2 = file.readlines()
    file.close()
    
    L1 = len(lines1)
    L2 = len(lines2)
    
    table_vec = []
    table_vec += [['model', 'TSP3 per res', '% TSP-favored', '% TSP-allowed', '% TSP-generously<br>allowed', '% TSP-scarce', 'hbond', '# hbonds']]
    table_vec += [[name1 + ' (' + str(L1) + ' res )', '', '', '', '' ,'', bmk1, hbonds1]]
    table_vec += [[name2 + ' (' + str(L2) + ' res )', '', '', '', '' ,'', bmk2, hbonds2]]
    table_vec += [['TSP range', 'N/A', '[-6, 0]', '[0, 5)', '[5, 10)', '10', 'N/A', 'N/A']]
    
    preferred1 = 0
    allowed1 = 0
    disfavored1 = 0
    disallowed1 = 0
    total1 = 0.0
    
    preferred2 = 0
    allowed2 = 0
    disfavored2 = 0
    disallowed2 = 0
    total2 = 0.0
    
    l = len(lines1)
    for i in range(l):
    tsp = float(lines1[i])
    total1 += tsp
    if tsp < 0.0: preferred1 += 1
    elif tsp >= 0.0 and tsp < 5.0: allowed1 += 1
    elif tsp >= 5.0 and tsp < 10.0: disfavored1 += 1
    elif tsp >= 10.0: disallowed1 += 1

    table_vec[1][1] = str(total1 / float(l))[0:min(4, len(str(total1)))]
    table_vec[1][2] = str((float(preferred1) / float(l)) * 100.0)[0:min(5, len(str((float(preferred1) / float(l)))))]
    table_vec[1][3] = str((float(allowed1) / float(l)) * 100.0)[0:min(5, len(str((float(allowed1) / float(l)) * 100.0)))]
    table_vec[1][4] = str((float(disfavored1) / float(l)) * 100.0)[0:min(5, len(str((float(disfavored1) / float(l)) * 100.0)))]
    table_vec[1][5] = str((float(disallowed1) / float(l)) * 100.0)[0:min(5, len(str((float(disallowed1) / float(l)) * 100.0)))]
    
    l = len(lines2)
    for i in range(l):
    tsp = float(lines2[i])
    total2 += tsp
    if tsp < 0.0: preferred2 += 1
    elif tsp >= 0.0 and tsp < 5.0: allowed2 += 1
    elif tsp >= 5.0 and tsp < 10.0: disfavored2 += 1
    elif tsp >= 10.0: disallowed2 += 1

    table_vec[2][1] = str(total2 / float(l))[0:min(4, len(str(total2)))]
    table_vec[2][2] = str((float(preferred2) / float(l)) * 100.0)[0:min(5, len(str((float(preferred2) / float(l)) * 100.0)))]
    table_vec[2][3] = str((float(allowed2) / float(l)) * 100.0)[0:min(5, len(str((float(allowed2) / float(l)) * 100.0)))]
    table_vec[2][4] = str((float(disfavored2) / float(l)) * 100.0)[0:min(5, len(str((float(disfavored2) / float(l)) * 100.0)))]
    table_vec[2][5] = str((float(disallowed2) / float(l)) * 100.0)[0:min(5, len(str((float(disallowed2) / float(l)) * 100.0)))]
    
    return table_vec
    
def HTML_table(title, table_vec):
    
    l = len(table_vec)
    table_str = '<h3>' + title + '</h3>\n<a href=\"http://godzilla.uchicago.edu/pages/refinement_details.html\">(definitions and examples)</a>\n<table border="13">\n'
    for i in range(l):
    row_str = '<tr>\n'
    for j in range(len(table_vec[i])):
        element_str = '<td align="center">' + table_vec[i][j] + '</td>\n'
        row_str += element_str
    row_str += '</tr>\n'
    table_str += row_str
    table_str += '</table>'
    
    return table_str
    
def HTML_table_notitle(table_vec):
    
    l = len(table_vec)
    table_str = '<table border=1>'
    for i in range(l):
    row_str = '<tr>'
    for j in range(len(table_vec[i])):
        element_str = '<td>' + table_vec[i][j] + '</td>'
        row_str += element_str
    row_str += '</tr>'
    table_str += row_str
    table_str += '</table>'
    
    return table_str
    
def Histogram_TSP_data(tsp_dir, out_list_path):
    
    out_list_tsp_path = out_list_path + '_tsp.txt'
    out_list_phi_path = out_list_path + '_phi.txt'
    out_list_psi_path = out_list_path + '_psi.txt'
    out_list_tsp_file = open(out_list_tsp_path, 'w')
    out_list_phi_file = open(out_list_phi_path, 'w')
    out_list_psi_file = open(out_list_psi_path, 'w')
    
    pdb_list = os.listdir(tsp_dir)
    for pdb in pdb_list:
    print pdb
    pdb_in_path = os.path.join(tsp_dir, pdb)
    
        pdb_path = tempfile.mktemp('.pdb')
        Renumber(1, 1, pdb_in_path, pdb_path)
    
        current_dir = os.getcwd()
        os.chdir('/home/secoops/web')
    
        backbone_vec = []
        backbone_path = tempfile.mktemp('.txt')
        os.system('./backbone ' + pdb_path + ' > ' + backbone_path)
        backbone_file = open(backbone_path, 'r')
        backbone_line = backbone_file.readline()
        while backbone_line:
        backbone_line = backbone_line.split()
        if len(backbone_line) > 2:
            backbone_vec = backbone_vec + [[backbone_line[2], backbone_line[3], backbone_line[4], backbone_line[5]]]
            backbone_line = backbone_file.readline()
        backbone_file.close()
        os.remove(backbone_path)
    
        phi_psi_path = 'phi_psi.txt'
        AA_path = 'AA.txt'
        label_path = 'label.txt'
    phi_psi_list(pdb_path, phi_psi_path, AA_path, label_path)
    list_path = tempfile.mktemp('.txt')
    os.system('./scalc -cfg scalc.cfg -calc libTSP1.so,tsp1-3A.cfg -str ' + pdb_path + ' > ' + list_path)
    os.chdir(current_dir)
    
    list_file = open(list_path, 'r')
    list_lines = list_file.readlines()
    list_file.close()
    os.remove(list_path)
    
    for i in range(len(list_lines) - 1):
        line = list_lines[i].strip()
        line = line.split()
        if backbone_vec[i][1] != '0.00':
            out_list_phi_file.write(backbone_vec[i][1] + '\n')
            out_list_psi_file.write(backbone_vec[i][2] + '\n')
            out_list_tsp_file.write(line[1] + '\n')
        
    out_list_tsp_file.close()
    out_list_phi_file.close()
    out_list_psi_file.close()
    
def TSP_scatterplot(label_path, name):
    
    phi_path = label_path + '_phi.txt'
    psi_path = label_path + '_psi.txt'
    tsp_path = label_path + '_tsp.txt'
    gif_path = label_path + '.gif'
    
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['figure.figsize'] = (8, 6)
    phi_data0 = pylab.load(phi_path)
    psi_data0 = pylab.load(psi_path)
    tsp_data0 = pylab.load(tsp_path)
    
    info_lines = readlines(label_path + '.info')
    
    phi_data_path = tempfile.mktemp('.txt')
    psi_data_path = tempfile.mktemp('.txt')
    tsp_data_path = tempfile.mktemp('.txt')
    phi_file = open(phi_data_path, 'w')
    psi_file = open(psi_data_path, 'w')
    tsp_file = open(tsp_data_path, 'w')
    for i in range(len(tsp_data0)):
    if int(info_lines[i].split()[3]) == 0:
        phi_file.write(str(phi_data0[i]) + '\n')
        psi_file.write(str(psi_data0[i]) + '\n')
        tsp_file.write(str(tsp_data0[i]) + '\n')
    phi_file.close()
    psi_file.close()
    tsp_file.close()
    
    phi_data = pylab.load(phi_data_path)
    psi_data = pylab.load(psi_data_path)
    tsp_data = pylab.load(tsp_data_path)
    
    os.remove(phi_data_path)
    os.remove(psi_data_path)
    os.remove(tsp_data_path)
    
    rama_path = '/home/secoops/web/rama.txt'
    rama_file = open(rama_path, 'r')
    rama_data = rama_file.readlines()
    rama_file.close()

    nbins = 36
    rama = numpy.zeros((nbins,nbins),dtype="int")
    nx = pylab.zeros((nbins),dtype="float")
    ny = pylab.zeros((nbins),dtype="float")
    j = 0
    for line in rama_data:
        x = line.split(" ")[:-1]    
        for i in range(0,len(x)):
            rama[j,i] = int(x[i])
            nx[j] = 360.0/nbins*j-180.0
            ny[i] = -360.0/nbins*i+180.0
        j += 1
    pylab.subplot(111,autoscale_on=False)
    pylab.contour(nx,ny,rama,(100,400,1100,5600),origin="upper",linewidths=numpy.array((2,2,2,2),dtype="float"),colors=('red','#ccff88','#aaccdd','blue'))
    
    pylab.scatter(phi_data, psi_data, c=tsp_data,faceted=False,vmin=tsp_data.min(),vmax=tsp_data.max(), s=30)
#    tsp_data_2d = pylab.meshgrid(phi_data, psi_data)
   # pylab.contour(phi_data, psi_data, tsp_data_2d)
    
    pylab.plot([0.0], pylab.arange(-180.0, 180.0), 'k')
    pylab.plot(pylab.arange(-180.0, 180.0), [0.0], 'k')
    
    pylab.xlabel('phi', fontsize=20)
    pylab.ylabel('psi', fontsize=20)
    pylab.xlim(-180.0, 180.0)
    pylab.ylim(-180.0, 180.0)
    pylab.colorbar()
    pylab.title('TSP3 distribution for ' + name, fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def color_scatterplot(data1_path, data2_path, data3_path, name, gif_path):
    
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    data1 = pylab.load(data1_path)
    data2 = pylab.load(data2_path)
    data3 = pylab.load(data3_path)
    
    pylab.scatter(data1, data2, c=data3,faceted=False,vmin=data3.min(),vmax=data3.max())
    pylab.plot([0.0], pylab.arange(-180.0, 180.0), 'k')
    pylab.plot(pylab.arange(-180.0, 180.0), [0.0], 'k')
    
    pylab.xlabel('psi', fontsize=20)
    pylab.ylabel('phi', fontsize=20)
    pylab.ylim(-180.0, 180.0)
    pylab.xlim(-180.0, 180.0)
    pylab.colorbar()
    pylab.title('PSI-PHI map for ' + name, fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
def general_color_scatterplot(data1_path, data2_path, data3_path, name, gif_path):
    
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    data1 = pylab.load(data1_path)
    data2 = pylab.load(data2_path)
    data3 = pylab.load(data3_path)
    
    pylab.scatter(data1, data2, c=data3,faceted=False,vmin=data3.min(),vmax=data3.max())
    
    pylab.xlabel('rmsd', fontsize=20)
    pylab.ylabel('energy', fontsize=20)
    pylab.colorbar()
    pylab.title('Folding scatter plot colored by buried hydrophobes', fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)

def PY_scatterplot(data1_path, data2_path, title, x_label, y_label, gif_path):
    
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '12'
    pylab.rcParams['ytick.labelsize'] = '12'
    data1 = pylab.load(data1_path)
    data2 = pylab.load(data2_path)
    
    pylab.scatter(data1, data2)
    
    pylab.xlabel(x_label, fontsize=12)
    pylab.ylabel(y_label, fontsize=12)

    pylab.title(title, fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def PYLAB_scatterplot(data_path, gif_path):
    
    data_file = open(data_path, 'r')
    lines = data_file.readlines()
    data_file.close()
    
    rmsd = []
    energy = []
    for i in range(len(lines)):
    line = lines[i].strip()
    line = line.split()
    rmsd += [float(line[1])]
    energy += [float(line[2])]
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    x = pylab.array(rmsd)
    y = pylab.array(energy)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.scatter(x, y)
    pylab.ylim(y.min() - 10.0, y.max())
    pylab.xlim(0.0, 15.0)
    #pylab.xlabel('rmsd (angstroms)', fontsize=20)
    #pylab.ylabel('energy', fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 100% ' + gif_path)
    os.remove(png_path)
    
def MakeRamaPlot(list_edit_path, gif_out_path):

    gnu_path = tempfile.mktemp('.gnurama')
    gnu_file = open(gnu_path, 'w')
    
    gnu_line = 'reset\nset terminal gif\nset output \"' + gif_out_path + '\"\nset size ratio -1\nset xr[-180:180]\nset yr[-180:180]\nset xtics 60\nset ytics 60\nset xlabel \"phi\"\nset ylabel \"psi\"\nset title \"Ramachandran plot colored by TSP scores\"\nset pm3d map\nset cbrange[-6:10]\nset cbtics scale 0\nset cblabel \"TSP score\"\nset palette rgbformulae 33,13,10\nsplot \"' + list_edit_path + '\" u ($4):($4 != 0.00 ? $5 : 1/0):($7) w p pt 1 ps 1 palette t \'\''
    
    gnu_file.write(gnu_line)
    gnu_file.close()
    os.system('gnuplot ' + gnu_path)
    os.remove(gnu_path)
    os.system('convert ' + gif_out_path + ' -resize 60% ' + gif_out_path)
    
def process_unfolded():
    
    while ('true' == 'true'):
        find_unfolded_job()
    time.sleep(60)
    
def check_for_running_unfolded_jobs():
    
    max_retry = 1000000
    user_name = 'secoops'
    
    tmp_fn = tempfile.mktemp('.njobs')
    n = 0
    while n <= max_retry:
        n = n + 1

        os.system('qstat | grep ' + user_name + ' | grep submit.sh | wc -l > ' + tmp_fn)

        ifile = open(tmp_fn, 'r')
        line = ifile.readline()
        ifile.close()

        njobs = int(line.strip())

        if njobs < 1:
            os.remove(tmp_fn)
        time.sleep(60)
            return
        else:
            time.sleep(60)
        
def find_unfolded_job():
    
    ####### CHOOSE A JOB FROM THE QUEUE #######
    
    jobs_dir_path = '/home/secoops/web/UNFOLDED_QUEUE'
    current_job_dir_path = '/home/secoops/web/UNFOLDED_CURRENT_JOB'
    
    jobs_dir_list = os.listdir(jobs_dir_path)
    N_jobs = len(jobs_dir_list)
    if N_jobs == 0: return 0
    earliest_time = 100000000000000
    earliest_job = jobs_dir_list[0]
    for job_file in jobs_dir_list:
    job_file_path = os.path.join(jobs_dir_path, job_file)
    tmp_fn = tempfile.mktemp('.timing')
    print 'Checking ' + tmp_fn
    os.system('ls -l ' + job_file_path + " | awk '{print $6}' > " + tmp_fn)
    os.system('ls -l ' + job_file_path + " | awk '{print $7}' >> " + tmp_fn)
    ifile = open(tmp_fn, 'r')
        date = ifile.readline()
    time = ifile.readline()
        ifile.close()
    os.remove(tmp_fn)
    date = date.strip()
    date = date.split('-')
    time = time.strip()
    time = time.split(':')
    total_time = date[0] + date[1] + date[2] + time[0] + time[1]
    if int(total_time) < earliest_time:
        earliest_job = job_file
        earliest_time = int(total_time)
    current_job = os.path.join(jobs_dir_path, earliest_job)
    os.system('mv ' + current_job + ' ' + current_job_dir_path)
    current_job = os.path.join(current_job_dir_path, earliest_job)
    submit_unfolded_job(current_job)
    return 1
    
def process_refine():
    
    while True:
        stat_path = tempfile.mktemp('.txt')
        os.system('qstat | grep \"SERVref\" | wc -l > ' + stat_path)
        stat_file = open(stat_path, 'r')
        n = int(stat_file.readline())
    stat_file.close()
    os.remove(stat_path)
        if n < 25:     
        find_refine_job()
    time.sleep(10)
    print 'Waiting...'
    
def find_refine_job():
    
    ####### CHOOSE A JOB FROM THE QUEUE #######
    
    jobs_dir_path = '/home/secoops/web/REFINE_QUEUE'
    model_dir_path = '/home/secoops/web/REFINE_MODELS'
    current_job_dir_path = '/home/secoops/web/REFINE_CURRENT_JOB'
    
    jobs_dir_list = os.listdir(jobs_dir_path)
    N_jobs = len(jobs_dir_list)
    if N_jobs == 0: return 0
    earliest_time = 100000000000000
    earliest_job = jobs_dir_list[0]
    for job_file in jobs_dir_list:
    job_file_path = os.path.join(jobs_dir_path, job_file)
    tmp_fn = tempfile.mktemp('.timing')
    os.system('ls -l ' + job_file_path + " | awk '{print $6}' > " + tmp_fn)
    os.system('ls -l ' + job_file_path + " | awk '{print $7}' >> " + tmp_fn)
    ifile = open(tmp_fn, 'r')
        date = ifile.readline()
    time = ifile.readline()
        ifile.close()
    os.remove(tmp_fn)
    date = date.strip()
    date = date.split('-')
    time = time.strip()
    time = time.split(':')
    total_time = date[0] + date[1] + date[2] + time[0] + time[1]
    if int(total_time) < earliest_time:
        earliest_job = job_file
        earliest_time = int(total_time)
    current_job = os.path.join(jobs_dir_path, earliest_job)
    os.system('mv ' + current_job + ' ' + current_job_dir_path)
    current_job = os.path.join(current_job_dir_path, earliest_job)
    print 'submitting ' + current_job
    submit_refine_job(current_job)
    return 1
    
def submit_refine_job(current_job):

    name_ext = os.path.split(current_job)[1]
    rand_label = name_ext.split('.')[0]
    print 'Submitting ' + rand_label

    #current_dir = os.getcwd()
    #os.chdir('/home/secoops/web/haipeng/refine')
    #os.system('nohup ./refine_job.py ' + pdb_path + ' ' + name + ' &')
    #os.chdir(current_dir)
    
    os.system('nohup ./build.py -run_refine ' + rand_label + ' &')
    
def submit_unfolded_job(current_job):
    
    ####### CLEAN OUT THE UNFOLDED IN AND OUT DIRECTORIES #######
    current_job_out_name = (os.path.split(current_job)[1]).split('.')[0]
    
    in_dir = '/home/secoops/web/Install/in'
    in_dir_list = os.listdir(in_dir)
    for in_file in in_dir_list:
        in_file_path = os.path.join(in_dir, in_file)
    os.remove(in_file_path)
    
    out_dir = '/home/secoops/web/Install/out'
    out_dir_list = os.listdir(out_dir)
    for out_file in out_dir_list:
        out_file_path = os.path.join(out_dir, out_file)
    os.remove(out_file_path)
    
    ####### SET THE DEFAULT NUMBER OF JOBS  #######
    
    n_jobs_str = '1000'
    
    ####### READ THE CURRENT JOB FILE #######
    
    current_job_file = open(current_job, 'r')
    line = current_job_file.readline()
    while line:
        line = line.strip()
        if line and (line[0] != '#'):
            v = line.split('=')
            var_name = v[0].strip()
            if len(v) == 2: var_value = v[1].strip()
            else: var_value = ''

            if var_name == 'NAME': target_name = var_value
        if var_name == 'SEQUENCE': fasta_sequence = var_value
        if var_name == 'EMAIL': email_address = var_value
        if var_name == 'N_JOBS': n_jobs_str = var_value
        
    line = current_job_file.readline()
    current_job_file.close()
    
    try:
        stripped = int(n_jobs_str)
    except:
        n_jobs_str = '1000'
    
    ####### MAKE THE FASTA FILE #######
    
    fasta_file_name = target_name + '.fasta'
    fasta_file_path = os.path.join(in_dir, fasta_file_name)
    fasta_file = open(fasta_file_path, 'w')
    fasta_sequence.strip()
    fasta_file.write(fasta_sequence + '\n')
    fasta_file.close()
    
    pwd = os.getcwd()
    
    submit_script_path = '/home/secoops/web/Install/submit.sh'
    submit_script = open(submit_script_path, 'w')
    submit_script.write('#!/bin/bash\n./oops -cf RCG.cfg -if in/' + fasta_file_name + ' -of out/' + target_name + '.pdt -ns ' + n_jobs_str + ' -si 1 -ascc -sscc -ssc > /home/secoops/web/Install/log/' + target_name + '.out')
    submit_script.close()
    
    os.chdir('/home/secoops/web/Install')
    os.system('qsub -cwd submit.sh')
    os.chdir(pwd)
    
    check_for_running_unfolded_jobs()
    usr_display_dir = '/var/www/user/' + current_job_out_name
    os.mkdir(usr_display_dir)
    usr_display_html = os.path.join(usr_display_dir, current_job_out_name + '.html')
    usr_display_str = '<H3>Download models here:</H3>\n<a href=\"' + target_name + '.pdt\">' + target_name + ' unfolded state</a><br><br><br>\nPlease cite the following publication:\n<br>Statistical coil model of the unfolded state: Resolving the reconciliation problem.  Abhishek K. Jha, Andres Colubri, Karl F. Freed, and Tobin R. Sosnick.  PNAS  Volume 102, no. 37, September 13, 2005, pages 13099-13104.<br>'
    foot_message = 'problems? contact godzilla-help@lists.uchicago.edu'
    Make_HTML_fileWEB(target_name + ' unfolded state results', usr_display_str, foot_message, usr_display_html)
    os.system('mv /home/secoops/web/Install/out/* ' + usr_display_dir)
    message = 'The results for your submitted sequence, ' + target_name + ', can be downloaded at the following link: http://godzilla.uchicago.edu/user/' + current_job_out_name + '/' + current_job_out_name + '.html'
    email_subject = target_name + '_unfolded'
    os.system('echo ' + message + ' | mail -s ' + email_subject + ' ' + email_address)
    os.system('mv ' + current_job + ' /home/secoops/web/unfolded_job_history/')
    
def update_refine_page(rand_label, stage):
    
    log_path = os.path.join('/home/secoops/web/REFINE_CURRENT_JOB', rand_label + '.qlog')
    
    log_file = open(log_path, 'r')
    line = log_file.readline()
    while line:
    line1 = line.strip()
    line2 = line1.split()
    if line2[0] == 'EMAIL': email_address = line2[2]
    if line2[0] == 'NAME': model_name = line2[2]
    if line2[0] == 'job_type': job_type_flag = int(line2[2])
    if line2[0] == 'mask_ligands': mask_ligands_flag = int(line2[2])
    line = log_file.readline()
    
    log_file.close()
    
    f1_path = os.path.join('/home/secoops/web/REFINE_MODELS', rand_label + '.pdb')
    f2_path = os.path.join('/home/secoops/web/haipeng/refine/in', rand_label + '.pdb')
    name1 = 'starting model'
    name2 = 'refined model'
    
    ed_log_path = os.path.join('/home/secoops/web/REFINE_LOGS_ed', rand_label + '.txt')

    lpath = '/var/www/refine/' + rand_label + '/' + str(stage) + '/' + rand_label
    model_out1_path = lpath + '_1.pdb'
    model_out2_path = lpath + '_2.pdb'
    
    find_chain_breaks(f1_path, lpath + '_1.info')
    find_chain_breaks(f2_path, lpath + '_2.info')
    
    os.system('cp ' + f1_path + ' ' + model_out1_path)
    os.system('cp ' + f2_path + ' ' + model_out2_path)

    TSP_server_main(lpath, name1, name2, 'Stage ' + str(stage) + ' of 3 refinement comparison for ' + model_name, 1)
    
    message = 'Stage ' + str(stage) + ' of 3 of the refinement of ' + model_name + ' is complete. You can view the results at the following page: http://godzilla.uchicago.edu/refine/' + rand_label + '/' + str(stage) + '/' + rand_label + '.html'
    email_subject = model_name + '_refinement'
    os.system('echo ' + message + ' | mail -s ' + email_subject + ' ' + email_address)
    
    if stage == 3:
    if job_type_flag == 0:
        os.mkdir('/var/www/refine/' + rand_label + '/ed')
        lpath = '/var/www/refine/' + rand_label + '/ed/' + rand_label
        density_path = os.path.join('/home/secoops/web/REFINE_REF', rand_label + '.situs')
        initial_pdb_path = os.path.join('/home/secoops/web/REFINE_INITIAL', rand_label + '.pdb')
        top_final_path = os.path.join('/home/secoops/web/TOP_FINAL_MODEL', rand_label + '.pdb')
            os.system('cp ' + model_out2_path + ' ' + top_final_path)
        os.system('/home/jhinshaw/theGreatElectronDensityCaper/runJob.py ' + initial_pdb_path + ' ' + top_final_path + ' ' + density_path + ' ' + str(mask_ligands_flag) + " &> " + ed_log_path)
        
        #time.sleep(100)
        density_out_path = '/home/jhinshaw/theGreatElectronDensityCaper/done/' + rand_label + '.pdb'
        find_chain_breaks(density_out_path, lpath + '_2.info')
        ed2_out_path = lpath + '_2.pdb'
        ed1_out_path = lpath + '_1.pdb'
        os.system('cp ' + f1_path + ' ' + ed1_out_path)
        os.system('cp ' + density_out_path + ' ' + ed2_out_path)
            find_chain_breaks(ed1_out_path, lpath + '_1.info')
            find_chain_breaks(ed2_out_path, lpath + '_2.info')
        TSP_server_main(lpath, name1, name2, 'Density fitting stage results for ' + model_name, 1)
        os.system('cp ' + density_out_path + ' ' + ed2_out_path)
        message = 'Density fitting for ' + model_name + ' is complete. You can view the results at the following page: http://godzilla.uchicago.edu/refine/' + rand_label + '/ed/' + rand_label + '.html'
        email_subject = model_name + '_refinement'
        os.system('echo ' + message + ' | mail -s ' + email_subject + ' ' + email_address)
        
def send_email(email_address, message_path, subject):
    message_file = open(message_path, 'r')
    message = message_file.readline()
    message_file.close()
    os.system('echo ' + message.strip() + ' | mail -s ' + subject + ' ' + email_address)
    
def delta_SecStrProbsPlot(SecStr_path, out_path):
    
    SecStr_file = open(SecStr_path, 'r')
    SecStr_lines = SecStr_file.readlines()
    l = len(SecStr_lines[0].strip())
    SecStr_file.close()
    
    basin_counts = [None] * l
    for i in range(l):
        basin_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]

    basin_probs = [None] * l
    for i in range(l):
        basin_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
    
    for j in range(len(SecStr_lines)):
    line = SecStr_lines[j].strip()
    for i in range(l):
        if line[i] == 'H': basin_counts[i][0] = basin_counts[i][0] + 1
        if line[i] == 'E': basin_counts[i][1] = basin_counts[i][1] + 1
        if line[i] == 'S': basin_counts[i][2] = basin_counts[i][2] + 1
        if line[i] == 'B': basin_counts[i][3] = basin_counts[i][3] + 1
        if line[i] == 'G': basin_counts[i][4] = basin_counts[i][4] + 1
        if line[i] == 'T': basin_counts[i][5] = basin_counts[i][5] + 1
        if line[i] == 'N': basin_counts[i][6] = basin_counts[i][6] + 1

    for i in range(l):
        Total = 0
        for j in range(7):
        Total = Total + basin_counts[i][j]
    basin_counts[i][7] = Total
    
    for i in range(l):
        for j in range(7):
        basin_probs[i][j] = float(basin_counts[i][j]) / float(basin_counts[i][7])
            basin_probs[i][8] = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5]  + basin_probs[i][6]
    

    probs_path = tempfile.mktemp('.probs')
    probsoutfile = open(probs_path, 'w')
    probsoutfile.write('Position H E C\n')
    for i in range(l):
       C_probs = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5] + basin_probs[i][6]
           probsoutfile.write(str(i + 1) + ' ' + str(basin_probs[i][0]) + ' ' + str(basin_probs[i][1]) + ' ' + str(basin_probs[i][8]) + '\n')
    probsoutfile.close()
       
    plot_out_path = tempfile.mktemp('.plot')
    Make_GNU_PLOT_Script_Probs(probs_path, plot_out_path, out_path)
    
    os.remove(probs_path)
    os.remove(plot_out_path)
    
def GetSecseq(SecStr_consensus_path, secseq_path, native_dssp_path, print_stuff, lib_probs_path, new_secseq_path, origins_path, write_secseq):
    
    
    if native_dssp_path != "":
        native_file = open(native_dssp_path, 'r')
        native_line = native_file.readline()
        native_dssp = native_line.strip()
    native_file.close()
    
    if secseq_path != "":
        secseq_file = open(secseq_path, 'r')
        secseq_line = secseq_file.readline()
        secseq_line = secseq_line.strip()
    
        l = len(secseq_line)
        secseq_file.close()
        
        turn_counts = [None] * (l - 1)
        for i in range(l - 1):
            turn_counts[i] = [0, 0]
        
    basin_counts = [None] * l
        for i in range(l):
            basin_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]
        
    origins_counts = [None] * l
        for i in range(l):
            origins_counts[i] = [0, 0, 0, 0, 0, 0, 0, 0]
        
    if SecStr_consensus_path != "":
        ifile = open(SecStr_consensus_path, 'r')
        line = ifile.readline()
        while line:
            line = line.strip()
        for i in range(l):
            if line[i] == 'H': basin_counts[i][0] = basin_counts[i][0] + 1
            if line[i] == 'E': basin_counts[i][1] = basin_counts[i][1] + 1
            if line[i] == 'S': basin_counts[i][2] = basin_counts[i][2] + 1
            if line[i] == 'B': basin_counts[i][3] = basin_counts[i][3] + 1
            if line[i] == 'G': basin_counts[i][4] = basin_counts[i][4] + 1
            if line[i] == 'T': basin_counts[i][5] = basin_counts[i][5] + 1
            if line[i] == 'N': basin_counts[i][6] = basin_counts[i][6] + 1
        for i in range(l - 1):
        if (line[i] == 'T' and line[i + 1] == 'T') or (line[i] == 'S' and line[i + 1] == 'S'):
            turn_counts[i][0] = turn_counts[i][0] + 1
        else: turn_counts[i][1] = turn_counts[i][1] + 1
            
        line = ifile.readline()
        for i in range(l):
            Total = 0
            for j in range(7):
            Total = Total + basin_counts[i][j]
        basin_counts[i][7] = Total

        basin_probs = [None] * l
        for i in range(l):
            basin_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
        
        turn_probs = [0.0] * (l - 1)
    for i in range(l - 1):
        total = turn_counts[i][0] + turn_counts[i][1]
        turn_probs[i] = float(turn_counts[i][0]) / float(total)
        
        for i in range(l):
            for j in range(7):
            basin_probs[i][j] = float(basin_counts[i][j]) / float(basin_counts[i][7])
            basin_probs[i][8] = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5]  + basin_probs[i][6]
        
    if origins_path != "":
        ifile = open(origins_path, 'r')
        line = ifile.readline()
        while line:
            line = line.strip()
        for i in range(l):
            if line[i] == 'H': origins_counts[i][0] = origins_counts[i][0] + 1
            if line[i] == 'E': origins_counts[i][1] = origins_counts[i][1] + 1
            if line[i] == 'S': origins_counts[i][2] = origins_counts[i][2] + 1
            if line[i] == 'B': origins_counts[i][3] = origins_counts[i][3] + 1
            if line[i] == 'G': origins_counts[i][4] = origins_counts[i][4] + 1
            if line[i] == 'T': origins_counts[i][5] = origins_counts[i][5] + 1
            if line[i] == 'N': origins_counts[i][6] = origins_counts[i][6] + 1
            
        line = ifile.readline()
        for i in range(l):
            Total = 0
            for j in range(7):
            Total = Total + origins_counts[i][j]
        origins_counts[i][7] = Total

        origins_probs = [None] * l
        for i in range(l):
            origins_probs[i] = [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
        for i in range(l):
            for j in range(7):
            origins_probs[i][j] = float(origins_counts[i][j]) / float(origins_counts[i][7])
            origins_probs[i][8] = origins_probs[i][2] + origins_probs[i][3] + origins_probs[i][4] + origins_probs[i][5] + origins_probs[i][6]
        
    if lib_probs_path != "":
        ifile = open(lib_probs_path, 'r')
        line = ifile.readline()
        lib_probs = [None] * l
        for i in range(l):
            lib_probs[i] = [0.00, 0.00, 0.00]
        while line:
            line = line.strip()
        line = line.split()
        number = int(line[0]) - 1
        lib_probs[number][0] = float(line[1])
        lib_probs[number][1] = float(line[2])
        lib_probs[number][2] = float(line[3])
        line = ifile.readline()
        
    if secseq_path != "":
        secseq_vec = []
        new_secseq_vec = []
    new_lib_secseq_vec = []
        for i in range(l):
            secseq_vec = secseq_vec + [secseq_line[i]]
        new_secseq_vec = new_secseq_vec + [secseq_line[i]]
        new_lib_secseq_vec = new_lib_secseq_vec + [secseq_line[i]]
        
    if print_stuff == 'Y':
        if SecStr_consensus_path != "":
        for i in range(l):
                print i + 1,
                print 'H: ' + str(basin_probs[i][0]) + '  ',
                print 'E: ' + str(basin_probs[i][1]) + '  ',
                print 'S: ' + str(basin_probs[i][2]) + '  ',
                #print 'B: ' + str(basin_probs[i][3]) + '  ',
                print 'G: ' + str(basin_probs[i][4]) + '  ',
                print 'T: ' + str(basin_probs[i][5]) + '  ',
                print 'N: ' + str(basin_probs[i][6]) + '  '

        #print 'C: ' + str(origins_probs[i][8]) + '  ',

            for i in range(l):
            print str(i + 1),
        print 'H: ' + str(origins_probs[i][0]) + '  ',
        print 'E: ' + str(origins_probs[i][1]) + '  ',
        print 'S: ' + str(origins_probs[i][2]) + '  ',
            print 'B: ' + str(origins_probs[i][3]) + '  ',
            print 'G: ' + str(origins_probs[i][4]) + '  ',
            print 'T: ' + str(origins_probs[i][5]) + '  ',
            print 'N: ' + str(origins_probs[i][6]) + '  '
        
        for i in range(l - 1):
        print i + 1, turn_probs[i], native_dssp[i]
        
        for i in range(l):
        C_probs = basin_probs[i][2] + basin_probs[i][3] + basin_probs[i][4] + basin_probs[i][5] + basin_probs[i][6]
                print i + 1,
                print 'H: ' + str(basin_probs[i][0]) + '  ',
                print 'E: ' + str(basin_probs[i][1]) + '  ',
        #print 'HB ' + str(basin_probs[i][3] + basin_probs[i][1]) + '  ',
        print native_dssp[i] + '  ',
        #C_probs = origins_probs[i][2] + origins_probs[i][3] + origins_probs[i][4] + origins_probs[i][5] + origins_probs[i][6]
        #print 'H: ' + str(origins_probs[i][0]) + '  ',
        print 'H: ' + str(origins_probs[i][0]) + '  ',
                print 'E: ' + str(origins_probs[i][1]) + '  ',
        print 'dE: ' + str(origins_probs[i][1] - lib_probs[i][1]) + '  '
            

    ###################### O CREATION ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(1, l - 1):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] < 0.03):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] < 0.03):
                j = j + 1
            if j > 6:
                for k in range(j):
                        new_secseq_vec[i + k] = 'O'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(1, l - 1):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][1] > 0.0 and origins_probs[i][1] > origins_probs[i][0] and origins_probs[i][1] > origins_probs[i][8] and (origins_probs[i][1] - lib_probs[i][1] > 0.00)):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + 1][1] > 0.0 and origins_probs[i + j][1] > origins_probs[i + j][0] and origins_probs[i + j][1] > origins_probs[i + j][8] and (origins_probs[i + j][1] - lib_probs[i + j][1] > 0.00)):
                j = j + 1
            if j > 3:
                for k in range(j):
                        new_secseq_vec[i + k] = 'O'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and origins_probs[i][1] > 0.50 and (origins_probs[i][1] - lib_probs[i][1] > 0.0)):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and origins_probs[i + j][1] > 0.50 and (origins_probs[i + j][1] - lib_probs[i + j][1] > 0.0)):
                j = j + 1
            if j > 2:
                for k in range(j):
                        new_secseq_vec[i + k] = 'O'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(10, l - 10):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] < 0.05):
            j = 0
            while ((i + j < l - 10) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] < 0.05):
                j = j + 1
            if j > 8:
                for k in range(j - 4):
                        new_secseq_vec[i + 2 + k] = 'O'
            
###################### Q CREATION ############################################################################

    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] > 0.40):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] > 0.40):
                j = j + 1
            if j > 3:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(1, l - 1):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] > 0.15 and (origins_probs[i][1] - lib_probs[i][1] < 0.00)):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] > 0.15 and (origins_probs[i + j][1] - lib_probs[i + j][1] < 0.00)):
                j = j + 1
            if j > 4:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and origins_probs[i][0] > 0.40):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and origins_probs[i + j][0] > 0.40):
                j = j + 1
            if j > 3:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] > 0.10):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] > 0.10):
                j = j + 1
            if j > 8:
                for k in range(j - 8):
                        new_secseq_vec[i + 4 + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][0] > 0.10 and origins_probs[i][0] >= 0.50):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][0] > 0.10 and origins_probs[i + j][0] >= 0.50):
                j = j + 1
            if j > 0:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'A' and basin_probs[i][1] < 0.02 and basin_probs[i][0] > 0.15):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and basin_probs[i + j][1] < 0.02 and basin_probs[i + j][0] > 0.15):
                j = j + 1
            if j > 5:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(1, l - 5):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'A' and secseq_vec[i] == 'Q' and secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'A' and new_secseq_vec[i + 4] == 'A' and basin_probs[i + 4][0] > 0.20):
            new_secseq_vec[i + 4] = 'Q'
        
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(5, l - 1):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i - 1] == 'A' and new_secseq_vec[i] == 'Q' and secseq_vec[i - 1] == 'A' and secseq_vec[i - 2] == 'A' and new_secseq_vec[i - 3] == 'A' and new_secseq_vec[i - 4] == 'A' and basin_probs[i - 4][0] > 0.20):
            new_secseq_vec[i - 4] = 'Q'
        
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(1, l - 5):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'A' and secseq_vec[i] == 'O' and secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'A' and new_secseq_vec[i + 4] == 'A' and basin_probs[i + 4][0] > 0.20):
            new_secseq_vec[i + 4] = 'Q'
        
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(5, l - 1):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'A' and secseq_vec[i] == 'O' and secseq_vec[i - 1] == 'A' and new_secseq_vec[i - 2] == 'A' and new_secseq_vec[i - 3] == 'A' and new_secseq_vec[i - 4] == 'A' and basin_probs[i - 4][0] > 0.20):
            new_secseq_vec[i - 4] = 'Q'    
            
###################### O EXPANSION ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i] == 'A' and secseq_vec[i + 1] == 'O'):
            j = 0
            while (i - j > 0) and new_secseq_vec[i - j] == 'A' and secseq_vec[i - j] == 'A' and (basin_probs[i - j][0] < 0.03):
            j = j + 1
            for k in range(j):
            new_secseq_vec[i - k] = 'O'
        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i] == 'A' and secseq_vec[i - 1] == 'O'):
            j = 0
            while ((i + j) < l - 2) and new_secseq_vec[i + j] == 'A' and secseq_vec[i + j] == 'A' and (basin_probs[i + j][0] < 0.03):
            j = j + 1
            for k in range(j):
            new_secseq_vec[i + k] = 'O'
            
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(10, l - 10):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i + 1] == 'Q' and secseq_vec[i] == 'A' and secseq_vec[i + 1] == 'Q'):
            j = 0
            while (i - j > 0) and new_secseq_vec[i - j] == 'A' and secseq_vec[i - j] == 'A' and basin_probs[i - j][0] < 0.05:
            j = j + 1
            for k in range(j):
            new_secseq_vec[i - k] = 'O'
        
        for i in range(10, l - 10):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i - 1] == 'Q' and secseq_vec[i] == 'A' and secseq_vec[i - 1] == 'Q'):
            j = 0
            while ((i + j) < l - 2) and new_secseq_vec[i + j] == 'A' and secseq_vec[i + j] == 'A' and basin_probs[i + j][0] < 0.05:
            j = j + 1
            for k in range(j):
            new_secseq_vec[i + k] = 'O'
            
###################### Q EXPANSION ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i + 1] == 'Q' and secseq_vec[i + 1] == 'Q'):
            j = 0
            while (i - j > 0) and new_secseq_vec[i - j] == 'A' and (basin_probs[i - j][0] > 0.40 or basin_probs[i - j][5] > 0.30):
            j = j + 1
            for k in range(j):
            new_secseq_vec[i - k] = 'Q'
        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'A' and new_secseq_vec[i - 1] == 'Q' and secseq_vec[i - 1] == 'Q'):
            j = 0
            while ((i + j) < l - 2) and new_secseq_vec[i + j] == 'A' and (basin_probs[i + j][0] > 0.40 or basin_probs[i + j][5] > 0.30):
            j = j + 1
            for k in range(j):
            new_secseq_vec[i + k] = 'Q'
            
###################### E EXPANSION ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'E'):
            j = 0
            while (i - j > 0) and new_secseq_vec[i - j] == 'O' and basin_probs[i - j][1] > 0.40:
            j = j + 1
            for k in range(j):
            new_secseq_vec[i - k] = 'E'
        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'E'):
            j = 0
            while ((i + j) < l - 2) and new_secseq_vec[i + j] == 'O' and basin_probs[i + j][1] > 0.40:
            j = j + 1
            for k in range(j):
            new_secseq_vec[i + k] = 'E'
            
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'E' and secseq_vec[i] == 'E' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O'):
            if basin_probs[i - 1][1] > basin_probs[i + 1][1]: new_secseq_vec[i - 1] = 'E'
        else: new_secseq_vec[i + 1] = 'E'
            
        for i in range(1, l - 3):
            if (new_secseq_vec[i] == 'E' and secseq_vec[i] == 'E' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'E' and secseq_vec[i + 1] == 'E' and new_secseq_vec[i + 2] == 'O' and secseq_vec[i + 2] == 'O'):
            if basin_probs[i - 1][1] > basin_probs[i + 3][1]: new_secseq_vec[i - 1] = 'E'
        else: new_secseq_vec[i + 3] = 'E'
            
###################### FIX HELIX ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        
        for i in range(1, l - 1):
            if new_secseq_vec[i] == 'Q' and secseq_vec[i] == 'Q':
            if basin_probs[i][0] > 0.90:
                    new_secseq_vec[i] = 'H'
        if origins_probs[i][0] < 0.05:
            new_secseq_vec[i] = 'C'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'Q' and basin_probs[i][0] > 0.50):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'Q' and basin_probs[i + j][0] > 0.50):
                j = j + 1
            if j > 4:
                for k in range(j - 4):
                        new_secseq_vec[i + 2 + k] = 'H'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'Q' and origins_probs[i][0] > 0.50):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'Q' and origins_probs[i + j][0] > 0.50):
                j = j + 1
            if j > 4:
                for k in range(j - 4):
                        new_secseq_vec[i + 2 + k] = 'H'
            
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'H' and new_secseq_vec[i - 1] == 'Q' and basin_probs[i][0] > 0.50 and basin_probs[i - 1][0] > 0.50 and basin_probs[i - 2][0] > 0.50):
            new_secseq_vec[i] = 'H'
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        for i in range(1, l - 2):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i - 1] == 'H' and new_secseq_vec[i + 1] == 'Q' and basin_probs[i][0] > 0.50 and basin_probs[i + 1][0] > 0.50 and basin_probs[i + 2][0] > 0.50):
            new_secseq_vec[i] = 'H'
            
###################### FIX COIL ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
        
        for i in range(2, l - 2):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O':
            if origins_probs[i][1] < 0.10:
                    new_secseq_vec[i] = 'C'
            
        for i in range(1, l - 1):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O':
            if origins_probs[i][1] < 0.05 and origins_probs[i - 1][1] < 0.05 and origins_probs[i + 1][1] < 0.05:
                    new_secseq_vec[i] = 'C'
            
    for i in range(1, l - 1):
            if (secseq_vec[i] == 'O' and new_secseq_vec[i] == 'O' and basin_probs[i][5] > 0.25 and secseq_vec[i - 1] != 'C' and secseq_vec[i + 1] != 'C'):
            new_secseq_vec[i] = 'C'
        
    for i in range(10, l - 10):
            if (secseq_vec[i] == 'Q' and new_secseq_vec[i] == 'Q' and secseq_vec[i - 1] == 'Q' and new_secseq_vec[i - 1] == 'Q' and secseq_vec[i + 1] == 'Q' and new_secseq_vec[i + 1] == 'Q' and basin_probs[i][0] < 0.10):
            new_secseq_vec[i] = 'C'
        
        for i in range(8, l - 8):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and (new_secseq_vec[i - 1] == 'O' or new_secseq_vec[i - 1] == 'C') and new_secseq_vec[i + 1] == 'O' and (new_secseq_vec[i + 2] == 'O' or new_secseq_vec[i + 2] == 'C'):
            if turn_probs[i] > 0.45:
                    new_secseq_vec[i] = 'C'
            new_secseq_vec[i + 1] = 'C'

###################### FIX STRAND ############################################################################

    if SecStr_consensus_path != "" and secseq_path != "":
         
    for i in range(3, l - 3):
            if secseq_vec[i] == 'O' and secseq_vec[i - 1] == 'O' and secseq_vec[i - 2] == 'O' and secseq_vec[i - 3] == 'O' and secseq_vec[i + 3] == 'O' and secseq_vec[i + 1] == 'O' and secseq_vec[i + 2] == 'O' and origins_probs[i][1] > 0.50 and origins_probs[i + 1][1] > 0.50 and origins_probs[i + 2][1] > 0.50 and origins_probs[i - 1][1] > 0.50 and origins_probs[i - 2][1] > 0.50: 
            new_secseq_vec[i] = 'E'
        
    if SecStr_consensus_path != "" and secseq_path != "":

        for i in range(1, l - 1):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O':
            if origins_probs[i][1] > 0.90 and origins_probs[i - 1][1] > 0.50 and origins_probs[i + 1][1] > 0.50:
                    new_secseq_vec[i] = 'E'
            
    if SecStr_consensus_path != "" and secseq_path != "":

        for i in range(1, l - 1):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and new_secseq_vec[i - 1] == 'O' and secseq_vec[i - 1] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O':
            if origins_probs[i][1] > 0.70 and origins_probs[i - 1][1] > 0.50 and origins_probs[i + 1][1] > 0.50:
                    new_secseq_vec[i] = 'E'
            
    if SecStr_consensus_path != "" and secseq_path != "":
        for i in range(l):
            if (new_secseq_vec[i] == 'O'):
            j = 0
            while ((i + j < l) and (new_secseq_vec[i + j] == 'O' or new_secseq_vec[i + j] == 'C')):
                j = j + 1
            if j > 11:
                for k in range(j - 8):
            if basin_probs[i + 4 + k][1] > 0.05 and origins_probs[i + 4 + k][1] > 0.33 and (origins_probs[i + 4 + k][1] > lib_probs[i + 4 + k][1] > 0.0):
                j2 = 0
                while (new_secseq_vec[i + 4 + k + j2] == 'O' or new_secseq_vec[i + 4 + k + j2] == 'C') and origins_probs[i + 4 + k + j2][1] > 0.33 and (origins_probs[i + 4 + k + j2][1] > lib_probs[i + 4 + k + j2][1] > 0.0):
                j2 = j2 + 1
                if j2 > 4:
                pos = 0
                max_E = 0.0
                for k2 in range(j2):
                    if origins_probs[i + 4 + k + k2] > max_E:
                    pos = i + 4 + k + k2
                    max_E = origins_probs[i + 4 + k + k2]
                if origins_probs[pos][1] > 0.50 and origins_probs[pos - 1][1] > 0.50 and origins_probs[pos + 1][1] > 0.50:
                    new_secseq_vec[pos] = 'E'
                    
    if SecStr_consensus_path != "" and secseq_path != "":

        for i in range(1, l - 4):
            if new_secseq_vec[i] == 'O' and secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'O' and secseq_vec[i + 1] == 'O' and new_secseq_vec[i + 2] == 'O' and secseq_vec[i + 2] == 'O' and new_secseq_vec[i + 3] == 'O' and secseq_vec[i + 3] == 'O':
            if origins_probs[i][1] > 0.50 and origins_probs[i + 3][1] > 0.50:
            if origins_probs[i + 1][1] > 0.80:
                        new_secseq_vec[i + 1] = 'E'    
            if origins_probs[i + 2][1] > 0.80:
                        new_secseq_vec[i + 2] = 'E'                   
            
###################### Cleanup ############################################################################
        
    if SecStr_consensus_path != "" and secseq_path != "":        
    
        for i in range(1, l - 5):
            if new_secseq_vec[i] == 'A':
                if (new_secseq_vec[i - 1] == 'Q' or new_secseq_vec[i - 1] == 'H') and ((new_secseq_vec[i + 1] == 'Q' or new_secseq_vec[i + 1] == 'H') or (new_secseq_vec[i + 2] == 'Q' or new_secseq_vec[i + 2] == 'H') or (new_secseq_vec[i + 3] == 'Q' or new_secseq_vec[i + 3] == 'H') or (new_secseq_vec[i + 4] == 'Q' or new_secseq_vec[i + 4] == 'H')):
                new_secseq_vec[i] = 'Q'
            
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'A' and new_secseq_vec[i + 4] == 'Q'):
            new_secseq_vec[i + 1] = 'Q'
        new_secseq_vec[i + 2] = 'Q'
        new_secseq_vec[i + 3] = 'Q'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'Q'):
            new_secseq_vec[i + 1] = 'Q'
        new_secseq_vec[i + 2] = 'Q'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'Q'):
            new_secseq_vec[i + 1] = 'Q'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'A' and new_secseq_vec[i + 4] == 'O'):
            new_secseq_vec[i + 1] = 'O'
        new_secseq_vec[i + 2] = 'O'
        new_secseq_vec[i + 3] = 'O'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'A' and new_secseq_vec[i + 3] == 'O'):
            new_secseq_vec[i + 1] = 'O'
        new_secseq_vec[i + 2] = 'O'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'O' and new_secseq_vec[i + 1] == 'A' and new_secseq_vec[i + 2] == 'O'):
            new_secseq_vec[i + 1] = 'O'
        
        for i in range(1, l - 4):
            if (new_secseq_vec[i] == 'Q' and new_secseq_vec[i + 1] == 'H' and new_secseq_vec[i - 1] == 'H'):
            new_secseq_vec[i] = 'H'
            
        for i in range(2, l - 3):
            if new_secseq_vec[i] == 'C' and new_secseq_vec[i + 3] == 'C' and new_secseq_vec[i + 1] != 'C' and new_secseq_vec[i + 2] != 'C':
                new_secseq_vec[i + 1] = 'C'
                new_secseq_vec[i + 2] = 'C'
            
        for i in range(1, l - 3):
            if new_secseq_vec[i] == 'C' and new_secseq_vec[i + 2] == 'C' and new_secseq_vec[i + 1] != 'C':
                new_secseq_vec[i + 1] = 'C'
        
        for i in range(1, l - 3):
            if new_secseq_vec[i] == 'E' and new_secseq_vec[i + 2] == 'E' and new_secseq_vec[i + 1] != 'E':
                new_secseq_vec[i + 1] = 'E'
        
        for i in range(1, l - 5):
            if new_secseq_vec[i] == 'A':
            if (new_secseq_vec[i - 1] == 'O' or new_secseq_vec[i - 1] == 'E' or new_secseq_vec[i - 1] == 'C') and ((new_secseq_vec[i + 1] == 'O' or new_secseq_vec[i + 1] == 'E' or new_secseq_vec[i + 1] == 'C') or (new_secseq_vec[i + 2] == 'O' or new_secseq_vec[i + 2] == 'E' or new_secseq_vec[i + 2] == 'C') or (new_secseq_vec[i + 3] == 'O' or new_secseq_vec[i + 3] == 'E' or new_secseq_vec[i + 3] == 'C') or (new_secseq_vec[i + 4] == 'O' or new_secseq_vec[i + 4] == 'E' or new_secseq_vec[i + 4] == 'C')):
                new_secseq_vec[i] = 'O'
            
        start_tetramer = new_secseq_vec[0] + new_secseq_vec[1] + new_secseq_vec[2] + new_secseq_vec[3]
        end_tetramer = new_secseq_vec[l - 4] + new_secseq_vec[l - 3] + new_secseq_vec[l - 2] + new_secseq_vec[l - 1]
        start_pentamer = new_secseq_vec[0] + new_secseq_vec[1] + new_secseq_vec[2] + new_secseq_vec[3] + new_secseq_vec[4]
        end_pentamer = new_secseq_vec[l - 5] + new_secseq_vec[l - 4] + new_secseq_vec[l - 3] + new_secseq_vec[l - 2] + new_secseq_vec[l - 1]
        if start_tetramer == 'AAAO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        new_secseq_vec[2] = 'O'
        if start_tetramer == 'AAOO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        if start_tetramer == 'AAOA':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
    if start_tetramer == 'AOOO':
        new_secseq_vec[0] = 'O'
        if start_pentamer == 'AAAAO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        new_secseq_vec[2] = 'O'
        new_secseq_vec[3] = 'O'
    if end_tetramer == 'OOOA':
        new_secseq_vec[l - 1] = 'O'
        if end_tetramer == 'OOAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
    if end_tetramer == 'OAAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
        new_secseq_vec[l - 3] = 'O'
    if end_pentamer == 'OAAAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
        new_secseq_vec[l - 3] = 'O'
        new_secseq_vec[l - 4] = 'O'
        if start_tetramer == 'AAAQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
        new_secseq_vec[2] = 'Q'
        if start_pentamer == 'AAAAQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
        new_secseq_vec[2] = 'Q'
        new_secseq_vec[3] = 'Q'
        if start_tetramer == 'AAQQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
    if start_tetramer == 'AQQQ':
        new_secseq_vec[0] = 'Q'
        if end_tetramer == 'QAAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
        new_secseq_vec[l - 3] = 'Q'
        if end_pentamer == 'QAAAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
        new_secseq_vec[l - 3] = 'Q'
        new_secseq_vec[l - 4] = 'Q'
        if end_tetramer == 'QQAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
    if end_tetramer == 'QQQA':
        new_secseq_vec[l - 1] = 'Q'
    if end_tetramer == 'CCCO':
        new_secseq_vec[l - 1] = 'C'
    if end_tetramer == 'CCOO':
        new_secseq_vec[l - 1] = 'C'
        new_secseq_vec[l - 2] = 'C'
            
###################### Print to Screen ############################################################################
            
    if print_stuff == 'Y':
        
        if SecStr_consensus_path != "" and secseq_path != "":
        num_str = '1234567890'
        n = 0
        print_num_str = ''
        while ('true' == 'true'):
        for i in range(len(num_str)):
            print_num_str = print_num_str + num_str[i]
            n = n + 1
            if n == l: break
        if n == l: break
        print print_num_str    
        
        if SecStr_consensus_path != "" and secseq_path != "":
        new_secseq = ''
            for i in range(l):
                new_secseq = new_secseq + new_secseq_vec[i]
        print secseq_line
        print new_secseq
        if SecStr_consensus_path != "" and native_dssp_path != "":
        native_dssp_str = ''
            for i in range(l):
                native_dssp_str = native_dssp_str + native_dssp[i]
        print native_dssp_str
        
###################### Write to file ############################################################################
        
    if new_secseq_path != '' and SecStr_consensus_path != "" and secseq_path != "" and write_secseq == 'Y':
    new_secseq_file = open(new_secseq_path, 'w')
    new_secseq = ''
        for i in range(l):
            new_secseq = new_secseq + new_secseq_vec[i]
    new_secseq_file.write(new_secseq)
    new_secseq_file.close()
    
def Round0_SecStr_prediction(native_dssp_path, SecStr_lib_path):
    
    if native_dssp_path != "":
        native_file = open(native_dssp_path, 'r')
        native_line = native_file.readline()
        native_dssp = native_line.strip()
    native_file.close()
    
    SecStr_lib_file = open(SecStr_lib_path, 'r')
    SecStr_lib_lines = SecStr_lib_file.readlines()
    SecStr_lib_file.close()
    l = len(SecStr_lib_lines)
    SecStr_lib_vec = [None] * l
    for i in range(l): SecStr_lib_vec[i] = [0.00] * 3
    for i in range(l):
    SecStr_lib_line = SecStr_lib_lines[i].split()
    for j in range(3):
        SecStr_lib_vec[i][j] = float(SecStr_lib_line[j + 1])
        
    SecStr_R0_vec = [''] * l
    for i in range(l): SecStr_R0_vec[i] = 'C'
    for i in range(l):
    if SecStr_lib_vec[i][0] > SecStr_lib_vec[i][1] and SecStr_lib_vec[i][0] > SecStr_lib_vec[i][2]: SecStr_R0_vec[i] = 'H'
    if SecStr_lib_vec[i][1] > SecStr_lib_vec[i][0] and SecStr_lib_vec[i][1] > SecStr_lib_vec[i][2]: SecStr_R0_vec[i] = 'E'
    
    SecStr_R0 = ''
    for i in range(l):
    SecStr_R0 = SecStr_R0 + SecStr_R0_vec[i]
    print SecStr_R0
    
    if native_dssp_path != "":
    
    native_SecStr_vec = [''] * l
    for i in range(l):
        if native_dssp[i] == 'E': native_SecStr_vec[i] = 'E'
        elif native_dssp[i] == 'H': native_SecStr_vec[i] = 'H'
        else: native_SecStr_vec[i] = 'C'
    native_SecStr = ''
    for i in range(l): native_SecStr = native_SecStr + native_SecStr_vec[i]
    print native_SecStr
    
    num_correct = 2
    for i in range(1, l - 1):
        if SecStr_R0[i] == native_SecStr[i]: num_correct = num_correct + 1
    print 'accuracy: ' + str(float(num_correct) / float(l))
    print l 
        
def LibProbsSecseq(native_dssp_path, print_stuff, lib_probs_path, new_secseq_path):
    
    if native_dssp_path != "":
        native_file = open(native_dssp_path, 'r')
        native_line = native_file.readline()
        native_dssp = native_line.strip()
    native_file.close()
    
    if lib_probs_path != "":
        ifile = open(lib_probs_path, 'r')
        lines = ifile.readlines()
    l = len(lines)
        lib_probs = [None] * l
        for i in range(l):
            lib_probs[i] = [0.00, 0.00, 0.00]
    count = 0
        for line in lines:
        count = count + 1
            newline = line.strip()
        newline = line.split()
        number = int(newline[0]) - 1
        lib_probs[number][0] = float(newline[1])
        lib_probs[number][1] = float(newline[2])
        lib_probs[number][2] = float(newline[3])
        print count, float(newline[1]), float(newline[2]), float(newline[3])
        
        new_secseq_vec = ['A'] * l
    for i in range(l):
            if (new_secseq_vec[i] == 'A' and lib_probs[i][0] > 0.50):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and lib_probs[i + j][0] > 0.50):
                j = j + 1
            if j > 4:
                for k in range(j):
                        new_secseq_vec[i + k] = 'Q'

    for i in range(l):
            if (new_secseq_vec[i] == 'A' and lib_probs[i][0] > lib_probs[i][1] and lib_probs[i][0] > lib_probs[i][2]):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and lib_probs[i + j][0] > lib_probs[i + j][1] and lib_probs[i + j][0] > lib_probs[i + j][2]):
                j = j + 1
            if j > 12:
                for k in range(j - 4):
                        new_secseq_vec[i + k + 2] = 'Q'
            
    for i in range(l):
            if (new_secseq_vec[i] == 'A' and lib_probs[i][1] > lib_probs[i][0] and lib_probs[i][1] > lib_probs[i][2]):
            j = 0
            while ((i + j < l) and new_secseq_vec[i + j] == 'A' and lib_probs[i + j][1] > lib_probs[i + j][0] and lib_probs[i + j][1] > lib_probs[i + j][2]):
                j = j + 1
            if j > 4:
                for k in range(j):
                        new_secseq_vec[i + k] = 'O'
            
###################### Cleanup ############################################################################
        
    if lib_probs_path != "":        
        start_tetramer = new_secseq_vec[0] + new_secseq_vec[1] + new_secseq_vec[2] + new_secseq_vec[3]
        end_tetramer = new_secseq_vec[l - 4] + new_secseq_vec[l - 3] + new_secseq_vec[l - 2] + new_secseq_vec[l - 1]
        start_pentamer = new_secseq_vec[0] + new_secseq_vec[1] + new_secseq_vec[2] + new_secseq_vec[3] + new_secseq_vec[4]
        end_pentamer = new_secseq_vec[l - 5] + new_secseq_vec[l - 4] + new_secseq_vec[l - 3] + new_secseq_vec[l - 2] + new_secseq_vec[l - 1]
        if start_tetramer == 'AAAO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        new_secseq_vec[2] = 'O'
        if start_tetramer == 'AAOO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        if start_tetramer == 'AAOA':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
    if start_tetramer == 'AOOO':
        new_secseq_vec[0] = 'O'
        if start_pentamer == 'AAAAO':
        new_secseq_vec[0] = 'O'
        new_secseq_vec[1] = 'O'
        new_secseq_vec[2] = 'O'
        new_secseq_vec[3] = 'O'
    if end_tetramer == 'OOOA':
        new_secseq_vec[l - 1] = 'O'
        if end_tetramer == 'OOAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
    if end_tetramer == 'OAAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
        new_secseq_vec[l - 3] = 'O'
    if end_pentamer == 'OAAAA':
        new_secseq_vec[l - 1] = 'O'
        new_secseq_vec[l - 2] = 'O'
        new_secseq_vec[l - 3] = 'O'
        new_secseq_vec[l - 4] = 'O'
        if start_tetramer == 'AAAQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
        new_secseq_vec[2] = 'Q'
        if start_pentamer == 'AAAAQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
        new_secseq_vec[2] = 'Q'
        new_secseq_vec[3] = 'Q'
        if start_tetramer == 'AAQQ':
        new_secseq_vec[0] = 'Q'
        new_secseq_vec[1] = 'Q'
    if start_tetramer == 'AQQQ':
        new_secseq_vec[0] = 'Q'
        if end_tetramer == 'QAAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
        new_secseq_vec[l - 3] = 'Q'
        if end_pentamer == 'QAAAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
        new_secseq_vec[l - 3] = 'Q'
        new_secseq_vec[l - 4] = 'Q'
        if end_tetramer == 'QQAA':
        new_secseq_vec[l - 1] = 'Q'
        new_secseq_vec[l - 2] = 'Q'
    if end_tetramer == 'QQQA':
        new_secseq_vec[l - 1] = 'Q'
    
    
        for i in range(1, l - 5):
            if new_secseq_vec[i] == 'A':
                if (new_secseq_vec[i - 1] == 'Q' or new_secseq_vec[i - 1] == 'H') and ((new_secseq_vec[i + 1] == 'Q' or new_secseq_vec[i + 1] == 'H') or (new_secseq_vec[i + 2] == 'Q' or new_secseq_vec[i + 2] == 'H') or (new_secseq_vec[i + 3] == 'Q' or new_secseq_vec[i + 3] == 'H') or (new_secseq_vec[i + 4] == 'Q' or new_secseq_vec[i + 4] == 'H')):
                new_secseq_vec[i] = 'Q'
    
        for i in range(1, l - 5):
            if new_secseq_vec[i] == 'A':
            if (new_secseq_vec[i - 1] == 'O' or new_secseq_vec[i - 1] == 'E' or new_secseq_vec[i - 1] == 'C') and ((new_secseq_vec[i + 1] == 'O' or new_secseq_vec[i + 1] == 'E' or new_secseq_vec[i + 1] == 'C') or (new_secseq_vec[i + 2] == 'O' or new_secseq_vec[i + 2] == 'E' or new_secseq_vec[i + 2] == 'C') or (new_secseq_vec[i + 3] == 'O' or new_secseq_vec[i + 3] == 'E' or new_secseq_vec[i + 3] == 'C') or (new_secseq_vec[i + 4] == 'O' or new_secseq_vec[i + 4] == 'E' or new_secseq_vec[i + 4] == 'C')):
                new_secseq_vec[i] = 'O'
            
##################### Write to file ############################################################################
        
    if new_secseq_path != '':
    new_secseq_file = open(new_secseq_path, 'w')
    new_secseq = ''
        for i in range(l):
            new_secseq = new_secseq + new_secseq_vec[i]
    new_secseq_file.write(new_secseq)
    new_secseq_file.close()
            
###################### Print to Screen ############################################################################
            
    if print_stuff == 'Y':
        
        if lib_probs_path != "":
        num_str = '1234567890'
        n = 0
        print_num_str = ''
        while ('true' == 'true'):
        for i in range(len(num_str)):
            print_num_str = print_num_str + num_str[i]
            n = n + 1
            if n == l: break
        if n == l: break
        print print_num_str    
        
        if lib_probs_path != "":
        new_secseq = ''
            for i in range(l):
                new_secseq = new_secseq + new_secseq_vec[i]
        print new_secseq
        if native_dssp_path != "":
        native_dssp_str = ''
            for i in range(l):
                native_dssp_str = native_dssp_str + native_dssp[i]
        print native_dssp_str
        
def HomologyAveSubs(sub_matrix_path):
    
    sub_matrix_file = open(sub_matrix_path, 'r')
    sub_matrix_lines = sub_matrix_file.readlines()
    sub_matrix_file.close()
    
    l = len(sub_matrix_lines)
    
    total = 0
    for i in range(l):
    line = sub_matrix_lines[i].strip()
    total = total + len(line)
    print float(total) / float(l)
        
def SecStrAlign(pdt_dir):

    name = os.path.split(pdt_dir)[1]
    SecStr_path = os.path.join(pdt_dir, name + '.SecStrAlign')
    if os.path.exists(SecStr_path): os.remove(SecStr_path)
    SecStr_alignment_file = open(SecStr_path, 'w')
    dir_list = os.listdir(pdt_dir)
    for file in dir_list:
    if os.path.splitext(file)[1] == '.SecStr':
        SecStr_file_path = os.path.join(pdt_dir, file)
        SecStr_file = open(SecStr_file_path, 'r')
        SecStr_lines = SecStr_file.readlines()
        SecStr_file.close()
        l = len(SecStr_lines)
        SecStr_alignment_file.write(SecStr_lines[l - 1])
    SecStr_alignment_file.close()
    
def SecStrAlignFinal(pdb_dir):

    SecStr_path = os.path.join(pdb_dir, 'protein.SecStrAlign')
    print SecStr_path
    if os.path.exists(SecStr_path): os.remove(SecStr_path)
    SecStr_alignment_file = open(SecStr_path, 'w')
    dir_list = os.listdir(pdb_dir)
    for file in dir_list:
    if os.path.splitext(file)[1] == '.pdb':
        SecStr_file_path = os.path.join(pdb_dir, '../' + os.path.splitext(file)[0] + '.SecStr')
        SecStr_file = open(SecStr_file_path, 'r')
        SecStr_lines = SecStr_file.readlines()
        SecStr_file.close()
        l = len(SecStr_lines)
        SecStr_alignment_file.write(SecStr_lines[l - 1])
    SecStr_alignment_file.close()
      
def SplitTrajectory(traj_path, out_dir_path):
    
    traj_file = open(traj_path, 'r')
    traj_line = traj_file.readline()
    name_ext = os.path.split(traj_path)[1]
    name = os.path.splitext(name_ext)[0]
    while traj_line:
    if traj_line[0:5] == 'MODEL':
        number = int(traj_line.split()[1])
        num_str = traj_line.split()[1]
        place_holder = len(num_str)
        num_place_holder = 5 - place_holder
        place_str = ''
        for i in range(num_place_holder): place_str = place_str + '0'
        pdb_out_path = os.path.join(out_dir_path, name + '-' + place_str + str(number) + '.pdb')
        pdb_out_file = open(pdb_out_path, 'w')
        while traj_line[0:6] != 'ENDMDL':
        traj_line = traj_file.readline()
        pdb_out_file.write(traj_line)
        pdb_out_file.close()
    traj_line = traj_file.readline()
        
      
def TrajectoryCluster(traj_path, out_dir_path, out_path):
    
    SplitTrajectory(traj_path, out_dir_path)
    
    in_file_list = os.listdir(out_dir_path)
    pdb_path = os.path.join(out_dir_path, in_file_list[0])
    pdb_file = open(pdb_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
        pdb_line = pdb_line.split()
        if pdb_line[0] == 'ATOM' and pdb_line[2] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    Contacts = [None] * N
    for i in range(N):
        Contacts[i] = [0] * N
    
    cluster_file = open(out_path, 'w')
    cluster_file.write('DATA\t')
    j_start = 0
    for i in range(N):
    for j in range(j_start):
        cluster_file.write(str(i) + '_' + str(j) + '\t')
    j_start = j_start + 1
    cluster_file.write('\n')
    
    for file in in_file_list:
        print file
    cluster_file.write(file + '\t')
        pdb_path = os.path.join(out_dir_path, file)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
    pdb_name = os.path.splitext(file)[0]
    
        PDB_vec = []
        while pdb_line:
            pdb_line = pdb_line.strip()
            pdb_line = pdb_line.split()
            if pdb_line[0] == 'ATOM' and pdb_line[2] == 'CA':
                PDB_vec = PDB_vec + [pdb_line]
        pdb_line = pdb_file.readline()
        
    j_start = 0
        for i in range(N):
        for j in range(j_start):
        value = 0.0
                for k in range(6, 9):
                    value = value + (float(PDB_vec[i][k]) - float(PDB_vec[j][k])) ** 2
                distance = float(math.sqrt(value))
        if distance < 8.00:
            ContactMatrix[i][j] = ContactMatrix[i][j] + 1
            cluster_file.write('1.00' + '\t')
        else: cluster_file.write('0.00' + '\t')
        j_start = j_start + 1
    cluster_file.write('\n')
        pdb_file.close()
    cluster_file.close()
    
def ContactMapComp(model1_path, model2_path, out_path):
    
    ################ MAKE CONTACT MAP #######################
    
    pdb_file = open(model1_path, 'r')
    pdb_line = pdb_file.readline()
    Name_ext = os.path.split(model1_path)[1]
    Name = os.path.splitext(Name_ext)[0]
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    pdb_file.close()
    
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    Contacts = [None] * N
    for i in range(N):
        Contacts[i] = [0] * N
    
    pdb_file = open(model1_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    pdb_file.close()
        
    j_start = 0
    for i in range(N):
    for j in range(j_start, N):
        x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
        y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
        z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
        if distance < 8.00:
        ContactMatrix[i][j] = ContactMatrix[i][j] + 1
    j_start = j_start + 1
    pdb_file.close()
    
    ################ READ NATIVE FILE #######################
    
    pdb_file = open(model2_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()

    j_start = 0
    for i in range(N):
    for j in range(j_start):
        x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
        y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
        z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
            if distance < 8.00:
        ContactMatrix[i][j] = 1
    j_start = j_start + 1
    
    plot_matrix_path = os.path.join(out_path, Name + '-native.cmatrix')
    plot_matrix_file = open(plot_matrix_path, 'w')
    
    for i in range(N):
    for j in range(N):
        plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(ContactMatrix[i][j]) + '\n')
    plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = os.path.join(out_path, Name + '-native-c.gnu')
    gif_out_path = os.path.join(out_path, Name + '.gif')
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, gif_out_path, N, N)
    
def ContactMapCompCB(model1_path, model2_path, out_path):
    
    ################ MAKE CONTACT MAP #######################
    
    pdb_file = open(model1_path, 'r')
    pdb_line = pdb_file.readline()
    Name_ext = os.path.split(model1_path)[1]
    Name = os.path.splitext(Name_ext)[0]
    
    PDB_vec = []
    CB_vec = []
    count = 0
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
        count = count + 1
        CB_vec = CB_vec + [""]
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
        CB_vec[count - 1] = pdb_line
    pdb_line = pdb_file.readline()
    pdb_file.close()
    
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
        
    j_start = 0
    for i in range(N):
    for j in range(j_start, N):
        if CB_vec[i] != "" and CB_vec[j] != "":
            x_diff = (float(CB_vec[i][30:38]) - float(CB_vec[j][30:38])) ** 2
            y_diff = (float(CB_vec[i][38:46]) - float(CB_vec[j][38:46])) ** 2
            z_diff = (float(CB_vec[i][46:54]) - float(CB_vec[j][46:54])) ** 2
                distance = float(math.sqrt(x_diff + y_diff + z_diff))
            if distance < 8.00:
            ContactMatrix[i][j] = ContactMatrix[i][j] + 1
    j_start = j_start + 1
    pdb_file.close()
    
    ################ READ NATIVE FILE #######################
    
    pdb_file = open(model2_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    CB_vec = []
    count = 0
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
        count = count + 1
        CB_vec = CB_vec + [""]
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
        CB_vec[count - 1] = pdb_line
    pdb_line = pdb_file.readline()
    pdb_file.close()
    
    j_start = 0
    for i in range(N):
    for j in range(j_start):
        if CB_vec[i] != "" and CB_vec[j] != "":
            x_diff = (float(CB_vec[i][30:38]) - float(CB_vec[j][30:38])) ** 2
            y_diff = (float(CB_vec[i][38:46]) - float(CB_vec[j][38:46])) ** 2
            z_diff = (float(CB_vec[i][46:54]) - float(CB_vec[j][46:54])) ** 2
                distance = float(math.sqrt(x_diff + y_diff + z_diff))
                if distance < 8.00:
            ContactMatrix[i][j] = 1
    j_start = j_start + 1
    
    plot_matrix_path = os.path.join(out_path, Name + '-native.cmatrix')
    plot_matrix_file = open(plot_matrix_path, 'w')
    
    for i in range(N):
    for j in range(N):
        plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(ContactMatrix[i][j]) + '\n')
    plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = os.path.join(out_path, Name + '-native-c.gnu')
    gif_out_path = os.path.join(out_path, Name + '.gif')
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, gif_out_path, N, N)
    
def ContactFormat(model1_path, out_path):
    
    ################ MAKE CONTACT MAP #######################
    
    pdb_file = open(model1_path, 'r')
    pdb_line = pdb_file.readline()
    Name_ext = os.path.split(model1_path)[1]
    Name = os.path.splitext(Name_ext)[0]
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    pdb_file = open(model1_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
        
    j_start = 0
    for i in range(N):
    for j in range(j_start, N):
        x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
        y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
        z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
        if distance < 6.00:
        ContactMatrix[i][j] = ContactMatrix[i][j] + 1
    j_start = j_start + 1
    pdb_file.close()
    
    plot_matrix_path = os.path.join(out_path, Name + '-native.cmatrix')
    plot_matrix_file = open(plot_matrix_path, 'w')
    
    j_start = 0
    for i in range(N):
    for j in range(j_start, N):
        cd = i - j
        if cd < 0: cd = cd * (-1)
        if cd > 3 and ContactMatrix[i][j] == 1:
            str(ContactMatrix[i][j])
            plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(ContactMatrix[i][j]) + '\n')
    j_start = j_start + 1
    plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = os.path.join(out_path, Name + '-native-c.gnu')
    gif_out_path = os.path.join(out_path, Name + '.gif')
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, gif_out_path, N, N)
    
def ContactMovie(traj_path, model_path, out_path):
    
    tmp_pdb_dir = '/tmp/contact_pdb'
    tmp_gif_dir = '/tmp/contact_gif'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    if os.path.exists(tmp_gif_dir):
        ClearDirectory(tmp_gif_dir)
        os.rmdir(tmp_gif_dir)
    os.mkdir(tmp_pdb_dir)
    os.mkdir(tmp_gif_dir)
    SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)
    for pdb in structure_list:
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
    ContactMapComp(pdb_path, model_path, tmp_gif_dir)
    os.system('gifsicle --delay=20 --loop ' + tmp_gif_dir + '/*.gif > ' + out_path)
    ClearDirectory(tmp_pdb_dir)
    ClearDirectory(tmp_gif_dir)
    os.rmdir(tmp_pdb_dir)
    os.rmdir(tmp_gif_dir)
    
def ContactSequencePlot(traj_path, unit_path, out_path):

    plot_matrix_path = '/tmp/contacts.cmatrix'
    if os.path.exists(plot_matrix_path): os.remove(plot_matrix_path)
    plot_matrix_file = open(plot_matrix_path, 'w')
    unit_vector1 = []
    unit_vector2 = []
    
    unit_file = open(unit_path, 'r')
    unit_lines = unit_file.readlines()
    for i in range(len(unit_lines)):
    if len(unit_lines[i].split()) > 2:
        unit_vector1 = unit_vector1 + [int(unit_lines[i].split()[0]) - 1]
        unit_vector2 = unit_vector2 + [int(unit_lines[i].split()[1]) - 1]

    tmp_pdb_dir = '/tmp/contact_pdb'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    os.mkdir(tmp_pdb_dir)
    SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)
    
    L = len(structure_list)
    SEQ_vec = [None] * L
    for i in range(L): SEQ_vec[i] = len(unit_vector1) * ['']
    
    count = 0
    for pdb in structure_list:
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
        PDB_vec = []
        while pdb_line:
            pdb_line = pdb_line.strip()
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
            PDB_vec = PDB_vec + [pdb_line]
        pdb_line = pdb_file.readline()
        pdb_file.close()
    print_str = ''
    for i in range(len(unit_vector1)):
        x_diff = (float(PDB_vec[unit_vector1[i]][30:38]) - float(PDB_vec[unit_vector2[i]][30:38])) ** 2
        y_diff = (float(PDB_vec[unit_vector1[i]][38:46]) - float(PDB_vec[unit_vector2[i]][38:46])) ** 2
        z_diff = (float(PDB_vec[unit_vector1[i]][46:54]) - float(PDB_vec[unit_vector2[i]][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
        bin = ''
            if distance < 6.00: bin = '1.00'
        else: bin = '0.00'
        print_str = print_str + str(int(float(bin)))
        SEQ_vec[count][i] = bin
    count = count + 1
        print print_str
    for i in range(len(unit_vector1)):
    for j in range(L):
            plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + SEQ_vec[j][i] + '\n')
        plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = '/tmp/contacts.gnu'
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, out_path, len(unit_vector1), L)
    
    os.remove(plot_out_path)
    os.remove(plot_matrix_path)
    ClearDirectory(tmp_pdb_dir)
    os.rmdir(tmp_pdb_dir)
    
def ContactSequencePlotTrajectory(traj_path, unit_path, out_path):

    plot_matrix_path = '/tmp/contacts.cmatrix'
    if os.path.exists(plot_matrix_path): os.remove(plot_matrix_path)
    plot_matrix_file = open(plot_matrix_path, 'w')
    unit_vector = []
    
    unit_file = open(unit_path, 'r')
    unit_lines = unit_file.readlines()
    for i in range(len(unit_lines)):
    if len(unit_lines[i].split()) == 4:
        unit_vector = unit_vector + [[int(unit_lines[i].split()[0]) - 1, int(unit_lines[i].split()[1]) - 1, int(unit_lines[i].split()[2]) - 1, int(unit_lines[i].split()[3]) - 1]]

    tmp_pdb_dir = '/tmp/contact_pdb'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    os.mkdir(tmp_pdb_dir)
    SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)
    
    L = len(structure_list)
    SEQ_vec = [None] * L
    for i in range(L): SEQ_vec[i] = len(unit_vector) * [0]
    
    count = 0
    for pdb in structure_list:
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
        PDB_vec = []
        while pdb_line:
            pdb_line = pdb_line.strip()
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
            PDB_vec = PDB_vec + [pdb_line]
        pdb_line = pdb_file.readline()
        pdb_file.close()

    for i in range(len(unit_vector)):
        for j in range(unit_vector[i][0] - 1, unit_vector[i][1]):
        for k in range(unit_vector[i][2] - 1, unit_vector[i][3]): 
                x_diff = (float(PDB_vec[j][30:38]) - float(PDB_vec[k][30:38])) ** 2
                y_diff = (float(PDB_vec[j][38:46]) - float(PDB_vec[k][38:46])) ** 2
                z_diff = (float(PDB_vec[j][46:54]) - float(PDB_vec[k][46:54])) ** 2
                    distance = float(math.sqrt(x_diff + y_diff + z_diff))
                    if distance < 6.00: SEQ_vec[count][i] = SEQ_vec[count][i] + 1
    count = count + 1
    
    for i in range(L):
    plot_matrix_file.write(str(i + 1) + '\t')
    for j in range(len(unit_vector)):
            plot_matrix_file.write(str(SEQ_vec[i][j]) + '\t')
        plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = '/tmp/contacts.gnu'
    
    Make_GNU_PLOT_Script_MultiLine(plot_matrix_path, plot_out_path, out_path)
    
    os.remove(plot_out_path)
    os.remove(plot_matrix_path)
    ClearDirectory(tmp_pdb_dir)
    os.rmdir(tmp_pdb_dir)
    
def AverageContactSequencePlot(traj_dir_path, unit_path, out_path):

    plot_matrix_path = '/tmp/contacts.cmatrix'
    if os.path.exists(plot_matrix_path): os.remove(plot_matrix_path)
    plot_matrix_file = open(plot_matrix_path, 'w')
    unit_vector1 = []
    unit_vector2 = []
    
    unit_file = open(unit_path, 'r')
    unit_lines = unit_file.readlines()
    for i in range(len(unit_lines)):
    if len(unit_lines[i].split()) > 2:
        unit_vector1 = unit_vector1 + [int(unit_lines[i].split()[0]) - 1]
        unit_vector2 = unit_vector2 + [int(unit_lines[i].split()[1]) - 1]

    tmp_pdb_dir = '/tmp/contact_pdb'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    os.mkdir(tmp_pdb_dir)
    trj_dir_list = os.listdir(traj_dir_path)
    for trj in trj_dir_list:
    traj_path = os.path.join(traj_dir_path, trj)
        SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)
    
    SEQ_vec = [None] * 100
    for i in range(100): SEQ_vec[i] = len(unit_vector1) * [0]
    
    for pdb in structure_list:
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
        PDB_vec = []
        while pdb_line:
            pdb_line = pdb_line.strip()
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
            PDB_vec = PDB_vec + [pdb_line]
        pdb_line = pdb_file.readline()
        pdb_file.close()
    print_str = ''
    count = 0
    for i in range(len(unit_vector1)):
        x_diff = (float(PDB_vec[unit_vector1[i]][30:38]) - float(PDB_vec[unit_vector2[i]][30:38])) ** 2
        y_diff = (float(PDB_vec[unit_vector1[i]][38:46]) - float(PDB_vec[unit_vector2[i]][38:46])) ** 2
        z_diff = (float(PDB_vec[unit_vector1[i]][46:54]) - float(PDB_vec[unit_vector2[i]][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
        bin = ''
            if distance < 8.00: 
        bin = '1.00'
        count = count + 1
        else: bin = '0.00'
        print_str = print_str + str(int(float(bin)))
        
    percent = int((float(count)/float(len(unit_vector1))) * 100.0)
    for i in range(len(unit_vector1)):
        x_diff = (float(PDB_vec[unit_vector1[i]][30:38]) - float(PDB_vec[unit_vector2[i]][30:38])) ** 2
        y_diff = (float(PDB_vec[unit_vector1[i]][38:46]) - float(PDB_vec[unit_vector2[i]][38:46])) ** 2
        z_diff = (float(PDB_vec[unit_vector1[i]][46:54]) - float(PDB_vec[unit_vector2[i]][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
            if distance < 8.00: 
        SEQ_vec[percent][i] = SEQ_vec[percent][i] + 1
    for i in range(len(unit_vector1)):
    for j in range(100):
            plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(SEQ_vec[j][i]) + '\n')
        plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = '/tmp/contacts.gnu'
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, out_path, len(unit_vector1), 100)
    
    os.remove(plot_out_path)
    #os.remove(plot_matrix_path)
    ClearDirectory(tmp_pdb_dir)
    os.rmdir(tmp_pdb_dir)
    
def AveragePathwayPlot(traj_dir_path, unit_path, native_path, out_path):

    unit_vector = []
    
    name = os.path.split(out_path)[1]
    dir_name = os.path.split(out_path)[0]
    name_ext = os.path.splitext(name)[0]
    
    unit_file = open(unit_path, 'r')
    unit_lines = unit_file.readlines()
    for i in range(len(unit_lines)):
    if len(unit_lines[i].split()) == 4:
        unit_vector = unit_vector + [[int(unit_lines[i].split()[0]) - 1, int(unit_lines[i].split()[1]) - 1, int(unit_lines[i].split()[2]) - 1, int(unit_lines[i].split()[3]) - 1, 0]]

    tmp_pdb_dir = 'contact_pdb'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    os.mkdir(tmp_pdb_dir)
    trj_dir_list = os.listdir(traj_dir_path)
    for trj in trj_dir_list:
    traj_path = os.path.join(traj_dir_path, trj)
    file_name = trj.split('.')
    if len(file_name) == 3:
        if file_name[1] == 'pdt' and file_name[2] == 'gz': 
        print "Splitting " + trj
            os.system('gunzip ' + traj_path)
        zip_path = os.path.join(traj_dir_path, file_name[0] + '.' + file_name[1])
                SplitTrajectory(zip_path, tmp_pdb_dir)
            os.system('gzip ' + zip_path)
    #if len(file_name) == 2:
        #if file_name[1] == 'pdt':
        #print "Splitting " + trj
                #SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)
    
    native_file = open(native_path, 'r')
    native_line = native_file.readline()
    
    NATIVE_vec = []
    while native_line:
        native_line = native_line.strip()
    if native_line[0:4] == 'ATOM' and native_line[13:15] == 'CA':
        NATIVE_vec = NATIVE_vec + [native_line]
    native_line = native_file.readline()
    native_file.close()
    
    L = len(NATIVE_vec)
    max_nat_cont = L * L
    
    SEQ_vec = [None] * max_nat_cont
    for i in range(max_nat_cont): SEQ_vec[i] = [None] * len(unit_vector)
    for i in range(max_nat_cont):
        for j in range(len(unit_vector)):
        SEQ_vec[i][j] = [0] * 2
    
    max_count = 0
    pdb_count = 0
    for pdb in structure_list:
    pdb_count = pdb_count + 1
    print "processing " + pdb
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
    SecStr = ReturnDSSP(pdb_path)
    
        PDB_vec = []
        while pdb_line:
            pdb_line = pdb_line.strip()
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
            PDB_vec = PDB_vec + [pdb_line]
        pdb_line = pdb_file.readline()
        pdb_file.close()
    
    count = 0
    for i in range(L):
        for j in range(L):
        x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
            y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
            z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
                distance1 = float(math.sqrt(x_diff + y_diff + z_diff))
            
        x_diff = (float(NATIVE_vec[i][30:38]) - float(NATIVE_vec[j][30:38])) ** 2
            y_diff = (float(NATIVE_vec[i][38:46]) - float(NATIVE_vec[j][38:46])) ** 2
            z_diff = (float(NATIVE_vec[i][46:54]) - float(NATIVE_vec[j][46:54])) ** 2
                distance2 = float(math.sqrt(x_diff + y_diff + z_diff))
        if distance1 < 6.00 and distance2 < 6.00:
            count = count + 1
            
    for i in range(len(unit_vector)):
        SEQ_vec[count][i][1] = SEQ_vec[count][i][1] + 1
    
    if count > max_count: max_count = count
    
    for i in range(len(unit_vector)):
        unit_count = 0
        for j in range(unit_vector[i][0] - 1, unit_vector[i][1]):
        for k in range(unit_vector[i][2] - 1, unit_vector[i][3]):
                x_diff = (float(PDB_vec[j][30:38]) - float(PDB_vec[k][30:38])) ** 2
                y_diff = (float(PDB_vec[j][38:46]) - float(PDB_vec[k][38:46])) ** 2
                z_diff = (float(PDB_vec[j][46:54]) - float(PDB_vec[k][46:54])) ** 2
                    distance = float(math.sqrt(x_diff + y_diff + z_diff))
                    if distance < 6.00: 
            unit_count = unit_count + 1
        if unit_count > 3: SEQ_vec[count][i][0] = SEQ_vec[count][i][0] + 1
            
    if pdb == (structure_list[len(structure_list) - 1]) or pdb_count == 100:
        pdb_count = 0
        plot_matrix_path = os.path.join(dir_name, name_ext + '.cmatrix')
            if os.path.exists(plot_matrix_path): os.remove(plot_matrix_path)
            plot_matrix_file = open(plot_matrix_path, 'w')
            for i in range(max_count + 1):
        cntrl_count = 0
        for j in range(len(unit_vector)):
            if SEQ_vec[i][j][0] > 0: cntrl_count = cntrl_count + 1
        if cntrl_count > 0:
            if max_count > 0:
                    plot_matrix_file.write(str((float(i) / float(max_count)) * 100.00) + '\t')
            else: plot_matrix_file.write(str(0.0) + '\t')
                for j in range(len(unit_vector)):
                print i, j, SEQ_vec[i][j][0], SEQ_vec[i][j][1]
                    if SEQ_vec[i][j][1] > 0:
                plot_matrix_file.write(str(float(SEQ_vec[i][j][0])/float(SEQ_vec[i][j][1])) + '\t')
                    else: plot_matrix_file.write(str(0.0) + '\t')
                    plot_matrix_file.write('\n')
    
            plot_matrix_file.close()
        
        plot_out_path = os.path.join(dir_name, name_ext + '.gnu')
    
            Make_GNU_PLOT_Script_MultiLine(plot_matrix_path, plot_out_path, out_path)
   
        
    ClearDirectory(tmp_pdb_dir)
    os.rmdir(tmp_pdb_dir)
    
def OrderedPathwayPlot(traj_dir_path, unit_path, CB_unit_path, native_path, out_path, tm_out_path):
    
    CB_unit_vector = []
    CB_unit_file = open(CB_unit_path, 'r')
    CB_unit_lines = CB_unit_file.readlines()
    for i in range(len(CB_unit_lines)):
    if len(CB_unit_lines[i].split()) == 4:
        CB_unit_vector = CB_unit_vector + [[int(CB_unit_lines[i].split()[0]) - 1, int(CB_unit_lines[i].split()[1]) - 1, int(CB_unit_lines[i].split()[2]) - 1, int(CB_unit_lines[i].split()[3]) - 1, 0]]
    
    name = os.path.split(out_path)[1]
    dir_name = os.path.split(out_path)[0]
    name_ext = os.path.splitext(name)[0]
    
    unit_vector = []
    unit_file = open(unit_path, 'r')
    unit_lines = unit_file.readlines()
    for i in range(len(unit_lines)):
    if len(unit_lines[i].split()) == 4:
        unit_vector = unit_vector + [[int(unit_lines[i].split()[0]) - 1, int(unit_lines[i].split()[1]) - 1, int(unit_lines[i].split()[2]) - 1, int(unit_lines[i].split()[3]) - 1, 0]]

    tmp_pdb_dir = 'contact_pdb'
    if os.path.exists(tmp_pdb_dir):
        ClearDirectory(tmp_pdb_dir)
        os.rmdir(tmp_pdb_dir)
    os.mkdir(tmp_pdb_dir)
    trj_dir_list = os.listdir(traj_dir_path)
    for trj in trj_dir_list:
    traj_path = os.path.join(traj_dir_path, trj)
    file_name = trj.split('.')
    if len(file_name) == 3:
        if file_name[1] == 'pdt' and file_name[2] == 'gz': 
        print "Splitting " + trj
            os.system('gunzip ' + traj_path)
        zip_path = os.path.join(traj_dir_path, file_name[0] + '.' + file_name[1])
                SplitTrajectory(zip_path, tmp_pdb_dir)
            os.system('gzip ' + zip_path)
    #if len(file_name) == 2:
        #if file_name[1] == 'pdt':
        #print "Splitting " + trj
                #SplitTrajectory(traj_path, tmp_pdb_dir)
    structure_list = os.listdir(tmp_pdb_dir)

    
    SEQ_vec = [None] * 1000
    for i in range(1000): SEQ_vec[i] = [None] * len(unit_vector)
    for i in range(1000):
        for j in range(len(unit_vector)):
        SEQ_vec[i][j] = [0] * 2
        
    TM_vec = [None] * 1000
    for i in range(1000): TM_vec[i] = [0.0, 0.0, 0.0, 0.0, 0.0]
        
    CB_SEQ_vec = [None] * 1000
    for i in range(1000): CB_SEQ_vec[i] = [None] * len(CB_unit_vector)
    for i in range(1000):
        for j in range(len(CB_unit_vector)):
        CB_SEQ_vec[i][j] = [0] * 2
    
    max_count = 0
    pdb_count = 0
    for pdb in structure_list:
    pdb_count = pdb_count + 1
    pdb_path = os.path.join(tmp_pdb_dir, pdb)
        pdb_file = open(pdb_path, 'r')
        pdb_line = pdb_file.readline()
    
        PDB_vec = []
        CB_vec = []
        count = 0
        while pdb_line:
            pdb_line = pdb_line.strip()
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
            PDB_vec = PDB_vec + [pdb_line]
            count = count + 1
            CB_vec = CB_vec + [""]
        if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
            CB_vec[count - 1] = pdb_line
        pdb_line = pdb_file.readline()
        pdb_file.close()
    
    name = pdb.split('.')[0]
    count = int(name.split('-')[2])
    
    for i in range(len(unit_vector)):
        SEQ_vec[count][i][1] = SEQ_vec[count][i][1] + 1
    for i in range(len(CB_unit_vector)):
        CB_SEQ_vec[count][i][1] = CB_SEQ_vec[count][i][1] + 1
        
    tm_score = TMScore(native_path, pdb_path)
    TM_vec[count][0] = TM_vec[count][0] + tm_score
    TM_vec[count][1] = TM_vec[count][1] + 1.0
    if TM_vec[count][1] > 0.0:
        TM_vec[count][2] = TM_vec[count][0] / TM_vec[count][1]
    else: TM_vec[count][2] = 0.0
    TM_vec[count][3] = TM_vec[count][3] + ((tm_score - TM_vec[count][2]) ** 2)
    if TM_vec[count][1] - 1.0 > 0.0:
        TM_vec[count][4] = math.sqrt(TM_vec[count][3] / (TM_vec[count][1] - 1.0))
    else: TM_vec[count][4] = 0.0
    
    if count > max_count: max_count = count
    
    for i in range(len(unit_vector)):
        unit_count = 0
        for j in range(unit_vector[i][0] - 1, unit_vector[i][1]):
        for k in range(unit_vector[i][2] - 1, unit_vector[i][3]):
                x_diff = (float(PDB_vec[j][30:38]) - float(PDB_vec[k][30:38])) ** 2
                y_diff = (float(PDB_vec[j][38:46]) - float(PDB_vec[k][38:46])) ** 2
                z_diff = (float(PDB_vec[j][46:54]) - float(PDB_vec[k][46:54])) ** 2
                    distance = float(math.sqrt(x_diff + y_diff + z_diff))
                    if distance < 6.00: 
            unit_count = unit_count + 1
        if unit_count > 3: SEQ_vec[count][i][0] = SEQ_vec[count][i][0] + 1
        
    for i in range(len(CB_unit_vector)):
        unit_count = 0
        for j in range(CB_unit_vector[i][0] - 1, CB_unit_vector[i][1]):
        for k in range(CB_unit_vector[i][2] - 1, CB_unit_vector[i][3]):
            if CB_vec[j] != "" and CB_vec[k] != "":
                    x_diff = (float(CB_vec[j][30:38]) - float(CB_vec[k][30:38])) ** 2
                    y_diff = (float(CB_vec[j][38:46]) - float(CB_vec[k][38:46])) ** 2
                    z_diff = (float(CB_vec[j][46:54]) - float(CB_vec[k][46:54])) ** 2
                        distance = float(math.sqrt(x_diff + y_diff + z_diff))
                        if distance < 8.00: 
                unit_count = unit_count + 1
        if unit_count > 6: CB_SEQ_vec[count][i][0] = CB_SEQ_vec[count][i][0] + 1

        
    if pdb == (structure_list[len(structure_list) - 1]) or pdb_count == 100:
        pdb_count = 0
        plot_matrix_path = os.path.join(dir_name, name_ext + '.cmatrix')
        tm_matrix_path = os.path.join(dir_name, name_ext + '.tmdata')
            if os.path.exists(plot_matrix_path): os.remove(plot_matrix_path)
        if os.path.exists(tm_matrix_path): os.remove(tm_matrix_path)
            plot_matrix_file = open(plot_matrix_path, 'w')
        tm_matrix_file = open(tm_matrix_path, 'w')
            for i in range(max_count):
        cntrl_count = 0
        tm_matrix_file.write(str(i + 1) + '\t' + str(TM_vec[i][2]) + '\t' + str(TM_vec[i][1]) + '\t' + str(TM_vec[i][4]) + '\n')
        for j in range(len(unit_vector)):
            if SEQ_vec[i][j][0] > 0: cntrl_count = cntrl_count + 1
        for j in range(len(CB_unit_vector)):
            if CB_SEQ_vec[i][j][0] > 0: cntrl_count = cntrl_count + 1
        if cntrl_count > 0:
            if max_count > 0:
                    plot_matrix_file.write(str(i + 1) + '\t')
            else: plot_matrix_file.write(str(0.0) + '\t')
                for j in range(len(unit_vector)):
                    if SEQ_vec[i][j][1] > 0:
                plot_matrix_file.write(str(float(SEQ_vec[i][j][0])/float(SEQ_vec[i][j][1])) + '\t')
                    else: plot_matrix_file.write(str(0.0) + '\t')
                for j in range(len(CB_unit_vector)):
                    if CB_SEQ_vec[i][j][1] > 0:
                plot_matrix_file.write(str(float(CB_SEQ_vec[i][j][0])/float(CB_SEQ_vec[i][j][1])) + '\t')
                    else: plot_matrix_file.write(str(0.0) + '\t')
                    plot_matrix_file.write('\n')
    
            plot_matrix_file.close()
        tm_matrix_file.close()
        
        tm_plot_out_path = os.path.join(dir_name, name_ext + '_tm.gnu')
        Make_GNU_PLOT_Script_MultiLine(tm_matrix_path, tm_plot_out_path, tm_out_path)
        
        plot_out_path = os.path.join(dir_name, name_ext + '.gnu')
    
            Make_GNU_PLOT_Script_MultiLine(plot_matrix_path, plot_out_path, out_path)
   
        
    ClearDirectory(tmp_pdb_dir)
    os.rmdir(tmp_pdb_dir)
    
def RGScatter(pdb_dir, native_path, gif_path):
    
    pdb_list = os.listdir(pdb_dir)
    
    rg_rmsd_plot_out_path = tempfile.mktemp('.rg')
    rg_rmsd_plot_out_file = open(rg_rmsd_plot_out_path, 'w')
    
    for pdb in pdb_list:
    if os.path.splitext(pdb)[1] == '.pdb':
        pdb_path = os.path.join(pdb_dir, pdb)
            tmp_fn1 = tempfile.mktemp('.rmsd')
        os.system('./scalc -cfg ../prj/SECsamplerSC/cfg/scalc.cfg -str ' + native_path + ' -str ' + pdb_path + ' -calc calc/libRMSDcalc.so > ' + tmp_fn1)
            ifile = open(tmp_fn1, 'r')
            rmsd = ifile.readline()
            rmsd = rmsd.strip()
            ifile.close()
        os.remove(tmp_fn1)
        rg = str(RGcalc(pdb_path))
        rg_rmsd_plot_out_file.write(pdb + '\t' + rmsd + '\t' + rg + '\n')
    rg_rmsd_plot_out_file.close()
    
    plot_out_path = '/tmp/RGtempScatter.gnu'
    Make_GNU_PLOT_Script_Scatter(rg_rmsd_plot_out_path, plot_out_path, gif_path)
    
    os.remove(rg_rmsd_plot_out_path)
    os.remove(plot_out_path)
    
def CisStats(pdb_dir):
    
    pdb_list = os.listdir(pdb_dir)
    
    cis_counts = [0] * 200
    
    pdb_count = 0
    for pdb in pdb_list:
    if os.path.splitext(pdb)[1] == '.pdb':
        pdb_count = pdb_count + 1
        pdb_path = os.path.join(pdb_dir, pdb)
            tmp_fn1 = tempfile.mktemp('.rmsd')
        os.system('./backbone ' + pdb_path + ' > ' + tmp_fn1)
            ifile = open(tmp_fn1, 'r')
            backbone_lines = ifile.readlines()
        L = len(backbone_lines)
        for i in range(len(backbone_lines)):
                backbone_line = backbone_lines[i].strip()
        backbone_line = backbone_line.split()
        #print backbone_line[5]
        omega = float(backbone_line[5])
        #print omega
        if (omega > -10.0 and omega <= 0.00) or (omega >= 0.0 and omega < 10.00): cis_counts[i] = cis_counts[i] + 1
        
            ifile.close()
        os.remove(tmp_fn1)
    for i in range(L): print i + 1, float(cis_counts[i]) / float(pdb_count)
    
def AverageContacts(pdb_dir, native_path, gif_out_path):
    
    pdb_list = os.listdir(pdb_dir)
    pdb_path = os.path.join(pdb_dir, pdb_list[0])
    pdb_file = open(pdb_path, 'r')
    pdb_line = pdb_file.readline()
    
    contact_energy_path = os.path.join(pdb_dir, 'protein-contact.energy')
    contact_energy_file = open(contact_energy_path, 'w')
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    pdb_file.close()
        
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    L = len(pdb_list)
    
    for file in pdb_list:
    if os.path.splitext(file)[1] == '.pdb':
            pdb_path = os.path.join(pdb_dir, file)
            pdb_file = open(pdb_path, 'r')
            pdb_line = pdb_file.readline()
    
        pdb_name = os.path.splitext(file)[0]
    
            PDB_vec = []
            while pdb_line:
                pdb_line = pdb_line.strip()
            if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
                PDB_vec = PDB_vec + [pdb_line]
            pdb_line = pdb_file.readline()
        
        j_start = 0
            for i in range(N):
            for j in range(j_start):
                x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
                y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
                z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
                    distance = float(math.sqrt(x_diff + y_diff + z_diff))
            cd = i - j
            if i - j < 0: cd = (-1) * cd
                    if distance < 8.00:
                ContactMatrix[i][j] = ContactMatrix[i][j] + 1
            j_start = j_start + 1
            pdb_file.close()
    
    ################ READ NATIVE FILE #######################
    pdb_file = open(native_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    pdb_file.close()
        

    j_start = 0
    for i in range(N):
    for j in range(j_start):
        x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
        y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
        z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
            distance = float(math.sqrt(x_diff + y_diff + z_diff))
        cd = i - j
        if i - j < 0: cd = (-1) * cd
            if distance < 8.00:
            ContactMatrix[j][i] = L
    j_start = j_start + 1
    
    plot_matrix_path = '/tmp/AverageContactsNew.cmatrix'
    plot_matrix_file = open(plot_matrix_path, 'w')
    
    for i in range(N):
    for j in range(N):
        plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(ContactMatrix[i][j]) + '\n')
    plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = '/tmp/AverageContactsNew.gnu'
    
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, gif_out_path, N, N)
    
def HPContacts(pdb_dir, secseq_path):
    
    pdb_list = os.listdir(pdb_dir)
    pdb_path = os.path.join(pdb_dir, pdb_list[0])
    pdb_file = open(pdb_path, 'r')
    pdb_line = pdb_file.readline()
    
    secseq_file = open(secseq_path, 'r')
    secseq = secseq_file.readline()
    secseq_file.close()
    
    PDB_vec = []
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
    pdb_line = pdb_file.readline()
    pdb_file.close()
        
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    L = len(pdb_list)
    
    num_pdb = 0
    for file in pdb_list:
    if os.path.splitext(file)[1] == '.pdb':
        num_pdb = num_pdb + 1
            pdb_path = os.path.join(pdb_dir, file)
            pdb_file = open(pdb_path, 'r')
            pdb_line = pdb_file.readline()
    
        pdb_name = os.path.splitext(file)[0]
    
            PDB_vec = []
            while pdb_line:
                pdb_line = pdb_line.strip()
            if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
                PDB_vec = PDB_vec + [pdb_line]
            pdb_line = pdb_file.readline()
        
        for i in range(N):
            for j in range(N):
                x_diff = (float(PDB_vec[i][30:38]) - float(PDB_vec[j][30:38])) ** 2
                y_diff = (float(PDB_vec[i][38:46]) - float(PDB_vec[j][38:46])) ** 2
                z_diff = (float(PDB_vec[i][46:54]) - float(PDB_vec[j][46:54])) ** 2
                    distance = float(math.sqrt(x_diff + y_diff + z_diff))
            cd = i - j
            if i - j < 0: cd = (-1) * cd
                    if distance < 8.00:
                ContactMatrix[i][j] = ContactMatrix[i][j] + 1
            pdb_file.close()
        
    for i in range(0, N - 6):
    if secseq[i] == 'E' and secseq[i + 1] == 'E' and secseq[i + 2] == 'E' and secseq[i + 4] == 'O':
        for j in range(i + 6, N - 3):
            if secseq[j] == 'E' and secseq[j + 1] == 'E' and secseq[j + 2] == 'E':
            count = 0
            for k in range(3):
            contact_count = 0
            for l in range(3):
                cd = (i + k) - (j + l)
                if cd < 0: cd = cd * (-1)
                if cd <= 20:
                    if (float(ContactMatrix[i + k][j + l]) / float(num_pdb)) > 0.25:
                        contact_count = contact_count + 1
                    print i + k, j + l
                    break
            if contact_count == 0: break
            else: count = count + 1
            if count == 3:
            start_res = i
            end_res = j + 2
            while ('true' == 'true'):
                start_test = start_res - 1
                end_test = end_res + 1
                cd = end_test - start_test
                if cd < 0: cd = cd * (-1)
                if cd > 20: break
                
                ### TEST START ###
                b_count = 0
                for b in range(j, end_test):
                if (float(ContactMatrix[start_test][j + b]) / float(num_pdb)) > 0.25:
                    b_count = b_count + 1
                    break
                
                 
            
                
            
        
        
    #for j in range(j_start):
        #if (float(ContactMatrix[i][j]) / float(num_pdb)) > 0.25:
        
    
def AverageContactsCB(pdb_dir, native_path, gif_out_path):
    
    pdb_list = os.listdir(pdb_dir)
    pdb_path = os.path.join(pdb_dir, pdb_list[0])
    pdb_file = open(pdb_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    CB_vec = []
    count = 0
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
        count = count + 1
        CB_vec = CB_vec + [""]
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
        CB_vec[count - 1] = pdb_line
    pdb_line = pdb_file.readline()
    pdb_file.close()
        
    N = len(PDB_vec)
        
    ContactMatrix = [None] * N
    for i in range(N):
        ContactMatrix[i] = [0] * N
    
    L = len(pdb_list)
    
    max_contacts = 0
    max_i = 0
    max_j = 0
    
    for file in pdb_list:
    if os.path.splitext(file)[1] == '.pdb':
            pdb_path = os.path.join(pdb_dir, file)
            pdb_file = open(pdb_path, 'r')
            pdb_line = pdb_file.readline()
    
        pdb_name = os.path.splitext(file)[0]
    
            PDB_vec = []
            CB_vec = []
            count = 0
            while pdb_line:
                pdb_line = pdb_line.strip()
            if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
                PDB_vec = PDB_vec + [pdb_line]
                count = count + 1
                CB_vec = CB_vec + [""]
            if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
                CB_vec[count - 1] = pdb_line
            pdb_line = pdb_file.readline()

        j_start = 0
            for i in range(N):
            for j in range(j_start):
            if CB_vec[i] != "" and CB_vec[j] != "":
                    x_diff = (float(CB_vec[i][30:38]) - float(CB_vec[j][30:38])) ** 2
                    y_diff = (float(CB_vec[i][38:46]) - float(CB_vec[j][38:46])) ** 2
                    z_diff = (float(CB_vec[i][46:54]) - float(CB_vec[j][46:54])) ** 2
                        distance = float(math.sqrt(x_diff + y_diff + z_diff))
                cd = i - j
                if i - j < 0: cd = (-1) * cd
                        if distance < 6.00:
                    ContactMatrix[i][j] = ContactMatrix[i][j] + 1
                if ContactMatrix[i][j] > max_contacts and cd > 4:
                max_contacts = ContactMatrix[i][j]
                max_i = i
                max_j = j
            j_start = j_start + 1
            pdb_file.close()
    
    ################ READ NATIVE FILE #######################
    pdb_file = open(native_path, 'r')
    pdb_line = pdb_file.readline()
    
    PDB_vec = []
    CB_vec = []
    count = 0
    while pdb_line:
        pdb_line = pdb_line.strip()
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CA':
        PDB_vec = PDB_vec + [pdb_line]
        count = count + 1
        CB_vec = CB_vec + [""]
    if pdb_line[0:4] == 'ATOM' and pdb_line[13:15] == 'CB':
        CB_vec[count - 1] = pdb_line
    pdb_line = pdb_file.readline()
    pdb_file.close()
        

    j_start = 0
    for i in range(N):
    for j in range(j_start):
        if CB_vec[i] != "" and CB_vec[j] != "":
            x_diff = (float(CB_vec[i][30:38]) - float(CB_vec[j][30:38])) ** 2
            y_diff = (float(CB_vec[i][38:46]) - float(CB_vec[j][38:46])) ** 2
            z_diff = (float(CB_vec[i][46:54]) - float(CB_vec[j][46:54])) ** 2
                distance = float(math.sqrt(x_diff + y_diff + z_diff))
            cd = i - j
            if i - j < 0: cd = (-1) * cd
                if distance < 6.00:
                ContactMatrix[j][i] = max_contacts
    j_start = j_start + 1
    
    plot_matrix_path = os.path.join(pdb_dir, 'AverageContactsNew.cmatrix')
    plot_matrix_file = open(plot_matrix_path, 'w')
    
    for i in range(N):
    for j in range(N):
        plot_matrix_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(ContactMatrix[i][j]) + '\n')
    plot_matrix_file.write('\n')
    
    plot_matrix_file.close()
    plot_out_path = '/tmp/AverageContactsNew.gnu'
    
    Make_GNU_PLOT_Script_Matrix(plot_matrix_path, plot_out_path, gif_out_path, N, N)
    
    #os.remove(plot_matrix_path)
    os.remove(plot_out_path)
    
    print max_i + 1, max_j + 1
    
def RGsort(pdb_dir):
    
    pdb_list = os.listdir(pdb_dir)
    pdb_rg_dir = os.path.join(pdb_dir, '../Final_rg15')
    if not os.path.exists(pdb_rg_dir): os.mkdir(pdb_rg_dir)
    
    pdb_vec = []
    for pdb in pdb_list:
    if os.path.splitext(pdb)[1] == '.pdb':
        pdb_path = os.path.join(pdb_dir, pdb)
        rg = RGcalc(pdb_path)
        if rg < 15.0:
        os.system('cp ' + pdb_path + ' ' + pdb_rg_dir)
    
def OOPS_AA_convert(AA3_str):
    if AA3_str == "ALA": return 0
    if AA3_str == "ARG": return 1
    if AA3_str == "ASN": return 2
    if AA3_str == "ASP": return 3
    if AA3_str == "CYS": return 4
    if AA3_str == "GLN": return 5
    if AA3_str == "GLU": return 6
    if AA3_str == "GLY": return 7
    if AA3_str == "HIS": return 8
    if AA3_str == "ILE": return 9
    if AA3_str == "LEU": return 10
    if AA3_str == "LYS": return 11
    if AA3_str == "MET": return 12
    if AA3_str == "PHE": return 13
    if AA3_str == "PRO": return 14
    if AA3_str == "SER": return 15
    if AA3_str == "THR": return 16
    if AA3_str == "TRP": return 17
    if AA3_str == "TYR": return 18
    if AA3_str == "VAL": return 19
    else: return 0
            
def phi_psi_list(pdb_path, phi_psi_path, AA_path, label_path):
        
    phi_psi_file = open(phi_psi_path, 'w')
    AA_file = open(AA_path, 'w')
    label_file = open(label_path, 'w')

    backbone_path = tempfile.mktemp('.backbone')
    os.system('./backbone ' + pdb_path + ' > ' + backbone_path)
    backbone_file = open(backbone_path, 'r')
    backbone_lines = backbone_file.readlines()
    for i in range(len(backbone_lines)):
    backbone_line = backbone_lines[i].strip()
    backbone_line = backbone_line.split()
    if len(backbone_line) > 2:
        phi_psi_file.write(backbone_line[3] + '\t' + backbone_line[4] + '\n')
        AA_file.write(str(OOPS_AA_convert(backbone_line[2])) + '\n')
        label_file.write(backbone_line[0] + '\t' + backbone_line[1] + '\n')
    phi_psi_file.close()
    backbone_file.close()
    label_file.close()
    AA_file.close()
    os.remove(backbone_path)
    
def TMScore(model1_path, model2_path):
    
    tm_path = tempfile.mktemp('.tm')
    m1_path = tempfile.mktemp('.m1')
    m2_path = tempfile.mktemp('.m2')
    Renumber(1, 1, model1_path, m1_path)
    Renumber(1, 1, model2_path, m2_path)
    os.system('./TMscore ' + m1_path + ' ' + m2_path + ' > ' + tm_path)
    tm_file = open(tm_path, 'r')
    tm_lines = tm_file.readlines()
    
    tm_score = float(tm_lines[16].split()[2])
    tm_file.close()
    os.remove(tm_path)
    os.remove(m1_path)
    os.remove(m2_path)
    return tm_score

def AverageTMScore(pdb_dir_path, native_path):

    pdb_list = os.listdir(pdb_dir_path)
    total_pdb = 0
    tm_total = 0.0
    average_tm = 0.0
    for pdb in pdb_list:
    if pdb.split('.')[1] == 'pdb':
        total_pdb = total_pdb + 1
        pdb_path = os.path.join(pdb_dir_path, pdb)
        tm_total = tm_total + TMScore(pdb_path, native_path)
        average_tm = tm_total / float(total_pdb)
        print average_tm
    return average_tm
    
def TMscoreRMSD(rmsd_energy_path, native_path, rmsd_tm_path):
    
    rmsd_energy_file = open(rmsd_energy_path, 'r')
    rmsd_energy_lines = rmsd_energy_file.readlines()
    rmsd_energy_file.close()
    pdb_dir_path = os.path.split(rmsd_energy_path)[0]
    
    rmsd_tm_file = open(rmsd_tm_path, 'w')
    l = len(rmsd_energy_lines)
    for i in range(l):
    line = rmsd_energy_lines[i]
    energy = line.split()[2]
    pdb = line.split()[0]
        pdb_path = os.path.join(pdb_dir_path, pdb + '.pdb')

    tm_score = str(TMScore(native_path, pdb_path))
    rmsd_tm_file.write(pdb + '\t' + tm_score + '\t' + energy + '\n')
    rmsd_tm_file.close()
    
def NewSecseq(in_dir, write_secseq, print_probs):
    
    name = os.path.split(in_dir)[1]
    old_secseq_path = '../prj/SECsamplerSC/secseq/' + name + '.secseq'
    SecStr_consensus_path = os.path.join(in_dir, 'Final/protein.SecStr')
    origins_path = os.path.join(in_dir, 'Final/protein.SecStrAlign')
    secseq_path = os.path.join(in_dir, name + '.secseq')
    lib_probs_path = os.path.join(in_dir, name + '-1.Library')
    native_dssp_path = '../prj/SECsamplerSC/ToDo/' + name + '.dssp'
    new_secseq_path = '../prj/SECsamplerSC/secseq/' + name + '.secseq'
    GetSecseq(SecStr_consensus_path, secseq_path, native_dssp_path, print_probs, lib_probs_path, new_secseq_path, origins_path, write_secseq)
    
def PredictionStats(rmsd_energy_path):
    
    rmsd_energy_file = open(rmsd_energy_path, 'r')
    rmsd_energy_lines = rmsd_energy_file.readlines()
    rmsd_energy_file.close()
    lowest_energy = 100000.0
    lowest_rmsd = 10000.00
    lowest_energy_rmsd = 0.0
    lowest_rmsd_energy = 100000.00
    lowest_energy_pdb = ""
    lowest_rmsd_pdb = ""
    for line in rmsd_energy_lines:
    energy = float(line.split()[2])
    rmsd = float(line.split()[1])
    pdb = line.split()[0]
    
    if energy < lowest_energy:
        lowest_energy = energy
        lowest_energy_pdb = pdb
        lowest_energy_rmsd = rmsd
        
    if rmsd < lowest_rmsd:
        lowest_rmsd = rmsd
        lowest_rmsd_pdb = pdb
        lowest_rmsd_energy = energy
    print lowest_rmsd_pdb, lowest_rmsd, lowest_rmsd_energy
    print lowest_energy_pdb, lowest_energy_rmsd, lowest_energy
    
    prediction_vec = [None] * 2
    for i in range(2): prediction_vec[i] = [''] * 3
    
    prediction_vec[0][0] = lowest_rmsd_pdb
    prediction_vec[0][1] = str(lowest_rmsd)
    prediction_vec[0][2] = str(lowest_rmsd_energy)
    
    prediction_vec[1][0] = lowest_energy_pdb
    prediction_vec[1][1] = str(lowest_energy_rmsd)
    prediction_vec[1][2] = str(lowest_energy)
    
    return prediction_vec
    
def FASTA_from_structure(pdb_path):
    
    cvec = CA_vec(pdb_path)
    L = len(cvec)
    aa_str = ''
    old_res = 0
    for i in range(L):
    res = int(cvec[i][23:28])
    if res != old_res and res > 0:
        aa_str += AAConvertTS(cvec[i][17:20])
        old_res = res
    
    #name = os.path.split(pdb_path)[1][0:4]
    #out_path = os.path.join(os.path.split(pdb_path)[0], name + '.fasta')
    #out_file = open(out_path, 'w')
    #out_file.write('> ' + name + '\n' + aa_str)
    #out_file.close()
    
    return aa_str
        
def PDB_from_structure(pdb_path, out_path):
    
    PDB_vec = []
    lines = readlines(pdb_path)
    N_old = -1
    CA_old = -1
    CB_old = -1
    C_old = -1
    O_old = -1
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15].strip() == 'CA' and int(line[23:28]) > CA_old:
        PDB_vec += [line]
        CA_old = int(line[23:28])
        if line[13:15].strip() == 'N' and int(line[23:28]) > N_old:
        PDB_vec += [line]
        N_old = int(line[23:28])
        if line[13:15].strip() == 'CB' and int(line[23:28]) > CB_old:
        PDB_vec += [line]
        CB_old = int(line[23:28])
        if line[13:15].strip() == 'C' and int(line[23:28]) > C_old:
        PDB_vec += [line]
        C_old = int(line[23:28])
        if line[13:15].strip() == 'O' and int(line[23:28]) > O_old:
        PDB_vec += [line]
        O_old = int(line[23:28])
        
    out_file = open(out_path, 'w')
    for i in range(len(PDB_vec)):
    out_file.write(PDB_vec[i])
    out_file.close()
    
def AAConvertTS(aaT):
    if aaT == 'ALA': return 'A'
    elif aaT == 'ARG': return 'R'
    elif aaT == 'ASN': return 'N'
    elif aaT == 'ASP': return 'D'
    elif aaT == 'CYS': return 'C'
    elif aaT == 'GLN': return 'Q'
    elif aaT == 'GLU': return 'E'
    elif aaT == 'GLY': return 'G'
    elif aaT == 'HIS': return 'H'
    elif aaT == 'ILE': return 'I'
    elif aaT == 'LEU': return 'L'
    elif aaT == 'LYS': return 'K'
    elif aaT == 'MET': return 'M'
    elif aaT == 'PHE': return 'F'
    elif aaT == 'PRO': return 'P'
    elif aaT == 'SER': return 'S'
    elif aaT == 'THR': return 'T'
    elif aaT == 'TRP': return 'W'
    elif aaT == 'TYR': return 'Y'
    elif aaT == 'VAL': return 'V'
    else: return 'X'
    
def AAConvertST(aaS):
    if aaS == 'A': return 'ALA'
    if aaS == 'R': return 'ARG'
    if aaS == 'N': return 'ASN'
    if aaS == 'D': return 'ASP'
    if aaS == 'C': return 'CYS'
    if aaS == 'Q': return 'GLN'
    if aaS == 'E': return 'GLU'
    if aaS == 'G': return 'GLY'
    if aaS == 'H': return 'HIS'
    if aaS == 'I': return 'ILE'
    if aaS == 'L': return 'LEU'
    if aaS == 'K': return 'LYS'
    if aaS == 'M': return 'MET'
    if aaS == 'F': return 'PHE'
    if aaS == 'P': return 'PRO'
    if aaS == 'S': return 'SER'
    if aaS == 'T': return 'THR'
    if aaS == 'W': return 'TRP'
    if aaS == 'Y': return 'TYR'
    if aaS == 'V': return 'VAL'
              
def QSUB_DOPE_SPEED(fasta_path, alignment_path, out_dir):
                 
    name = os.path.split(fasta_path)[1].split('.')[0]
              
    par_dir = '/home/secoops/Folding/clOOPS-0.9.6-BETA1-src/data/par'
    par_vec = []
    par_vec += ['dope-PW_0A_ncont.par']
    par_vec += ['dope-PW_1A_ncont.par']
    par_vec += ['dope-PW_EE_cont.par']
    par_vec += ['dope-PW_0EEap_ncont.par']
    par_vec += ['dope-PW_2A_ncont.par']
    par_vec += ['dope-PW_HH_cont.par']
    par_vec += ['dope-PW_0EEp_ncont.par']
    par_vec += ['dope-PW_CC_cont.par']
    for i in range(8):
    par_path = os.path.join(par_dir, par_vec[i])
    sh_path = tempfile.mktemp('.sh')
    sh_file = open(sh_path, 'w')
    par_out_path = os.path.join(out_dir, name + '_' + par_vec[i])
    sh_file.write('/home/secoops/web/build.py -dope_speed ' + fasta_path + ' ' + alignment_path + ' ' + par_path + ' ' + par_out_path)
    sh_file.close()
    os.system('chmod u+x ' + sh_path)
    os.system('qsub -cwd ' + sh_path)
        

def DOPE_SPEED0(fasta_path, alignment_path, par_path, par_out_path):
    
    atom_vec = ['N', 'CA', 'CB', 'C', 'O']
    num_bins = 30
    
    name_ext = os.path.split(fasta_path)[1]
    name = name_ext.split('.')[0]
    
    fasta_file = open(fasta_path, 'r')
    fasta_lines = fasta_file.readlines()
    sequence = fasta_lines[1].strip()
    fasta_file.close()
    l = len(sequence)
    
    alignment_lines = readlines(alignment_path)
    
    N = len(alignment_lines)
    
    par_file = open(par_path, 'r')
    par_lines = par_file.readlines()
    par_file.close()
    par_out_file = open(par_out_path, 'w')
    for i in range(l - 2):
    for j in range(i + 2, l):
        for atom_i in atom_vec:
        for atom_j in atom_vec:
            print i + 1, j + 1, atom_i, atom_j
            energy_vec = [0.0] * num_bins
            count = 0
            for alignment_line in alignment_lines:
            if i > len(alignment_line.strip()) - 1 or j > len(alignment_line.strip()) - 1: continue
            aa1 = alignment_line[i]
            aa2 = alignment_line[j]
            gly_check = 'yes'
            if aa1 == 'G' and atom_i == 'CB': gly_check = 'no'
            if aa2 == 'G' and atom_j == 'CB': gly_check = 'no'
            if aa1 != ' ' and aa2 != ' ' and aa1 != '-' and aa2 != '-' and aa1 != 'X' and aa2 != 'X' and gly_check == 'yes':
                for par_line in par_lines:
                par_line_split = par_line.split()
                if par_line_split[0] == aa1 and par_line_split[2] == aa2 and par_line_split[1] == atom_i and par_line_split[3] == atom_j:
                    for k in range(num_bins):
                    energy = float(par_line_split[4 + k])
                    energy_vec[k] += energy
                    count = count + 1
                    break
            if count > 0:
            for k in range(num_bins): energy_vec[k] = energy_vec[k] / float(count)
            par_out_file.write(str(i + 1) + ' ' + atom_i + ' ' + str(j + 1) + ' ' + atom_j + ' ')
            for k in range(num_bins): par_out_file.write(str(energy_vec[k]) + ' ')
            par_out_file.write('\n')
    par_out_file.close()
    
def DOPE_SPEED(fasta_path, alignment_path, par_path, par_out_path):
    
    atom_vec = ['N', 'CA', 'CB', 'C', 'O']
    num_bins = 30
    
    name_ext = os.path.split(fasta_path)[1]
    name = name_ext.split('.')[0]
    
    fasta_file = open(fasta_path, 'r')
    fasta_lines = fasta_file.readlines()
    sequence = fasta_lines[1].strip()
    fasta_file.close()
    l = len(sequence)
    
    alignment_lines = readlines(alignment_path)
    
    N = len(alignment_lines)
    
    par_vec = [None] * 20
    for i in range(20):
    par_vec[i] = [None] * 20
        for j in range(20):
        par_vec[i][j] = [None] * 5
        for k in range(5):
        par_vec[i][j][k] = [None] * 5
        for n in range(5):
            par_vec[i][j][k][n] = [0.0] * 30
            
    #AtomChar(atom)
    #AAChar_fasta(AA_code)
        
    par_lines = readlines(par_path)
    for i in range(len(par_lines)):
    items = par_lines[i].split()
    if AtomPos(items[1].strip()) < 5 and AtomPos(items[3].strip()) < 5:
        for j in range(30):
            par_vec[AAChar_int(items[0].strip())][AAChar_int(items[2].strip())][AtomPos(items[1].strip())][AtomPos(items[3].strip())][j] = float(items[4 + j])
    
    par_out_file = open(par_out_path, 'w')
    for i in range(l - 2):
    for j in range(i + 2, l):
        for atom_i in atom_vec:
        for atom_j in atom_vec:
            print i + 1, j + 1, atom_i, atom_j
            energy_vec = [0.0] * num_bins
            count = 0
            for alignment_line in alignment_lines:
            if i > len(alignment_line.strip()) - 1 or j > len(alignment_line.strip()) - 1: continue
            aa1 = alignment_line[i]
            aa2 = alignment_line[j]
            gly_check = 'yes'
            if aa1 == 'G' and atom_i == 'CB': gly_check = 'no'
            if aa2 == 'G' and atom_j == 'CB': gly_check = 'no'
            if aa1 != ' ' and aa2 != ' ' and aa1 != '-' and aa2 != '-' and aa1 != 'X' and aa2 != 'X' and gly_check == 'yes':
                for k in range(num_bins):
                energy_vec[k] += par_vec[AAChar_int(aa1)][AAChar_int(aa2)][AtomPos(atom_i)][AtomPos(atom_j)][k]
                count = count + 1
            if count > 0:
            for k in range(num_bins): energy_vec[k] = energy_vec[k] / float(count)
            par_out_file.write(str(i + 1) + ' ' + atom_i + ' ' + str(j + 1) + ' ' + atom_j + ' ')
            for k in range(num_bins): par_out_file.write(str(energy_vec[k]) + ' ')
            par_out_file.write('\n')
    par_out_file.close()
            
def DOPE_SPEED_profile(alignment_path, par_path, pos1, pos2, atom1, atom2, bin_size, gif_path):
    
    alignment_file = open(alignment_path, 'r')
    alignment_lines = alignment_file.readlines()
    alignment_file.close()
    
    par_file = open(par_path, 'r')
    par_lines = par_file.readlines()
    par_file.close()
    
    num_bins = 30
    energy_vec = [0.0] * num_bins
    count = 0
    for alignment_line in alignment_lines:
    print alignment_line
    if len(alignment_line) > int(pos2) - 1:
        aa1 = alignment_line[int(pos1) - 1]
        aa2 = alignment_line[int(pos2) - 1]
        gly_check = 'yes'
        if aa1 == 'G' and atom1 == 'CB': gly_check = 'no'
        if aa2 == 'G' and atom1 == 'CB': gly_check = 'no'
        if aa1 != ' ' and aa2 != ' ' and aa1 != '-' and aa2 != '-' and aa1 != 'X' and aa2 != 'X' and gly_check == 'yes':
            count = count + 1
            for par_line in par_lines:
            par_line_split = par_line.split()
            if par_line_split[0] == aa1 and par_line_split[2] == aa2 and par_line_split[1] == atom1 and par_line_split[3] == atom2:
                for k in range(num_bins):
                energy = float(par_line_split[4 + k])
                energy_vec[k] = energy_vec[k] + energy
    if count > 0:
    for k in range(num_bins): energy_vec[k] = energy_vec[k] / float(count)
    
    name_ext = os.path.split(gif_path)[1]
    name = name_ext.split('.')[0]
    data_path = os.path.join(os.path.split(gif_path)[0], name + '.data')
    
    gnu_path = tempfile.mktemp('.dope_speed_plot')
    data_file = open(data_path, 'w')
    for i in range(num_bins):
    data_file.write(str(float(bin_size) + float(bin_size) * i) + ' ' + str(energy_vec[i]) + '\n')
    data_file.close()
    gnu_file = open(gnu_path, 'w')
    gnu_file.write('reset\nset terminal gif\nset output \"' + gif_path + '\"\nset xlabel \"distance (A)\"\nset ylabel \"energy\"\nplot \"' + data_path + '\" u 1:2 w l')
    gnu_file.close()
    os.system('gnuplot ' + gnu_path)
    os.remove(gnu_path)
    
def PhiPsi_verify(model_path, native_path, phi_psi_comp_path):

    model_backbone_path = tempfile.mktemp('.model_backbone')
    native_backbone_path = tempfile.mktemp('.native_backbone')
    
    os.system('./backbone ' + model_path + ' > ' + model_backbone_path)
    os.system('./backbone ' + native_path + ' > ' + native_backbone_path)
    
    model_backbone_file = open(model_backbone_path, 'r')
    native_backbone_file = open(native_backbone_path, 'r')
    
    model_backbone_lines = model_backbone_file.readlines()
    native_backbone_lines = native_backbone_file.readlines()
    
    model_backbone_file.close()
    native_backbone_file.close()
    
    os.remove(model_backbone_path)
    os.remove(native_backbone_path)
    
    phi_psi_comp_file = open(phi_psi_comp_path, 'w')
    
    for i in range(len(model_backbone_lines)):
        model_line = model_backbone_lines[i].split()
        native_line = native_backbone_lines[i].split()
    
    phi_diff = float(model_line[3]) - float(native_line[3])
    if phi_diff < 0.0: phi_diff = phi_diff * (-1.0)
    if phi_diff > 180.00: phi_diff = 360.00 - phi_diff
    
    psi_diff = float(model_line[4]) - float(native_line[4])
    if psi_diff < 0.0: psi_diff = psi_diff * (-1.0)
    if psi_diff > 180.00: psi_diff = 360.00 - psi_diff
    
    phi_psi_diff = math.sqrt((phi_diff ** 2) + (psi_diff ** 2))
    
    phi_psi_comp_file.write(str(phi_psi_diff) + '\n')
    
    phi_psi_comp_file.close()
    
def PhiPsi_verify_dir(model_dir, native_path, phi_psi_comp_path):
    
    model_list = os.listdir(model_dir)
    for model in model_list:
    if len(model.split('.')) > 1:
        if model.split('.')[1] == 'pdb':
                model_path = os.path.join(model_dir, model)
            comp_path = tempfile.mktemp('phi_psi_comp_path')
            PhiPsi_verify(model_path, native_path, comp_path)
            os.system('more ' + comp_path + ' >> ' + phi_psi_comp_path)
            os.remove(comp_path)
    
def Average(data_path):
    
    data_file = open(data_path, 'r')
    data_lines = data_file.readlines()
    data_file.close()
    
    total = 0.0
    for i in range(len(data_lines)):
    data_line = data_lines[i].strip()
    val = float(data_line)
    total = total + val
    
    average = total / float(len(data_lines))
    print average
    
def histogram(data_path, total_bins):
    
    data_file = open(data_path, 'r')
    data_lines = data_file.readlines()
    data_file.close()
    min_value = 100000000000.0
    max_value = 0.0
    for line in data_lines:
    value = float(line.strip())
    if value > max_value: max_value = value
    if value < min_value: min_value = value
    
    counts_vec = [0] * total_bins
    bin_val_vec = [0.0] * total_bins
    
    bin_size = (max_value - min_value) / float(total_bins)
    for i in range(total_bins):
    window_min = min_value + (i * bin_size)
    window_max = min_value + ((i + 1) * bin_size)
    
    bin_val_vec[i] = window_max
    
    for line in data_lines:
        value = float(line.strip())
        if value >= window_min and value < window_max: counts_vec[i] = counts_vec[i] + 1
        
    for i in range(total_bins):
    print bin_val_vec[i], counts_vec[i]
    
def secseq_int(secseq_char):
    
    if secseq_char == 'A': return 0
    elif secseq_char == 'O': return 1
    elif secseq_char == 'Q': return 2
    elif secseq_char == 'H': return 3
    elif secseq_char == 'C': return 4
    elif secseq_char == 'E': return 5
    elif secseq_char == 'S': return 6
    elif secseq_char == 'T': return 7
    elif secseq_char == 'G': return 8
    elif secseq_char == 'N': return 9
    
def secseq_str(secseq_int):
    
    if secseq_int == 0: return 'A'
    elif secseq_int == 1: return 'O'
    elif secseq_int == 2: return 'Q'
    elif secseq_int == 3: return 'H'
    elif secseq_int == 4: return 'C'
    elif secseq_int == 5: return 'E'
    elif secseq_int == 6: return 'S'
    elif secseq_int == 7: return 'T'
    elif secseq_int == 8: return 'G'
    elif secseq_int == 9: return 'N'
    
def AACode(AA_char):
    if AA_char == 'ALA': return 0
    elif AA_char == 'CYS': return 1
    elif AA_char == 'ASP': return 2
    elif AA_char == 'GLU': return 3
    elif AA_char == 'PHE': return 4
    elif AA_char == 'GLY': return 5
    elif AA_char == 'HIS': return 6
    elif AA_char == 'ILE': return 7
    elif AA_char == 'LYS': return 8
    elif AA_char == 'LEU': return 9
    elif AA_char == 'MET': return 10
    elif AA_char == 'ASN': return 11
    elif AA_char == 'PRO': return 12
    elif AA_char == 'GLN': return 13
    elif AA_char == 'ARG': return 14
    elif AA_char == 'SER': return 15
    elif AA_char == 'THR': return 16
    elif AA_char == 'VAL': return 17
    elif AA_char == 'TRP': return 18
    elif AA_char == 'TYR': return 19
    else: return 20
    
def AAChar(AA_code):
    if AA_code == 0: return 'ALA'
    elif AA_code == 1: return 'CYS'
    elif AA_code == 2: return 'ASP'
    elif AA_code == 3: return 'GLU'
    elif AA_code == 4: return 'PHE'
    elif AA_code == 5: return 'GLY'
    elif AA_code == 6: return 'HIS'
    elif AA_code == 7: return 'ILE'
    elif AA_code == 8: return 'LYS'
    elif AA_code == 9: return 'LEU'
    elif AA_code == 10: return 'MET'
    elif AA_code == 11: return 'ASN'
    elif AA_code == 12: return 'PRO'
    elif AA_code == 13: return 'GLN'
    elif AA_code == 14: return 'ARG'
    elif AA_code == 15: return 'SER'
    elif AA_code == 16: return 'THR'
    elif AA_code == 17: return 'VAL'
    elif AA_code == 18: return 'TRP'
    elif AA_code == 19: return 'TYR'
    else: return 'ERR'
    
def AAVolume(aa_int):
    
    vol_list = [28.5, 48.4, 51.0, 78.3, 129.8, 0.0, 93.1, 106.6, 108.5, 106.6, 102.8, 54.0, 52.6, 83.7, 113.3, 28.9, 56.0, 79.9, 167.7, 133.5]
    return vol_list[aa_int]
    
def AAChar_fasta(AA_code):
    if AA_code == 0: return 'A'
    elif AA_code == 1: return 'C'
    elif AA_code == 2: return 'D'
    elif AA_code == 3: return 'E'
    elif AA_code == 4: return 'F'
    elif AA_code == 5: return 'G'
    elif AA_code == 6: return 'H'
    elif AA_code == 7: return 'I'
    elif AA_code == 8: return 'K'
    elif AA_code == 9: return 'L'
    elif AA_code == 10: return 'M'
    elif AA_code == 11: return 'N'
    elif AA_code == 12: return 'P'
    elif AA_code == 13: return 'Q'
    elif AA_code == 14: return 'R'
    elif AA_code == 15: return 'S'
    elif AA_code == 16: return 'T'
    elif AA_code == 17: return 'V'
    elif AA_code == 18: return 'W'
    elif AA_code == 19: return 'Y'
    elif AA_code == 20: return 'X'
    
def AAChar_int(AA_code):
    if AA_code == 'A': return 0
    elif AA_code == 'C': return 1
    elif AA_code == 'D': return 2
    elif AA_code == 'E': return 3
    elif AA_code == 'F': return 4
    elif AA_code == 'G': return 5
    elif AA_code == 'H': return 6
    elif AA_code == 'I': return 7
    elif AA_code == 'K': return 8
    elif AA_code == 'L': return 9
    elif AA_code == 'M': return 10
    elif AA_code == 'N': return 11
    elif AA_code == 'P': return 12
    elif AA_code == 'Q': return 13
    elif AA_code == 'R': return 14
    elif AA_code == 'S': return 15
    elif AA_code == 'T': return 16
    elif AA_code == 'V': return 17
    elif AA_code == 'W': return 18
    elif AA_code == 'Y': return 19
    else: return 20
    
def rama_contour_plot_GNUPLOT(secseq0, secseq1, secseq2, pickle_path, gif_path):
    
    name_ext = os.path.split(pickle_path)[1]
    name = name_ext.split('.')[0]
    #png_path = os.path.join(os.path.split(pickle_path)[0], name + '.png')

    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    data_path = tempfile.mktemp('.ramaplot')
    data_file = open(data_path, 'w')
    
    for i in range(18):
    for j in range(18):
        ss0 = secseq_int(secseq0)
        ss1 = secseq_int(secseq1)
        ss2 = secseq_int(secseq2)
        
        ss_list = [ss0, ss1, ss2]
        secseq_index = baseX2Dec(ss_list, 6)
        
        #data_file.write(str(rama_bins[secseq_index][(324 - 18 * (i + 1)) + j])+ ' ')
        #data_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(rama_bins[secseq_index][(18 * i) + j]) + '\n')
        data_file.write(str(i + 1) + '  ' + str(j + 1) + '  ' + str(rama_bins[secseq_index][i + 18 * j]) + '\n')
    data_file.write('\n')
    data_file.close()
    
    plot_out_path = tempfile.mktemp('.gnu')
    Make_GNU_PLOT_Script_Matrix(data_path, plot_out_path, gif_path, 18, 18)
    os.remove(plot_out_path)
    os.remove(data_path)
    
def rama_contour_plot_PYLAB(secseq0, secseq1, secseq2, res, pickle_path, gif_path, data_path, log_path):
    
    name_ext = os.path.split(pickle_path)[1]
    name = name_ext.split('.')[0]
    png_dir = os.path.split(gif_path)[0]
    png_path = os.path.join(png_dir, name + '.png')

    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    log_file = open(log_path, 'w')
    
    data_file = open(data_path, 'w')

    res_int = 360 / int(res)
    tot_bins = res_int ** 2

    plot_max = float(res_int - 1)
    plot_mid = plot_max / 2.0
    
    for i in range(res_int):
    for j in range(res_int):
        ss0 = secseq_int(secseq0)
        ss1 = secseq_int(secseq1)
        ss2 = secseq_int(secseq2)
        
        ss_list = [ss0, ss1, ss2]
        secseq_index = baseX2Dec(ss_list, 6)
        
        data_str = str(rama_bins[secseq_index][i * res_int + j])
        if rama_bins[secseq_index][i * res_int + j] > 0.0: data_str = str(math.log(rama_bins[secseq_index][i * res_int + j]))
        
        #data_file.write(str(rama_bins[secseq_index][(324 - 18 * (i + 1)) + j]) + ' ')
        data_file.write(data_str + ' ')
        log_file.write(str(rama_bins[secseq_index][(tot_bins - res_int * (i + 1)) + j]) + ' ')
    data_file.write('\n')
    log_file.write('\n')
    data_file.close()
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    rama_data = pylab.load(data_path)
    pylab.xticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.yticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.contourf(rama_data)
    pylab.plot([plot_mid], pylab.arange(0.0, float(res_int)), 'k')
    #pylab.plot([plot_max / 4.0], pylab.arange(0.0, float(res_int)), 'k')
    #pylab.plot(pylab.arange(0.0, float(res_int)), [plot_max / 4.0], 'k')
    pylab.plot(pylab.arange(0.0, float(res_int)), [plot_mid], 'k')
    
    pylab.xlabel('phi', fontsize=15)
    pylab.ylabel('psi', fontsize=15)
    pylab.title('Ramachandran map for ' + name[0] + '-' + name[1] + '-' + name[2] + ' with SecStr ' + secseq0 + '-' + secseq1 + '-' + secseq2, fontsize=20) 
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    log_file.close()
    
def rama_contour_plot_PYLAB_all(secseq0, secseq1, secseq2, res, pickle_path, gif_path, data_path, log_path):
    
    name_ext = os.path.split(pickle_path)[1]
    name = name_ext.split('.')[0]
    png_dir = os.path.split(gif_path)[0]
    png_path = os.path.join(png_dir, name + '.png')

    pickle_file = open(pickle_path, 'rb')
    pickle_vec = pickle.load(pickle_file)
    pickle_file.close()
    
    log_file = open(log_path, 'w')
    
    data_file = open(data_path, 'w')

    res_int = 360 / int(res)
    tot_bins = res_int ** 2

    rama_bins = []
    for i in range(len(pickle_vec)):
        rama_bins.append([])
    for j in range(len(pickle_vec[i])):
        diff = pickle_vec[i][j][1] - len(rama_bins[i])
        for k in range(diff):
            rama_bins[i].append(0)
        rama_bins[i].append(pickle_vec[i][j][0])
    for j in range(tot_bins - len(rama_bins[i])): rama_bins[i].append(0)

    plot_max = float(res_int - 1)
    plot_mid = plot_max / 2.0
    
    for i in range(res_int):
    for j in range(res_int):
        ss0 = secseq_int(secseq0)
        ss1 = secseq_int(secseq1)
        ss2 = secseq_int(secseq2)
        
        ss_list = [ss0, ss1, ss2]
        secseq_index = baseX2Dec(ss_list, 10)
        
        #data_file.write(str(rama_bins[secseq_index][(324 - 18 * (i + 1)) + j]) + ' ')
        count = rama_bins[secseq_index][i * res_int + j]
        if count > 0: count = log10(count)
        
        data_file.write(str(count) + ' ')
        log_file.write(str(rama_bins[secseq_index][(tot_bins - res_int * (i + 1)) + j]) + ' ')
    data_file.write('\n')
    log_file.write('\n')
    data_file.close()
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    
    rama_data = pylab.load(data_path)
    pylab.xticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.yticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
  
    pylab.contourf(rama_data)
    pylab.plot([plot_mid], pylab.arange(0.0, float(res_int)), 'k', lw=1)
    pylab.plot(pylab.arange(0.0, float(res_int)), [plot_mid], 'k', lw=1)
    
    pylab.xlabel('phi', fontsize=20)
    pylab.ylabel('psi', fontsize=20)
    pylab.title('Ramachandran map for ' + name[0] + '-' + name[1] + '-' + name[2] + ' with SecStr ' + secseq0 + '-' + secseq1 + '-' + secseq2, fontsize=20) 
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    log_file.close()
    
def psi_phi_contour_plot_PYLAB(aa0, aa1, gif_path, data_path, log_path):
    
    png_dir = os.path.split(gif_path)[0]
    name = os.path.split(gif_path)[1].split('.')[0]
    png_path = os.path.join(png_dir, name + '.png')

    pickle_path = '/home/secoops/web/psi_phi/psi_phi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    log_file = open(log_path, 'w')
    
    data_file = open(data_path, 'w')

    res = 20
    res_int = 360 / int(res)
    tot_bins = res_int ** 2

    plot_max = float(res_int - 1)
    plot_mid = plot_max / 2.0
    
    for i in range(res_int):
    for j in range(res_int):
        data0 = rama_bins[AAChar_int(aa0)][AAChar_int(aa1)][i * res_int + j]
        if data0 > 0: data0 = math.log(data0)
        
        #data_file.write(str(rama_bins[secseq_index][(324 - 18 * (i + 1)) + j]) + ' ')
        data_file.write(str(data0) + ' ')
        log_file.write(str(rama_bins[AAChar_int(aa0)][AAChar_int(aa1)][(tot_bins - res_int * (i + 1)) + j]) + ' ')
    data_file.write('\n')
    log_file.write('\n')
    data_file.close()
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    rama_data = pylab.load(data_path)
    pylab.xticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.yticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.contourf(rama_data)
    pylab.plot([plot_mid], pylab.arange(0.0, float(res_int)), 'k')
    pylab.plot(pylab.arange(0.0, float(res_int)), [plot_mid], 'k')
    
    pylab.xlabel('psi', fontsize=20)
    pylab.ylabel('phi', fontsize=20)
    pylab.title('Psi-Phi Ramachandran map for ' + aa0 + ' and ' + aa1, fontsize=20) 
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    log_file.close()
    
def psi_psi_contour_plot_PYLAB(aa0, aa1, gif_path, data_path, log_path):
    
    png_dir = os.path.split(gif_path)[0]
    name = os.path.split(gif_path)[1].split('.')[0]
    png_path = os.path.join(png_dir, name + '.png')

    pickle_path = '/home/secoops/web/psi_phi/psi_psi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    log_file = open(log_path, 'w')
    
    data_file = open(data_path, 'w')

    res = 20
    res_int = 360 / int(res)
    tot_bins = res_int ** 2

    plot_max = float(res_int - 1)
    plot_mid = plot_max / 2.0
    
    for i in range(res_int):
    for j in range(res_int):
        
        #data_file.write(str(rama_bins[secseq_index][(324 - 18 * (i + 1)) + j]) + ' ')
        data_file.write(str(rama_bins[AAChar_int(aa0)][AAChar_int(aa1)][i * res_int + j]) + ' ')
        log_file.write(str(rama_bins[AAChar_int(aa0)][AAChar_int(aa1)][(tot_bins - res_int * (i + 1)) + j]) + ' ')
    data_file.write('\n')
    log_file.write('\n')
    data_file.close()
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    rama_data = pylab.load(data_path)
    pylab.xticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.yticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
    pylab.contourf(rama_data)
    pylab.plot([plot_mid], pylab.arange(0.0, float(res_int)), 'k')
    pylab.plot(pylab.arange(0.0, float(res_int)), [plot_mid], 'k')
    
    pylab.xlabel('psi', fontsize=20)
    pylab.ylabel('psi', fontsize=20)
    pylab.title('Psi-Psi Ramachandran map for ' + aa0 + ' and ' + aa1, fontsize=20) 
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    log_file.close()
    
def numero(number):
    
    return ('0' * (6 - len(str(number))) + str(number))

def psi_phi_rama_maps(fasta_path, native_path, out_dir):
    
    name = os.path.split(fasta_path)[1].split('.')[0]
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    native_rama = []
    for i in range(len(back_lines) - 1):
    line = back_lines[i].split()
    line2 = back_lines[i + 1].split()
    if len(line) > 4 and len(line2) > 4:
       psi_angle = float(line[4])
       phi_angle = float(line2[3])
       print psi_angle, phi_angle
       native_rama.append([psi_angle, phi_angle])
    
    fasta = readline(fasta_path, 2)
    
    L = len(fasta)
    
    pickle_path = '/home/secoops/web/psi_phi/psi_phi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    for position in range(L - 1):
    
        png_path = tempfile.mktemp('.png')
        data_path = tempfile.mktemp('.txt')
        data_file = open(data_path, 'w')

        res = 20
        res_int = 360 / int(res)
        tot_bins = res_int ** 2

        plot_max = float(res_int - 1)
        plot_mid = plot_max / 2.0
    
    aa0 = fasta[position]
    aa1 = fasta[position + 1]
    
        for i in range(res_int):
        for j in range(res_int):
            data0 = rama_bins[AAChar_int(aa0)][AAChar_int(aa1)][i * res_int + j]
            if data0 > 0: data0 = math.log(data0)
        
            data_file.write(str(data0) + ' ')
        data_file.write('\n')
        data_file.close()
    
        import matplotlib
        matplotlib.use( 'Agg' )
        import pylab
        pylab.rcParams['xtick.labelsize'] = '15'
        pylab.rcParams['ytick.labelsize'] = '15'
        rama_data = pylab.load(data_path)
    os.remove(data_path)
        pylab.xticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
        pylab.yticks([0.0, plot_mid, plot_max], ('-180', '0.0', '180'))
        pylab.contourf(rama_data)
        pylab.plot([plot_mid], pylab.arange(0.0, float(res_int)), 'k')
        pylab.plot(pylab.arange(0.0, float(res_int)), [plot_mid], 'k')
    
    native_x = (native_rama[position][0] + 180.0) / 20.0
    native_y = (native_rama[position][1] + 180.0) / 20.0
    
    pylab.plot(pylab.array([native_x]), pylab.array([native_y]), 'ko', markersize=10.0)
    
        pylab.xlabel('psi', fontsize=20)
        pylab.ylabel('phi', fontsize=20)
        pylab.title('Psi-Phi Ramachandran map for ' + aa0 + ' and ' + aa1 + ' (position ' + str(position + 1) + ')', fontsize=20) 
        pylab.savefig(png_path)
    gif_path = os.path.join(out_dir, name + '-' + numero(position + 1) + '.gif')
        os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
        os.remove(png_path)
    
    pylab.close()
    
def rama_maps(rama_path, native_path, out_dir):
    
    name = os.path.split(rama_path)[1].split('.')[0]
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    native_rama = []
    for i in range(len(back_lines)):
    line = back_lines[i].split()
    if len(line) > 4:
       native_rama.append([float(line[3]), float(line[4])])
    
    rama_file = open(rama_path, 'r')
    rama_lines = rama_file.readlines()
    rama_file.close()
    
    L = len(rama_lines)
    
    for position in range(L):
    
        png_path = tempfile.mktemp('.png')
    
        line = rama_lines[position]
        line = line.strip()
        line = line.split()
    
        data_vec = []
        for i in range(len(line)):
        data_vec += [line[i]]
    
        data_path = tempfile.mktemp('.ramaplot')
        data_file = open(data_path, 'w')
    
        L_counts = 0.0
    R_counts = 0.0
    
        for i in range(72):
        for j in range(72):
            data_point = data_vec[i * 72 + j]
        if j < 36: L_counts += float(data_point)
        else: R_counts += float(data_point)
            if float(data_vec[i * 72 + j]) > 0.0: data_point = str(math.log(float(data_vec[i * 72 + j])))
            data_file.write(data_point + ' ')
        data_file.write('\n')
        data_file.close()
    
    L_probs = 0.0
    R_probs = 0.0
    if (L_counts + R_counts) > 0.0:
        L_probs = L_counts / (L_counts + R_counts)
        R_probs = R_counts / (L_counts + R_counts)

        import matplotlib
        matplotlib.use( 'Agg' )
        import pylab
        pylab.rcParams['xtick.labelsize'] = '15'
        pylab.rcParams['ytick.labelsize'] = '15'
        rama_data = pylab.load(data_path)
        #pylab.xticks([0.0, 35.5, 71.0], ('-180', '0.0', '180'))
        #pylab.yticks([0.0, 35.5, 71.0], ('-180', '0.0', '180'))
        pylab.xticks([0.0, 35.5, 71.0], ('', '', ''))
        pylab.yticks([0.0, 35.5, 71.0], ('', '', ''))
        pylab.contourf(rama_data)
        pylab.plot([35.5], pylab.arange(0.0, 72.0), 'k')
        pylab.plot(pylab.arange(0.0, 72.0), [35.5], 'k')
    
    native_x = (native_rama[position][0] + 180.0) / 5.0
    native_y = (native_rama[position][1] + 180.0) / 5.0
    
    pylab.plot(pylab.array([native_x]), pylab.array([native_y]), 'ko', markersize=10.0)
    
        #pylab.xlabel('phi', fontsize=20)
        #pylab.ylabel('psi', fontsize=20)
        #pylab.title('Rama map for ' + name + ' position ' + str(position + 1) + ' : L(' + str(L_probs)[0:4] + '), R(' + str(R_probs)[0:4] + ')', fontsize=20) 
        pylab.savefig(png_path)
    gif_path = os.path.join(out_dir, name + '-' + numero(position + 1) + '.gif')
        os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
        os.remove(png_path)
        os.remove(data_path)
    
    pylab.close()
    
def rama_maps10x10(rama_path, native_path, out_dir):
    
    name = os.path.split(rama_path)[1].split('.')[0]
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    native_rama = []
    for i in range(len(back_lines)):
    line = back_lines[i].split()
    if len(line) > 4:
       native_rama.append([float(line[3]), float(line[4])])
    
    rama_file = open(rama_path, 'r')
    rama_lines = rama_file.readlines()
    rama_file.close()
    
    L = len(rama_lines)
    
    for position in range(L):
    
        png_path = tempfile.mktemp('.png')
    
        line = rama_lines[position]
        line = line.strip()
        line = line.split()
    
        data_vec = []
        for i in range(len(line)):
        data_vec += [line[i]]
    
        data_path = tempfile.mktemp('.ramaplot')
        data_file = open(data_path, 'w')
    
        L_counts = 0.0
    R_counts = 0.0
    
        for i in range(36):
        for j in range(36):
            data_point = data_vec[i * 36 + j]
        if j < 18: L_counts += float(data_point)
        else: R_counts += float(data_point)
            if float(data_vec[i * 36 + j]) > 0.0: data_point = str(math.log(float(data_vec[i * 36 + j])))
            data_file.write(data_point + ' ')
        data_file.write('\n')
        data_file.close()
    
    L_probs = 0.0
    R_probs = 0.0
    if (L_counts + R_counts) > 0.0:
        L_probs = L_counts / (L_counts + R_counts)
        R_probs = R_counts / (L_counts + R_counts)

        import matplotlib
        matplotlib.use( 'Agg' )
        import pylab
        pylab.rcParams['xtick.labelsize'] = '15'
        pylab.rcParams['ytick.labelsize'] = '15'
        rama_data = pylab.load(data_path)
        pylab.xticks([0.0, 17.5, 35.0], ('-180', '0.0', '180'))
        pylab.yticks([0.0, 17.5, 35.0], ('-180', '0.0', '180'))
        pylab.contourf(rama_data)
        pylab.plot([17.5], pylab.arange(0.0, 36.0), 'k')
        pylab.plot(pylab.arange(0.0, 36.0), [17.5], 'k')
    
    native_x = (native_rama[position][0] + 180.0) / 10.0
    native_y = (native_rama[position][1] + 180.0) / 10.0
    
    pylab.plot(pylab.array([native_x]), pylab.array([native_y]), 'ko', markersize=10.0)
    
        pylab.xlabel('phi', fontsize=20)
        pylab.ylabel('psi', fontsize=20)
        #pylab.title('Rama map for ' + name + ' position ' + str(position + 1) + ' : L(' + str(L_probs)[0:4] + '), R(' + str(R_probs)[0:4] + ')', fontsize=20) 
        pylab.savefig(png_path)
    gif_path = os.path.join(out_dir, name + '-' + numero(position + 1) + '.gif')
        os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
        os.remove(png_path)
        os.remove(data_path)
    
    pylab.close()

def rama_hist(gif_path):
    
    pdb_dir = '/home/secoops/web/rama_hist/pdb'
    hfree_dir = '/home/secoops/web/rama_hist/hfree_usable_matrix'
    speed_dir = '/home/secoops/web/rama_hist/speed_usable_matrix'
    pdb_list = os.listdir(pdb_dir)
    
    hfree_coil = []
    speed_coil = []
    hfree_all = []
    speed_all = []
    
    hfree_count = 0.0
    speed_count = 0.0
    count = 0.0
    
    for pdb_file in pdb_list:
    
    pdb_path = os.path.join(pdb_dir, pdb_file)
    tpdb_path = tempfile.mktemp('.pdb')
    PDB_from_structure(pdb_path, tpdb_path)
    dssp = ReturnDSSP(tpdb_path)
    L = len(dssp)
    name = pdb_file[0:4]
    hfree_rama_path = os.path.join(hfree_dir, name + '.rama')
    speed_rama_path = os.path.join(speed_dir, name + '.rama')
    
    hfree_array = rama_energy(hfree_rama_path, tpdb_path)
    speed_array = rama_energy(speed_rama_path, tpdb_path)
    
    print name, L, len(hfree_array), len(speed_array), len(CA_vec(tpdb_path))
    print dssp
    print FASTA_from_structure(pdb_path)
    
    os.remove(tpdb_path)
    
    for i in range(L - 2):
        #if math.fabs(hfree_array[i] - speed_array[i]) > 0.20:
        if hfree_array[i] < 0.25: hfree_count += 1.0
        if speed_array[i] < 0.25: speed_count += 1.0
        count += 1.0
        #hfree_coil.append(hfree_array[i])
        #speed_coil.append(speed_array[i])
    print hfree_count / count, speed_count / count
        
    hfree_coil_array = array(hfree_coil)
    speed_coil_array = array(speed_coil)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.hist(hfree_coil_array, normed=1, facecolor='red', alpha=0.45)
    pylab.hist(speed_coil_array, normed=1, facecolor='blue', alpha=0.45)

    pylab.xlabel('native basin probability', fontsize=20)
    png_path = tempfile.mktemp('.png')
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + gif_path)
    os.remove(png_path)
    
def energy_distribution(pred_path, out_path, N_std):
    
    pred_lines = readlines(pred_path)
    L = len(pred_lines)
    
    names = []
    rmsd = []
    energy = []
    
    for i in range(L):
    line = pred_lines[i].split()
    names.append(line[0])
    rmsd.append(line[1])
    energy.append(float(line[2]))
    
    energy_array = array(energy)
    
    mean_energy = mean(energy_array)
    std_energy = std(energy_array)
    
    out_file = open(out_path, 'w')
    for i in range(L):
    if energy[i] < mean_energy - (N_std * std_energy):
        out_file.write(names[i] + '\t' + rmsd[i] + '\t' + str(energy[i]) + '\n')
    out_file.close()
    
def model_native_rama_probs(model_dir, native_path):
    
    model_list = os.listdir(model_dir)
    pdb_list = []
    for model in (model_list):
    if model.split('.')[1] == 'pdb': pdb_list.append(os.path.join(model_dir, model))
    
    N_models = len(pdb_list)
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    L = len(CA_vec(native_path))
    
    probs_array = []
    native_basins = []
    for i in range(L): probs_array.append(0.0)
    
    native_rama = []
    for i in range(len(back_lines)):
    line = back_lines[i].split()
    if len(line) > 4:
       native_rama.append([float(line[3]), float(line[4])])
       
    native_basins.append(0)
    for position in range(1, L - 1):

    native_x = (native_rama[position][0] + 180.0) / 5.0
    native_y = (native_rama[position][1] + 180.0) / 5.0

    if native_x < 36 and native_y > 16 and native_y < 46: native_basin = 0
    elif native_x < 36 and (native_y <= 16 or native_y >= 46): native_basin = 1
        elif native_x >= 36 and (native_y >= 56 or native_y <= 16): native_basin = 2
        elif native_x >= 36 and (native_y < 56 and native_y > 16): native_basin = 3
    
    native_basins.append(native_basin)
    native_basins.append(0)
    
    if len(native_basins) != L:
    print 'problem'
    return
    
    for i in range(len(pdb_list)):
        
    pdb_path = tempfile.mktemp('.pdb')
    os.system('cp ' + pdb_list[i] + ' ' + pdb_path) 
        
        back_path = tempfile.mktemp('.txt')
        os.system('./backbone ' + pdb_path + ' > ' + back_path)
        back_lines = readlines(back_path)
        os.remove(back_path)
    os.remove(pdb_path)
        
    print pdb_list[i]
        
        model_rama = []
        for i in range(len(back_lines)):
        line = back_lines[i].split()
        if len(line) > 4: model_rama.append([float(line[3]), float(line[4])])
    
        if len(model_rama) != L:
        print 'problem'
        return
        
        for position in range(1, L - 1):

        model_x = (model_rama[position][0] + 180.0) / 5.0
        model_y = (model_rama[position][1] + 180.0) / 5.0

        if model_x < 36 and model_y > 16 and model_y < 46: model_basin = 0
        elif model_x < 36 and (model_y <= 16 or model_y >= 46): model_basin = 1
            elif model_x >= 36 and (model_y >= 56 or model_y <= 16): model_basin = 2
            elif model_x >= 36 and (model_y < 56 and model_y > 16): model_basin = 3
        
        if model_basin == native_basins[position]: probs_array[position] += 1.0
    
    new_list = []
    for i in range(1, L - 1):
    probs_array[i] = probs_array[i] / float(N_models)
    new_list.append(probs_array[i])
    
    new_array = array(new_list)

    print probs_array
    return new_array
    
def rama_energy(rama_path, native_path):
    
    name = os.path.split(rama_path)[1].split('.')[0]
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    probs_array = []
    
    native_rama = []
    for i in range(len(back_lines)):
    line = back_lines[i].split()
    if len(line) > 4:
       native_rama.append([float(line[3]), float(line[4])])
    
    rama_file = open(rama_path, 'r')
    rama_lines = rama_file.readlines()
    rama_file.close()
    
    L = len(rama_lines)
    energy = 0.0
    count = 0.0
    tot_probs = 0.0
    
    for position in range(1, L - 1):

        basin_counts = [0] * 5
        basin_probs = [0.0] * 4

    native_x = (native_rama[position][0] + 180.0) / 5.0
    native_y = (native_rama[position][1] + 180.0) / 5.0

    if native_x < 36 and native_y > 16 and native_y < 46: native_basin = 0
    elif native_x < 36 and (native_y <= 16 or native_y >= 46): native_basin = 1
        elif native_x >= 36 and (native_y >= 56 or native_y <= 16): native_basin = 2
        elif native_x >= 36 and (native_y < 56 and native_y > 16): native_basin = 3
    
        line = rama_lines[position]
        line = line.strip()
        line = line.split()
    
        data_vec = []
        for i in range(len(line)):
        data_vec += [line[i]]
    
        for i in range(72):
        for j in range(72):
            data_point = int(data_vec[i * 72 + j])

            #Lhelix, LExt, RExt, RHelix 
            if j < 36 and i > 16 and i < 46: basin_counts[0] += data_point
            elif j < 36 and (i <= 16 or i >= 46): basin_counts[1] += data_point
        elif j >= 36 and (i >= 56 or i <= 16): basin_counts[2] += data_point
        elif j >= 36 and (i < 56 and i > 16): basin_counts[3] += data_point

        for i in range(4): basin_counts[4] += basin_counts[i]

    if basin_counts[4] > 0: 
        for i in range(4):
        basin_probs[i] = float(basin_counts[i]) / float(basin_counts[4])
    if basin_probs[native_basin] > 0.0: energy += math.log(basin_probs[native_basin]) * -1.0
    else: energy += 10.0

        #print position + 1, 'Lhelix', basin_probs[0], 'LExt', basin_probs[1], 'RExt', basin_probs[2], 'Rhelix', basin_probs[3], 'Native', basin_probs[native_basin]
    probs_array.append(basin_probs[native_basin])
    if basin_probs[native_basin] > 0.25: count += 1.0
    tot_probs += basin_probs[native_basin]
    print float(count) / float(L), tot_probs / float(L)
    return probs_array
    
def rama_energy10x10(rama_path, native_path):
    
    name = os.path.split(rama_path)[1].split('.')[0]
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    probs_array = []
    
    native_rama = []
    for i in range(len(back_lines)):
    line = back_lines[i].split()
    if len(line) > 4:
       native_rama.append([float(line[3]), float(line[4])])
    
    rama_file = open(rama_path, 'r')
    rama_lines = rama_file.readlines()
    rama_file.close()
    
    L = len(rama_lines)
    energy = 0.0
    count = 0.0
    tot_probs = 0.0
    
    for position in range(1, L - 1):

        basin_counts = [0] * 5
        basin_probs = [0.0] * 4

    native_x = (native_rama[position][0] + 180.0) / 10.0
    native_y = (native_rama[position][1] + 180.0) / 10.0

    if native_x < 18 and native_y > 8 and native_y < 23: native_basin = 0
    elif native_x < 18 and (native_y <= 8 or native_y >= 23): native_basin = 1
        elif native_x >= 18 and (native_y >= 28 or native_y <= 8): native_basin = 2
        elif native_x >= 18 and (native_y < 28 and native_y > 8): native_basin = 3
    
        line = rama_lines[position]
        line = line.strip()
        line = line.split()
    
        data_vec = []
        for i in range(len(line)):
        data_vec += [line[i]]
    
        for i in range(36):
        for j in range(36):
            data_point = int(data_vec[i * 36 + j])

            #Lhelix, LExt, RExt, RHelix 
            if j < 18 and i > 8 and i < 23: basin_counts[0] += data_point
            elif j < 18 and (i <= 8 or i >= 23): basin_counts[1] += data_point
        elif j >= 18 and (i >= 28 or i <= 8): basin_counts[2] += data_point
        elif j >= 18 and (i < 28 and i > 8): basin_counts[3] += data_point

        for i in range(4): basin_counts[4] += basin_counts[i]

    if basin_counts[4] > 0: 
        for i in range(4):
        basin_probs[i] = float(basin_counts[i]) / float(basin_counts[4])
    if basin_probs[native_basin] > 0.0: energy += math.log(basin_probs[native_basin]) * -1.0
    else: energy += 10.0

        #print position + 1, 'Lhelix', basin_probs[0], 'LExt', basin_probs[1], 'RExt', basin_probs[2], 'Rhelix', basin_probs[3], 'Native', basin_probs[native_basin]
    probs_array.append(basin_probs[native_basin])
    if basin_probs[native_basin] > 0.25: count += 1.0
    tot_probs += basin_probs[native_basin]
    print float(count) / float(L), tot_probs / float(L)
    return probs_array

def rama_bar(in_dir):

    lines = readlines(os.path.join(in_dir, 'data.txt'))
    L = len(lines)

    names = []
    hfree = []
    speed = []

    for i in range(L):
    line = lines[i].split()
    names.append(line[0])
    hfree.append(float(line[1]))
    speed.append(float(line[2]))

    hfree_array = array(hfree)
    speed_array = array(speed)
    ind = arange(L)
    width = 0.30

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['legend.fontsize'] = '17'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (12, 6)

    fig = pylab.figure()
    ax = fig.add_subplot(111)


    hfree_bar = ax.bar(ind, hfree_array, width, color='r')
    speed_bar = ax.bar(ind+width, speed_array, width, color='y')
    ax.set_xticks(ind+width)
    ax.set_xticklabels( names )
    pylab.ylim(75.0, 100.0)
    


    ax.legend( (hfree_bar[0], speed_bar[0]), ('homology-free', 'SPEED') )

    
    png_path = os.path.join(in_dir, 'data.png')
    pylab.savefig(png_path)
    gif_path = os.path.join(in_dir, 'data.gif')
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
    
def fold_pos_bar(model_dir, speed_rama_path, native_path, fasta_path, dssp_path, out_path):

    secseq_str = readline(dssp_path, 1)
    aa_str = readline(fasta_path, 2)

    secseq = []
    for i in range(1, len(secseq_str)):
    num_str = ''
    if (i == 1) or (((i + 1) % 5) == 0): num_str = '\n' + str(i + 1)
    secseq.append(aa_str[i] + '\n' + secseq_str[i] + num_str)

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['legend.fontsize'] = '17'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (12, 6)
    
    from matplotlib.font_manager import FontProperties
    font0 = FontProperties()
    font = font0.copy()
    font.set_family('sans-serif')

    speed_array = array(rama_energy(speed_rama_path, native_path))
    model_array = array(model_native_rama_probs(model_dir, native_path))

    
    L = len(speed_array)
    ind = arange(L)
    width = 0.35

    fig = pylab.figure()
    ax = fig.add_subplot(111)


    speed_bar = ax.bar(ind, speed_array, width, color='r')
    model_bar = ax.bar(ind+width, model_array, width, color='y')
    ax.set_xticks(ind+width)
    ax.set_xticklabels( secseq )
    pylab.ylim(0.0, 1.0)
    pylab.xlim(0.0, float(L))
    ax.legend( (speed_bar[0], model_bar[0]), ('SPEED', 'R1 models') )
    
    png_path = tempfile.mktemp('.png')
    pylab.savefig(png_path)
    gif_path = os.path.join(out_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()

def pos_bar(hfree_rama_path, speed_rama_path, native_path, fasta_path, dssp_path, out_path):

    secseq_str = readline(dssp_path, 1)
    aa_str = readline(fasta_path, 2)

    secseq = []
    for i in range(1, len(secseq_str)):
    num_str = ''
    if (i == 1) or (((i + 1) % 5) == 0): num_str = '\n' + str(i + 1)
    secseq.append(aa_str[i] + '\n' + secseq_str[i] + num_str)

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['legend.fontsize'] = '17'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (12, 6)
    
    from matplotlib.font_manager import FontProperties
    font0 = FontProperties()
    font = font0.copy()
    font.set_family('sans-serif')

    #hfree_array = pylab.load(os.path.join(in_dir, 'hfree.txt'))
    #speed_array = pylab.load(os.path.join(in_dir, 'speed.txt'))
    hfree_array = array(rama_energy10x10(hfree_rama_path, native_path))
    speed_array = array(rama_energy10x10(speed_rama_path, native_path))
    
    print len(hfree_array)
    change = 0.0
    cchange = 0.0
    count = 0.0
    ccount = 0.0
    for i in range(len(hfree_array)):
    if secseq_str[i + 1] != 'H' and secseq_str[i + 1] != 'E':
        cchange += (speed_array[i] - hfree_array[i])
        ccount += 1.0
    else:
        change += (speed_array[i] - hfree_array[i])
        count += 1.0
    print change / count
    print cchange / ccount
    
    L = len(speed_array)
    ind = arange(L)
    width = 0.35

    fig = pylab.figure()
    ax = fig.add_subplot(111)


    hfree_bar = ax.bar(ind, hfree_array, width, color='r')
    speed_bar = ax.bar(ind+width, speed_array, width, color='y')
    ax.set_xticks(ind+width)
    ax.set_xticklabels( secseq )
    pylab.ylim(0.0, 1.0)
    pylab.xlim(0.0, float(L))
    ax.legend( (hfree_bar[0], speed_bar[0]), ('R0', 'R1') )
    
    png_path = tempfile.mktemp('.png')
    pylab.savefig(png_path)
    gif_path = os.path.join(out_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
    
def rama_script(script_dir, seqdata_dir, pickle_dir):
    
    for i in range(21):
    for j in range(21):
        for k in range(21):
        print i, j, k, AAChar_fasta(i), AAChar_fasta(j), AAChar_fasta(k)
        script_path = os.path.join(script_dir, AAChar_fasta(i) + AAChar_fasta(j) + AAChar_fasta(k) + '.sh')
        script_file = open(script_path, 'w')
        script_file.write('./build.py -rama_bin ' + str(i) + ' ' + str(j) + ' ' + str(k) + ' ' + seqdata_dir + ' ' + pickle_dir)
        script_file.close()
        while True:
            if number_of_jobs_running('secoops') < 100:
                os.system('chmod u+x ' + script_path)
                os.system('qsub -cwd '  + script_path)
                break
            else: time.sleep(2)
            
def rama_bins_AA(seqdata_dir):

    #### Getting memory #####
    L_count = []
    for i in range(1296):
    L_count.append([])
    for j in range(20): L_count[i].append(0)
    
    C_count = []
    for i in range(1296):
    C_count.append([])
    for j in range(20): C_count[i].append(0)
    
    R_count = []
    for i in range(1296):
    R_count.append([])
    for j in range(20): R_count[i].append(0)
    
    L_probs = []
    for i in range(1296):
    L_probs.append([])
    for j in range(20): L_probs[i].append(0.0)
            
    C_probs = []
    for i in range(1296):
    C_probs.append([])
    for j in range(20): C_probs[i].append(0.0)
    
    R_probs = []
    for i in range(1296):
    R_probs.append([])
    for j in range(20): R_probs[i].append(0.0)
    
    L_max = []
    for i in range(1296): L_max.append(0)
    C_max = []
    for i in range(1296): C_max.append(0)
    R_max = []
    for i in range(1296): R_max.append(0)
    
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    #print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(1, len(seqdata_lines) - 1):
        seqdata_items_0 = seqdata_lines[i - 1].split()
        seqdata_items_1 = seqdata_lines[i].split()
        seqdata_items_2 = seqdata_lines[i + 1].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(seqdata_items_2) > 3:
        aaL = AACode(seqdata_items_0[2])
        aaC = AACode(seqdata_items_1[2])
        aaR = AACode(seqdata_items_2[2])
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20 or AACode(seqdata_items_2[2]) >= 20: continue
        
        phi = float(seqdata_items_1[3])
        psi = float(seqdata_items_1[4])
        if phi == 180.00: phi -= 0.01
        if phi == -180.00: phi += 0.01
        if psi == 180.00: psi -= 0.01
        if psi == -180.00: psi += 0.01
            phi_bin = int((phi + 180.00) / 10.0)
        psi_bin = int((psi + 180.00) / 10.0)
        phi_psi_bin = phi_bin + 36 * psi_bin
        
        L_count[phi_psi_bin][aaL] += 1
        C_count[phi_psi_bin][aaC] += 1
        R_count[phi_psi_bin][aaR] += 1
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += L_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        L_probs[i][j] = float(L_count[i][j]) / float(total)
        if L_probs[i][j] > max_probs:
            L_max[i] = j
            max_probs = L_probs[i][j]
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += C_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        C_probs[i][j] = float(C_count[i][j]) / float(total)
        if C_probs[i][j] > max_probs:
            C_max[i] = j
            max_probs = C_probs[i][j]
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += R_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        R_probs[i][j] = float(R_count[i][j]) / float(total)
        if R_probs[i][j] > max_probs:
            R_max[i] = j
            max_probs = R_probs[i][j]

        
    ##### CSS STYLE DATA #####
    head_file = open('/var/www/includes/head_oops', 'r')
    header_string = head_file.read()
    header_string = header_string.replace('HEADERHERE', 'Model refinement analysis')
    header_string = header_string.replace('REPLACETITLE', 'ItFix server')
    
    ##### SEQUENCE INFO #####
    sequence_string = '<script type=\"text/javascript\">\nfunction changeText3(newHTML){\ndocument.getElementById(\'para\').innerHTML = newHTML;\n}\n</script>\n</html>\n</head>\n<body>\n<img src =\"img/rama.gif\" width =\"600\" height =\"500\" alt=\"rama map\" usemap=\"#planetmap" style=\"float:left\"/>\n<map name=\"planetmap\">\n'

    rwidth = (540.0 - 75.0) / 36.0
    rheight = (450.0 - 50.0) / 36.0

    for phi_bin in range(36):
        for psi_bin in range(36):
            phi_psi_bin = phi_bin + 36 * psi_bin
        w0 = str(75.0 + float(phi_bin) * rwidth)
        w1 = str(float(w0) + rwidth)
        h0 = str(450.0 - rheight - float(psi_bin) * rheight)
        h1 = str(float(h0) + rheight)
            sequence_string += '<area shape =\"rect\" coords =\"' + w0 + ','+ h0 + ',' + w1 + ',' + h1 + '\"\n'
        table_vec = []
        for i in range(21):
            table_vec.append([])
        for j in range(4): table_vec[i].append('')
        table_vec[0][0] = 'AA'
        table_vec[0][1] = 'Left'
        table_vec[0][2] = 'Center'
        table_vec[0][3] = 'Right'
        for i in range(20):
        table_vec[1 + i][0] = AAChar(i)
        table_vec[1 + i][1] = str(L_probs[phi_psi_bin][i])[0:min(len(str(L_probs[phi_psi_bin][i])), 4)]
        if len(str(L_probs[phi_psi_bin][i])) < 4: table_vec[1 + i][1] += '0'*(4-len(str(L_probs[phi_psi_bin][i])))
        table_vec[1 + i][2] = str(C_probs[phi_psi_bin][i])[0:min(len(str(C_probs[phi_psi_bin][i])), 4)]
        if len(str(C_probs[phi_psi_bin][i])) < 4: table_vec[1 + i][2] += '0'*(4-len(str(C_probs[phi_psi_bin][i])))
        table_vec[1 + i][3] = str(R_probs[phi_psi_bin][i])[0:min(len(str(R_probs[phi_psi_bin][i])), 4)]
        if len(str(R_probs[phi_psi_bin][i])) < 4: table_vec[1 + i][3] += '0'*(4-len(str(R_probs[phi_psi_bin][i])))
        sequence_string += 'onMouseOver=\"changeText3(\'' + HTML_table_notitle(table_vec) + '\')\"\n\n'

    sequence_string += '</map>\n\n<p id=\'para\'></p>\n\n'
    
   
    foot_file = open('/var/www/includes/foot', 'r')
    foot_string = foot_file.read()
    foot_file.close()
    
    server_string = header_string + sequence_string + foot_string
    print server_string
     
def rama_bins_AA1(seqdata_dir):

    #### Getting memory #####
    L_count = []
    for i in range(1296):
    L_count.append([])
    for j in range(20): L_count[i].append(0)
    
    C_count = []
    for i in range(1296):
    C_count.append([])
    for j in range(20): C_count[i].append(0)
    
    R_count = []
    for i in range(1296):
    R_count.append([])
    for j in range(20): R_count[i].append(0)
    
    L_probs = []
    for i in range(1296):
    L_probs.append([])
    for j in range(20): L_probs[i].append(0.0)
            
    C_probs = []
    for i in range(1296):
    C_probs.append([])
    for j in range(20): C_probs[i].append(0.0)
    
    R_probs = []
    for i in range(1296):
    R_probs.append([])
    for j in range(20): R_probs[i].append(0.0)
    
    L_max = []
    for i in range(1296): L_max.append(0)
    C_max = []
    for i in range(1296): C_max.append(0)
    R_max = []
    for i in range(1296): R_max.append(0)
    
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    #print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(1, len(seqdata_lines) - 1):
        seqdata_items_0 = seqdata_lines[i - 1].split()
        seqdata_items_1 = seqdata_lines[i].split()
        seqdata_items_2 = seqdata_lines[i + 1].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(seqdata_items_2) > 3:
        aaL = AACode(seqdata_items_0[2])
        aaC = AACode(seqdata_items_1[2])
        aaR = AACode(seqdata_items_2[2])
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20 or AACode(seqdata_items_2[2]) >= 20: continue
        
        phi = float(seqdata_items_1[3])
        psi = float(seqdata_items_1[4])
        if phi == 180.00: phi -= 0.01
        if phi == -180.00: phi += 0.01
        if psi == 180.00: psi -= 0.01
        if psi == -180.00: psi += 0.01
            phi_bin = int((phi + 180.00) / 10.0)
        psi_bin = int((psi + 180.00) / 10.0)
        phi_psi_bin = phi_bin + 36 * psi_bin
        
        L_count[phi_psi_bin][aaL] += 1
        C_count[phi_psi_bin][aaC] += 1
        R_count[phi_psi_bin][aaR] += 1
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += L_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        L_probs[i][j] = float(L_count[i][j]) / float(total)
        if L_probs[i][j] > max_probs:
            L_max[i] = j
            max_probs = L_probs[i][j]
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += C_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        C_probs[i][j] = float(C_count[i][j]) / float(total)
        if C_probs[i][j] > max_probs:
            C_max[i] = j
            max_probs = C_probs[i][j]
        
    for i in range(1296):
    total = 0
    for j in range(20):
        total += R_count[i][j]
    if total > 0:
        max_probs = 0.0
        for j in range(20):
        R_probs[i][j] = float(R_count[i][j]) / float(total)
        if R_probs[i][j] > max_probs:
            R_max[i] = j
            max_probs = R_probs[i][j]

    sequence_string = '<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\">\n<html>\n<head>\n<script src=\"http://code.jquery.com/jquery-latest.js\"></script>\n<script>\n$(document).ready(function(){\n'

    rwidth = (540.0 - 75.0) / 36.0
    rheight = (450.0 - 50.0) / 36.0

    for phi_bin in range(36):
        for psi_bin in range(36): 
            phi_psi_bin = phi_bin + 36 * psi_bin
        table_vec = []
        for i in range(21):
            table_vec.append([])
        for j in range(4): table_vec[i].append('')
        table_vec[0][0] = 'AA&nbsp&nbsp&nbsp&nbsp'
        table_vec[0][1] = 'Left&nbsp&nbsp&nbsp'
        table_vec[0][2] = 'Center&nbsp'
        table_vec[0][3] = 'Right&nbsp&nbsp'
        for i in range(20):
        L_str = str(L_probs[phi_psi_bin][i])[0:min(len(str(L_probs[phi_psi_bin][i])), 4)]
        if len(L_str) < 4: L_str += '0'*(4-len(str(L_probs[phi_psi_bin][i])))
        if L_max[phi_psi_bin] == i:
            L_str = '<b><span style=\'color:red\'>' + L_str + '</span></b>'
        C_str = str(C_probs[phi_psi_bin][i])[0:min(len(str(C_probs[phi_psi_bin][i])), 4)]
        if len(C_str) < 4: C_str += '0'*(4-len(str(C_probs[phi_psi_bin][i])))
        if C_max[phi_psi_bin] == i:
            C_str = '<b><span style=\'color:red\'>' + C_str + '</span></b>'
        R_str = str(R_probs[phi_psi_bin][i])[0:min(len(str(R_probs[phi_psi_bin][i])), 4)]
        if len(R_str) < 4: R_str += '0'*(4-len(str(R_probs[phi_psi_bin][i])))
        if R_max[phi_psi_bin] == i:
            R_str = '<b><span style=\'color:red\'>' + R_str + '</span></b>'
        
        table_vec[1 + i][0] = '<b>' + AAChar(i) + '</b>'
        table_vec[1 + i][1] = L_str
        table_vec[1 + i][2] = C_str
        table_vec[1 + i][3] = R_str
        sequence_string += '$(\'#' + str(phi_psi_bin) + '\').hover(\nfunction() {\n$(\'#result\').html(\"' + HTML_table_notitle(table_vec) + '\");\n});\n'
        
    sequence_string += '});\n</script>\n</head>\n<body><img src=\"http://godzilla.uchicago.edu/img/rama.gif\" width =\"600\" height =\"500\" alt=\"ramamap\" border=\"0\" usemap=\"#ramamap\" style=\"float:left\" id=\"ramamap\"/>\n<map name=\"ramamap\">\n'
    
    for phi_bin in range(36):
        for psi_bin in range(36): 
            phi_psi_bin = phi_bin + 36 * psi_bin
        w0 = str(75.0 + float(phi_bin) * rwidth)
        w1 = str(float(w0) + rwidth)
        h0 = str(450.0 - rheight - float(psi_bin) * rheight)
        h1 = str(float(h0) + rheight)
            sequence_string += '<area shape =\"rect\" coords =\"' + w0 + ','+ h0 + ',' + w1 + ',' + h1 + '\" id=\"' + str(phi_psi_bin) + '\"/>\n'
    
    sequence_string += '</map>\n<span id=\"result\"> </span>\n</body>\n</html>'
    print sequence_string
    
def is_number(string):
    try:
        float(string)
        return True
    except ValueError:
        return False
 
def low_energy_list(pdb_dir):

    pdb_vec = []
    pdb_list = os.listdir(pdb_dir)

    info_path = os.path.join(pdb_dir, 'prediction.txt')
    info_lines = readlines(info_path)

    name_vec = []
    energy_vec = []

    for line in info_lines:
        items = line.split()
        name_vec.append(items[0])
        energy_vec.append(float(items[2]))

    energy_array = array(energy_vec)
    energy_mean = mean(energy_vec)
    energy_std = std(energy_vec)

    low_energy_vec = []
    for i in range(len(energy_array)):
        if energy_array[i] < energy_mean - energy_std: low_energy_vec.append(os.path.join(pdb_dir, name_vec[i] + '.pdb'))

    return low_energy_vec
    
def smitfix(pdb_dir, out_path):

    #pdb_vec = []
    #pdb_list = os.listdir(pdb_dir)
    #for file in pdb_list:
#    if file.split('.')[1] == 'pdb':
#        pdb_vec.append(os.path.join(pdb_dir, file))
        
    lines = readlines('../prj/SECsamplerSC/trj/Final_Round/T1ubq_cons/cluster_5_analysis.txt')
    select = False
    pdb_vec = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(18):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(pdb_vec, lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break

    #pdb_vec = low_energy_list(pdb_dir)
        
    L = N_res(pdb_vec[0])

    #### Getting memory #####
    rama_counts_vec = []
    for i in range(L):
    rama_counts_vec.append([])
    for j in range(1296): rama_counts_vec[i].append(0)
            
    for pdb_path in pdb_vec:
        print len(pdb_vec)
    print pdb_path
    
    phi_psi_vec = phi_psi_listing(pdb_path)
    for i in range(len(phi_psi_vec)):
        phi = phi_psi_vec[i][0]
        psi = phi_psi_vec[i][1]
        
        if phi == 180.00: phi -= 0.01
        if phi == -180.00: phi += 0.01
        if psi == 180.00: psi -= 0.01
        if psi == -180.00: psi += 0.01
        
        phi_bin = int((phi + 180.00) / 10.0)
        psi_bin = int((psi + 180.00) / 10.0)
        phi_psi_bin = phi_bin + 36 * psi_bin
        
        rama_counts_vec[i][phi_psi_bin] += 1
        
    out_file = open(out_path, 'w')
    for i in range(L):
    for j in range(36 * 36): out_file.write(str(rama_counts_vec[i][j]) + ' ')
    out_file.write('\n')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def rama_bins(aa0, aa1, aa2, seqdata_dir, pickle_dir):

    #### Getting memory #####
    rama_counts_vec = [None] * 1000
    for i in range(1000):
    rama_counts_vec[i] = [0] * 1296
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(1, len(seqdata_lines) - 1):
        seqdata_items_0 = seqdata_lines[i - 1].split()
        seqdata_items_1 = seqdata_lines[i].split()
        seqdata_items_2 = seqdata_lines[i + 1].split()
        #print seqdata_items_0
        #print seqdata_items_1
        #print seqdata_items_2
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(seqdata_items_2) > 3:
            
        if (AACode(seqdata_items_0[2]) != aa0 and aa0 < 20) or (AACode(seqdata_items_1[2]) != aa1 and aa1 < 20) or (AACode(seqdata_items_2[2]) != aa2 and aa2 < 20): continue
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20 or AACode(seqdata_items_2[2]) >= 20: continue
                
        phi = float(seqdata_items_1[3])
        psi = float(seqdata_items_1[4])
        if phi == 180.00: phi -= 0.01
        if phi == -180.00: phi += 0.01
        if psi == 180.00: psi -= 0.01
        if psi == -180.00: psi += 0.01
            phi_bin = int((phi + 180.00) / 10.0)
        psi_bin = int((psi + 180.00) / 10.0)
        phi_psi_bin = phi_bin + 36 * psi_bin
        
        SecStr_char0 = seqdata_items_0[7]
        SecStr_char1 = seqdata_items_1[7]
        SecStr_char2 = seqdata_items_2[7]
        
        if SecStr_char0 == 'H': SecStr_string0 = '023'
        elif SecStr_char0 == 'E': SecStr_string0 = '015'
        elif SecStr_char0 == 'S': SecStr_string0 = '01246'
        elif SecStr_char0 == 'T': SecStr_string0 = '01247'
        elif SecStr_char0 == 'G': SecStr_string0 = '01248'
        elif SecStr_char0 == '-': SecStr_string0 = '01249'
        else: SecStr_string0 = '0124'
        
        if SecStr_char1 == 'H': SecStr_string1 = '023'
        elif SecStr_char1 == 'E': SecStr_string1 = '015'
        elif SecStr_char1 == 'S': SecStr_string1 = '01246'
        elif SecStr_char1 == 'T': SecStr_string1 = '01247'
        elif SecStr_char1 == 'G': SecStr_string1 = '01248'
        elif SecStr_char1 == '-': SecStr_string1 = '01249'
        else: SecStr_string1 = '0124'
        
        if SecStr_char2 == 'H': SecStr_string2 = '023'
        elif SecStr_char2 == 'E': SecStr_string2 = '015'
        elif SecStr_char2 == 'S': SecStr_string2 = '01246'
        elif SecStr_char2 == 'T': SecStr_string2 = '01247'
        elif SecStr_char2 == 'G': SecStr_string2 = '01248'
        elif SecStr_char2 == '-': SecStr_string2 = '01249'
        else: SecStr_string2 = '0124'
        
        for j in range(len(SecStr_string0)):
            for k in range(len(SecStr_string1)):
                for l in range(len(SecStr_string2)):
                
                secseq_code_list = [int(SecStr_string0[j]), int(SecStr_string1[k]), int(SecStr_string2[l])]
        
                secseq_index = baseX2Dec(secseq_code_list, 10)
                
                rama_counts_vec[secseq_index][phi_psi_bin] += 1
    pickle_vec = []
    for i in range(1000):
        pickle_vec.append([])
    count = -1
        for j in range(len(rama_counts_vec[i])):
            if rama_counts_vec[i][j] > 0:
        count += 1
            pickle_vec[i].append([])
        pickle_vec[i][count].append(rama_counts_vec[i][j])
        pickle_vec[i][count].append(j)
        
    pickle_path = os.path.join(pickle_dir, AAChar_fasta(aa0) + AAChar_fasta(aa1) + AAChar_fasta(aa2) + '.pickle')
    pickle_file = open(pickle_path, 'wb')
    pickle.dump(pickle_vec, pickle_file)
    pickle_file.close()
    
def psi_phi_rama_bins(seqdata_dir, pickle_dir):

    #### Getting memory #####
    rama_counts_vec = [None] * 20
    for i in range(20):
    rama_counts_vec[i] = [None] * 20
    for j in range(20): rama_counts_vec[i][j] = [0] * 324

    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(len(seqdata_lines) - 1):
        seqdata_items_0 = seqdata_lines[i].split()
        seqdata_items_1 = seqdata_lines[i + 1].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3:
            
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20: continue

            psi_bin = int((float(seqdata_items_0[4]) + 180.00) / 20.0)
        phi_bin = int((float(seqdata_items_1[3]) + 180.00) / 20.0)
        psi_phi_bin = psi_bin + 18 * phi_bin
        
        rama_counts_vec[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][psi_phi_bin] += 1
        
    pickle_path = os.path.join(pickle_dir, 'psi_phi_20x20.pickle')
    pickle_file = open(pickle_path, 'wb')
    pickle.dump(rama_counts_vec, pickle_file)
    pickle_file.close()
    
def general_rama_bins(seqdata_dir, pickle_dir):

    #### Getting memory #####
    rama_counts_vec = [None] * 20
    for i in range(20):
    rama_counts_vec[i] = [None] * 20
    for j in range(20): rama_counts_vec[i][j] = [0] * 324
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(len(seqdata_lines) - 2):
        #stretch1 = seqdata_lines[i].split()
        stretch2 = seqdata_lines[i + 2].split()
        seqdata_items_0 = seqdata_lines[i].split()
        seqdata_items_1 = seqdata_lines[i + 1].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(stretch2) > 3:
        
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20: continue

            angle1_bin = int((float(seqdata_items_0[4]) + 179.99) / 20.0)
        angle2_bin = int((float(seqdata_items_1[4]) + 179.99) / 20.0)
        bin = angle1_bin + 18 * angle2_bin
        
        rama_counts_vec[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][bin] += 1
        
    pickle_path = os.path.join(pickle_dir, 'psi_psi_20x20.pickle')
    pickle_file = open(pickle_path, 'wb')
    pickle.dump(rama_counts_vec, pickle_file)
    pickle_file.close()
    
def rama_allowed(seqdata_dir, pickle_path):

    #### Getting memory #####
    rama_counts_vec = [None] * 81
    for i in range(81):
    rama_counts_vec[i] = [None] * 81
    for j in range(81): rama_counts_vec[i][j] = [0] * 81
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(len(seqdata_lines) - 5):
        seqdata_items_0 = seqdata_lines[i].split()
        seqdata_items_1 = seqdata_lines[i + 1].split()
        seqdata_items_2 = seqdata_lines[i + 2].split()
        seqdata_items_3 = seqdata_lines[i + 3].split()
        seqdata_items_4 = seqdata_lines[i + 4].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(seqdata_items_2) > 3 and len(seqdata_items_3) > 3 and len(seqdata_items_4) > 3:
        
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20 or AACode(seqdata_items_2[2]) >= 20 or AACode(seqdata_items_3[2]) >= 20 or AACode(seqdata_items_4[2]) >= 20: continue

            angle1_bin = int((float(seqdata_items_1[3]) + 179.99) / 40.0)
        angle2_bin = int((float(seqdata_items_1[4]) + 179.99) / 40.0)
        bin1 = angle1_bin + 9 * angle2_bin
        
            angle1_bin = int((float(seqdata_items_2[3]) + 179.99) / 40.0)
        angle2_bin = int((float(seqdata_items_2[4]) + 179.99) / 40.0)
        bin2 = angle1_bin + 9 * angle2_bin
        
            angle1_bin = int((float(seqdata_items_3[3]) + 179.99) / 40.0)
        angle2_bin = int((float(seqdata_items_3[4]) + 179.99) / 40.0)
        bin3 = angle1_bin + 9 * angle2_bin
        
        rama_counts_vec[bin1][bin2][bin3] += 1
        
    pickle_file = open(pickle_path, 'wb')
    pickle.dump(rama_counts_vec, pickle_file)
    pickle_file.close()

def rama_violations(pdb_dir, pickle_path, native_path):

    #### Getting memory #####
    pickle_file = open(pickle_path, 'rb')
    rama_counts_vec = pickle.load(pickle_file)
    pickle_file.close()
            
    pdb_list = os.listdir(pdb_dir)
    for pdb_fn in pdb_list:
        if pdb_fn.split('.')[1] != 'pdb': continue
    
    pdb_path = os.path.join(pdb_dir, pdb_fn)
        seqdata_path = tempfile.mktemp('.txt')
        os.system('./backbone ' + pdb_path + ' > ' + seqdata_path)
        seqdata_lines = readlines(seqdata_path)
    os.remove(seqdata_path)
    
    count = 0
    
        for i in range(len(seqdata_lines) - 5):
        seqdata_items_0 = seqdata_lines[i].split()
        seqdata_items_1 = seqdata_lines[i + 1].split()
        seqdata_items_2 = seqdata_lines[i + 2].split()
        seqdata_items_3 = seqdata_lines[i + 3].split()
        seqdata_items_4 = seqdata_lines[i + 4].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3 and len(seqdata_items_2) > 3 and len(seqdata_items_3) > 3 and len(seqdata_items_4) > 3:
        
            if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20 or AACode(seqdata_items_2[2]) >= 20 or AACode(seqdata_items_3[2]) >= 20 or AACode(seqdata_items_4[2]) >= 20: continue

            angle1_bin = int((float(seqdata_items_1[3]) + 179.99) / 40.0)
            angle2_bin = int((float(seqdata_items_1[4]) + 179.99) / 40.0)
            bin1 = angle1_bin + 9 * angle2_bin
        
            angle1_bin = int((float(seqdata_items_2[3]) + 179.99) / 40.0)
            angle2_bin = int((float(seqdata_items_2[4]) + 179.99) / 40.0)
            bin2 = angle1_bin + 9 * angle2_bin
        
            angle1_bin = int((float(seqdata_items_3[3]) + 179.99) / 40.0)
            angle2_bin = int((float(seqdata_items_3[4]) + 179.99) / 40.0)
            bin3 = angle1_bin + 9 * angle2_bin
        
            if int(seqdata_items_2[1]) == 8: count += rama_counts_vec[bin1][bin2][bin3]
         
    print pdb_fn, count, rmsd(pdb_path, native_path)
    
def omega_probs(seqdata_dir, omega_path):

    #### Getting memory #####
    rama_counts_vec = [None] * 20
    for i in range(20):
    rama_counts_vec[i] = [None] * 20
    for j in range(20): rama_counts_vec[i][j] = [0] * 2
            
    seqdata_list = os.listdir(seqdata_dir)
    for seqdata_name in seqdata_list:
    print seqdata_name
    seqdata_path = os.path.join(seqdata_dir, seqdata_name)
    seqdata_file = open(seqdata_path, 'r')
    seqdata_lines = seqdata_file.readlines()
    seqdata_file.close()
    for i in range(len(seqdata_lines) - 1):
        seqdata_items_0 = seqdata_lines[i].split()
        seqdata_items_1 = seqdata_lines[i + 1].split()
        if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3:
            
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20: continue

        omega = float(seqdata_items_0[5])
            if omega < -100.0 or omega > 100.0: omega_bin = 0
        else: omega_bin = 1
        
        rama_counts_vec[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][omega_bin] += 1
        
    omega_file = open(omega_path, 'w')
    for i in range(20):
    for j in range(20):
        omega_file.write(AAChar(i) + ' ' + AAChar(j) + ' ' + str(float(rama_counts_vec[i][j][1]) / (float(rama_counts_vec[i][j][1]) + float(rama_counts_vec[i][j][0]))) + '\n')
    omega_file.close()
    
def psi_phi_violations(pdb_path):
    
    pickle_path = '/home/secoops/web/psi_phi/psi_phi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    probs = [None] * 20
    for i in range(20):
    probs[i] = [None] * 20
    for j in range(20):
        probs[i][j] = [0.0] * 324
        
    for i in range(20):
    for j in range(20):
        count = 0
        for k in range(324): count += rama_bins[i][j][k]
        for k in range(324): probs[i][j][k] = float(rama_bins[i][j][k]) / float(count)
    
    #par_file = open('phi_phi.par', 'w')
    #for i in range(20):
    #for j in range(20):
        #total = 0
        #for k in range(324): total += rama_bins[i][j][k]
        #par_file.write(AAChar(i) + '\n' + AAChar(j) + '\n')
        #for k in range(324): par_file.write(str(float(rama_bins[i][j][k]) / float(total)) + '\n')
    #par_file.close()
        
    
    seqdata_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + pdb_path + ' > ' + seqdata_path)
    seqdata_lines = readlines(seqdata_path)
    
    for i in range(len(seqdata_lines) - 1):
    seqdata_items_0 = seqdata_lines[i].split()
    seqdata_items_1 = seqdata_lines[i + 1].split()
    if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3:
            
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20: continue

        psi_bin = int((float(seqdata_items_0[4]) + 180.00) / 20.0)
        phi_bin = int((float(seqdata_items_1[3]) + 180.00) / 20.0)
        psi_phi_bin = psi_bin + 18 * phi_bin
        
        print i + 1, seqdata_items_0[2], seqdata_items_1[2], probs[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][psi_phi_bin] 
        
        #if rama_bins[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][psi_phi_bin] == 0:
            #print seqdata_lines[i]
            #print seqdata_lines[i + 1]
        
    os.remove(seqdata_path)
    
def violations(pdb_path):
    
    pickle_path = '/home/secoops/web/psi_phi/psi_psi_20x20.pickle'
    pickle_file = open(pickle_path, 'rb')
    rama_bins = pickle.load(pickle_file)
    pickle_file.close()
    
    #par_file = open('psi_psi.par', 'w')
    #for i in range(20):
    #for j in range(20):
        #total = 0
        #for k in range(324): total += rama_bins[i][j][k]
        #par_file.write(AAChar(i) + '\n' + AAChar(j) + '\n')
        #for k in range(324): par_file.write(str(float(rama_bins[i][j][k]) / float(total)) + '\n')
    #par_file.close()
    
    seqdata_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + pdb_path + ' > ' + seqdata_path)
    seqdata_lines = readlines(seqdata_path)
    
    for i in range(len(seqdata_lines) - 1):
    seqdata_items_0 = seqdata_lines[i].split()
    seqdata_items_1 = seqdata_lines[i + 1].split()
    if len(seqdata_items_0) > 3 and len(seqdata_items_1) > 3:
            
        if AACode(seqdata_items_0[2]) >= 20 or AACode(seqdata_items_1[2]) >= 20: continue

        angle0_bin = int((float(seqdata_items_0[4]) + 180.00) / 20.0)
        angle1_bin = int((float(seqdata_items_1[4]) + 180.00) / 20.0)
        bin = angle0_bin + 18 * angle1_bin
        
        if rama_bins[AACode(seqdata_items_0[2])][AACode(seqdata_items_1[2])][bin] == 0:
            print seqdata_lines[i]
            print seqdata_lines[i + 1]
        
    os.remove(seqdata_path)
    
def remake_rama_file(in_path, out_path):

    lines = readlines(in_path)
    l = len(lines)
    
    out_file = open(out_path, 'w')
    
    out_file.write(lines[1])
    for i in range(l - 2):
    out_file.write(lines[i + 1])
    out_file.write(lines[-2])
    out_file.close()
    
def baseX2Dec(num_list, baseX):
    
    l = len(num_list)
    num = 0
    for i in range(l):
    base = l - i - 1
    num = num + num_list[i] * (baseX ** base)
    return num
    
def Denary2Binary(n):
    
    bStr = ''
    if n < 0: raise ValueError, "must be a positive integer"
    if n == 0: return '0'
    while n > 0:
        bStr = str(n % 2) + bStr
    n = n >> 1
    print n
    
    return bStr

def int2bin(n, count=24):
    
    return "".join([str((n >> y) & 1) for y in range(count-1, -1, -1)])

def seq_sim(str1, str2):
    
    l1 = len(str1)
    l2 = len(str2)
    if l1 <= l2: 
    l_max = l2
    l_min = l1
    else: 
    l_max = l1
    l_min = l2
    sim_count = 0
    pos_count = 0
    for i in range(l_min):
    if str1[i] != ' ' and str1[i] != '-' and str2[i] != ' ' and str2[i] != '-':
        pos_count += 1
        if str1[i] == str2[i]:
        sim_count += 1
        
    return float(sim_count) / float(pos_count)
    
def CullMatrix(matrix_path, redund_cutoff, out_matrix_path):

    matrix_file = open(matrix_path, 'r')
    matrix_lines = matrix_file.readlines()
    matrix_file.close()
    
    N = len(matrix_lines)
    cull_vec = [0] * N
    total_cull = 0
    
    i = 0
    while i < N - 1:
    if cull_vec[i] == 1:
        i = i + 1
        continue
    matrix_line_i = matrix_lines[i]
    j = 1
    while i + j < N - 1:
        if cull_vec[i + j] == 1:
            j = j + 1
            continue
        matrix_line_j = matrix_lines[i + j]
        if seq_sim(matrix_line_i, matrix_line_j) > float(redund_cutoff):
            cull_vec[i + j] = 1
        total_cull = total_cull + 1
        print total_cull
        j += 1
        else:
        j = j + 1
    i = i + 1

    out_matrix_file = open(out_matrix_path, 'w')
    for i in range(N):
    if cull_vec[i] == 0: out_matrix_file.write(matrix_lines[i])
    out_matrix_file.close()
    
def AACheck(aa):
    if aa == 'A': return 1
    elif aa == 'C': return 1
    elif aa == 'D': return 1
    elif aa == 'E': return 1
    elif aa == 'F': return 1
    elif aa == 'G': return 1
    elif aa == 'H': return 1
    elif aa == 'I': return 1
    elif aa == 'K': return 1
    elif aa == 'L': return 1
    elif aa == 'M': return 1
    elif aa == 'N': return 1
    elif aa == 'P': return 1
    elif aa == 'Q': return 1
    elif aa == 'R': return 1
    elif aa == 'S': return 1
    elif aa == 'T': return 1
    elif aa == 'V': return 1
    elif aa == 'W': return 1
    elif aa == 'Y': return 1
    else: return 0
    
def SPEED_sampling_profile(alignment_path, secseq_path, out_path):

    secseq_file = open(secseq_path, 'r')
    secseq = secseq_file.readline()
    secseq = secseq.strip()
    secseq_file.close()

    N = len(secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3
    
    alignment_file = open(alignment_path, 'r')
    alignment_lines = alignment_file.readlines()
    alignment_file.close()
    
    count = 0
    for sequence in alignment_lines:
    count += 1
    l = len(sequence)
    for i in range(1, l - 1):
        if AACheck(sequence[i - 1]) == 1 and AACheck(sequence[i]) == 1 and AACheck(sequence[i + 1]) == 1:
        trimer = sequence[i - 1] + sequence[i] + sequence[i + 1]
        found = 0
        for j in range(len(speed_vec[i])):
            if speed_vec[i][j][0] == trimer:
            found = 1
            speed_vec[i][j][1] = str(int(speed_vec[i][j][1]) + 1)
            break
        if found == 0:
            speed_vec[i][len(speed_vec[i]) - 1][0] = trimer
            speed_vec[i][len(speed_vec[i]) - 1][1] = '1'
            speed_vec[i] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (72 * 72)
    
    total_pos = 0
    for i in range(len(speed_vec)): total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_5x5_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(secseq[k - 1])
                    ss1 = secseq_int(secseq[k])
                       ss2 = secseq_int(secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(72 * 72): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for i in range(N):
    for j in range(72 * 72):
        out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    out_file.close()
    
def SPEED_sampling_profile2(alignment_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path):

    new_secseq = readline(new_secseq_path, 1)
    if prev_secseq_path != 'no': prev_secseq = readline(prev_secseq_path, 1)
    else:
    prev_secseq = ''
    for i in range(len(new_secseq)): prev_secseq += 'X'
    if prev_lib_path != 'no': prev_lib = readlines(prev_lib_path)
    alignment_lines = readlines(alignment_path)

    N = len(new_secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3
    
    count = 0
    for sequence in alignment_lines:
    count += 1
    l = len(sequence)
    for i in range(1, l - 1):
        if AACheck(sequence[i - 1]) == 1 and AACheck(sequence[i]) == 1 and AACheck(sequence[i + 1]) == 1:
        trimer = sequence[i - 1] + sequence[i] + sequence[i + 1]
        found = 0
        for j in range(len(speed_vec[i])):
            if speed_vec[i][j][0] == trimer:
            found = 1
            speed_vec[i][j][1] = str(int(speed_vec[i][j][1]) + 1)
            break
        if found == 0:
            speed_vec[i][len(speed_vec[i]) - 1][0] = trimer
            speed_vec[i][len(speed_vec[i]) - 1][1] = '1'
            speed_vec[i] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (72 * 72)
    
    total_pos = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    print i + 1, len(speed_vec[i]) - 1
        total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_5x5_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            if new_secseq[k - 1] == prev_secseq[k - 1] and new_secseq[k] == prev_secseq[k] and new_secseq[k + 1] == prev_secseq[k + 1]: continue
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(new_secseq[k - 1])
                    ss1 = secseq_int(new_secseq[k])
                       ss2 = secseq_int(new_secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(72 * 72): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for j in range(72 * 72): out_file.write(str(rama_vec[0][j]) + ' ')
    out_file.write('\n')
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: out_file.write(prev_lib[i].strip())
    else:
        for j in range(72 * 72): out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    for j in range(72 * 72): out_file.write(str(rama_vec[N - 1][j]) + ' ')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def substitution_matrix(aa):
    if aa == 'A': return 'A'
    elif aa == 'C': return 'CIVQRK'
    elif aa == 'D': return 'DEKQRH'
    elif aa == 'E': return 'DEKQRH'
    elif aa == 'F': return 'VIF'
    elif aa == 'G': return 'G'
    elif aa == 'H': return 'DEKQRH'
    elif aa == 'I': return 'VIF'
    elif aa == 'K': return 'DEKQRH'
    elif aa == 'L': return 'LM'
    elif aa == 'M': return 'LM'
    elif aa == 'N': return 'N'
    elif aa == 'P': return 'P'
    elif aa == 'Q': return 'DEKQRH'
    elif aa == 'R': return 'DEKQRH'
    elif aa == 'S': return 'S'
    elif aa == 'T': return 'T'
    elif aa == 'V': return 'VIF'
    elif aa == 'W': return 'WYF'
    elif aa == 'Y': return 'WYF'
    
def homology_free_sampling_profile(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path):

    fasta = readline(fasta_path, 2)
    if new_secseq_path != 'no': new_secseq = readline(new_secseq_path, 1)
    else:
    new_secseq = ''
    for i in range(len(fasta)): new_secseq += 'A'
    if prev_secseq_path != 'no': prev_secseq = readline(prev_secseq_path, 1)
    else:
    prev_secseq = ''
    for i in range(len(new_secseq)): prev_secseq += 'X'
    if prev_lib_path != 'no': prev_lib = readlines(prev_lib_path)
    

    N = len(new_secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3

    for aa in range(1, N - 1):
    aa0 = fasta[aa - 1]
    aa1 = fasta[aa]
    aa2 = fasta[aa + 1]
    
    if AACheck(aa0) != 1 or AACheck(aa1) != 1 or AACheck(aa2) != 1:
        print "ERROR! Unknown amino acid"
        return
    
    subs_str0 = substitution_matrix(aa0)
    subs_str1 = substitution_matrix(aa1)
    subs_str2 = substitution_matrix(aa2)
    
    for subs0 in subs_str0:
        for subs1 in subs_str1:
        for subs2 in subs_str2:
            
                trimer = subs0 + subs1 + subs2
            speed_vec[aa][-1][0] = trimer
            speed_vec[aa][-1][1] = '1'
            speed_vec[aa] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (36 * 36)
    
    total_pos = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    print i + 1, len(speed_vec[i]) - 1
        total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_10x10_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            if new_secseq[k - 1] == prev_secseq[k - 1] and new_secseq[k] == prev_secseq[k] and new_secseq[k + 1] == prev_secseq[k + 1]: continue
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(new_secseq[k - 1])
                    ss1 = secseq_int(new_secseq[k])
                       ss2 = secseq_int(new_secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(36 * 36): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for j in range(36 * 36): out_file.write(str(rama_vec[0][j]) + ' ')
    out_file.write('\n')
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: out_file.write(prev_lib[i].strip())
    else:
        for j in range(36 * 36): out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    for j in range(36 * 36): out_file.write(str(rama_vec[N - 1][j]) + ' ')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def homology_free_sampling_profile_custom_subs(fasta_path, subs_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path):

    fasta = readline(fasta_path, 2)
    if new_secseq_path != 'no': new_secseq = readline(new_secseq_path, 1)
    else:
    new_secseq = ''
    for i in range(len(fasta)): new_secseq += 'A'
    if prev_secseq_path != 'no': prev_secseq = readline(prev_secseq_path, 1)
    else:
    prev_secseq = ''
    for i in range(len(new_secseq)): prev_secseq += 'X'
    if prev_lib_path != 'no': prev_lib = readlines(prev_lib_path)
    
    subs_lines = readlines(subs_path)
    subs_matrix = []
    for line in subs_lines: subs_matrix.append(line.strip())

    N = len(new_secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3

    for aa in range(1, N - 1):
    aa0 = fasta[aa - 1]
    aa1 = fasta[aa]
    aa2 = fasta[aa + 1]
    
    if AACheck(aa0) != 1 or AACheck(aa1) != 1 or AACheck(aa2) != 1:
        print "ERROR! Unknown amino acid"
        return
    
    subs_str0 = subs_matrix[aa - 1]
    subs_str1 = subs_matrix[aa]
    subs_str2 = subs_matrix[aa + 1]
    
    for subs0 in range(len(subs_str0)):
        for subs1 in range(len(subs_str1)):
        for subs2 in range(len(subs_str2)):
            
                trimer = subs_str0[subs0] + subs_str1[subs1] + subs_str2[subs2]
            speed_vec[aa][-1][0] = trimer
            speed_vec[aa][-1][1] = '1'
            speed_vec[aa] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (72 * 72)
    
    total_pos = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    print i + 1, len(speed_vec[i]) - 1
        total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_5x5_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            if new_secseq[k - 1] == prev_secseq[k - 1] and new_secseq[k] == prev_secseq[k] and new_secseq[k + 1] == prev_secseq[k + 1]: continue
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(new_secseq[k - 1])
                    ss1 = secseq_int(new_secseq[k])
                       ss2 = secseq_int(new_secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(72 * 72): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for j in range(72 * 72): out_file.write(str(rama_vec[0][j]) + ' ')
    out_file.write('\n')
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: out_file.write(prev_lib[i].strip())
    else:
        for j in range(72 * 72): out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    for j in range(72 * 72): out_file.write(str(rama_vec[N - 1][j]) + ' ')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def homology_free_sampling_profile_no_sub(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path):

    fasta = readline(fasta_path, 2)
    if new_secseq_path != 'no': new_secseq = readline(new_secseq_path, 1)
    else:
    new_secseq = ''
    for i in range(len(fasta)): new_secseq += 'A'
    if prev_secseq_path != 'no': prev_secseq = readline(prev_secseq_path, 1)
    else:
    prev_secseq = ''
    for i in range(len(new_secseq)): prev_secseq += 'X'
    if prev_lib_path != 'no': prev_lib = readlines(prev_lib_path)
    fasta = readline(fasta_path, 2)

    N = len(new_secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3

    for aa in range(1, N - 1):
    aa0 = fasta[aa - 1]
    aa1 = fasta[aa]
    aa2 = fasta[aa + 1]
    
    if AACheck(aa0) != 1 or AACheck(aa1) != 1 or AACheck(aa2) != 1:
        print "ERROR! Unknown amino acid"
        return
    
    subs_str0 = aa0
    subs_str1 = aa1
    subs_str2 = aa2
    
    for subs0 in subs_str0:
        for subs1 in subs_str1:
        for subs2 in subs_str2:
            
                trimer = subs0 + subs1 + subs2
            speed_vec[aa][-1][0] = trimer
            speed_vec[aa][-1][1] = '1'
            speed_vec[aa] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (72 * 72)
    
    total_pos = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    print i + 1, len(speed_vec[i]) - 1
        total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_5x5_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            if new_secseq[k - 1] == prev_secseq[k - 1] and new_secseq[k] == prev_secseq[k] and new_secseq[k + 1] == prev_secseq[k + 1]: continue
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(new_secseq[k - 1])
                    ss1 = secseq_int(new_secseq[k])
                       ss2 = secseq_int(new_secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(72 * 72): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for j in range(72 * 72): out_file.write(str(rama_vec[0][j]) + ' ')
    out_file.write('\n')
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: out_file.write(prev_lib[i].strip())
    else:
        for j in range(72 * 72): out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    for j in range(72 * 72): out_file.write(str(rama_vec[N - 1][j]) + ' ')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def hfree_rama_dist(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path):

    fasta = readline(fasta_path, 2)
    if new_secseq_path != 'no': new_secseq = readline(new_secseq_path, 1)
    else:
    new_secseq = ''
    for i in range(len(fasta)): new_secseq += 'A'
    if prev_secseq_path != 'no': prev_secseq = readline(prev_secseq_path, 1)
    else:
    prev_secseq = ''
    for i in range(len(new_secseq)): prev_secseq += 'X'
    if prev_lib_path != 'no': prev_lib = readlines(prev_lib_path)
    fasta = readline(fasta_path, 2)

    N = len(new_secseq)
    speed_vec = [None] * N
    for i in range(N): 
    speed_vec[i] = [None]
    speed_vec[i][0] = [''] * 3

    for aa in range(1, N - 1):
    aa0 = fasta[aa - 1]
    aa1 = fasta[aa]
    aa2 = fasta[aa + 1]
    
    if AACheck(aa0) != 1 or AACheck(aa1) != 1 or AACheck(aa2) != 1:
        print "ERROR! Unknown amino acid"
        return
    
    subs_str0 = aa0
    subs_str1 = aa1
    subs_str2 = aa2
    
    for subs0 in subs_str0:
        for subs1 in subs_str1:
        for subs2 in subs_str2:
            
                trimer = subs0 + subs1 + subs2
            speed_vec[aa][-1][0] = trimer
            speed_vec[aa][-1][1] = '1'
            speed_vec[aa] += [[''] * 3]
            
    rama_vec = [None] * N
    for i in range(N): rama_vec[i] = [0] * (36 * 36)
    
    total_pos = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    print i + 1, len(speed_vec[i]) - 1
        total_pos += (len(speed_vec[i]) - 1)
    tally = total_pos
    
    print total_pos
    
    total_trimers = 0
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: continue
    for j in range(len(speed_vec[i])):
        if speed_vec[i][j][2] == '':
        total_trimers += 1
        print str(total_trimers) + ' unique trimers found'
        print str(100.0 - (float(tally) / float(total_pos)) * 100.0) + '% finished'
        trimer = speed_vec[i][j][0]
        if trimer == '': continue
        pickle_path = os.path.join('/home/secoops/web/rama_10x10_pickles', trimer + '.pickle')
        if not os.path.exists(pickle_path): continue
        pickle_file = open(pickle_path, 'rb')
        try:
            rama_bins = pickle.load(pickle_file)
        except:
            pickle_file.close()
            continue
        pickle_file.close()
            
        for k in range(1, N - 1):
            if new_secseq[k - 1] == prev_secseq[k - 1] and new_secseq[k] == prev_secseq[k] and new_secseq[k + 1] == prev_secseq[k + 1]: continue
            for l in range(len(speed_vec[k])):
            if speed_vec[k][l][0] == trimer and speed_vec[k][l][2] == '':
                 
                ss0 = secseq_int(new_secseq[k - 1])
                    ss1 = secseq_int(new_secseq[k])
                       ss2 = secseq_int(new_secseq[k + 1])
        
                    ss_list = [ss0, ss1, ss2]
                    secseq_index = baseX2Dec(ss_list, 6)
                   
                for m in range(36 * 36): rama_vec[k][m] += (int(speed_vec[k][l][1]) * rama_bins[secseq_index][m])
                
                speed_vec[k][l][2] = '1'
                
                if tally > 0: tally -= 1
        
    out_file = open(out_path, 'w')
    for j in range(36 * 36): out_file.write(str(rama_vec[0][j]) + ' ')
    out_file.write('\n')
    for i in range(1, N - 1):
    if new_secseq[i - 1] == prev_secseq[i - 1] and new_secseq[i] == prev_secseq[i] and new_secseq[i + 1] == prev_secseq[i + 1]: out_file.write(prev_lib[i].strip())
    else:
        for j in range(36 * 36): out_file.write(str(rama_vec[i][j]) + ' ')
    out_file.write('\n')
    for j in range(36 * 36): out_file.write(str(rama_vec[N - 1][j]) + ' ')
    out_file.close()
    
    out_dir = os.path.split(out_path)[0]
    out_name = os.path.split(out_path)[1]
    name = out_name.split('.')[0]
    probs_out_path = os.path.join(out_dir, name + '.rama_map')
    index_out_path = os.path.join(out_dir, name + '.rama_index')
    
    SPEED_sampling_par(out_path, probs_out_path, index_out_path)
    
def SPEED_sampling_par(profile_path, probs_out_path, index_out_path):
    
    profile_file = open(profile_path, 'r')
    profile = profile_file.readlines()
    profile_file.close()
    
    probs_file = open(probs_out_path, 'w')
    index_file = open(index_out_path, 'w')
    
    for line in profile:
    rama_map = line.strip()
    rama_map = rama_map.split()
    N = len(rama_map)
    rama_vec = [None] * N
    total = 0.0
    for i in range(N): 
        rama_vec[i] = [0.0] * 2
        rama_vec[i][1] = float(i)
        total += float(rama_map[i])
    for i in range(N):
        if total > 0.0: rama_vec[i][0] = float(rama_map[i]) / total
        else: rama_vec[i][0] = 0.0
        
    rama_vec.sort()
    rama_vec.reverse()
    
    for i in range(N):
        probs_file.write(str(rama_vec[i][0]) + ' ')
        index_file.write(str(int(rama_vec[i][1])) + ' ')
        
    probs_file.write('\n')
    index_file.write('\n')
    
    probs_file.close()
    index_file.close()
    
def choose_directions(profile_path, out_dir):
    
    profile_file = open(profile_path, 'r')
    profile = profile_file.readlines()
    profile_file.close()
    L = len(profile)
    
    name = os.path.split(profile_path)[1].split('.')[0]
    probs_file = open(os.path.join(out_dir, name + '.rama_map'), 'w')
    index_file = open(os.path.join(out_dir, name + '.rama_index'), 'w')
    rama_file = open(os.path.join(out_dir, name + '.rama'), 'w')
    
    line_count = 0
    for line in profile:
    line_count += 1
    
    rama_line = line.strip().split()
    N = len(rama_line)
    rama_map = []
    
    rama_vec = [None] * N
    total = 0.0
    res_int = int(math.sqrt(N))
    
    L_count = 0
    R_count = 0
    
    for i in range(res_int):
        for j in range(res_int): 
            if j < int(float(res_int / 2)): L_count += int(rama_line[i * res_int + j])
        else: R_count += int(rama_line[i * res_int + j])
            
    L_probs = 0.0
    R_probs = 0.0
    
    if (L_count + R_count > 0):
        L_probs = float(L_count) / float(L_count + R_count)
        R_probs = float(R_count) / float(L_count + R_count)
        
    for i in range(res_int):
        for j in range(res_int):
        if R_probs > 0.50 and line_count > 6 and line_count < L - 6:
            if j >= int(float(res_int / 2)): rama_map.append(rama_line[i * res_int + j])
            else: rama_map.append('0')
        else: rama_map.append(rama_line[i * res_int + j])
    
    for i in range(res_int):
        for j in range(res_int): 
            rama_vec[i * res_int + j] = [0.0] * 2
            rama_vec[i * res_int + j][1] = float(i * res_int + j)
            total += float(rama_map[i * res_int + j])
        
    for i in range(res_int):
        for j in range(res_int): 
            if total > 0.0: rama_vec[i * res_int + j][0] = float(rama_map[i * res_int + j]) / total
        
    rama_vec.sort()
    rama_vec.reverse()
    
    for i in range(N):
        rama_file.write(str(rama_map[i]) + ' ')
        probs_file.write(str(rama_vec[i][0]) + ' ')
        index_file.write(str(int(rama_vec[i][1])) + ' ')
        
    probs_file.write('\n')
    index_file.write('\n')
    rama_file.write('\n')
    
    probs_file.close()
    index_file.close()
    rama_file.close()
    
def density(hist_obj, from_value, to_value, num_points = 100):
    heights, cuts = hist_obj[:2]
    x_values = []
    bin_size = cuts[1] - cuts[0]
    for i in xrange(len(cuts)):
        x_values.append(cuts[i] + bin_size / 2.0)
    x_values = array(x_values)
    spl_obj = interpolate.splrep(x_values, heights)
    x_pred = linspace(from_value, to_value, num_points)
    y_pred = interpolate.splev(x_pred, spl_obj, der = 0)
    return x_pred, y_pred
    
def file_to_string(file_path):
    file = open(file_path, 'r')
    file_lines = file.readlines()
    file.close()
    
    file_string = ''
    for i in range(len(file_lines)):
    for j in range(len(file_lines[i])): file_string += file_lines[i][j]
    
    return file_string
    
def tsp_BFactor(val):
    if val >= 10: return 100.0
    elif val >= 0 and val < 10.0: return (50.0 + (val / 10.0) * 50.0)
    elif val < -7: return 0.0
    elif val < 0.0 and val >= -7.0: return (50.0 + (val / 7.0) * 50.0)
    
def tsp_diff_BFactor(val):
    if val >= 10: return 100.0
    elif val >= 0 and val < 10.0: return (50.0 + (val / 10.0) * 50.0)
    elif val < -10: return 0.0
    elif val < 0.0 and val >= -10.0: return (50.0 + (val / 10.0) * 50.0)
    
def RU_stats(list_path):

    list_file = open(list_path, 'r')
    lines = list_file.readlines()
    list_file.close()
    
    count = 0
    for line in lines:
        
    line0 = line.strip()
    name = os.path.split(line0)[1]
    pdb_path = os.path.join(line0, name + '.pdb')
    if os.path.exists(pdb_path):
        count = count + 1
        ru = RUcalc(pdb_path)
        if ru > 4.2:
            print name, ru
        
def find_chain_breaks(pdb_path, out_path):
    
    lines = readlines(pdb_path)
    
    pdb_lines = []
    for line in lines:
    if (line[0:4] == 'ATOM' and ResidueVerify(line[17:20].strip()) > 0) or (line[0:6] == 'HETATM' and line[17:20] == 'MSE'): pdb_lines += [line]
        
    out_vec = []
    pos = int(pdb_lines[0][23:28])
    chain_str = pdb_lines[0][21:22]
    if len(chain_str.strip()) == 0: chain_str = '0'
    out_vec += [[str(1), str(pos), chain_str, '1']]
    count = 1
    for i in range(len(pdb_lines)):
    pos_new = int(pdb_lines[i][23:28])
    chain_str = pdb_lines[i][21:22]
    if len(chain_str.strip()) == 0: chain_str = '0'
    if pos_new != pos:
        count += 1
        if pos_new != pos + 1: 
            break_str = '1'
        out_vec[count - 2][3] = '1' 
        else: break_str = '0'
        out_vec += [[str(count), str(pos_new), chain_str, break_str]]
        
    pos = pos_new
    
    out_vec[count - 1][3] = '1'
    
    out_file = open(out_path, 'w')
    for i in range(len(out_vec)):
        out_file.write(out_vec[i][0] + '\t' + out_vec[i][1] + '\t' + out_vec[i][2] + '\t' + out_vec[i][3] + '\n')
    out_file.close()
    
def readlines(file_path):
    
    file = open(file_path, 'r')
    lines = file.readlines()
    file.close()
    return lines

def writelines(file_path, string):
    
    file = open(file_path, 'w')
    file.write(string)
    file.close()

def readline(file_path, line_int):
    
    file = open(file_path, 'r')
    lines = file.readlines()
    file.close()
    return lines[line_int - 1].strip()

def log_energy(log_path):
    lines = readlines(log_path)
    l = len(lines)
    i = l - 1
    while i > 0:
    if len(lines[i].split()) == 3:
        if lines[i].split()[0] == 'TOTAL' and lines[i].split()[1] == 'ENERGY:': return float(lines[i].split()[2])
    i -= 1
        
def rmsd(pdb1_path, pdb2_path):

    os.chdir('/home/secoops/test/clOOPS-0.9.6-BETA1-src/bin')
    tmp_fn = tempfile.mktemp('.rmsd')
    os.system('./scalc -cfg ../prj/SECsamplerSC/cfg/scalc.cfg -str ' + pdb1_path + ' -str ' + pdb2_path + ' -calc calc/libRMSDcalc.so > ' + tmp_fn)
        
    ifile = open(tmp_fn, 'r')
    rmsd = ifile.readline()
    rmsd = float(rmsd.strip())
    ifile.close()
    os.remove(tmp_fn)
    os.chdir('/home/secoops/web')
    
    return rmsd
    
def coyote_rmsd(pdb1_path, pdb2_path):
  
    os.chdir('/home/bartolo/web/haipeng/web')
    tmp_fn = coyote_temp('.rmsd')
    os.system('./scalc -cfg scalc.cfg -str ' + pdb1_path + ' -str ' + pdb2_path + ' -calc libRMSDcalc.so > ' + tmp_fn)
        
    rmsd = float(readline(tmp_fn, 1))
    os.remove(tmp_fn)
    
    return rmsd
    
def coyote_SASA(pdb_path):
  
    os.chdir('/home/bartolo/web/haipeng/web')
    tmp_fn = coyote_temp('.sasa')
    os.system('./scalc -cfg scalc.cfg -str ' + pdb_path + ' -calc libASAcalc.so > ' + tmp_fn)
        
    sasa = []
    sasa_lines = readlines(tmp_fn)
    for i in range(len(sasa_lines) - 1):
        sasa.append(float(sasa_lines[i].split()[1]))
    os.remove(tmp_fn)
    
    return sasa
    
def residue_SASA(pdb_path):
  
    os.chdir('/home/bartolo/web/haipeng/web')
    tmp_fn = '/home/bartolo/web/temp_' + str(random.randint(1, 100000)) + '.txt'
    os.system('./scalc -cfg scalc.cfg -str ' + pdb_path + ' -calc libASAcalc.so > ' + tmp_fn)
        
    sasa = []
    sasa_lines = readlines(tmp_fn)
    for i in range(len(sasa_lines) - 1):
        sasa.append(float(sasa_lines[i].split()[1]))
    os.remove(tmp_fn)
    
    return sasa
    
def interacting_pairs(preset_path):
  
    pdb_path = preset_path + '.pdb'
    res_path = preset_path + '.res'
    ip_path = preset_path + '.ip'
    mask_path = preset_path + '.mask'
    
    ip_file = open(ip_path, 'w')
    
    lines = readlines(pdb_path)
    pdb = []
    for line in lines: pdb.append(line)
    
    resdata = lines2list(res_path)
    res = []
    for i in range(len(resdata)): res.append(resdata[i][0])
    
    maskdata = lines2list(mask_path)
    mask = []
    for i in range(len(maskdata)): mask.append(maskdata[i][0])
    
    pdb_tree = []
    L = 0
    for i in range(len(pdb)):
        line = pdb[i]
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
            L += 1
            pdb_tree.append([])
            
    for i in range(len(pdb)):
        line = pdb[i]
        if line[0:4] == 'ATOM':
        position = int(line[22:28].strip()) - 1
        if not line[13:15].strip() in ['N', 'C', 'O']: pdb_tree[position].append(line)
        
    for i in range(L):
        for k in range(len(pdb_tree[i])):
            pline = []
            for j in range(len(pdb_tree[i][k])): pline.append(pdb_tree[i][k][j])
            for j in range(6): pline[22 + j] = ''
            nint = 1
            sint = str(nint)
            lint = len(sint)
            for j in range(lint): pline[25 + j] = sint[-1 * j - 1]
            nline = ''
            for j in range(len(pline)):
            if len(pline[j]) == 0: nline += ' '
            else: nline += pline[j]
            pdb_tree[i][k] = nline
          
    pos_sasa = []
    for i in range(L):
        op = '/home/bartolo/web/res_sasa_' + str(random.randint(1, 100000)) + '.pdb'
        of = open(op, 'w')
        for k in range(len(pdb_tree[i])): of.write(pdb_tree[i][k])
        of.close()
        res_sasa = residue_SASA(op)
        os.remove(op)
        pos_sasa.append(float(res_sasa[0]))

    for i in range(L):
        for j in range(i + 1, L):
        if not i + 1 in res and not j + 1 in res: continue
        if i + 1 in mask or j + 1 in mask: continue
        if i + 1 in res and j + 1 in res: continue
        op = '/home/bartolo/web/res_sasa_' + str(random.randint(1, 100000)) + '.pdb'
        of = open(op, 'w')
        for k in range(len(pdb_tree[i])): of.write(pdb_tree[i][k])
        for k in range(len(pdb_tree[j])):
        pline = []
        for l in range(len(pdb_tree[j][k])): pline.append(pdb_tree[j][k][l])
        for l in range(6): pline[22 + l] = ''
        nint = 2
        sint = str(nint)
        lint = len(sint)
        for l in range(lint): pline[25 + l] = sint[-1 * l - 1]
        nline = ''
        for l in range(len(pline)):
            if len(pline[l]) == 0: nline += ' '
            else: nline += pline[l]
        of.write(nline)
        of.close()
        res_sasa = residue_SASA(op)
        os.remove(op)
        
        if pos_sasa[i] - res_sasa[0] > 10.0 and pos_sasa[j] - res_sasa[1] > 10.0:
            
            ip_file.write(str(i + 1) + '\t' + str(j + 1) + '\n')
    ip_file.close()
        
    
def buried_apolar_SA(pdb_path, res_path):
  
    print pdb_path
  
    res_vec = []
    res_lines = readlines(res_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
        
    sasa_pdb_path = coyote_temp('.pdb')
    TruncatePolar(pdb_path, sasa_pdb_path)

    sequence = FASTA_from_structure(pdb_path)
    sasa = coyote_SASA(sasa_pdb_path)
    os.remove(sasa_pdb_path)
    tot_asa = 0.0
    tot_bsa = 0.0
    
    if len(sequence) != len(sasa):
        print 'unequal lengths'
        return
    
    for i in res_vec:
      
        if sequence[i] in ['A', 'F', 'I', 'L', 'V', 'W', 'Y']:
            tot_sa = tmax_sasa(AAChar_int(sequence[i]))
            asa = sasa[i]
            bsa = tot_sa - asa
            tot_asa += asa
            tot_bsa += bsa
            
            #print i + 1, asa, bsa
        
    return float(str(-1.0 * math.log(tot_bsa))[0:5])
    
def EnergyRmsdPlot(pdb_dir, native_path):
    
    data1_path = os.path.join(pdb_dir, 'energy.txt')
    data2_path = os.path.join(pdb_dir, 'rmsd.txt')
    log_path = os.path.join(pdb_dir, 'prediction.txt')
    gif_path = os.path.join(pdb_dir, 'energy_rmsd.gif')
    
    data1_file = open(data1_path, 'w')
    data2_file = open(data2_path, 'w')
    log_file = open(log_path, 'w')
    
    pdb_list = os.listdir(pdb_dir)
    for file_name in pdb_list:
    label = file_name.split('.')[0]
    ext = file_name.split('.')[1]
    if ext == 'pdb':
        name = label.split('-')[0]
        num = label.split('-')[1]
        pdb_path = os.path.join(pdb_dir, file_name)
        log_dir = pdb_dir + '/../log'
        log_path = os.path.join(log_dir, name + '-oops-' + num + '.log')
        energy = log_energy(log_path)
        #energy = PhiPsi_rmsd(pdb_path, native_path)
        rmsd_val = rmsd(pdb_path, native_path)
        data1_file.write(str(energy) + '\n')
        data2_file.write(str(rmsd_val) + '\n')
        log_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
    data1_file.close()
    data2_file.close()
    log_file.close()
    
    title = 'Folding scatter plot'
    x_label = 'rmsd'
    y_label = 'energy'
    
    PY_scatterplot(data2_path, data1_path, title, x_label, y_label, gif_path)
    
def just_rmsd(pdb_dir, native_path, pred_path):
    
    data_file = open(pred_path, 'w')
    
    pdb_list = os.listdir(pdb_dir)
    for file_name in pdb_list:
    label = file_name.split('.')[0]
    ext = file_name.split('.')[1]
    if ext == 'pdb':
        name = label.split('-')[0]
        num = label.split('-')[1]
        pdb_path = os.path.join(pdb_dir, file_name)
        log_dir = pdb_dir + '/../log'
        log_path = os.path.join(log_dir, name + '-oops-' + num + '.log')
        energy = log_energy(log_path)
        #energy = PhiPsi_rmsd(pdb_path, native_path)
        rmsd_val = rmsd(pdb_path, native_path)
        data1_file.write(str(energy) + '\n')
        data2_file.write(str(rmsd_val) + '\n')
        log_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
    pred_file.close()
    
def RCORmsdPlot(pdb_dir, native_path, gif_path):
    
    data1_path = os.path.join(pdb_dir, 'rco.txt')
    data2_path = os.path.join(pdb_dir, 'rmsd.txt')
    log_path = os.path.join(pdb_dir, 'rco_prediction.txt')
    
    data1_file = open(data1_path, 'w')
    data2_file = open(data2_path, 'w')
    log_file = open(log_path, 'w')
    
    pdb_list = os.listdir(pdb_dir)
    for file_name in pdb_list:
    label = file_name.split('.')[0]
    ext = file_name.split('.')[1]
    if ext == 'pdb':
        name = label.split('-')[0]
        num = label.split('-')[1]
        pdb_path = os.path.join(pdb_dir, file_name)
        log_dir = pdb_dir + '/../log'
        log_path = os.path.join(log_dir, name + '-oops-' + num + '.log')
        energy = RCO(pdb_path)
        rmsd_val = rmsd(pdb_path, native_path)
        data1_file.write(str(energy) + '\n')
        data2_file.write(str(rmsd_val) + '\n')
        log_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
    data1_file.close()
    data2_file.close()
    log_file.close()
    
    title = 'RCO scatter plot'
    x_label = 'rmsd'
    y_label = 'RCO'
    
    PY_scatterplot(data2_path, data1_path, title, x_label, y_label, gif_path)
    
def RUrmsdPlot(pdb_dir, native_path, gif_path):
    
    data1_path = os.path.join(pdb_dir, 'ru.txt')
    data2_path = os.path.join(pdb_dir, 'rmsd.txt')
    log_path = os.path.join(pdb_dir, 'ru_prediction.txt')
    
    data1_file = open(data1_path, 'w')
    data2_file = open(data2_path, 'w')
    log_file = open(log_path, 'w')
    
    pdb_list = os.listdir(pdb_dir)
    for file_name in pdb_list:
    label = file_name.split('.')[0]
    ext = file_name.split('.')[1]
    if ext == 'pdb':
        name = label.split('-')[0]
        num = label.split('-')[1]
        pdb_path = os.path.join(pdb_dir, file_name)
        log_dir = pdb_dir + '/../log'
        log_path = os.path.join(log_dir, name + '-oops-' + num + '.log')
        energy = RUcalc(pdb_path)
        rmsd_val = rmsd(pdb_path, native_path)
        data1_file.write(str(energy) + '\n')
        data2_file.write(str(rmsd_val) + '\n')
        log_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
    data1_file.close()
    data2_file.close()
    log_file.close()
    
    title = 'RU scatter plot'
    x_label = 'rmsd'
    y_label = 'RU'
    
    PY_scatterplot(data2_path, data1_path, title, x_label, y_label, gif_path)
    
def EnergyRmsdPlot2Round(pdb_dir, native_path, gif_path):
    
    data1_path = os.path.join(pdb_dir, 'energy1.txt')
    data2_path = os.path.join(pdb_dir, 'rmsd1.txt')
    log_path = os.path.join(pdb_dir, 'prediction1.txt')
    
    data1_file = open(data1_path, 'w')
    data2_file = open(data2_path, 'w')
    log_file = open(log_path, 'w')
    
    data3_path = os.path.join(pdb_dir, 'energy2.txt')
    data4_path = os.path.join(pdb_dir, 'rmsd2.txt')
    log2_path = os.path.join(pdb_dir, 'prediction2.txt')
    
    data3_file = open(data3_path, 'w')
    data4_file = open(data4_path, 'w')
    log2_file = open(log2_path, 'w')
    
    round1_dir = os.path.join(pdb_dir, '../round1')
    if not os.path.exists(round1_dir): os.mkdir(round1_dir)
    
    pdb_list = os.listdir(pdb_dir)
    for file_name in pdb_list:
    label = file_name.split('.')[0]
    ext = file_name.split('.')[1]
    if ext == 'pdb':
        name = label.split('-')[0]
        num = label.split('-')[1]
        pdb_path = os.path.join(pdb_dir, file_name)
        log_dir = pdb_dir + '/../log'
        log_path = os.path.join(log_dir, name + '-oops-' + num + '.log')
        energy = log_energy(log_path)
        rmsd_val = rmsd(pdb_path, native_path)
        data1_file.write(str(energy) + '\n')
        data2_file.write(str(rmsd_val) + '\n')
        log_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
        
        model_num = log_minima(log_path)
        traj_dir = pdb_dir + '/../'
        pdt_path = os.path.join(traj_dir, label + '.pdt.gz')
        model_path = os.path.join(round1_dir, file_name)
        if os.path.exists(pdt_path):
        os.system('gunzip ' + pdt_path)
        zip_path = os.path.join(traj_dir, label + '.pdt')
        pull_model(zip_path, model_num, model_path)
        os.system('gzip ' + zip_path)
        rmsd_val = rmsd(model_path, native_path)
        energy = energy_minima(log_path)
            data3_file.write(str(energy) + '\n')
            data4_file.write(str(rmsd_val) + '\n')
            log2_file.write(label + '\t' + str(rmsd_val) + '\t' + str(energy) + '\n')
        
        
    data1_file.close()
    data2_file.close()
    log_file.close()
    
    data3_file.close()
    data4_file.close()
    log2_file.close()
    
    gif_file_name = os.path.split(gif_path)[1]
    gif_dir = os.path.split(gif_path)[0]
    gif_name = gif_file_name.split('.')[0]
    
    title = 'T1af7 models after DblCrank with DOPE_PW'
    x_label = 'rmsd'
    y_label = 'DOPE_PW'
    PY_scatterplot(data2_path, data1_path, title, x_label, y_label, os.path.join(gif_dir, gif_name + '_dc.gif'))
    
    title = 'T1af7 models after folding with DOPE_PW'
    x_label = 'rmsd'
    y_label = 'DOPE_PW' 
    PY_scatterplot(data4_path, data3_path, title, x_label, y_label, gif_path)
    
def pull_model(pdt_path, model_num, pdb_path):

    lines = readlines(pdt_path)

    pdb_file = open(pdb_path, 'w')

    found_model = 'False'
    for i in range(len(lines)):
        if lines[i].strip()[0] == '': continue
        if lines[i].split()[0] == 'MODEL':
        if int(lines[i].split()[1]) == model_num:
            found_model = 'True'
        continue
        if found_model == 'True': pdb_file.write(lines[i])
    if found_model == 'True' and lines[i].split()[0] == 'ENDMDL': break

    pdb_file.close()

def energy_minima(log_path):
    
    lines = readlines(log_path)
    for i in range(len(lines)):
        if lines[i].strip() == '': continue
    if lines[i].split()[0] == 'Final': return float(lines[i + 2].split()[2])
    
def log_minima(log_path):
    
    lines = readlines(log_path)
    minima = 0
    for i in range(len(lines)):
        if lines[i].strip() == '': continue
    if lines[i].split()[0] == 'Minimum': minima += 1
    if lines[i].split()[0] == 'Final': return minima
        
def CA_vec(pdb_path):
    
    CA_vec = []
    lines = readlines(pdb_path)
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA': CA_vec += [line]
    return CA_vec
        
def backbone(pdb_path):
    
    tmp_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + pdb_path + ' > ' + tmp_path)
    back_lines = readlines(tmp_path)
    os.remove(tmp_path)
    return back_lines

def phi_psi_listing(pdb_path):
    phi_psi_vec = []
    back_lines = backbone(pdb_path)
    for i in range(len(back_lines)):
    back_line = back_lines[i].split()
    phi_psi_vec.append([])
    phi = float(back_line[3])
    psi = float(back_line[4])
    phi_psi_vec[i].append(phi)
    phi_psi_vec[i].append(psi)
    return phi_psi_vec
        
def N_res(pdb_path):
    
    CA_vec = []
    lines = readlines(pdb_path)
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA': CA_vec += [line]
    return len(CA_vec)
        
def CB_vec(pdb_path):
    
    CB_vec = []
    lines = readlines(pdb_path)
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CB': CB_vec += [line]
        if line[17:20] == 'GLY' and line[13:15] == 'CA': CB_vec += [line]
    return CB_vec
        
def CB_distances(pdb_path, out_path):
    
    CB_coord = CB_coord_vec(pdb_path)
    CA = CA_vec(pdb_path)
    L = len(CB_coord)
    
    out_file = open(out_path, 'w')
    
    for i in range(L):
    for j in range(i + 1, L):
        if CA[i][17:20] != 'GLY' and CA[j][17:20] != 'GLY':
            dist = distance(CB_coord[i], CB_coord[j])
        out_file.write(str(i) + '\t' + str(j) + '\t' + str(dist) + '\n')
    out_file.close()

def CA_distances(pdb_path, out_path):
    
    CA_coord = coord_vec(pdb_path)
    L = len(CA_coord)
    
    out_file = open(out_path, 'w')
    
    for i in range(L):
    for j in range(i + 1, L):
        dist = distance(CA_coord[i], CA_coord[j])
        out_file.write(str(i) + '\t' + str(j) + '\t' + str(dist) + '\n')
    out_file.close()

def cluster_contact_energy(cce_path, native_path):

    lines = readlines(cce_path)
    CA_list = CA_vec(native_path)
    L = len(CA_list)

    CA_matrix = []
    for i in range(L):
        CA_matrix.append([])
    for j in range(L): CA_matrix[i].append(0)

    for k in range(L):
        for l in range(k + 6, L):
            CA_dist = math.sqrt( ((float(CA_list[k][30:38]) - float(CA_list[l][30:38])) ** 2) + ((float(CA_list[k][39:46]) - float(CA_list[l][39:46])) ** 2) + ((float(CA_list[k][47:54]) - float(CA_list[l][47:54])) ** 2) )
        if CA_dist < 8.0:
            CA_matrix[k][l] += 1

    e_total = 0.0
    for i in range(len(lines)):
        line = lines[i].split()
        k = int(line[0]) - 1
    l = int(line[1]) - 1
    dist = float(line[2]) - 1
    if dist < 8.0 and CA_matrix[k][l] == 1:
        e_total -= 100.00
        #print k + 1, l + 1, dist
    return e_total
    
def cluster_prediction(in_dir, cluster_int):

    lines = readlines(os.path.join(in_dir, 'cluster_4_analysis.txt'))
    pred_file = open(os.path.join(in_dir, 'cluster_pred.txt'), 'w')
    
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pred_file.write(lines[j].split()[0] + '\t' + lines[j].split()[1] + '\t' + lines[j].split()[2] + '\n')
        else:
            select = True 
            break
    if select: break

    pred_file.close()

def analyze_refined_cluster(in_dir, cluster_int, pred_path):

    name = os.path.split(in_dir)[1]

    lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: 
            pdb_list.append([lines[j].split()[0], lines[j].split()[1]])
        else:
            select = True 
            break
    if select: break
    
    L = len(pdb_list)
    
    data = []
    # 0:name, 1:native rmsd, 2:ave refined rmsd, 3: ave refined energy, 4: model count, 5:lowest energy, 6: lowest rmsd
    for i in range(L): data.append([pdb_list[i][0], pdb_list[i][1], 0.0, 0.0, 0.0, 0.0, 0.0])

    pred_lines = readlines(pred_path)
    N = len(pred_lines)
    
    for i in range(N):
    line = pred_lines[i].split()
    num = line[0].split('-')[1]
    if (float(num) / 100.0) % 1.0 > 0.0 : idx = int(float(num) / 100.0)
        else: idx = int(float(num) / 100.0) - 1

    if float(line[2]) < 0.0:
        data[idx][2] += float(line[1])
        data[idx][3] += float(line[2])
        data[idx][4] += 1.0
        
        if float(line[2]) < data[idx][5]:
        data[idx][5] = float(line[2])
        data[idx][6] = float(line[1])
    
    for i in range(L):
    if data[i][4] > 0.0:
        data[i][2] = data[i][2] / data[i][4]
        data[i][3] = data[i][3] / data[i][4]
    
    out_file = open(os.path.join(in_dir, 'refined_cluster.txt'), 'w')
    for i in range(L):
    out_file.write(data[i][0] + '\t' + data[i][1] + '\t' + str(data[i][2]) + '\t' + str(data[i][3]) + '\t' + str(data[i][6]) + '\n')
    out_file.close()
    
def cluster_ave_rmsd(in_dir, cluster_int):

    lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    select = False
    count = 0.0
    rmsd = 0.0
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4:
            count += 1.0
            rmsd += float(lines[j].split()[1])
        else:
            select = True 
            break
    if select: break
    
    print rmsd / count
    
def refine_clusters(in_dir, cluster_int, start_int):
    
    name = os.path.split(in_dir)[1]
    in_path = os.path.join('/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/in', name + '.pdb')
    run_path = '/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC/run.oops'

    lines = readlines(os.path.join(in_dir, 'cluster_5_analysis.txt'))
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break
    
    L = len(pdb_list)
    
    job_list = []
    for i in range(L):
    job_list.append([])
    for j in range(100): job_list[i].append(['', ''])
    
    for i in range(start_int, L):
    start_str = str(i * 100 + 1)
    end_str = str((i + 1) * 100)
    
    temp_path = tempfile.mktemp('.txt')
    temp_file = open(temp_path, 'w')
    
    run_lines = readlines(run_path)
    for line in run_lines:
        if len(line.split()) == 0:
        temp_file.write(line)
        elif line.split()[0] == 'N_RUN0':
        temp_file.write('N_RUN0 = ' + start_str + '\n')
        elif line.split()[0] == 'N_RUN1':
        temp_file.write('N_RUN1 = ' + end_str + '\n')
        else: temp_file.write(line)
    temp_file.close()
     
    os.system('cp ' + temp_path + ' ' + run_path)
    os.remove(temp_path)
         
    os.system('cp ' + pdb_list[i] + ' ' + in_path)
    
    run_oops('/home/secoops/test/clOOPS-0.9.6-BETA1-src/prj/SECsamplerSC')
    
    time.sleep(10)
    while (True):
        print 'Checking series', str(i) + '...'
        temp_path = tempfile.mktemp('.txt')
        os.system('qstat -u secoops | grep MASTER | grep ' + name + ' > ' + temp_path)
        lines = readlines(temp_path)
        os.remove(temp_path)
        for line in lines:
        items = line.split()
        pid = items[0]
        jstat = items[4]
        
        print 'process id:', pid
        print 'status:', jstat
        print
        
        pid_found = False
        for k in range(i + 1):
            for p in range(100):
            if job_list[k][p][0] == pid:
                pid_found = True
                if jstat == 'r' and job_list[k][p][1] != 'r': job_list[k][p][1] = 'r'
                break
            if pid_found: break
            
        if not pid_found:
            for k in range(100):
            if job_list[i][k][0] == '':
                job_list[i][k][0] == pid
                if jstat == 'r': job_list[i][k][1] = 'r'
                break
            
        submit_more = True
        for ids in range(100):
        if job_list[i][ids][1] != 'r':
            submit_more = False
            break
        
        if submit_more: break
        time.sleep(10)

def cluster_cce(in_dir, cluster_int):

    lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    cce_path = os.path.join(in_dir, 'CA_matrix.txt')
    
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break

    for path in pdb_list:
        print path, cluster_contact_energy(cce_path, path)
        
def distance_matrix_cluster(in_dir, cluster_int):
    
    lines = readlines(os.path.join(in_dir, 'cluster_analysis.txt'))
    
    select = False
    pdb_list = []
    for i in range(len(lines)):
    if len(lines[i].split()) < 2: continue
    if lines[i].split()[0] == 'cluster' and int(lines[i].split()[1]) == int(cluster_int):
        for j in range(i + 1 , len(lines)):
            if len(lines[j].split()) > 4: pdb_list.append(os.path.join(in_dir, 'Final/' + lines[j].split()[0] + '.pdb'))
        else:
            select = True 
            break
    if select: break
        
    temp_array = CA_vec(pdb_list[0])
    L = len(temp_array)
    del temp_array
    
    CA_matrix = []
    for i in range(L):
        CA_matrix.append([])
    for j in range(L): CA_matrix[i].append(0.0)
    
    CB_matrix = []
    for i in range(L):
        CB_matrix.append([])
    for j in range(L): CB_matrix[i].append(0.0)
    
    CA_count = []
    for i in range(L):
        CA_count.append([])
    for j in range(L): CA_count[i].append(0)
    
    CB_count = []
    for i in range(L):
        CB_count.append([])
    for j in range(L): CB_count[i].append(0)

    N = len(pdb_list)
    check = True
    for i in range(N):

        pdb_path = pdb_list[i]
    CA_list = CA_vec(pdb_path)
    CB_list = CB_vec(pdb_path)

        for k in range(L):
        for l in range(k + 6, L):
        CA_dist = math.sqrt( ((float(CA_list[k][30:38]) - float(CA_list[l][30:38])) ** 2) + ((float(CA_list[k][39:46]) - float(CA_list[l][39:46])) ** 2) + ((float(CA_list[k][47:54]) - float(CA_list[l][47:54])) ** 2) )
        if CA_dist < 8.0:
            CA_matrix[k][l] += CA_dist
            CA_count[k][l] += 1
        CB_dist = math.sqrt( ((float(CB_list[k][30:38]) - float(CB_list[l][30:38])) ** 2) + ((float(CB_list[k][39:46]) - float(CB_list[l][39:46])) ** 2) + ((float(CB_list[k][47:54]) - float(CB_list[l][47:54])) ** 2) )
        if CA_dist < 8.0:
            CB_matrix[k][l] += CB_dist
            CB_count[k][l] += 1

    print N
    for i in range(L):
    for j in range(i + 6, L):
        
        if CA_count[i][j] > int(float(N) * 0.1): CA_matrix[i][j] = CA_matrix[i][j] / float(CA_count[i][j])
        else: CA_matrix[i][j] = 100.0
        if CB_count[i][j] > int(float(N) * 0.1): CB_matrix[i][j] = CB_matrix[i][j] / float(CB_count[i][j])
        else: CB_matrix[i][j] = 100.0

    out_file = open(os.path.join(in_dir, 'CA_matrix.txt'), 'w')
    for i in range(L):
    for j in range(i + 6, L):
        if CA_matrix[i][j] < 100.0: out_file.write(str(i + 1) + '\t' + str(j + 1) + '\n')
        
    out_file = open(os.path.join(in_dir, 'CB_matrix.txt'), 'w')
    for i in range(L):
    for j in range(i + 6, L):
        if CB_matrix[i][j] < 100.0: out_file.write(str(i + 1) + '\t' + str(j + 1) + '\n')
        
def RCO(pdb_path):
    
    pdb_vec = CA_vec(pdb_path)
    L = len(pdb_vec)
    N = 0
    dS = 0
    for i in range(L):
    for j in range(i + 1, L):
        distance = math.sqrt( ((float(pdb_vec[i][30:38]) - float(pdb_vec[j][30:38])) ** 2) + ((float(pdb_vec[i][39:46]) - float(pdb_vec[j][39:46])) ** 2) + ((float(pdb_vec[i][47:54]) - float(pdb_vec[j][47:54])) ** 2) )
        if distance < 8.0:
        N += 1
        dS += (j - i)
        
    return (float(dS) / (float(L) * float(N)))
        
def StrandPredictor(fasta_path, par_path):
    
    num_bins = 30
    
    sequence = readline(fasta_path, 2)
    l = len(sequence)
    
    strand_vec = [None] * l
    for i in range(l): strand_vec[i] = [-4.0] * l
    
    align_vec = [None] * l
    for i in range(l): align_vec[i] = [0] * l
    
    par_vec = [None] * 20
    for i in range(20):
    par_vec[i] = [None] * 20
        for j in range(20):
        par_vec[i][j] = [None] * 5
        for k in range(5):
        par_vec[i][j][k] = [None] * 5
        for n in range(5):
            par_vec[i][j][k][n] = [0.0] * 30
        
    par_lines = readlines(par_path)
    for i in range(len(par_lines)):
    items = par_lines[i].split()
    if AtomPos(items[1].strip()) < 5 and AtomPos(items[3].strip()) < 5:
        for j in range(30):
            par_vec[AAChar_int(items[0].strip())][AAChar_int(items[2].strip())][AtomPos(items[1].strip())][AtomPos(items[3].strip())][j] = float(items[4 + j])
        
    for pos_i in range(len(sequence)):
    for pos_j in range(pos_i + 2 + 3, l):
        if pos_j + 2 > l - 1: break
        
        align_energy = 0.0
                
        posL_vec = [[pos_i, pos_j + 2], [pos_i + 1, pos_j + 1], [pos_i + 2, pos_j]]
        posR_vec = [[pos_i, pos_j + 1], [pos_i + 1, pos_j], [pos_i + 1, pos_j + 2], [pos_i + 2, pos_j + 1]]
        
        for pos in range(len(posL_vec)):
        i = posL_vec[pos][0]
        j = posL_vec[pos][1]
        
            L_min_energy = 10.0
            for k in range(13):
            energy = par_vec[AAChar_int(sequence[i])][AAChar_int(sequence[j])][AtomPos('CB')][AtomPos('CB')][k]
            if energy < L_min_energy: L_min_energy = energy
        if L_min_energy == 10.0: L_min_energy = 0.0
        align_energy += L_min_energy
        
        for pos in range(len(posR_vec)):
        i = posR_vec[pos][0]
        j = posR_vec[pos][1]
        
            R_min_energy = 10.0
            for k in range(14, 17):
            energy = par_vec[AAChar_int(sequence[i])][AAChar_int(sequence[j])][AtomPos('CB')][AtomPos('CB')][k]
            if energy < R_min_energy: R_min_energy = energy
        if R_min_energy == 10.0: R_min_energy = 0.0
        align_energy += R_min_energy
        strand_vec[pos_i + 1][pos_j + 1] = align_energy
    
    for i in range(1, l - 1):
    for j in range(i + 3, l - 1):
        #print i + 1, j + 1, strand_vec[i][j]
        if (((strand_vec[i][j] - strand_vec[i][j - 1]) < -0.25) and sequence[i] != 'G' and sequence[j - 1] != 'G' and strand_vec[i][j - 1] > -5.5): align_vec[i][j - 1] = 1
        if (((strand_vec[i][j] - strand_vec[i][j + 1]) < -0.25) and sequence[i] != 'G' and sequence[j + 1] != 'G' and strand_vec[i][j + 1] > -5.5): align_vec[i][j + 1] = 1
        
    count = 0
    for i in range(1, l - 1):
    for j in range(i + 3, l - 1):
        count += 1
        if align_vec[i][j] == 1: print 'A ' + str(i + 1) + '-' + str(j + 1)
    print count
    
def StrandPredictorSPEED(fasta_path, par_path):
    
    num_bins = 30
    
    sequence = readline(fasta_path, 2)
    l = len(sequence)
    
    strand_vec = [None] * l
    for i in range(l): strand_vec[i] = [-4.0] * l
    
    align_vec = [None] * l
    for i in range(l): align_vec[i] = [0] * l
    
    par_vec = [None] * l
    for i in range(l):
    par_vec[i] = [None] * l
        for j in range(l):
        par_vec[i][j] = [None] * 5
        for k in range(5):
        par_vec[i][j][k] = [None] * 5
        for n in range(5):
            par_vec[i][j][k][n] = [0.0] * 30
        
    par_lines = readlines(par_path)
    for i in range(len(par_lines)):
    items = par_lines[i].split()
    if AtomPos(items[1].strip()) < 5 and AtomPos(items[3].strip()) < 5:
        for j in range(30):
            par_vec[int(items[0]) - 1][int(items[2]) - 1][AtomPos(items[1].strip())][AtomPos(items[3].strip())][j] = float(items[4 + j])
        
    for pos_i in range(len(sequence)):
    for pos_j in range(pos_i + 2 + 3, l):
        if pos_j + 2 > l - 1: break
        
        align_energy = 0.0
                
        posL_vec = [[pos_i, pos_j + 2], [pos_i + 1, pos_j + 1], [pos_i + 2, pos_j]]
        posR_vec = [[pos_i, pos_j + 1], [pos_i + 1, pos_j], [pos_i + 1, pos_j + 2], [pos_i + 2, pos_j + 1]]
        
        for pos in range(len(posL_vec)):
        i = posL_vec[pos][0]
        j = posL_vec[pos][1]
        
            L_min_energy = 10.0
            for k in range(13):
            energy = par_vec[i][j][AtomPos('CB')][AtomPos('CB')][k]
            if energy < L_min_energy: L_min_energy = energy
        if L_min_energy == 10.0: L_min_energy = 0.0
        align_energy += L_min_energy
        
        for pos in range(len(posR_vec)):
        i = posR_vec[pos][0]
        j = posR_vec[pos][1]
        
            R_min_energy = 10.0
            for k in range(14, 17):
            energy = par_vec[i][j][AtomPos('CB')][AtomPos('CB')][k]
            if energy < R_min_energy: R_min_energy = energy
        if R_min_energy == 10.0: R_min_energy = 0.0
        align_energy += R_min_energy
        strand_vec[pos_i + 1][pos_j + 1] = align_energy
    
    for i in range(1, l - 1):
    for j in range(i + 3, l - 1):
        #print i + 1, j + 1, strand_vec[i][j]
        if (((strand_vec[i][j] - strand_vec[i][j - 1]) < -0.25) and sequence[i] != 'G' and sequence[j - 1] != 'G' and strand_vec[i][j - 1] > -5.5): align_vec[i][j - 1] = 1
        if (((strand_vec[i][j] - strand_vec[i][j + 1]) < -0.25) and sequence[i] != 'G' and sequence[j + 1] != 'G' and strand_vec[i][j + 1] > -5.5): align_vec[i][j + 1] = 1
        
    count = 0
    for i in range(1, l - 1):
    for j in range(i + 3, l - 1):
        if align_vec[i][j] == 1: print str(i + 1) + ' ' + str(j + 1)
        
def StrandPredictorCompare(native_path, predict_path):
    
    native_strand_path = tempfile.mktemp('.txt')
    os.system('./scalc -cfg ../prj/SECsamplerSC/cfg/scalc.cfg -calc calc/libPrint_Strands.so,../prj/SECsamplerSC/cfg/dope-PW.cfg -str ' + native_path + ' > ' + native_strand_path)
    native_strand_lines = readlines(native_strand_path)
    
    predict_lines = readlines(predict_path)
    
    for i in range(len(native_strand_lines)):
    for j in range(len(predict_lines)):
        if predict_lines[j].strip() == native_strand_lines[i].strip(): print predict_lines[j].strip()
    
    os.remove(native_strand_path)
    
    #print len(predict_lines) - 1
    #print predict_lines[-1]

def average_rmsd(pred_path, percent):

    pred_lines = readlines(pred_path)
    l = len(pred_lines)

    one_num = int(l * float(percent))
    one_vec = [100.0] * one_num
    
    for i in range(l):
        rmsd = float(pred_lines[i].split()[1])
    max_indx = 0
    max_rmsd = 0.0
        for j in range(len(one_vec)):
        if one_vec[j] > max_rmsd:
            max_rmsd = one_vec[j]
        max_indx = j
        if rmsd < max_rmsd:
        one_vec[max_indx] = rmsd

    total = 0.0
    for i in range(one_num):
        total += one_vec[i]
    print (total / float(one_num))
    
def average_energy(pred_path, percent):

    pred_lines = readlines(pred_path)
    l = len(pred_lines)

    one_num = int(l * float(percent))
    one_vec = [None] * one_num
    for i in range(one_num):
        one_vec[i] = [0.0] * 2
    
    for i in range(one_num):
    one_vec[i][0] = 1000.0
    
    for i in range(l):
        rmsd = float(pred_lines[i].split()[1])
    energy = float(pred_lines[i].split()[2])
    max_indx = 0
    max_energy = 0.0
        for j in range(len(one_vec)):
        if one_vec[j] > max_energy:
            max_energy = one_vec[j]
        max_indx = j
        if energy < max_energy:
        one_vec[max_indx][0] = energy
        one_vec[max_indx][1] = rmsd

    total = 0.0
    for i in range(one_num):
        total += one_vec[i][1]
    print (total / float(one_num))
    
def percent_below(pred_path, rmsd_cutoff):

    pred_lines = readlines(pred_path)
    l = len(pred_lines)
    
    count = 0
    for i in range(l):
        rmsd = float(pred_lines[i].split()[1])
    if rmsd < float(rmsd_cutoff): count += 1

    return (float(count) / float(l))
    
def percent_below_plot(in_dir):
    
    data_dir = os.path.join(in_dir, 'data')
    data_list = os.listdir(data_dir)
    
    data_array = []
    
    x_rmsd = []
    rmsd = 0.0
    for j in range(30):
    rmsd += 0.5
    x_rmsd.append(rmsd)
    
    x_array = array(x_rmsd)
    
    for i in range(len(data_list)):
    data_array.append([])
    data_path = os.path.join(data_dir, data_list[i])
    rmsd = 0.0
    for j in range(30):
        rmsd += 0.5
        data_array[i].append(percent_below(data_path, str(rmsd)))
        
    style_array = ['k:', 'k--', 'k-', 'k-.', 'ko', 'k,', 'k:', 'k--', 'k-', 'k-.', 'ko', 'k,']
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['legend.fontsize'] = '17'
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    
    label_list = []
    for i in range(len(data_list)):
    name = data_list[i].split('.')[0]
    name = name.replace('_', ' ')
    name = name.replace('*', '.')
    label_list.append(name)
    
    for i in range(len(data_array)):
    pylab.plot(x_array, array(data_array[i]), style_array[i], lw=4, label=label_list[i])
    #pylab.plot(x_array, array(data_array[i]), 'k--', lw=4, label=data_list[i].split('.')[0])
    
    pylab.xlim(4.0, 13.0)
    pylab.ylim(0.0, 1.0)
    #pylab.xlabel('rmsd cutoff', fontsize=20)
    #pylab.ylabel('fraction of models below cutoff', fontsize=20)
    
    #pylab.legend(loc=0)
    
    pylab.savefig(os.path.join(in_dir, 'percent_below.png'))
        
    pylab.close()
    
    
def speed_comparison(pw_path, aa1, aa2, speed_path, pos1, pos2, bin_size):
    
    pw_lines = readlines(pw_path)
    speed_lines = readlines(speed_path)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pw_vec = []
    for line in pw_lines:
    line_split = line.split()
    if line_split[0] == aa1 and line_split[1] == 'CB' and line_split[2] == aa2 and line_split[3] == 'CB':
        for j in range(30): pw_vec += [float(line_split[4 + j])]
        pw_array = pylab.array(pw_vec)
        break
        
    speed_vec = []
    for i in range(len(speed_lines)):
    line = speed_lines[i].split()
    if line[0] == pos1 and line[1] == 'CB' and line[2] == pos2 and line[3] == 'CB':
        for j in range(30): speed_vec += [float(line[4 + j])]
        speed_array = pylab.array(speed_vec)
        break
        
    x_vec = []
    for i in range(30): x_vec += [float(float(bin_size) * i)]
    x_array = pylab.array(x_vec)

    pylab.plot(x_array, pw_array, 'b', lw=4, label='dope-PW')
    pylab.plot(x_array, speed_array, 'r', lw=4, label='dope-PW SPEED')
    
    pylab.xlabel('distance (angstroms)', fontsize=20)
    pylab.ylabel('energy', fontsize=20)
    pylab.legend()
    
    pylab.savefig('here.png')
    
    pylab.close()
    
def DOPE_CB_PROFILE(par_path, aa1, aa2, atom1, atom2, aa11, aa12, atom11, atom12):
    
    par_lines = readlines(par_path)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    
    pair1_vec = []
    for line in par_lines:
    line_split = line.split()
    if line_split[0] == aa1 and line_split[1] == atom1 and line_split[2] == aa2 and line_split[3] == atom2:
        for j in range(30): pair1_vec += [float(line_split[4 + j])]
        pair1_array = pylab.array(pair1_vec)
        break
        
    pair2_vec = []
    for line in par_lines:
    line_split = line.split()
    if line_split[0] == aa11 and line_split[1] == atom11 and line_split[2] == aa12 and line_split[3] == atom12:
        for j in range(30): pair2_vec += [float(line_split[4 + j])]
        pair2_array = pylab.array(pair2_vec)
        break
        
    x_vec = []
    for i in range(30): x_vec += [float(float(0.5) * i)]
    x_array = pylab.array(x_vec)

    pylab.plot(x_array, pair1_array, 'b', lw=4)
    pylab.plot(x_array, pair2_array, 'r', lw=4)
    
    pylab.xlim(0.0, 14.0)
    
    pylab.savefig('here.png')
    
    pylab.close()
    
def DOPE_PW_PROFILE(par_path, aa1, aa2, atom1, atom2, aa11, aa12, atom11, atom12):
    
    par_lines = readlines(par_path)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    
    pair1_vec = []
    for line in par_lines:
    line_split = line.split()
    if line_split[0] == aa1 and line_split[1] == atom1 and line_split[2] == aa2 and line_split[3] == atom2:
        for j in range(30): pair1_vec += [float(line_split[4 + j])]
        pair1_array = pylab.array(pair1_vec)
        break
        
    pair2_vec = []
    for line in par_lines:
    line_split = line.split()
    if line_split[0] == aa11 and line_split[1] == atom11 and line_split[2] == aa12 and line_split[3] == atom12:
        for j in range(30): pair2_vec += [float(line_split[4 + j])]
        pair2_array = pylab.array(pair2_vec)
        break
        
    x_vec = []
    for i in range(30): x_vec += [float(float(0.5) * i)]
    x_array = pylab.array(x_vec)

    pylab.plot(x_array, pair1_array, 'b', lw=4)
    pylab.plot(x_array, pair2_array, 'r', lw=4)
    
    pylab.xlim(0.0, 14.0)
    
    pylab.savefig('here.png')
    
    pylab.close()
    
def CD_PLOT(x1, y1, x2, y2, x3, y3):
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    
    x1data = pylab.load(x1)
    x2data = pylab.load(x2)
    x3data = pylab.load(x3)
    y1data = pylab.load(y1)
    y2data = pylab.load(y2)
    y3data = pylab.load(y3)
    
    #y2data = y2data * 0.7
    y3data = y3data * 0.002

    pylab.plot(x1data, y1data, 'b', lw=4)
    #pylab.plot(x2data, y2data, 'r', lw=4)
    #pylab.plot(x3data, y3data, 'g', lw=4)
    
    pylab.xlim(195, 250)
    pylab.ylim(-13.0, 0.0)    
    pylab.savefig('here.png')
    
    pylab.close()

def MSA_contacts(alignment_path, native_path, gif_path):
    
    native_coord = coord_vec(native_path)
    L = len(native_coord)
    
    pmatrix = []
    for i in range(L):
    pmatrix.append([])
    for j in range(L): pmatrix[i].append(0.0)
    
    for i in range(L):
    for j in range(i + 1, L):
        if distance(native_coord[i], native_coord[j]) < 8.0:
            pmatrix[i][j] = 0.50
    
    alignment_lines = readlines(alignment_path)
    l = len(alignment_lines)

    for pos0 in range(L):
        for pos1 in range(pos0 + 4, L):
    
        tot_count = 0.0
        tot_cond_count = 0.0
        count = 0.0
        cond_count = 0.0
        prob = 0.0
        cond_prob = 0.0
    
        for i in range(l):
        if pos1 > len(alignment_lines[i]) - 1: continue
        if AAChar_int(alignment_lines[i][pos0]) < 20 and AAChar_int(alignment_lines[i][pos1]) < 20:
            tot_count += 1.0
            if alignment_lines[i][pos1] == 'E': count += 1.0
            if alignment_lines[i][pos0] == 'E':
                tot_cond_count += 1.0
            if alignment_lines[i][pos1] == 'E': cond_count += 1.0

        if tot_count > 0.0: prob = count / tot_count
        if tot_cond_count > 0.0: cond_prob = cond_count / tot_cond_count

        if ((tot_cond_count / tot_count) > 0.05):
            pmatrix[pos1][pos0] = cond_prob - prob

        if ((tot_cond_count / tot_count) > 0.05) and cond_prob - prob < -0.10: print pos0 + 1, pos1 + 1, prob, cond_prob

    cpath = tempfile.mktemp('.txt')
    cfile = open(cpath, 'w')
        
    for i in range(L):
    for j in range(L):
        cfile.write(str(pmatrix[i][j]) + '\t')
    cfile.write('\n')
    
    cfile.close()
   
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
         
    cdata = pylab.load(cpath)
    os.remove(cpath)
    
    pylab.contour(cdata)

    png_path = tempfile.mktemp('.png')
    pylab.savefig(png_path)
    os.system('convert ' + png_path + ' -resize 50% ' + gif_path)
    os.remove(png_path)
    
    pylab.close()
    
def conditional_MSA(alignment_path, pos0, pos1, aa_str):
    
    alignment_lines = readlines(alignment_path)
    l = len(alignment_lines)
    
    matrix_counts = []
    for i in range(20): matrix_counts.append(0)
    
    conditional_counts = []
    for i in range(20): conditional_counts.append(0)

    matrix_probs = []
    for i in range(20): matrix_probs.append(0.0)
    
    conditional_probs = []
    for i in range(20): conditional_probs.append(0.0)
    
    for i in range(l):
    if pos1 > len(alignment_lines[i]) - 1: continue
    if AAChar_int(alignment_lines[i][pos0]) < 20 and AAChar_int(alignment_lines[i][pos1]) < 20:
        matrix_counts[AAChar_int(alignment_lines[i][pos1])] += 1
        if AAChar_fasta(AAChar_int(alignment_lines[i][pos0])) == aa_str:
        conditional_counts[AAChar_int(alignment_lines[i][pos1])] += 1
        
    total = 0.0
    for i in range(20):
    total += float(matrix_counts[i])
    for i in range(20):
    matrix_probs[i] = float(matrix_counts[i]) / total
    
    total = 0.0
    for i in range(20):
    total += float(conditional_counts[i])
    for i in range(20):
    conditional_probs[i] = float(conditional_counts[i]) / total
    
    for i in range(20):
    #if (conditional_probs[i] - matrix_probs[i]) > 0.05 or conditional_probs[i] > 0.25 or matrix_probs[i] > 0.25:
    print AAChar_fasta(i), matrix_probs[i], conditional_probs[i]
    
def consensus_sequence(alignment_path, fasta_path, subs_path):
    
    new_fasta_path = os.path.join(os.path.split(subs_path)[0], os.path.split(subs_path)[1].split('.')[0] + '.fasta')
    
    alignment_lines = readlines(alignment_path)
    l = len(alignment_lines)
    
    fasta = readline(fasta_path, 2)
    seq_length = len(fasta)
    
    matrix_counts = [None] * seq_length
    for i in range(seq_length):
    matrix_counts[i] = [0] * 20

    matrix_probs = [None] * seq_length
    for i in range(seq_length):
    matrix_probs[i] = [0.0] * 20
    
    for i in range(l):
    for j in range(len(alignment_lines[i].strip())):
        if AAChar_int(alignment_lines[i][j]) < 20: matrix_counts[j][AAChar_int(alignment_lines[i][j])] += 1
            
    for i in range(seq_length):
    total = 0
    for j in range(20):
        total += matrix_counts[i][j]
    print i + 1, fasta[i] + ':',
    for j in range(20):
        matrix_probs[i][j] = float(matrix_counts[i][j]) / float(total)
        if matrix_probs[i][j] > 0.05: print AAChar_fasta(j), str(matrix_probs[i][j])[0:4],
    print
        
    subs_matrix = []
    for i in range(seq_length): subs_matrix.append([])

    seq_str = ''
    for i in range(seq_length):
    phil_count = 0
    #if matrix_probs[i][12] > 0.10:
     #   inx = 12
      #  subs_matrix[i].append(12)
       # continue
    if fasta[i] == 'P':
        subs_matrix[i].append(12)
        continue
    if i > 1 and i < seq_length - 2:
        if matrix_probs[i][12] > 0.05 and matrix_probs[i][12] > matrix_probs[i - 1][12] and matrix_probs[i][12] > matrix_probs[i + 1][12] and matrix_probs[i][12] > matrix_probs[i - 2][12] and matrix_probs[i][12] > matrix_probs[i + 2][12] and fasta[i - 1] != 'P' and fasta[i - 2] != 'P' and fasta[i + 1] != 'P' and fasta[i + 2] != 'P':
            inx = 12
            subs_matrix[i].append(12)
        continue

    for j in range(20):
        probs = matrix_probs[i][j]
        if matrix_probs[i][j] > 0.10:
        subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.05 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.04 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.03 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.02 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.01 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    if len(subs_matrix[i]) < 2 and AAChar_fasta(subs_matrix[i][0]) != 'G':
        for j in range(20):
            probs = matrix_probs[i][j]
            if matrix_probs[i][j] > 0.005 and (j not in subs_matrix[i]):
            subs_matrix[i].append(j)
    
    subs_file = open(subs_path, 'w')
    for i in range(seq_length):
    for j in range(len(subs_matrix[i])):
        subs_file.write(AAChar_fasta(subs_matrix[i][j]))
    subs_file.write('\n')
    subs_file.close()
    
#def hydrophobic(AA_char):
 #   if AA_char == 'A' or AA_char == 'C' or AA_char == 'F' or AA_char == 'I' or AA_char == 'L' or AA_char == 'M' or AA_char == 'V' or AA_char == 'W' or AA_char == 'Y': return 1
  #  else: return 0
  
def hydrophobic(AA_char):
    if AA_char == 'I' or AA_char == 'L' or AA_char == 'M' or AA_char == 'V': return 1
    else: return 0
    
def thread(pdb_path, sequence_path, out_path):

    sequence = readline(sequence_path, 2)
    
    pdb_lines = readlines(pdb_path)
    
    new_pdb_vec = []
    
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if int(line[23:27]) <= len(sequence):
            if line[17:20].strip() == 'GLY':
                new_pdb_vec += [line]
            else:
                new_aa = AAConvertST(sequence[int(line[23:27]) - 1])
                line_list = list(line)
                for j in range(3): line_list[17 + j] = new_aa[j]
            if new_aa == 'GLY' and line[13:15] == 'CB': continue
            else:
                new_pdb_vec += [string.join(line_list, '')]
        
    out_file = open(out_path, 'w')
    for i in range(len(new_pdb_vec)):
    out_file.write(new_pdb_vec[i] + '\n')
    out_file.close()

def switch_core(alignment_path, fasta_path, sasa_path):

    alignment_lines = readlines(alignment_path)
    sequence = readline(fasta_path, 2)
    sasa = readline(sasa_path, 1)

    l = len(alignment_lines)

    for i in range(l):
    if len(alignment_lines[i].strip()) == len(sasa.strip()):
        count = 0
            for j in range(len(sasa.strip())):
                if sasa[j] == '0' and alignment_lines[i][j] != sequence[j] and alignment_lines[i][j] != ' ': count += 1
            if count > 11:
            print count
        print alignment_lines[i]
        
def SecStr_from_log(log_path):
    
    log_lines = readlines(log_path)
    L = len(log_lines)
    
    for i in range(L):
    if not ' ' in log_lines[L - i - 1].strip() and len(log_lines[L - i - 1].strip()) > 40:
        return log_lines[L - i - 1].strip()
    
def find_hairpin(traj_dir, secseq_path):
    
    secseq = readline(secseq_path, 1)
    l = len(secseq)
    
    strand_list = []
    
    cont = False
    for i in range(l):
    if secseq[i] == 'E' and cont == False:
        start = i
        cont = True
    elif secseq[i] == 'E' and cont == True:
        continue
    elif cont == True:
        end = i - 1
        cont = False
        strand_list += [[start, end, 0]]
        
    N = len(strand_list)
    
    for i in range(N - 1):
    if strand_list[i + 1][0] - strand_list[i][1] < 10:
        strand_list[i][2] = 1

    hp_list = []
    for i in range(N - 1):
    if strand_list[i][2] == 1:
       hp_list += [[strand_list[i][0], strand_list[i][1], strand_list[i + 1][0], strand_list[i + 1][1], ]]

    model_list = [None] * len(hp_list)
    for i in range(len(hp_list)):
    model_list[i] = ['']
    
    pdb_list = os.listdir(os.path.join(traj_dir, 'Final'))
    for file in pdb_list:
    if file.split('.')[1] == 'pdb':
        SecStr = SecStr_from_log(os.path.join(os.path.join(traj_dir, 'log'), file.split('-')[0] + '-oops-' + file.split('-')[1].split('.')[0] + '.log'))
        for i in range(len(hp_list)):
        hairpin = True
        for j in range(hp_list[i][0], hp_list[i][1] + 1):
            if SecStr[j] != '1': hairpin = False
        for j in range(hp_list[i][2], hp_list[i][3] + 1):
            if SecStr[j] != '1': hairpin = False
        for j in range(hp_list[i][1] + 1, hp_list[i][2]):
            if secseq[j] == 'C' and SecStr[j] != '2': hairpin = False
        if hairpin:
            model_list[i] += [os.path.join(os.path.join(traj_dir, 'Final'), file)]
            
    for i in range(len(model_list)): del model_list[i][0]
    
    align_matrix = [None] * l
    for i in range(l):
    align_matrix[i] = [0] * l
    
    for i in range(len(model_list)):
    for j in range(len(model_list[i])):
        align_vec = hairpin_alignment(model_list[i][j], hp_list[i])
        for k in range(len(align_vec)):
        align_matrix[hp_list[i][0] + k][align_vec[k]] += 1
        

    best_models_list = [None] * len(hp_list)
    for i in range(len(hp_list)):
    best_models_list[i] = ['']
    
    for i in range(len(model_list)):
    max_score = 0
    for j in range(len(model_list[i])):
        score = 0
        align_vec = hairpin_alignment(model_list[i][j], hp_list[i])
        for k in range(len(align_vec)):
        score += align_matrix[hp_list[i][0] + k][align_vec[k]]
        if score > max_score: max_score = score
    for j in range(len(model_list[i])):
        score = 0
        align_vec = hairpin_alignment(model_list[i][j], hp_list[i])
        #print model_list[i][j]
        for k in range(len(align_vec)):
        #print hp_list[i][0] + k + 1, align_vec[k] + 1, align_matrix[hp_list[i][0] + k][align_vec[k]]
        score += align_matrix[hp_list[i][0] + k][align_vec[k]]
        if score == max_score: best_models_list[i] += [model_list[i][j]]
        
    del model_list[i][0]
    del best_models_list[i][0]
    
    for i in range(len(best_models_list)):
    inter_count_max = 0
    inter_count_inx = 0
    for j in range(len(best_models_list[i])):
        file = os.path.split(best_models_list[i][j])[1]
        print file
        print best_models_list[i][j]
        print os.path.join(os.path.join(traj_dir, 'log'), file.split('-')[0] + '-oops-' + file.split('-')[1].split('.')[0] + '.log')
        SecStr = SecStr_from_log(os.path.join(os.path.join(traj_dir, 'log'), file.split('-')[0] + '-oops-' + file.split('-')[1].split('.')[0] + '.log'))
        inter_count = 0
        for k in range(hp_list[i][1] + 1, hp_list[i][2]):
        if SecStr[k] == '1': inter_count += 1
        if inter_count > inter_count_max:
        inter_count_max = inter_count
        inter_count_idx = j
    print best_models_list[i][inter_count_idx]
    print
    
def hairpin_alignment(pdb_path, range_vec):
    
    coord_vec = []
    pdb_file = open(pdb_path, 'r')
    pdb_lines = pdb_file.readlines()
    pdb_file.close()
    for i in range(len(pdb_lines)):
        line = pdb_lines[i].strip()
        if line[0:4] == 'ATOM':
        if AACode(line[17:20].strip()) < 20:
            if line[13:15] == 'CA':
                coord_vec = coord_vec + [[float(line[30:38]), float(line[39:46]), float(line[47:54])]]
    
    N_pairs = range_vec[1] - range_vec[0] + 1
    align_vec = [0] * N_pairs
    
    #print pdb_path
    for i in range(range_vec[0], range_vec[1] + 1):
        min_dist = 100.0
        min_pos = 0
        for j in range(range_vec[1] + 3, range_vec[3] + 1):
        dist = distance(coord_vec[i], coord_vec[j])
        #print i + 1, j + 1, dist, pdb_path
        if dist < min_dist:
            min_dist = dist
            min_pos = j
    align_vec[i - range_vec[0]] = min_pos
        
    return align_vec
        
def distance(coord_vec1, coord_vec2):
    
    dist = math.sqrt(((coord_vec1[0] - coord_vec2[0]) ** 2) + ((coord_vec1[1] - coord_vec2[1]) ** 2) + ((coord_vec1[2] - coord_vec2[2]) ** 2))
    return dist

def Michael_Unfolded(fasta_path, out_path):
    
    os.chdir('/home/secoops/web/Install')
    
    for i in range(100):
        sh_path = tempfile.mktemp('.sh')
    sh_file = open(sh_path, 'w')
    trj_path = os.path.join(out_path, 'T1ubq-' + str(i + 1) + '.pdt')
    log_path = os.path.join(out_path, 'T1ubq-' + str(i + 1) + '.log')
        sh_file.write('./oops -cf RCG.cfg -if ' + fasta_path + ' -of ' + trj_path + ' -ns 1000 -si 1 -ascc -sscc -ssc > ' + log_path)
    sh_file.close()
    os.system('chmod u+x ' + sh_path)
    os.system('qsub -cwd ' + sh_path)

def PhiPsi_rmsd(pdb_path, native_path):
    
    pdb_back_path = tempfile.mktemp('.txt')
    native_back_path = tempfile.mktemp('.txt')
    
    os.system('./backbone ' + pdb_path + ' > ' + pdb_back_path)
    os.system('./backbone ' + native_path + ' > ' + native_back_path)
    
    pdb_lines = readlines(pdb_back_path)
    native_lines = readlines(native_back_path)
    
    os.remove(pdb_back_path)
    os.remove(native_back_path)
    
    L = len(pdb_lines)
    
    N = 0
    total = 0.0
    for i in range(L):
    dphi = float(pdb_lines[i].split()[3]) - float(native_lines[i].split()[3])
    if dphi > 180.0: dphi -= 180.0
    if dphi < -180.0: dphi += 180.0
    
    dpsi = float(pdb_lines[i].split()[4]) - float(native_lines[i].split()[4])
    if dpsi > 180.0: dpsi -= 180.0
    if dpsi < -180.0: dpsi += 180.0
    
    total += dphi ** 2
    total += dpsi ** 2
    N += 2
    
    return math.sqrt(total / N)
    
def index_in_list(item, list_vec):
    
    for listy in range(len(list_vec)):
    if list_vec[listy].strip() == item: return listy
    return -1
    
def parse_clusters(clus_dir):
    
    final_dir = os.path.join(clus_dir, 'Final')
    
    parse_list = readlines(os.path.join(final_dir, 'prediction_parse.txt'))
    pred_list = readlines(os.path.join(final_dir, 'prediction.txt'))
    N = len(parse_list)
    
    if len(pred_list) != N:
    print "ERROR!"
    return
    
    matrix = []
    for i in range(N): matrix.append([100.0] * N)

    for i in range(N):
    txt_path = os.path.join(clus_dir, 'cluster/clust_' + str(i) + '.txt')
    print 'loading data for ' + str(i + 1) + ' of ' + str(N)
    if os.path.exists(txt_path):
        lines = readlines(txt_path)
        L = len(lines)
        for j in range(L):
        rmsd = float(lines[j].split()[2].strip())
            model1_path = lines[j].split()[0].strip()
        model2_path = lines[j].split()[1].strip()
            idx0 = i
        idx1 = index_in_list(model2_path, parse_list)
        matrix[idx0][idx1] = rmsd
        matrix[idx1][idx0] = rmsd

    for rmsd_cutoff in range(1, 8):
        
        clusters = []
        
        for i in range(N):
        clusters.append([1, 0.0, [i]])
        for i in range(N):
        for j in range(i + 1, N):
            if matrix[i][j] < float(rmsd_cutoff):
            clusters[i][2].append(j)
            clusters[i][0] += 1
            clusters[j][2].append(i)
            clusters[j][0] += 1
            clusters[i][1] += matrix[i][j]
            clusters[j][1] += matrix[i][j]
        for i in range(N):
        clusters[i][1] = clusters[i][1] / float(clusters[i][0])
        clusters.sort()
        clusters.reverse()
    
        idx = 0
        while True:
        if idx == len(clusters): break
        if clusters[idx][0] < 40: del clusters[idx]
        else: idx += 1
    
        idx0 = 0
        while True:
        if idx0 == len(clusters): break
        for i in range(len(clusters[idx0][2])):
            search_val = clusters[idx0][2][i]
            idx1 = idx0 + 1
            while True:
            if idx1 == len(clusters): break
            if search_val in clusters[idx1][2]: del clusters[idx1]
            else: idx1 += 1
        idx0 += 1
    
        cluster_path = os.path.join(clus_dir, 'cluster_' + str(rmsd_cutoff) + '.txt')
        cluster_file = open(cluster_path, 'w')
        for i in range(len(clusters)):
        for j in range(len(clusters[i][2])):
            cluster_file.write(pred_list[clusters[i][2][j]].split()[0] + '\t' + pred_list[clusters[i][2][j]].split()[1] + '\n')
        #+ pred_list[clusters[i][2][j]].split()[2] + '\n')
        cluster_file.write(str(clusters[i][1]) + '\n')
        cluster_file.close()
    
        cluster_analysis(cluster_path)



def cluster_analysis(cluster_path):
    
    dir_path = os.path.split(cluster_path)[0]
    cluster_lines = readlines(cluster_path)
    
    out_str = 'cluster 1\n'
    ave_rco = 0.0
    ave_rg = 0.0
    ave_br = 0.0
    ave_tight = 0.0
    ave_energy = 0.0
    #ave_rmsd = 0.0
    clus_num = 1
    N = 0
    clusters = []
    for i in range(len(cluster_lines)):
    print i
    line = cluster_lines[i].split()
    if len(line) > 1:
        pdb_path = os.path.join(dir_path, 'Final/' + line[0])
        rco = RCO(pdb_path)
        rg = RGcalc(pdb_path)
        br = burial_ratio(pdb_path)
        ave_rco += rco
        ave_rg += rg
        ave_br += br
        ave_energy += float(line[1])
        #ave_rmsd += float(line[1])
        N += 1
        out_str += (line[0] + '\t' + line[1] + '\t' + str(rco) + '\t' + str(rg) + '\t' + str(br) + '\n')
    else:
        clus_num += 1
        ave_rco = ave_rco / float(N)
        ave_rg = ave_rg / float(N)
        ave_br = ave_br / float(N)
        ave_energy = ave_energy / float(N)
        #ave_rmsd = ave_rmsd / float(N)
        if len(line) == 1: ave_tight = float(line[0])
        out_str += 'ave RCO:' + '\t' + str(ave_rco) + '\n'
        out_str += 'ave RG:' + '\t' + str(ave_rg) + '\n'
        out_str += 'ave BR:' + '\t' + str(ave_br) + '\n'
        out_str += 'ave energy:' + '\t' + str(ave_energy) + '\n'
        #out_str += 'ave rmsd to native:' + '\t' + str(ave_rmsd) + '\n'
        out_str += 'tightness:' + '\t' + str(ave_tight) + '\n'
        out_str += 'N:' + '\t' + str(N) + '\n'
        out_str += '\ncluster ' + str(clus_num) + '\n'
        
        clusters.append([N, ave_rco, out_str])
        
        ave_rco = 0.0
        ave_rg = 0.0
        ave_br = 0.0
        out_str = ''
        N = 0
        
    clusters.sort()
    clusters.reverse()
    
    out_file = open(os.path.join(dir_path, os.path.split(cluster_path)[1].split('.')[0] + '_analysis.txt'), 'w')
    for i in range(len(clusters)):
        out_file.write(clusters[i][2])
    out_file.close()
    
def Pcount(MSA_path):
    
    lines = readlines(MSA_path)
    
    for line_str in lines:
    line = line_str.strip()
    p_count = 0
    for i in range(len(line)):
        if line[i] == 'C': p_count += 1
    if p_count > 1: print line, p_count

def rama_dist_comp():

    align_dir = '/home/secoops/web/speed_usable'
    fasta_dir = '/home/secoops/web/speed_fasta'
    align_list = os.listdir(align_dir)
    hfree_dir = '/home/secoops/web/hfree_usable_matrix'
    speed_dir = '/home/secoops/web/speed_usable_matrix'
    if not os.path.exists(hfree_dir): os.mkdir(hfree_dir)
    if not os.path.exists(speed_dir): os.mkdir(speed_dir)

    for file in align_list:
        align_path = os.path.join(align_dir, file)
    name = file[0:4]
    fasta_path = os.path.join(fasta_dir, name + '.fasta')
    subs_path = os.path.join(align_dir, name + '.matrix')
        speed_path = os.path.join(speed_dir, name + '.rama')
    hfree_path = os.path.join(hfree_dir, name + '.rama')
    sh_path = os.path.join('/home/secoops/web', 'T' + name + '.sh')
    sh_str = './build.py -consensus_sequence ' + align_path + ' ' + fasta_path + ' '  + subs_path + '\n'
    sh_str += './build.py -custom_sub ' + fasta_path + ' ' + subs_path + ' no no no ' + speed_path + '\n'
    sh_str += './build.py -homology_free_sampling_no_sub ' + fasta_path + ' no no no ' + hfree_path
    sh_file = open(sh_path, 'w')
    sh_file.write(sh_str)
    sh_file.close()
    os.system('chmod u+x ' + sh_path)
    os.system('qsub -cwd ' + sh_path)
    
def tot_trimers(rama_path):
    
    rama_lines = readlines(rama_path)
    L = len(rama_lines) - 2
    count = 0
    
    for i in range(L):
    line = rama_lines[i + 1].split()
    for j in range(len(line)): count += int(line[j])
     
    print float(count) / float(L)
    
def total_radial_tries(log_dir):
    
    log_list = os.listdir(log_dir)
    
    N_logs = 0
    count = 0
    for file in log_list:
    if file.split('.')[1] == 'log':
        N_logs += 1
        log_path = os.path.join(log_dir, file)
        lines = readlines(log_path)
        for i in range(len(lines)):
        line = lines[i].split()
        if len(line) > 1:
            if line[0] == 'Initial' and line[1] == 'energy': count += 1
            
    print float(count) / float(N_logs)

def CA_dist_error(pred_path, native_path):

    bfact_list = bfactor_vec(native_path)
    pdb_dir = os.path.split(pred_path)[0]

    pred_lines = readlines(pred_path)
    pdb_list = []

    for i in range(len(pred_lines)):
        line = pred_lines[i].split()
    if float(line[1]) < 5.0:
        pdb_list.append(os.path.join(pdb_dir, line[0] + '.pdb'))

    L = len(pdb_list)
    N = len(coord_vec(pdb_list[0]))

    average_vec = []
    for i in range(N):
        average_vec.append([])
        for j in range(N): average_vec[i].append(0.0)

    std_vec = []
    for i in range(N):
        std_vec.append([])
        for j in range(N): std_vec[i].append(0.0)

    for i in range(len(pdb_list)):
        pdb_path = pdb_list[i]
    cvec = coord_vec(pdb_path)
    for j in range(N):
        for k in range(N):
            average_vec[j][k] += distance(cvec[j], cvec[k])

    for i in range(N):
    for j in range(N):
        average_vec[i][j] = average_vec[i][j] / float(L)

    for i in range(len(pdb_list)):
        pdb_path = pdb_list[i]
    cvec = coord_vec(pdb_path)
    for j in range(N):
        for k in range(N):
            std_vec[j][k] += ((distance(cvec[j], cvec[k]) - average_vec[j][k]) ** 2)

    for i in range(N):
    for j in range(N):
        std_vec[i][j] = math.sqrt( std_vec[i][j] / float(L - 1) )

    std_pos = []
    for i in range(N):
    total = 0.0
    for j in range(N): total += std_vec[i][j]
    std_pos.append(total / float(N))
    print i + 1, total / float(N), bfact_list[i]

    std_pos_array = array(std_pos)
    bfact_array = array(bfact_list)
    import pylab
    print pylab.corrcoef(std_pos_array, bfact_array)

def rmsd_error(cluster_path, native_path, cluster_int):

    bfact_list = bfactor_vec(native_path)
    pdb_dir = os.path.join(os.path.split(cluster_path)[0], 'Final')

    pdb_list = cluster_pdb_list(cluster_path, cluster_int)

    L = len(pdb_list)
    N = len(CA_vec(pdb_list[0]))

    average_vec = []
    for i in range(N): average_vec.append(0.0)

    std_vec = []
    for i in range(N): std_vec.append(0.0)

    nat_average_vec = []
    for i in range(N): nat_average_vec.append(0.0)

    nat_std_vec = []
    for i in range(N): nat_std_vec.append(0.0)

    pos_vec = []
    count = 0
    for i in range(L):
    for j in range(i + 1, L):
        count += 1
        print count, 'of', (L * L / 2)
        pdbi_path = pdb_list[i]
        pdbj_path = pdb_list[j]
        print os.path.split(pdbi_path)[1], os.path.split(pdbj_path)[1]
        pos_vec.append(position_rmsd(pdbi_path, pdbj_path))

    total = len(pos_vec)
    for i in range(total):
        for j in range(N):
        average_vec[j] += pos_vec[i][j]

    for i in range(N): average_vec[i] = (average_vec[i] / float(total))

    for i in range(total):
    for j in range(N):
        std_vec[j] += ((pos_vec[i][j] - average_vec[j]) ** 2)

    for i in range(N): std_vec[i] = math.sqrt(std_vec[i] / float(total - 1))

    nat_pos_vec = []
    for i in range(L):
    print i + 1, 'of', L
    nat_pos_vec.append(position_rmsd(pdb_list[i], native_path))
    os.path.split(pdb_list[i])[1]

    for i in range(L):
    for j in range(N): nat_average_vec[j] += nat_pos_vec[i][j]

    for i in range(N): nat_average_vec[i] = (nat_average_vec[i] / float(L))

    for i in range(L):
    for j in range(N):
        nat_std_vec[j] += ((nat_pos_vec[i][j] - nat_average_vec[j]) ** 2)

    for i in range(N): nat_std_vec[i] = math.sqrt(nat_std_vec[i] / float(L - 1))

    average_array = array(average_vec)
    std_array = array(std_vec)
    nat_average_array = array(nat_average_vec)
    nat_std_array = array(nat_std_vec)
    
    import pylab
    print (pylab.corrcoef(average_array, nat_average_array)[0][1]) ** 2
    print (pylab.corrcoef(std_array, nat_std_array)[0][1]) ** 2
    print (pylab.corrcoef(std_array, nat_average_array)[0][1]) ** 2
    print (pylab.corrcoef(average_array, nat_std_array)[0][1]) ** 2
    
    out_path = os.path.join(pdb_dir, 'rmsd_error.txt')
    out_file = open(out_path, 'w')
    for i in range(len(average_vec)):
    out_file.write(str(average_vec[i]) + '\t' + str(std_vec[i]) + '\t' + str(nat_average_vec[i]) + '\t' + str(nat_std_vec[i]) + '\n')
    out_file.close()
        

def bfactor_vec(pdb_path):
    cavec = CA_vec(pdb_path)
    L = len(cavec)
    bfact_list = []
    for i in range(L):
    bfact_list.append(float(cavec[i][61:67]))

    return bfact_list
    
def cluster_SecStr(cluster_path, cluster_int):
    
    pdb_list = cluster_pdb_list(cluster_path, cluster_int)
    
    SecStr_str = ''
    for i in range(len(pdb_list)):
    SecStr_str += ReturnDSSP(pdb_list[i]) + '\n'
    
    out_path = os.path.join(os.path.join(os.path.split(cluster_path)[0], 'Final'), 'cluster.SecStr')
    out_file = open(out_path, 'w')
    out_file.write(SecStr_str)
    out_file.close()
    
def error_plots(in_dir, dssp_path):
    
    error_path = os.path.join(in_dir, 'Final/rmsd_error.txt')
    error_lines = readlines(error_path)
    ave = []
    std = []
    nat_ave = []
    nat_std = []
    positions = []
    
    for i in range(1, len(error_lines) - 1):
    items = error_lines[i].split()
    ave.append(float(items[0]))
    std.append(float(items[1]))
    nat_ave.append(float(items[2]))
    nat_std.append(float(items[3]))
    positions.append(i)
    
    ave_array = array(ave)
    std_array = array(std)
    nat_ave_array = array(nat_ave)
    nat_std_array = array(nat_std)
    positions_array = array(positions)
    
    ave_line = line_array(ave_array, nat_ave_array)
    std_line = line_array(std_array, nat_std_array)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.scatter(ave_array, nat_ave_array, c='r', marker='>', s=100)
    pylab.scatter(std_array, nat_std_array, c='b', marker='>', s=100)
    pylab.plot(ave_line[0], ave_line[1], 'k')
    pylab.plot(std_line[0], std_line[1], 'k')
    
    minx = min(min(ave_array), min(std_array))
    maxx = max(max(ave_array), max(std_array))
    miny = min(min(nat_ave_array), min(nat_std_array))
    maxy = max(max(nat_ave_array), max(nat_std_array))
    
    print minx, maxx, miny, maxy
    
    xpad = ((maxx - minx) * 0.05)
    ypad = ((maxy - miny) * 0.05)
    pylab.xlim(minx - xpad, maxx + xpad)
    pylab.ylim(miny - ypad, maxy + ypad)
    
    pylab.savefig(os.path.join(in_dir, 'rmsd_error_scatter.png'))
    pylab.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '17'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (16, 6)
    
    secseq_str = readline(dssp_path, 1)

    secseq = []
    for i in range(1, len(secseq_str) - 1):
    num_str = ''
    if (i == 1) or (((i + 1) % 10) == 0): num_str = '\n' + str(i + 1)
    secseq.append(secseq_str[i] + num_str)
    print secseq

    fig = pylab.figure()
    ax = fig.add_subplot(111)

    ax.errorbar(positions_array, ave_array, std_array, fmt='o', mfc='green', ecolor='green')
    ax.errorbar(positions_array, nat_ave_array, nat_std_array, fmt='o', mfc='red', ecolor='red')
    pylab.xlim(min(positions_array), max(positions_array))
    L = len(secseq)
    ind = arange(L) + 1
    ax.set_xticks(ind)
    ax.set_xticklabels( secseq )
    
    pylab.savefig(os.path.join(in_dir, 'rmsd_error_bars.png'))
    
    pylab.close()

def blast(fasta_path, out_path):
    from Bio.Blast import NCBIWWW
    fasta_string = readline(fasta_path, 2)
    result_handle = NCBIWWW.qblast("blastp", "nr", fasta_string, alignments = 500)
    blast_results = result_handle.read()
    save_file = open(out_path, "w")
    save_file.write(blast_results)
    save_file.close()

def line_array(a1, a2):
    
    minx = min(a1)
    maxx = max(a1)
    line_params = stats.linregress(a1, a2)
    slope = line_params[0]
    intercept = line_params[1]
     
    miny = slope * minx + intercept
    maxy = slope * maxx + intercept
    
    x_array = array([minx, maxx])
    y_array = array([miny, maxy])
    line_arrays = []
    line_arrays.append(x_array)
    line_arrays.append(y_array)
    
    line_arrays.append([slope])
    line_arrays.append([intercept])
    
    return line_arrays

def sasa(idx, sasa):
    
    if idx == 0: return 1.0 - (sasa / 204.0)
    elif idx == 1: return 1.0 - (sasa / 238.0)
    elif idx == 2: return 1.0 - (sasa / 258.0)
    elif idx == 3: return 1.0 - (sasa / 288.0)
    elif idx == 4: return 1.0 - (sasa / 277.0)
    elif idx == 5: return 1.0 - (sasa / 195.0)
    elif idx == 6: return 1.0 - (sasa / 286.0)
    elif idx == 7: return 1.0 - (sasa / 248.0)
    elif idx == 8: return 1.0 - (sasa / 334.0)
    elif idx == 9: return 1.0 - (sasa / 285.0)
    elif idx == 10: return 1.0 - (sasa / 301.0)
    elif idx == 11: return 1.0 - (sasa / 260.0)
    elif idx == 12: return 1.0 - (sasa / 229.0)
    elif idx == 13: return 1.0 - (sasa / 278.0)
    elif idx == 14: return 1.0 - (sasa / 342.0)
    elif idx == 15: return 1.0 - (sasa / 234.0)
    elif idx == 16: return 1.0 - (sasa / 233.0)
    elif idx == 17: return 1.0 - (sasa / 262.0)
    elif idx == 18: return 1.0 - (sasa / 351.0)
    elif idx == 19: return 1.0 - (sasa / 339.0)
    
def tmax_sasa(idx):
    
    if idx == 0: return 221.0
    elif idx == 1: return 257.4
    elif idx == 2: return 263.2
    elif idx == 3: return 291.3
    elif idx == 4: return 324.9
    elif idx == 5: return 0.0
    elif idx == 6: return 302.7
    elif idx == 7: return 279.9
    elif idx == 8: return 313.4
    elif idx == 9: return 282.9
    elif idx == 10: return 308.1
    elif idx == 11: return 257.6
    elif idx == 12: return 249.6
    elif idx == 13: return 290.1
    elif idx == 14: return 351.1
    elif idx == 15: return 223.4
    elif idx == 16: return 253.0
    elif idx == 17: return 262.1
    elif idx == 18: return 362.3
    elif idx == 19: return 338.6

def max_SASA():

    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90'
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    seqdata_list = os.listdir(seqdata_dir)
    
    max_sasa = []
    for i in range(20): 
    max_sasa.append(0.0)
    
    for file in seqdata_list:
    print file
    lines = readlines(os.path.join(seqdata_dir, file))
    for line in lines:
        items = line.split()
        if len(items) > 5:
            idx = AACode(items[2])
            sasa = float(items[9])
            if idx < 20:
            if sasa > max_sasa[idx]: max_sasa[idx] = sasa
            
    for i in range(20):
    print i, AAChar_fasta(i), max_sasa[i]

def search_blast(blast_path):
    
    blast_lines = readlines(blast_path)
    L = len(blast_lines)

    for i in range(L):
    if blast_lines[i].strip().find('<Hit_num>') > -1:
        if blast_lines[i + 19].strip().find('<Hsp_gaps>') == -1:
        e_val = float(blast_lines[i + 10].strip()[blast_lines[i + 10].strip().find('<Hsp_evalue>')+len('<Hsp_evalue>'):blast_lines[i + 10].strip().find('</Hsp_evalue>')])
        q_from = int(blast_lines[i + 11].strip()[blast_lines[i + 11].strip().find('<Hsp_query-from>')+len('<Hsp_query-from>'):blast_lines[i + 11].strip().find('</Hsp_query-from>')])
        q_to = int(blast_lines[i + 12].strip()[blast_lines[i + 12].strip().find('<Hsp_query-to>')+len('<Hsp_query-to>'):blast_lines[i + 12].strip().find('</Hsp_query-to>')])
        q_seq = blast_lines[i + 20].strip()[blast_lines[i + 20].strip().find('<Hsp_qseq>')+len('<Hsp_qseq>'):blast_lines[i + 20].strip().find('</Hsp_qseq>')]
        h_seq = blast_lines[i + 21].strip()[blast_lines[i + 21].strip().find('<Hsp_hseq>')+len('<Hsp_hseq>'):blast_lines[i + 21].strip().find('</Hsp_hseq>')]
        midline_seq = blast_lines[i + 22].strip()[blast_lines[i + 22].strip().find('<Hsp_midline>')+len('<Hsp_midline>'):blast_lines[i + 22].strip().find('</Hsp_midline>')]
        
        if q_from == 1 and q_to > 68 and e_val > 0.00001:
            print q_seq
            print midline_seq
            print h_seq
            
def compare_similarity(matrix_path, fasta_path):
    
    fasta_seq = readline(fasta_path, 2)
    matrix_lines = readlines(matrix_path)
    
    pos_vec = [1, 3, 5, 13, 15, 17, 23, 26, 30, 36, 41, 43, 45, 50, 56, 59, 61, 67, 69, 71]
    
    for line in matrix_lines:
    identity = 1.0
    tot_pos = 0
    mismatch = 0
    for pos in pos_vec:
        if pos - 1 <= len(line) - 1:
        if line[pos - 1] != '-' and line[pos - 1] != ' ':
            tot_pos += 1
                if fasta_seq[pos - 1] != line[pos - 1]:
            mismatch += 1
    if tot_pos > 0:
        identity = float(mismatch) / float(tot_pos)
        
        if identity > 0.90:
        print line
        break
    
def phi_psi_distance(phi0, phi1, psi0, psi1):
    
    phi_diff = phi1 - phi0
    if phi_diff < 0.0: phi_diff = phi_diff * -1.0
    if phi_diff > 180.0: phi_diff = 360.0 - phi_diff
    
    psi_diff = psi1 - psi0
    if psi_diff < 0.0: psi_diff = psi_diff * -1.0
    if psi_diff > 180.0: psi_diff = 360.0 - psi_diff
     
    return math.sqrt(phi_diff ** 2 + psi_diff ** 2)
    
def position_phi_psi_diff(pred_path, native_path):
    
    model_dir = os.path.split(pred_path)[0]
    pred_lines = readlines(pred_path)
    
    back_path = tempfile.mktemp('.txt')
    os.system('./backbone ' + native_path + ' > ' + back_path)
    back_lines = readlines(back_path)
    os.remove(back_path)
    
    native_angles = []
    phi_psi_vec = []
    for line in back_lines:
    items = line.split()
    native_angles.append([float(items[3]), float(items[4])])
    phi_psi_vec.append([])
    
    model_vec = []
    name_vec = []
    rmsd_vec = []
    
    for line in pred_lines:
    items = line.split()
    model_vec.append(os.path.join(model_dir, items[0] + '.pdb'))
    name_vec.append(items[0])
    rmsd_vec.append(float(items[1]))
    for i in range(len(phi_psi_vec)): phi_psi_vec[i].append(0.0)
    
    
    for i in range(len(model_vec)):
            
    model_path = model_vec[i]
    print model_path
    back_path = tempfile.mktemp('.txt')
        os.system('./backbone ' + model_path + ' > ' + back_path)
        back_lines = readlines(back_path)
        os.remove(back_path)
    
    for j in range(len(back_lines)):
        items = back_lines[j].split()
        phi = float(items[3])
        psi = float(items[4])
        phi_psi_vec[j][i] = phi_psi_distance(phi, native_angles[j][0], psi, native_angles[j][1])
       
    pos_vec = []
    coeff_vec = []
    import pylab
    for i in range(len(back_lines)):
    
    pos_vec.append(i)
    angle_array = pylab.array(phi_psi_vec[i])
    coeff_vec.append(float(pylab.corrcoef(pylab.array(rmsd_vec), angle_array)[0][1]))
    
    png_path = tempfile.mktemp('.png')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.bar(array(pos_vec), array(coeff_vec), color='b')
    pylab.xlabel('position in sequence', fontsize=20)
    pylab.ylabel('correlation', fontsize=20)
    pylab.savefig(png_path)
    pylab.close()
    os.system('convert ' + png_path + ' -resize 35% ' + '/home/secoops/correlation.gif')
    os.remove(png_path)
    
def process_toplogies(traj_path, energy_path, rmsd_path):
    
    dir_path = os.path.split(traj_path)[0]
    
    group_names_path = os.path.join(dir_path, 'group_names.txt')
    group_energy_path = os.path.join(dir_path, 'group_energy.txt')
    group_rmsd_path = os.path.join(dir_path, 'group_rmsd.txt')
    out_path = os.path.join(dir_path, 'group_data.txt')
    
    names_vec = []
    lines = readlines(traj_path)
    for line in lines:
    if len(line.split()) == 2:
        if line.split()[0] == 'MODEL':
            names_vec.append(line.split()[1].strip())

        
    L = len(names_vec)
        
    check_vec = []
    for i in range(L): check_vec.append('N')
        
    energy_vec = []
    energy_list = readlines(energy_path)
    for item in energy_list:
    energy_vec.append(float(item))
    
    rmsd_vec = []
    rmsd_list = readlines(rmsd_path)
    for item in rmsd_list:
    rmsd_vec.append(float(item))
    
    out_file = open(out_path, 'w')
    group_names_file = open(group_names_path, 'w')
    group_energy_file = open(group_energy_path, 'w')
    group_rmsd_file = open(group_rmsd_path, 'w')
    count = 0
    for i in range(L):
    if check_vec[i] == 'N':

        check_vec[i] = 'Y'
        new_list = []
        new_energy = []
        new_rmsd = []
        
        new_list.append(names_vec[i])
        new_energy.append(energy_vec[i])
        new_rmsd.append(rmsd_vec[i])
        
        group_id = names_vec[i].split('-')[1] + '-' + names_vec[i].split('-')[2]
        

        for j in range(i + 1, L):
        sub_id = names_vec[j].split('-')[1] + '-' + names_vec[j].split('-')[2]
        
        if check_vec[j] == 'N' and sub_id == group_id:
                new_list.append(names_vec[j])
                new_energy.append(energy_vec[j])
                new_rmsd.append(rmsd_vec[j])
            check_vec[j] = 'Y'
            
         
            
        n = len(new_list)
        if n < 3: continue
        count += 1
        group_num = str(count)
        out_file.write('topology ' + group_num + '\n')
        tot_energy = 0.0
        tot_rmsd = 0.0
        for k in range(n):
        out_file.write(new_list[k] + '\t' + str(new_energy[k]) + '\t' + str(new_rmsd[k]) + '\n')
        
            tot_energy += new_energy[k]
        tot_rmsd += new_rmsd[k]
        
        ave_energy = tot_energy / float(n)
        ave_rmsd = tot_rmsd / float(n)
        
        out_file.write('average energy: ' + str(ave_energy) + '\n')
        out_file.write('average rmsd: ' + str(ave_rmsd) + '\n\n')
        
        group_names_file.write(group_id + '\n')
        group_energy_file.write(str(ave_energy) + '\n')
        group_rmsd_file.write(str(ave_rmsd) + '\n')
        
    out_file.close()
    group_names_file.close()
    group_energy_file.close()
    group_rmsd_file.close()
    
    PY_scatterplot(group_rmsd_path, group_energy_path, 'DOPE-PW topology ranking', 'ave. rmsd of topology', 'ave. DOPE-PW of topology', os.path.join(dir_path, 'topologies_scatter.gif'))
    
def noops_energy_sort(in_path):

    scripts_dir = os.path.join(in_path, 'scripts')
    final_dir = os.path.join(in_path, 'Final')
    
    scripts_list = os.listdir(scripts_dir)
    
    log_vec = []
    count = 0
    for file in scripts_list:
    
    if len(file.split('.')) == 3:
        if file.split('.')[2][0] == 'o':
        pdb_path = os.path.join(final_dir, file.split('.')[0] + '.pdb')
        if os.path.exists(pdb_path):
            count += 1
            if count % 100 == 0: print count
            log_path = os.path.join(scripts_dir, file)
                    log_vec.append([noops_log_energy(log_path), pdb_path])
    N = len(log_vec)
    log_vec.sort()
    
    low_dir = os.path.join(in_path, 'lowest')
    if not os.path.exists(low_dir): os.mkdir(low_dir)
    
    for i in range(2000):
    print log_vec[i][0]
    os.system('cp ' + log_vec[i][1] + ' ' + low_dir)
    
    
def noops_log_energy(log_path):
    
    return float(readlines(log_path)[-7].split()[2])
    
def noops(start_path, number):
    
    folding_dir = '/home/secoops/noops/folding'
    name = os.path.split(start_path)[1].split('.')[0]
    results_dir = os.path.join(folding_dir, name)
    scripts_dir = os.path.join(results_dir, 'scripts')
    traj_dir = os.path.join(results_dir, 'traj')
    final_dir = os.path.join(results_dir, 'Final')
    
    dsa_cfg_path = tempfile.mktemp('.cfg')
    oops_cfg_path = tempfile.mktemp('.cfg')
    
    local_traj_path = '/local/' + name + '_' + numero(number) + '.pdt'
    
    dsa_cfg_str = 'ENERGY FUNCTION=RADIAL,/home/secoops/noops/cfg/radial.cfg,1.0\nTRAJECTORY FILE=' + local_traj_path + '\nMAXIMUM NUMBER OF STEPS=0\nRANDOM INIT=1\nCOUNTER MOVES=0\nPARAMETER DIR=/home/secoops/noops/par\nRAMA DIR=/home/secoops/noops/rama\nTEMPERATURE UPDATE INTERVAL=500\nDEFAULT INITIAL TEMPERATURE=50\nUPDATE TEMP COEFFICIENT=0.1\nNAME=' + name + '\nSEED=' + str(random.randint(1, 1000000000)) 
    oops_cfg_str = 'SAMPLING MODULE=DSA\nSAMPLING CONFIG=' + dsa_cfg_path
    

    writelines(dsa_cfg_path, dsa_cfg_str)
    writelines(oops_cfg_path, oops_cfg_str)

    protein = None
    if("fasta" in start_path):
        protein = seq_to_PDB(start_path)
    else:
        parser = PDBParser()
        protein = parser.get_structure('start', start_path)
    start_time = time.time()

    simulator = FoldingSimulator()
    simulator.set_structure(protein)
    simulator.set_driver("OOPS")
    simulator.run_simulation(oops_cfg_path)
    
    FinalStructure(local_traj_path, os.path.join(final_dir, name + '_' + numero(number) + '.pdb'))
    os.system('mv ' + local_traj_path + ' ' + os.path.join(traj_dir, name + '_' + numero(number) + '.pdt'))
    
    os.remove(dsa_cfg_path)
    os.remove(oops_cfg_path)
    
    print("Elapsed time: %lf" % (time.time()-start_time))
    
def run_noops(start_path):
    
    run_noops_cfg_path = '/home/secoops/noops/cfg/run_noops.cfg'
    noops_cfg_lines = readlines(run_noops_cfg_path)
    for cfg_line in noops_cfg_lines:
    items = cfg_line.split('=')
    if len(items) == 2:
        item = items[0].strip()
        value = items[1].strip()
        if item == 'RUN_START':
        run_start = int(value)
        if item == 'RUN_END':
        run_end = int(value)
        if item == 'USER_NAME':
        user_name = value
        if item == 'MAX_NJOBS':
        max_njobs = int(value)
        if item == 'WAIT_TIME':
        wait_time = int(value)
        if item == 'MAX_RETRY':
        max_retry = int(value)
    
    folding_dir = '/home/secoops/noops/folding'
    name = os.path.split(start_path)[1].split('.')[0]
    results_dir = os.path.join(folding_dir, name)
    scripts_dir = os.path.join(results_dir, 'scripts')
    traj_dir = os.path.join(results_dir, 'traj')
    final_dir = os.path.join(results_dir, 'Final')
    
    if not os.path.exists(results_dir): os.mkdir(results_dir)
    if not os.path.exists(scripts_dir): os.mkdir(scripts_dir)
    if not os.path.exists(traj_dir): os.mkdir(traj_dir)
    if not os.path.exists(final_dir): os.mkdir(final_dir)
        
    os.chdir(scripts_dir)
    for num in range(run_start, run_end + 1):
    number = num + 1
    script_path = os.path.join(scripts_dir, name + '_' + numero(number) + '.sh')
    script_string = '#!/bin/bash\n/home/secoops/web/build.py -noops ' + start_path + ' ' + str(number)
    writelines(script_path, script_string)
    os.system('chmod u+x ' + script_path)
    
    submit_sge_job(script_path, user_name, max_njobs, wait_time, max_retry)
    
def unzip_pdb():
    
    pdb_dir = '/home/bartolo/PDBget-0.9-bin/pdb'
    scripts_dir = '/home/secoops/web/PDB/pdb_scripts'
    pdbz_dir = '/home/secoops/web/PDB/pdbz'
    
    pdb_list = os.listdir(pdb_dir)
    
    for pdb in pdb_list:
    pdb_path = os.path.join(pdb_dir, pdb)
    pdb_tmp_path = tempfile.mktemp('.ent')
    name = pdb.split('.')[0]
    pdbz_path = os.path.join(pdbz_dir, name + '.ent.gz')
    script_path = os.path.join(scripts_dir, name + '.sh')
    script_string = 'cp ' + pdb_path + ' ' + pdb_tmp_path + '\ngzip ' + pdb_tmp_path + '\nmv ' + pdb_tmp_path + '.gz ' + pdbz_path
    writelines(script_path, script_string)
    os.system('chmod u+x ' + script_path)
    
    submit_sge_job(script_path, 'secoops', 200, 30, 100)
    
def tsp_record_model():

    pdb_dir = '/home/bartolo/PDBget-0.9-bin/pdb'
    tsp_dir = '/home/secoops/web/tsp_recordsC'
    culled_dir = '/home/bartolo/PDBget-0.9-bin/culled'
    tsp_dir_list = os.listdir(tsp_dir)
    
    total = len(tsp_dir_list)
    
    count = 0
    for tsp_file in tsp_dir_list:
    count += 1
        if count % 1000 == 0: print float(count) / float(total)
    culled_path = os.path.join(culled_dir, tsp_file.split('.')[0] + '.pdb')
    if not os.path.exists(culled_path): continue
    tsp_path = os.path.join(tsp_dir, tsp_file)
    name = os.path.split(tsp_path)[1][0:4]
    pdb_path = os.path.join(pdb_dir, 'pdb' + name + '.ent')
    pdb_info = PDB_get_info(pdb_path)
    if len(pdb_info) == 3:
        if pdb_info[1] == 'XRAY':
        #if float(pdb_info[2]) > 0.9: continue
        tsp_lines = readlines(tsp_path)
        N = len(tsp_lines)
        tsp = 0.0
        for i in range(N):
            tsp_at_pos = float(tsp_lines[i].strip())
                    tsp += tsp_at_pos
        if N > 0:
            tsp_pos = tsp / float(N)
            if tsp_pos < -2.0: print pdb_path
    
def tsp_records():

    pdb_dir = '/home/bartolo/PDBget-0.9-bin/pdb'
    tsp_dir = '/home/secoops/web/tsp_records'
    culled_dir = '/home/bartolo/PDBget-0.9-bin/culled'
    tsp_dir_list = os.listdir(tsp_dir)

    tsp_min = -6.0
    bin_size = 0.5
 
    tsp_vec_lt09 = []
    for i in range(33): tsp_vec_lt09.append(0.0)
    tsp_vec_09_30 = []
    for i in range(33): tsp_vec_09_30.append(0.0)
    tsp_vec_gt30 = []
    for i in range(33): tsp_vec_gt30.append(0.0)

    tsp_vec_lt09_pos = []
    for i in range(33): tsp_vec_lt09_pos.append(0.0)
    tsp_vec_09_30_pos = []
    for i in range(33): tsp_vec_09_30_pos.append(0.0)
    tsp_vec_gt30_pos = []
    for i in range(33): tsp_vec_gt30_pos.append(0.0)


    #tsp_res_path = '/home/secoops/web/tsp_res_90_sing_pos.txt'
    #tsp_res_file = open(tsp_res_path, 'w')
    
    total = len(tsp_dir_list)
    
    out_file = open('/home/secoops/web/haipeng/web/tsp_hist_new.txt', 'w')
    
    count = 0
    for tsp_file in tsp_dir_list:
    count += 1
        if count % 1000 == 0: print float(count) / float(total)
    culled_path = os.path.join(culled_dir, tsp_file.split('.')[0] + '.pdb')
    if not os.path.exists(culled_path): continue
    tsp_path = os.path.join(tsp_dir, tsp_file)
    name = os.path.split(tsp_path)[1][0:4]
    pdb_path = os.path.join(pdb_dir, 'pdb' + name + '.ent')
    pdb_info = PDB_get_info(pdb_path)
    if len(pdb_info) == 3:
        if pdb_info[1] == 'XRAY':
        if float(pdb_info[2]) > 0.9: continue
        tsp_lines = readlines(tsp_path)
        N = len(tsp_lines)
        tsp = 0.0
        for i in range(N):
            tsp_at_pos = float(tsp_lines[i].strip())
                    if float(pdb_info[2]) <= 0.9:
            out_file.write(str(tsp_at_pos) + '\n')
                tsp_vec_lt09_pos[int((tsp_at_pos - tsp_min) / bin_size)] += 1
            if float(pdb_info[2]) > 0.9 and float(pdb_info[2]) < 3.0:
            tsp_vec_09_30_pos[int((tsp_at_pos - tsp_min) / bin_size)] += 1                                        
            if float(pdb_info[2]) > 3.0:
            tsp_vec_gt30_pos[int((tsp_at_pos - tsp_min) / bin_size)] += 1

            tsp += tsp_at_pos
        tsp_pos = 0.0
        if N > 0:
            tsp_pos = tsp / float(N)
            if float(pdb_info[2]) <= 0.9:
                tsp_vec_lt09[int((tsp_pos - tsp_min) / bin_size)] += 1
            if float(pdb_info[2]) > 0.9 and float(pdb_info[2]) < 3.0:
            if tsp_pos < -4.0:
                print pdb_path
                print culled_path
                tsp_vec_09_30[int((tsp_pos - tsp_min) / bin_size)] += 1
            if float(pdb_info[2]) > 3.0:
                tsp_vec_gt30[int((tsp_pos - tsp_min) / bin_size)] += 1
            #tsp_res_file.write(tsp_lines[i].strip() + '\n')
    out_file.close()
    print 'TSP per res for each chain (< 0.9)'
    count_sum = float(sum(array(tsp_vec_lt09)))
    for i in range(33):
        print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size),
    if count_sum > 0.0: print tsp_vec_lt09[i] / count_sum
    else: print 0.0
    count_sum = float(sum(array(tsp_vec_09_30)))
    print '\nTSP per res for each chain (>= 0.9 and < 3.0)'
    for i in range(33):
        print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size), 
    if count_sum > 0.0: print tsp_vec_09_30[i] / count_sum
    else: print 0.0
    print '\nTSP per res for each chain (> 3.0)'
    count_sum = float(sum(array(tsp_vec_gt30)))
    for i in range(33):
        print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size),
    if count_sum > 0.0: print tsp_vec_gt30[i] / count_sum
    else: print 0.0

    print '\nTSP for every residue (< 0.9)'
    count_sum = float(sum(array(tsp_vec_lt09_pos)))
    for i in range(33):
        print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size),
    if count_sum > 0.0: print tsp_vec_lt09_pos[i] / count_sum
    else: print 0.0
    print '\nTSP for every residue (>= 0.9 and < 3.0)'
    count_sum = float(sum(array(tsp_vec_09_30_pos)))
    for i in range(33):
    print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size),
    if count_sum > 0.0: print tsp_vec_09_30_pos[i] / count_sum
    else: print 0.0
    print '\nTSP for every residue (> 3.0)'
    count_sum = float(sum(array(tsp_vec_gt30_pos)))
    for i in range(33):
    print str(tsp_min + (bin_size * i)) + '-' + str(tsp_min + (bin_size * i) + bin_size),
    if count_sum > 0.0: print tsp_vec_gt30_pos[i] / count_sum
        else: print 0.0

        #if N > 0:
            #tsp_res_file.write(pdb_info[2] + '\t' + str(tsp / float(N)) + '\n')
            #tsp_res_file.write(str(tsp / float(N)) + '\n')
        #else:
         #   continue
        
    #if count % 1000 == 0:
     #   print float(count) / float(total)
        
  #  tsp_res_file.close()
    
    #pyHistogram('/home/secoops/web/tsp_res_90_hires09.txt', '/home/secoops/web/tsp_res_90_sing.txt', '/home/secoops/web/tsp_res_90_hires09.png')
    
def tsp_records_scatter():

    pdb_dir = '/home/bartolo/PDBget-0.9-bin/pdb'
    tsp_dir = '/home/secoops/web/tsp_recordsC'
    culled_dir = '/home/bartolo/PDBget-0.9-bin/culled'
    tsp_dir_list = os.listdir(tsp_dir)


    tsp_res_path = '/home/secoops/web/tsp_resC.txt'
    tsp_res_file = open(tsp_res_path, 'w')
    
    total = len(tsp_dir_list)
    
    count = 0
    for tsp_file in tsp_dir_list:
    count += 1
        if count % 1000 == 0: print float(count) / float(total)
    culled_path = os.path.join(culled_dir, tsp_file.split('.')[0] + '.pdb')
    if not os.path.exists(culled_path): continue
    tsp_path = os.path.join(tsp_dir, tsp_file)
    name = os.path.split(tsp_path)[1][0:4]
    pdb_path = os.path.join(pdb_dir, 'pdb' + name + '.ent')
    pdb_info = PDB_get_info(pdb_path)
    if len(pdb_info) == 3:
        if pdb_info[1] == 'XRAY':
        tsp_lines = readlines(tsp_path)
        N = len(tsp_lines)
        tsp = 0.0
        for i in range(N):
            tsp_at_pos = float(tsp_lines[i].strip())
            tsp += tsp_at_pos
        if N > 0:
            tsp_res_file.write(pdb_info[2] + '\t' + str(tsp / float(N)) + '\n')
            
    tsp_res_file.close()
    
def plot_tsp_records():

    res_vec = []
    tsp_vec = []
    lines = readlines('/home/secoops/web/tsp_resC.txt')
    for line in lines:
    items = line.split()
    if len(items) > 1:
        res = float(line.split()[0])
        tsp = float(line.split()[1])
        if res < 5.0:
            res_vec.append(res)
            tsp_vec.append(tsp)
    
    res_array = array(res_vec)
    tsp_array = array(tsp_vec)
   
    tsp_res_line = line_array(res_array, tsp_array)
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.scatter(res_array, tsp_array, c='r', s=1)
    pylab.plot(tsp_res_line[0], tsp_res_line[1], 'k')
    
    R2 = (pylab.corrcoef(res_array, tsp_array)[0][1]) ** 2
    
    minx = min(res_array)
    maxx = max(res_array)
    miny = min(tsp_array)
    maxy = max(tsp_array)
    
    xpad = ((maxx - minx) * 0.05)
    ypad = ((maxy - miny) * 0.05)
    pylab.xlim(minx - xpad, maxx + xpad)
    pylab.ylim(miny - ypad, maxy + ypad)
    
    slope = tsp_res_line[2][0]
    yint = tsp_res_line[3][0]
    
    if yint >= 0:
    inter_sign = '+'
    else:
    inter_sign = '-'
    
    pylab.xlabel('Resolution', fontsize=20)
    pylab.ylabel('TSP3', fontsize=20)
    
    labels = 'TSP3 = ' + str(slope)[0:3] + ' * resolution ' + inter_sign + ' ' + str(pylab.absolute(yint))[0:3] + '\nR^2 = ' + str(R2)
    # + '\nR^2 = ' + str(R2)
    pylab.text(0.8, 8.0, labels, fontsize=10)
    
    
    
    rev_slope = 1.0 / slope
    rev_yint = (yint * -1.0) / slope
    if rev_yint >= 0:
    rev_inter_sign = '+'
    else:
    rev_inter_sign = '-'
    
    rev_labels = 'resolution = ' + str(rev_slope)[0:4] + ' * TSP3 ' + rev_inter_sign + ' ' + str(pylab.absolute(rev_yint))[0:3]+ '\nR^2 = ' + str(R2)
    # + '\nR^2 = ' + str(R2)
    pylab.text(0.8, 7.0, rev_labels, fontsize=10)
    
    pylab.savefig('/home/secoops/web/tsp_resC.png')
    
    pylab.close()
        
def PDB_get_info(pdb_path):
    
    data_type = ''
    data_vec = []
    
    pdb_lines = readlines(pdb_path)
    year = int(pdb_lines[0].split()[-2][-2] + pdb_lines[0].split()[-2][-1])
    if year >= 0 and year <= 10: year += 2000
    else: year += 1900
    data_vec.append(str(year))
    for i in range(1, len(pdb_lines)):
    if pdb_lines[i][0:6] == 'EXPDTA':
        if len(pdb_lines[i].split()) > 2:
        if pdb_lines[i].split()[1] == 'X-RAY':
            data_type = 'XRAY'
            data_vec.append(data_type)
    if len(pdb_lines[i].split()) > 4:
        if pdb_lines[i].split()[2] == 'RESOLUTION.' and pdb_lines[i].split()[4] == 'ANGSTROMS.': data_vec.append(pdb_lines[i].split()[3])
            
        if len(data_vec) == 3:
        break
    return data_vec
        
def TSP_platinum(pdb_path, tsp_path):

    current_dir = os.getcwd()
    os.chdir('/home/secoops/web/haipeng/web')
    
    genseq_path = tempfile.mktemp('.seq')
    os.system('./genseq -in ' + pdb_path + ' -out ' + genseq_path)
    seq_lines = readlines(genseq_path)
    os.remove(genseq_path)
    jury_vec = []
    sub_vec = []
    idx = 0
    for line in seq_lines:
    backbone_line = line.strip().split()
    if len(backbone_line) > 2:
        AA3 = backbone_line[2]
        if ResidueVerify(AA3) == 1 and backbone_line[7] != 'H':
        sub_vec.append(idx)
        else:
            if len(sub_vec) > 10:
                jury_vec.append(sub_vec)
        sub_vec = []
    else:
        if len(sub_vec) > 10:
            jury_vec.append(sub_vec)
        sub_vec = []
    idx += 1
    if idx == len(seq_lines) - 1:
        if len(sub_vec) > 10:
            jury_vec.append(sub_vec)

    tsp_vec = []        
    for i in range(len(jury_vec)):
        
    phi_psi_path = tempfile.mktemp('.txt')
        AA_path = tempfile.mktemp('.txt')
    labeling_path = tempfile.mktemp('.txt')
    phi_psi_file = open(phi_psi_path, 'w')
    AA_file = open(AA_path, 'w')
    label_file = open(labeling_path, 'w')
    for j in range(len(jury_vec[i])):
        idx = jury_vec[i][j]
        seq_line = seq_lines[idx].split()
        phi_psi_file.write(seq_line[3] + '\t' + seq_line[4] + '\n')
        AA_file.write(str(OOPS_AA_convert(seq_line[2])) + '\n')
        label_file.write(seq_line[0] + '\t' + seq_line[1] + '\n')
        phi_psi_file.close()
        label_file.close()
        AA_file.close()
    
        list_path = tempfile.mktemp('.list')
        tsp_cfg_new_path = tempfile.mktemp('.cfg')
        tsp_cfg_new_file = open(tsp_cfg_new_path, 'w')
        tsp_cfg_old_lines = readlines('/home/secoops/web/haipeng/web/tsp1-3A.cfg')
        for i in range(6): tsp_cfg_new_file.write(tsp_cfg_old_lines[i])
        tsp_cfg_new_file.write(tsp_cfg_old_lines[-2].replace('phi_psi.txt', phi_psi_path))
        tsp_cfg_new_file.write(tsp_cfg_old_lines[-1].replace('AA.txt', AA_path))
        tsp_cfg_new_file.close()
    
        os.system('nice ./scalc -cfg scalc.cfg -calc libTSP1.so,' + tsp_cfg_new_path + ' -str ' + pdb_path + ' > ' + list_path)
        os.remove(tsp_cfg_new_path)
    
        list_vec = readlines(list_path)
    for j in range(len(list_vec) - 3):
        list_line = list_vec[j + 1].split()
        tsp_vec.append(float(list_line[1]))
    
        os.remove(list_path)
        os.remove(labeling_path)
        os.remove(AA_path)
        os.remove(phi_psi_path)

    if len(tsp_vec) > 0:
        tsp_file = open(tsp_path, 'w')
        for i in range(len(tsp_vec)): tsp_file.write(str(tsp_vec[i]) + '\n')
        tsp_file.close()

    os.chdir(current_dir)

def run_tsp_platinum():

    out_dir = '/home/secoops/web/tsp_recordsC'
    script_dir = '/home/secoops/web/tsp_scripts'
    pdb_dir = '/home/bartolo/PDBget-0.9-bin/culled'
    pdb_list = os.listdir(pdb_dir)
    for file in pdb_list:
        pdb_path = os.path.join(pdb_dir, file)
    name = os.path.split(pdb_path)[1].split('.')[0]
    out_path = os.path.join(out_dir, name + '.tsp')
    if not os.path.exists(out_path):
        script_path = os.path.join(script_dir, 'T' + name + '.sh')

            script_file = open(script_path, 'w')
        script_file.write('/home/secoops/web/build.py -tsp_platinum ' + pdb_path + ' ' + out_path)
        script_file.close()
        os.system('chmod u+x ' + script_path)
            submit_sge_job(script_path, 'secoops', 100, 60, 200)
    
def AA_FW(AA):
    if AA == 'A': return 71.037114
    elif AA == 'C': return 103.00919
    elif AA == 'D': return 103.00919
    elif AA == 'E': return 129.1299
    elif AA == 'F': return 147.1900
    elif AA == 'G': return 57.0669
    elif AA == 'H': return 137.1552
    elif AA == 'I': return 113.1736
    elif AA == 'K': return 128.1882
    elif AA == 'L': return 113.1736
    elif AA == 'M': return 131.2124
    elif AA == 'N': return 114.1184
    elif AA == 'P': return 97.1310
    elif AA == 'Q': return 128.1451
    elif AA == 'R': return 156.2017
    elif AA == 'S': return 87.0930
    elif AA == 'T': return 101.1197
    elif AA == 'V': return 99.1469
    elif AA == 'W': return 186.2262
    elif AA == 'Y': return 163.1894
    
def AA_FW_N15(AA):
    if AA == 'A': return 72.0931
    elif AA == 'C': return 104.1590
    elif AA == 'D': return 116.1032
    elif AA == 'E': return 130.1299
    elif AA == 'F': return 147.1900
    elif AA == 'G': return 58.0669
    elif AA == 'H': return 140.1552
    elif AA == 'I': return 114.1736
    elif AA == 'K': return 130.1882
    elif AA == 'L': return 114.1736
    elif AA == 'M': return 132.2124
    elif AA == 'N': return 116.1184
    elif AA == 'P': return 99.1310
    elif AA == 'Q': return 130.1451
    elif AA == 'R': return 160.2017
    elif AA == 'S': return 88.0930
    elif AA == 'T': return 102.1197
    elif AA == 'V': return 100.1469
    elif AA == 'W': return 188.2262
    elif AA == 'Y': return 164.1894
    
def mass_spec_analysis(fasta_path):
    
    sequence = readline(fasta_path, 2)
    sequence = sequence.strip()
    
    N = len(sequence)
    for i in range(N):
    mass_sum = 0.0
    seq_frag = ''
    for j in range(N - i):
        mass_sum += AA_FW_N15(sequence[j])
        seq_frag += sequence[j]
    print seq_frag
    print mass_sum
     
def neighbor_probability():
    
    seq_dir = '/home/secoops/web/PDB/seqdata_90'
    seq_list = os.listdir(seq_dir)
    
    singletL_prob = []
    for i in range(20): singletL_prob.append(0.0)
    
    singletR_prob = []
    for i in range(20): singletR_prob.append(0.0)
        
    doublet = []
    for i in range(20):
    doublet.append([])
    for j in range(20):
        doublet[i].append(0)
        
    doubletL_prob = []
    for i in range(20):
    doubletL_prob.append([])
    for j in range(20):
        doubletL_prob[i].append(0.0)
        
    doubletR_prob = []
    for i in range(20):
    doubletR_prob.append([])
    for j in range(20):
        doubletR_prob[i].append(0.0)
    
    sep_int = 1
    SecStr = 'E'
    count = 0
    for file in seq_list:
    count += 1
    seq_path = os.path.join(seq_dir, file)
    back_lines = readlines(seq_path)
    N = len(back_lines)
    for i in range(N):
        if i + sep_int < N - 1:
        matches = 0
        for j in range(sep_int):
            items = back_lines[i + j].split()
            if len(items) > 2:
            AA3 = items[2]
            if ResidueVerify(AA3) == 1 and items[7] == SecStr: matches += 1
            else: break
            else: break
        if matches < sep_int: continue
            items1 = back_lines[i].split()
        items2 = back_lines[i + sep_int].split()
        if len(items1) > 2 and len(items2) > 2:
                AA3_1 = items1[2]
            AA3_2 = items2[2]
                if ResidueVerify(AA3_1) == 1 and ResidueVerify(AA3_2) == 1 and items1[7] == 'E' and items2[7] == 'E':
                AA1_idx = AAChar_int(AAConvertTS(AA3_1))
            AA2_idx = AAChar_int(AAConvertTS(AA3_2))
            doublet[AA1_idx][AA2_idx] += 1

    if count % 1000 == 0:
        
            total = 0
        for i in range(20):
            for j in range(20):
            total += doublet[i][j]
        
        for i in range(20):
            totalL = 0
            for j in range(20):
            totalL += doublet[i][j]
                singletL_prob[i] = float(totalL) / float(total)
        for j in range(20):
            doubletL_prob[i][j] = float(doublet[i][j]) / float(totalL)

        totalR = 0
        for j in range(20):
            totalR += doublet[j][i]
        singletR_prob[i] = float(totalR) / float(total)
        for j in range(20):
            doubletR_prob[j][i] = float(doublet[j][i]) / float(totalR)
        
        
        print float(count) / float(len(seq_list))
        prob_file = open('/home/secoops/web/EE_doublet_probs.txt', 'w')
        prob_file.write('AA\t')
        for i in range(20):
        prob_file.write(AAChar_fasta(i) + '\t')
        prob_file.write('\n')
        for i in range(20):
        prob_file.write(AAChar_fasta(i) + '\t')
        for j in range(20):
            prob = (doubletL_prob[i][j]) / singletR_prob[j]
            prob_file.write(str(prob)[0:5] + '\t')
        prob_file.write('\n')
        prob_file.write('\n\n')
        
        prob_file.write('AA\t')
        for i in range(20):
        prob_file.write(AAChar_fasta(i) + '\t')
        prob_file.write('\n')
        for i in range(20):
        prob_file.write(AAChar_fasta(i) + '\t')
        for j in range(20):
            prob = doubletR_prob[j][i] / singletL_prob[j]
            prob_file.write(str(prob)[0:5] + '\t')
        prob_file.write('\n')
        
        prob_file.close()
        
def vector_angle(set1, set2):
    
    coords1 = []
    coords2 = []
    for i in range(3):
    coords1.append(set1[0][i] - set1[1][i])
    coords2.append(set2[0][i] - set2[1][i])
    
    try: return math.degrees(math.acos((coords1[0] * coords2[0] + coords1[1] * coords2[1] + coords1[2] * coords2[2]) / (math.sqrt(coords1[0] * coords1[0] + coords1[1] * coords1[1] + coords1[2] * coords1[2]) * math.sqrt(coords2[0] * coords2[0] + coords2[1] * coords2[1] + coords2[2] * coords2[2]))))
    except: return 0.0
    
def propwash(set1, set2):
    
    coords1 = []
    coords2 = []
    for i in range(3):
    coords1.append(set1[0][i] - set1[1][i])
    coords2.append(set1[0][i] - set2[0][i])
    
    try: pw1 = math.degrees(math.acos((coords1[0] * coords2[0] + coords1[1] * coords2[1] + coords1[2] * coords2[2]) / (math.sqrt(coords1[0] * coords1[0] + coords1[1] * coords1[1] + coords1[2] * coords1[2]) * math.sqrt(coords2[0] * coords2[0] + coords2[1] * coords2[1] + coords2[2] * coords2[2]))))
    except: return 0.0
    
    coords1 = []
    coords2 = []
    for i in range(3):
    coords1.append(set2[0][i] - set2[1][i])
    coords2.append(set2[0][i] - set1[0][i])
    
    try: pw2 = math.degrees(math.acos((coords1[0] * coords2[0] + coords1[1] * coords2[1] + coords1[2] * coords2[2]) / (math.sqrt(coords1[0] * coords1[0] + coords1[1] * coords1[1] + coords1[2] * coords1[2]) * math.sqrt(coords2[0] * coords2[0] + coords2[1] * coords2[1] + coords2[2] * coords2[2]))))
    except: return 0.0
    
    try: return math.sqrt((pw1 - 90.0) ** 2 + (pw2 - 90.0) ** 2)
    except: return 0.0
        
def helix_position_prob():
    
    seq_dir = '/home/secoops/web/PDB/seqdata_90'
    seq_list = os.listdir(seq_dir)
    
    pos_count = []
    for i in range(12):
        pos_count.append([])
    for j in range(20): pos_count[i].append(0)
    
    pos_probs = []
    for i in range(12):
        pos_probs.append([])
    for j in range(20): pos_probs[i].append(0.0)
    
    count = []
    for i in range(20): count.append(0)
    
    prob = []
    for i in range(20): prob.append(0.0)
    
    counts = 0
    for file in seq_list:
    counts += 1
    seq_path = os.path.join(seq_dir, file)
    back_lines = readlines(seq_path)
    N = len(back_lines)
    for i in range(N):
        if i + 5 < N - 1:
        items = back_lines[i].split()
        matches = 0
        if len(items) > 2:
            AA3 = items[2]
            if ResidueVerify(AA3) == 1 and items[7] != 'H':
                for j in range(5):
                    items = back_lines[i + 1 + j].split()
                    if len(items) > 2:
                    AA3 = items[2]
                    if ResidueVerify(AA3) == 1 and items[7] == 'H': matches += 1
                    else: break
                    else: break
        if matches == 5:
            for j in range(6):
                items = back_lines[i + j].split()
            AA3 = items[2]
            AA_idx = AAChar_int(AAConvertTS(AA3))
            pos_count[j][AA_idx] += 1
            count[AA_idx] += 1

        if i > 4:
        items = back_lines[i].split()
        matches = 0
        if len(items) > 2:
            AA3 = items[2]
            if ResidueVerify(AA3) == 1 and items[7] != 'H':
                for j in range(5):
                    items = back_lines[i - 1 - j].split()
                    if len(items) > 2:
                    AA3 = items[2]
                    if ResidueVerify(AA3) == 1 and items[7] == 'H': matches += 1
                    else: break
                    else: break
        if matches == 5:
            for j in range(6):
                items = back_lines[i - j].split()
            AA3 = items[2]
            AA_idx = AAChar_int(AAConvertTS(AA3))
            pos_count[11 - j][AA_idx] += 1
            count[AA_idx] += 1

    if counts % 1000 == 0:
        
            total = 0
        for i in range(20):
            total += count[i]
        
        for i in range(20):
        prob[i] = float(count[i]) / float(total)
        
        for i in range(12):
        totali = 0
        for j in range(20):
            totali += pos_count[i][j]
        for j in range(20):
            pos_probs[i][j] = float(pos_count[i][j]) / float(totali)
        
        print float(counts) / float(len(seq_list))
        prob_file = open('/home/secoops/web/Hpos_probs.txt', 'w')
        prob_file.write('AA\t')
        for i in range(20):
        prob_file.write(AAChar_fasta(i) + '\t')
        prob_file.write('\n')
        for i in range(12):
        if i < 6: prob_file.write('i+' + str(i) + '\t')
        else: prob_file.write('i-' + str(11-i) + '\t')
        for j in range(20):
            pos_prob = pos_probs[i][j] / prob[j]
            prob_file.write(str(pos_prob)[0:5] + '\t')
        prob_file.write('\n')
        prob_file.write('\n\n')
        
        prob_file.close()
        
def pdb_info(pdb_path, seqdata_path):

    pdbinfo_vec = []
    lines = readlines(pdb_path)
    
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
        try:
            position = int(line[22:28].strip())
        except:
            continue
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            pdbinfo_vec.append([])
            pdbinfo_vec[-1].append(position)
            pdbinfo_vec[-1].append(AAChar_int(AAConvertTS(AA3)))
            pdbinfo_vec[-1].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
            if AAConvertTS(AA3) == 'G':
            pdbinfo_vec[-1].append([1000.0, 1000.0, 1000.0])

    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CB':
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            try:
                position = int(line[22:28].strip())
            except:
            continue
            for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1]:
                if len(pdbinfo_vec[i]) == 3: pdbinfo_vec[i].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
                break
            
    seqdata_vec = []
    seqdata_lines = readlines(seqdata_path)
    
    for line in seqdata_lines:
    items = line.split()
    if len(items) > 2:
        AA3 = items[2]
        position = int(items[1])
        if ResidueVerify(AA3) == 1:
        for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1]: 
                pdbinfo_vec[i].append(items[7])
            pdbinfo_vec[i].append([float(items[3]), float(items[4])])
            pdbinfo_vec[i].append(sasa(pdbinfo_vec[i][1], float(items[9])))

    while True:
    count = 0
        for i in range(len(pdbinfo_vec)):
        count += 1
        if len(pdbinfo_vec[i]) != 7:
            #print 'ERROR!'
            #print pdb_path
        try:
                del pdbinfo_vec[i]
        except: break
        break
        if len(pdbinfo_vec[i][2]) != 3 or len(pdbinfo_vec[i][3]) != 3 or len(pdbinfo_vec[i][5]) != 2:
            #print 'ERROR!'
            #print pdb_path
            del pdbinfo_vec[i]
        break
    if count == len(pdbinfo_vec): break
    if len(pdbinfo_vec[-1]) != 7: del pdbinfo_vec[-1]

    for i in range(len(pdbinfo_vec)):
    if len(pdbinfo_vec[i]) != 7:
        print 'size ERROR!'
        print pdb_path
        print pdbinfo_vec[i]
    try:
        float(pdbinfo_vec[i][2][0])
        float(pdbinfo_vec[i][2][1])
        float(pdbinfo_vec[i][2][2])
        float(pdbinfo_vec[i][3][0])
        float(pdbinfo_vec[i][3][1])
        float(pdbinfo_vec[i][3][2])
        float(pdbinfo_vec[i][5][0])
        float(pdbinfo_vec[i][5][1])
    except:
        print 'shape ERROR!'
        print pdb_path
            
    return pdbinfo_vec
    
def pdb_info2(pdb_path, seqdata_path):

    pdbinfo_vec = []
    lines = readlines(pdb_path)
    
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
        try:
            position = int(line[22:28].strip())
            chainid = line[21:22].strip()
        except:
            continue
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            pdbinfo_vec.append([])
            pdbinfo_vec[-1].append([position, chainid])
            pdbinfo_vec[-1].append(AAChar_int(AAConvertTS(AA3)))
            pdbinfo_vec[-1].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
            if AAConvertTS(AA3) == 'G':
            pdbinfo_vec[-1].append([1000.0, 1000.0, 1000.0])

    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CB':
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            try:
                position = int(line[22:28].strip())
                chainid = line[21:22].strip()
            except:
            continue
            for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1] and chainid == pdbinfo_vec[i][0][1]:
                if len(pdbinfo_vec[i]) == 3: pdbinfo_vec[i].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
                break
            
    seqdata_vec = []
    seqdata_lines = readlines(seqdata_path)
    
    for line in seqdata_lines:
    items = line.split()
    if len(items) > 2:
        AA1 = items[2]
        position = int(items[0])
        chainid = items[1]
        if ResidueVerify(AAConvertST(AA1)) == 1:
        for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AA1) == pdbinfo_vec[i][1] and chainid == pdbinfo_vec[i][0][1]:
                pdbinfo_vec[i].append(items[3])
            pdbinfo_vec[i].append(sasa(pdbinfo_vec[i][1], float(items[4])))

    while True:
    count = 0
        for i in range(len(pdbinfo_vec)):
        count += 1
        if len(pdbinfo_vec[i]) != 6:
            #print 'ERROR!'
            #print pdb_path
        try:
                del pdbinfo_vec[i]
        except: break
        break
        if len(pdbinfo_vec[i][2]) != 3 or len(pdbinfo_vec[i][3]) != 3:
            #print 'ERROR!'
            #print pdb_path
            del pdbinfo_vec[i]
        break
    if count == len(pdbinfo_vec): break
    if len(pdbinfo_vec[-1]) != 6: del pdbinfo_vec[-1]

    for i in range(len(pdbinfo_vec)):
    if len(pdbinfo_vec[i]) != 6:
        print 'size ERROR!'
        print pdb_path
        print pdbinfo_vec[i]
    try:
        float(pdbinfo_vec[i][2][0])
        float(pdbinfo_vec[i][2][1])
        float(pdbinfo_vec[i][2][2])
        float(pdbinfo_vec[i][3][0])
        float(pdbinfo_vec[i][3][1])
        float(pdbinfo_vec[i][3][2])
    except:
        print 'shape ERROR!'
        print pdb_path
            
    return pdbinfo_vec
    
def structure_info(pdb_path, seqdata_path):

    pdbinfo_vec = []
    lines = readlines(pdb_path)
    
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
        try:
            position = int(line[22:28].strip())
            chainid = line[21:22].strip()
        except:
            continue
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            pdbinfo_vec.append([])
            pdbinfo_vec[-1].append([position, chainid])
            pdbinfo_vec[-1].append(AAChar_int(AAConvertTS(AA3)))
            pdbinfo_vec[-1].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
            if AAConvertTS(AA3) == 'G':
            pdbinfo_vec[-1].append([1000.0, 1000.0, 1000.0])

    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CB':
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            try:
                position = int(line[22:28].strip())
                chainid = line[21:22].strip()
            except:
            continue
            for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1] and chainid == pdbinfo_vec[i][0][1]:
                if len(pdbinfo_vec[i]) == 3: pdbinfo_vec[i].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
                break
                
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15].strip() == 'N':
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            try:
                position = int(line[22:28].strip())
                chainid = line[21:22].strip()
            except:
            continue
            for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1] and chainid == pdbinfo_vec[i][0][1]:
                if len(pdbinfo_vec[i]) == 4: pdbinfo_vec[i].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
                break
                
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15].strip() == 'C':
        AA3 = line[17:20]
        if ResidueVerify(AA3) == 1:
            try:
                position = int(line[22:28].strip())
                chainid = line[21:22].strip()
            except:
            continue
            for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AAConvertTS(AA3)) == pdbinfo_vec[i][1] and chainid == pdbinfo_vec[i][0][1]:
                if len(pdbinfo_vec[i]) == 5: pdbinfo_vec[i].append([float(line[30:38]), float(line[39:46]), float(line[47:54])])
                break
            
    seqdata_vec = []
    seqdata_lines = readlines(seqdata_path)
    
    for line in seqdata_lines:
    items = line.split()
    if len(items) > 2:
        AA1 = items[-3]
        position = int(items[0])
        if ResidueVerify(AAConvertST(AA1)) == 1:
        for i in range(len(pdbinfo_vec)):
            if position == pdbinfo_vec[i][0][0] and AAChar_int(AA1) == pdbinfo_vec[i][1]:
                pdbinfo_vec[i].append(items[-2])
            pdbinfo_vec[i].append(sasa(pdbinfo_vec[i][1], float(items[-1])))

    while True:
    count = 0
        for i in range(len(pdbinfo_vec)):
        count += 1
        if len(pdbinfo_vec[i]) != 8:
        try:
                del pdbinfo_vec[i]
        except: break
        break
        if len(pdbinfo_vec[i][2]) != 3 or len(pdbinfo_vec[i][3]) != 3 or len(pdbinfo_vec[i][4]) != 3 or len(pdbinfo_vec[i][5]) != 3:
            del pdbinfo_vec[i]
        break

    if count == len(pdbinfo_vec): break
    if len(pdbinfo_vec[-1]) != 8: del pdbinfo_vec[-1]

    for i in range(len(pdbinfo_vec)):
    try:
        float(pdbinfo_vec[i][2][0])
        float(pdbinfo_vec[i][2][1])
        float(pdbinfo_vec[i][2][2])
        float(pdbinfo_vec[i][3][0])
        float(pdbinfo_vec[i][3][1])
        float(pdbinfo_vec[i][3][2])
        float(pdbinfo_vec[i][4][0])
        float(pdbinfo_vec[i][4][1])
        float(pdbinfo_vec[i][4][2])
        float(pdbinfo_vec[i][5][0])
        float(pdbinfo_vec[i][5][1])
        float(pdbinfo_vec[i][5][2])
    except:
        int('A')
    
    return pdbinfo_vec
    
def sidechain_atoms(AA):
  
    if AA == 'A': return ['CB']
    elif AA == 'C': return ['CB', 'SG']
    elif AA == 'D': return ['CB', 'OD1', 'OD2']
    elif AA == 'E': return ['CB', 'OE1', 'OE2']
    elif AA == 'F': return ['CB', 'CE1', 'CE2', 'CZ']
    elif AA == 'G': return ['CA']
    elif AA == 'H': return ['CB', 'CE1', 'NE2']
    elif AA == 'I': return ['CB', 'CG1', 'CG2', 'CD1']
    elif AA == 'K': return ['CB', 'NZ']
    elif AA == 'L': return ['CB', 'CD1', 'CD2']
    elif AA == 'M': return ['CB', 'CE']
    elif AA == 'N': return ['CB', 'OD1', 'ND2']
    elif AA == 'P': return ['CB', 'CG', 'CD']
    elif AA == 'Q': return ['CB', 'OE1', 'NE2']
    elif AA == 'R': return ['CB', 'NE', 'CZ']
    elif AA == 'S': return ['CB', 'OG']
    elif AA == 'T': return ['CB', 'OG1', 'CG2']
    elif AA == 'V': return ['CB', 'CG1', 'CG2']
    elif AA == 'W': return ['CB', 'CD1', 'CD2', 'NE1', 'CZ2', 'CZ3', 'CH2']
    elif AA == 'Y': return ['CB', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ', 'OH']

def sidechain_cutoff_dist(AA):
  
    if AA == 'A': return 0.2
    elif AA == 'C': return 0.4
    elif AA == 'D': return 0.4
    elif AA == 'E': return 0.4
    elif AA == 'F': return 0.4
    elif AA == 'G': return 0.2
    elif AA == 'H': return 0.4
    elif AA == 'I': return 0.4
    elif AA == 'K': return 0.4
    elif AA == 'L': return 0.4
    elif AA == 'M': return 0.4
    elif AA == 'N': return 0.4
    elif AA == 'P': return 0.4
    elif AA == 'Q': return 0.4
    elif AA == 'R': return 0.4
    elif AA == 'S': return 0.4
    elif AA == 'T': return 0.4
    elif AA == 'V': return 0.4
    elif AA == 'W': return 0.4
    elif AA == 'Y': return 0.4

def residue_atoms(AA):
  
    if AA == 'A': return ['CB']
    elif AA == 'C': return ['CB', 'SG']
    elif AA == 'D': return ['CB', 'CG', 'OD1', 'OD2']
    elif AA == 'E': return ['CB', 'CG', 'CD', 'OE1', 'OE2']
    elif AA == 'F': return ['CB', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ']
    elif AA == 'G': return ['CA']
    elif AA == 'H': return ['CB', 'CG', 'ND1', 'CD2', 'CE1', 'NE2']
    elif AA == 'I': return ['CB', 'CG1', 'CG2', 'CD1']
    elif AA == 'K': return ['CB', 'CG', 'CD', 'CE', 'NZ']
    elif AA == 'L': return ['CB', 'CG', 'CD1', 'CD2']
    elif AA == 'M': return ['CB', 'CG', 'SD', 'CE']
    elif AA == 'N': return ['CB', 'CG', 'OD1', 'ND2']
    elif AA == 'P': return ['CB', 'CG', 'CD']
    elif AA == 'Q': return ['CB', 'CG', 'CD', 'OE1', 'NE2']
    elif AA == 'R': return ['CB', 'CG', 'CD', 'NE', 'CZ']
    elif AA == 'S': return ['CB', 'OG']
    elif AA == 'T': return ['CB', 'OG1', 'CG2']
    elif AA == 'V': return ['CB', 'CG1', 'CG2']
    elif AA == 'W': return ['CB', 'CD1', 'CD2', 'NE1', 'CZ2', 'CZ3', 'CH2']
    elif AA == 'Y': return ['CB', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ', 'OH']

def sidechain_atoms_match(AA):
  
    if AA == 'A': return ['CB']
    elif AA == 'C': return ['CB', 'SG']
    elif AA == 'D': return ['CB', 'OD1', 'OD2']
    elif AA == 'E': return ['CB', 'OE1', 'OE2']
    elif AA == 'F': return ['CB', 'CE1', 'CE2', 'CZ']
    elif AA == 'G': return ['CA']
    elif AA == 'H': return ['CB', 'CE1', 'NE2']
    elif AA == 'I': return ['CB', 'CG1', 'CG2', 'CD1']
    elif AA == 'K': return ['CB', 'NZ']
    elif AA == 'L': return ['CB', 'CD1', 'CD2']
    elif AA == 'M': return ['CB', 'CE']
    elif AA == 'N': return ['CB', 'OD1', 'ND2']
    elif AA == 'P': return ['CB', 'CG', 'CD']
    elif AA == 'Q': return ['CB', 'OE1', 'NE2']
    elif AA == 'R': return ['CB', 'NE', 'CZ']
    elif AA == 'S': return ['CB', 'OG']
    elif AA == 'T': return ['CB', 'OG1', 'CG2']
    elif AA == 'V': return ['CB', 'CG1', 'CG2']
    elif AA == 'W': return ['CB', 'CD1', 'CD2', 'NE1', 'CZ2', 'CZ3', 'CH2']
    elif AA == 'Y': return ['CB', 'CD1', 'CD2', 'CE1', 'CE2', 'CZ', 'OH']

def store_pdb_info(pdb_path):

    pdbinfo_vec = []
    res_list = []
 
    lines = readlines(pdb_path)
    
    for i in range(len(lines)):
        if lines[i][0:4] == 'ATOM':
        if lines[i][13:15] == 'CA':
        try:
            position = int(lines[i][22:28].strip())
            chainid = lines[i][21:22].strip()
        except:
            continue
        if position in res_list: continue
        res_list.append(position)
        AA3 = lines[i][17:20]
        if ResidueVerify(AA3) == 1:
            pdbinfo_vec.append([])
            pdbinfo_vec[-1].append([position, chainid])
            pdbinfo_vec[-1].append(AAChar_int(AAConvertTS(AA3)))
            pdbinfo_vec[-1].append([[], []])
            pdbinfo_vec[-1][-1][0].append('CA')
            pdbinfo_vec[-1][-1][1].append([float(lines[i][30:38]), float(lines[i][39:46]), float(lines[i][47:54])])
             
            atoms_list = sidechain_atoms(AAConvertTS(AA3))
            found_list = []
            for j in range(i, len(lines)):
            if lines[j][0:4] == 'ATOM':
                try:
                    position_j = int(lines[j][22:28].strip())
                chainid_j = lines[j][21:22].strip()
                except: continue
                if position_j > position: break
                if position_j == position and chainid_j == chainid:
                    atom_type = lines[j][13:16].strip()
                    if atom_type in atoms_list and not atom_type in found_list:
                    found_list.append(atom_type)
                    pdbinfo_vec[-1][-1][0].append(atom_type)
                    pdbinfo_vec[-1][-1][1].append([float(lines[j][30:38]), float(lines[j][39:46]), float(lines[j][47:54])])

    for i in range(len(pdbinfo_vec)):
        if len(pdbinfo_vec[i]) != 3:
        print 'SOMETHING MISSING IN ' + pdb_path
        print pdbinfo_vec[i]
        
    for j in range(len(pdbinfo_vec[i][2][1])):
        for k in range(3):
            try: float(pdbinfo_vec[i][2][1][j][k])
            except: print 'Bad coordinate at ' + AA1 + str(i + 1) + ' in ' + pdb_path
    
    return pdbinfo_vec
    
def info_test():
  
    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_list = os.listdir(pdb_dir)
    count = 0
    for seqd in seqdata_list:
        count += 1
        if count > 0 and count % 100 == 0: print float(count) / float(len(seqdata_list)) 
        name = seqd.split('.')[0]
        sp = os.path.join(seqdata_dir, seqd)
        pp = os.path.join(pdb_dir, name + '.pdb')
        store_pdb_info(pp)
            
def distance_matrixCB(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][3], pdbinfo_vec[j][3])
        
    return distance_matrix
    
def distance_matrix_sidechain(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N):
        distance_matrix[i].append([[], []])
    
    for i in range(N):
    for j in range(i + 1, N):
        for k in range(len(pdbinfo_vec[i][2][0])):
            for l in range(len(pdbinfo_vec[j][2][0])):
            distance_matrix[i][j][0].append([pdbinfo_vec[i][2][0][k], pdbinfo_vec[j][2][0][l]])
            distance_matrix[i][j][1].append(distance(pdbinfo_vec[i][2][1][k], pdbinfo_vec[j][2][1][l]))
        
    return distance_matrix
    
def distance_matrix_sidechain_use(pdbinfo_vec, use_index):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N):
        distance_matrix[i].append([[], []])
    
    for pair in use_index:
    i = pair[0]
    j = pair[1]
    for k in range(len(pdbinfo_vec[i][2][0])):
        for l in range(len(pdbinfo_vec[j][2][0])):
            atom1 = pdbinfo_vec[i][2][0][k]
            atom2 = pdbinfo_vec[j][2][0][l]
            dist = distance(pdbinfo_vec[i][2][1][k], pdbinfo_vec[j][2][1][l])
            distance_matrix[i][j][0].append([atom1, atom2])
        distance_matrix[i][j][1].append(dist)
    
        
    return distance_matrix
    
def distance_matrixN(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][4], pdbinfo_vec[j][4])
        
    return distance_matrix
    
def distance_matrixC(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][5], pdbinfo_vec[j][5])
        
    return distance_matrix
    
def distance_matrixCA(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][2], pdbinfo_vec[j][2])
        
    return distance_matrix
    
def distance_matrixCACB(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][2], pdbinfo_vec[j][3])
        
    return distance_matrix
    
def distance_matrixCBCA(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    distance_matrix = []
    for i in range(N):
    distance_matrix.append([])
    for j in range(N): distance_matrix[i].append(0.0)
    
    for i in range(N):
    for j in range(i + 1, N):
        distance_matrix[i][j] = distance(pdbinfo_vec[i][3], pdbinfo_vec[j][2])
        
    return distance_matrix
        
def angle_matrix(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    angle_matrix = []
    for i in range(N):
    angle_matrix.append([])
    for j in range(N): angle_matrix[i].append(0.0)
    
    for i in range(N):
    set1 = []
    set1.append(pdbinfo_vec[i][2])
    set1.append(pdbinfo_vec[i][3])
    for j in range(i + 1, N):
        set2 = []
        set2.append(pdbinfo_vec[j][2])
        set2.append(pdbinfo_vec[j][3])
        angle_matrix[i][j] = vector_angle(set1, set2)
    return angle_matrix
    
def angle_matrix_sidechain(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    angle_matrix = []
    for i in range(N):
    angle_matrix.append([])
    for j in range(N): angle_matrix[i].append(0.0)
    
    for i in range(N):
        set1 = []
        if AAChar_fasta(pdbinfo_vec[i][1]) != 'G':
        try:
            set1.append(pdbinfo_vec[i][2][1][pdbinfo_vec[i][2][0].index('CA')])
            set1.append(pdbinfo_vec[i][2][1][pdbinfo_vec[i][2][0].index('CB')])
        except: set1 = []
    for j in range(i + 1, N):
        set2 = []
        if AAChar_fasta(pdbinfo_vec[j][1]) != 'G':
            try:
                set2.append(pdbinfo_vec[j][2][1][pdbinfo_vec[j][2][0].index('CA')])
                set2.append(pdbinfo_vec[j][2][1][pdbinfo_vec[j][2][0].index('CB')])
            except: set2 = []
        if len(set1) > 0 and len(set2) > 0:
            try: angle_matrix[i][j] = vector_angle(set1, set2)
            except: angle_matrix[i][j] = 10000000000.0
        else: angle_matrix[i][j] = 10000000000.0
    return angle_matrix
    
def backbone_angle_matrix(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    angle_matrix = []
    for i in range(N):
    angle_matrix.append([])
    for j in range(N): angle_matrix[i].append(0.0)
    
    for i in range(N):
    set1 = []
    set1.append(pdbinfo_vec[i][4])
    set1.append(pdbinfo_vec[i][5])
    for j in range(i + 1, N):
        set2 = []
        set2.append(pdbinfo_vec[j][4])
        set2.append(pdbinfo_vec[j][5])
        angle_matrix[i][j] = vector_angle(set1, set2)
    return angle_matrix
    
def pw_matrix(pdbinfo_vec):
    
    N = len(pdbinfo_vec)
    angle_matrix = []
    for i in range(N):
    angle_matrix.append([])
    for j in range(N): angle_matrix[i].append(0.0)
    
    for i in range(N):
    set1 = []
    set1.append(pdbinfo_vec[i][2])
    set1.append(pdbinfo_vec[i][3])
    for j in range(i + 1, N):
        set2 = []
        set2.append(pdbinfo_vec[j][2])
        set2.append(pdbinfo_vec[j][3])
        angle_matrix[i][j] = propwash(set1, set2)
    return angle_matrix
    
def phi_psi_same(phi0, psi0, phi1, psi1):
    
    phi_diff = False
    psi_diff = False
    
    phi0 += 180.0
    psi0 += 180.0
    phi1 += 180.0
    psi1 += 180.0
    
    if phi0 - phi1 > -5.0 and phi0 - phi1 < 5.0: phi_diff = True
    if psi0 - psi1 > -5.0 and psi0 - psi1 < 5.0: psi_diff = True
    
    if (phi_diff and psi_diff): return True
    else: return False

def bayesian_design_psi_phi(template_pdb_path, template_seqdata_path):
    
    seqdata_dir = '/home/secoops/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/secoops/web/PDB/culled_90'
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    
    use_index = []
    for i in range(N - 1):
    sub_vec = []
    sub_vec.append(i)
    sub_vec.append(i + 1)
    use_index.append(sub_vec)

    Nuse = len(use_index)

    for i in range(Nuse):
    print use_index[i][0], use_index[i][1], i
    
    abcounts = []
    for i in range(20): abcounts.append(0)
    
    abprobs = []
    for i in range(20): abprobs.append(0.0)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)
    
    sprobsL = []
    for i in range(Nuse):
    sprobsL.append([])
    for j in range(20): sprobsL[i].append(0.0)
    
    sprobsR = []
    for i in range(Nuse):
    sprobsR.append([])
    for j in range(20): sprobsR[i].append(0.0)
    
    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    dprobsL = []
    for i in range(Nuse):
    dprobsL.append([])
    for j in range(20):
        dprobsL[i].append([])
        for k in range(20): dprobsL[i][j].append(0.0)
        
    dprobsR = []
    for i in range(Nuse):
    dprobsR.append([])
    for j in range(20):
        dprobsR[i].append([])
        for k in range(20): dprobsR[i][j].append(0.0)
        
    count = 0
    for file in seqdata_list:
    count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
    for i in range(len(lib_pdbinfo_vec)):
        abcounts[lib_pdbinfo_vec[i][1]] += 1
        
        libN = len(lib_pdbinfo_vec)
    
        lib_use_index = []
        for i in range(libN - 1):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(i + 1)
        lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libsasa1 = lib_pdbinfo_vec[libpos1][6]
            libsasa2 = lib_pdbinfo_vec[libpos2][6]
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
                sasa1 = pdbinfo_vec[pos1][6]
        sasa2 = pdbinfo_vec[pos2][6]
        if (phi_psi_same(pdbinfo_vec[pos1][5][1], pdbinfo_vec[pos2][5][0], lib_pdbinfo_vec[libpos1][5][1], lib_pdbinfo_vec[libpos2][5][0])) and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
        
            libAA1 = lib_pdbinfo_vec[libpos1][1]
            libAA2 = lib_pdbinfo_vec[libpos2][1]
            
            try:
            scountsL[j][libAA1] += 1
                scountsR[j][libAA2] += 1
                dcounts[j][libAA1][libAA2] += 1
            except:
            print Nuse, j, libAA1, libAA2
            
    if count % 10 == 0:
        print 100.0 * float(count) / float(len(seqdata_list))
        
    if count % 10 == 0:
        
            abtotal = 0
        for i in range(20):
        abtotal += abcounts[i]
        
        for i in range(20):
        abprobs[i] = float(abcounts[i]) / float(abtotal)
            
        for pos in range(Nuse):
        
                stotalL = 0
            for i in range(20):
            stotalL += scountsL[pos][i]
        
                stotalR = 0
            for i in range(20):
            stotalR += scountsR[pos][i]
        
            for i in range(20):
            if stotalL > 0: sprobsL[pos][i] = float(scountsL[pos][i]) / float(stotalL)
            else: sprobsL[pos][i] = 0.0
        
        
            for i in range(20):
            if stotalR > 0: sprobsR[pos][i] = float(scountsR[pos][i]) / float(stotalR)
            else: sprobsR[pos][i] = 0.0
        
            for i in range(20):
                totalR = 0
                for j in range(20):
                totalR += dcounts[pos][i][j]
            for j in range(20):
                if totalR > 0: dprobsR[pos][i][j] = float(dcounts[pos][i][j]) / float(totalR)
                else: dprobsR[pos][i][j] = 0.0
            
            for i in range(20):
                totalL = 0
                for j in range(20):
                totalL += dcounts[pos][j][i]
            for j in range(20):
                if totalL > 0: dprobsL[pos][j][i] = float(dcounts[pos][j][i]) / float(totalL)
                else: dprobsL[pos][j][i] = 0.0
         
            probL_file = open('/home/secoops/web/1af7/bayes_psi_phi/' + str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_ppLprobs.txt', 'w')
        probR_file = open('/home/secoops/web/1af7/bayes_psi_phi/' + str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_ppRprobs.txt', 'w')
            probL_file.write('AA\t')
        probR_file.write('AA\t')
            for i in range(20):
            probL_file.write(AAChar_fasta(i) + '\t')
            probR_file.write(AAChar_fasta(i) + '\t')
            probL_file.write('\n')
        probR_file.write('\n')
            for i in range(20):
            probL_file.write(AAChar_fasta(i) + '\t')
            probR_file.write(AAChar_fasta(i) + '\t')
            for j in range(20):
                if sprobsR[pos][j] > 0.0:
                if sprobsR[pos][j] / abprobs[j] > 1.0:
                        probR = (dprobsR[pos][i][j] / sprobsR[pos][j])
                else: probR = 0.0
                else: probR = 0.0
                if sprobsL[pos][i] > 0.0:
                if sprobsL[pos][i] / abprobs[i] > 1.0:
                       probL = (dprobsL[pos][i][j] / sprobsL[pos][i])
                else: probL = 0.0
                else: probL = 0.0
            if probL == 0.0: probR = 0.0
            if probR == 0.0: probL = 0.0
                probL_file.write(str(probL)[0:4] + '\t')
            probR_file.write(str(probR)[0:4] + '\t')
            probL_file.write('\n')
            probR_file.write('\n')
            probL_file.close()
        probR_file.close()
        
def AA_comp():
    
    seqdata_dir = '/home/secoops/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/secoops/web/PDB/culled_90'
    
    acounts = []
    for i in range(20): acounts.append(0)
    
    aprobs = []
    for i in range(20): aprobs.append(0.0)
        
    count = 0
    for file in seqdata_list:
    count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
    for i in range(len(lib_pdbinfo_vec)):
        acounts[lib_pdbinfo_vec[i][1]] += 1
            
    if count % 10 == 0:
        print 100.0 * float(count) / float(len(seqdata_list))
        
    if count % 10 == 0:
            atotal = 0
        for i in range(20):
        atotal += acounts[i]
        
        for i in range(20):
        aprobs[i] = float(acounts[i]) / float(atotal)
        
        for j in range(20):
            print AAChar_fasta(j), aprobs[j]
        
def bayesian_design(template_pdb_path, template_seqdata_path):
    
    seqdata_dir = '/home/secoops/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/secoops/web/PDB/culled_90'
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    
    backvec = []
    for i in range(N):
    backvec.append([])
    for j in range(20): backvec[i].append(0)
    
    backprobs = []
    for i in range(N):
    backprobs.append([])
    for j in range(20): backprobs[i].append(0.0)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][4] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][4] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])
    
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        #if cont_vec[j] - cont_vec[i] > 0 and j - i > 4:
        if template_distance_matrix[i][j] < 10.0 and ((template_distance_matrix[i][j] < template_CAdistance_matrix[i][j]) or  template_angle_matrix[i][j] < 120.0) and template_distance_matrix[i][j] > 0.0:
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)

    #for i in range(Nuse):
    #print use_index[i][0], use_index[i][1], i
    
    acounts = []
    for i in range(20): acounts.append(0)
    
    aprobs = []
    for i in range(20): aprobs.append(0.0)
    
    abcounts = []
    for i in range(20): abcounts.append(0)
    
    abprobs = []
    for i in range(20): abprobs.append(0.0)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)
    
    sprobsL = []
    for i in range(Nuse):
    sprobsL.append([])
    for j in range(20): sprobsL[i].append(0.0)
    
    sprobsR = []
    for i in range(Nuse):
    sprobsR.append([])
    for j in range(20): sprobsR[i].append(0.0)
    
    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    dprobsL = []
    for i in range(Nuse):
    dprobsL.append([])
    for j in range(20):
        dprobsL[i].append([])
        for k in range(20): dprobsL[i][j].append(0.0)
        
    dprobsR = []
    for i in range(Nuse):
    dprobsR.append([])
    for j in range(20):
        dprobsR[i].append([])
        for k in range(20): dprobsR[i][j].append(0.0)
        
    count = 0
    for file in seqdata_list:
    count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
    for i in range(len(lib_pdbinfo_vec)):
        if AAChar_fasta(lib_pdbinfo_vec[i][1]) != 'G':
            acounts[lib_pdbinfo_vec[i][1]] += 1
        abcounts[lib_pdbinfo_vec[i][1]] += 1
        
    for i in range(len(pdbinfo_vec)):
        for j in range(len(lib_pdbinfo_vec)):
            if (phi_psi_same(pdbinfo_vec[i][5][0], pdbinfo_vec[i][5][1], lib_pdbinfo_vec[j][5][0], lib_pdbinfo_vec[j][5][1])):
            backvec[i][lib_pdbinfo_vec[j][1]] += 1
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][4] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][4] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
            #if lib_cont_vec[j] - lib_cont_vec[i] > 0 and j - i > 4:
        if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][6]
        libsasa2 = lib_pdbinfo_vec[libpos2][6]
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
            distance = template_distance_matrix[pos1][pos2]
            angle = template_angle_matrix[pos1][pos2]
        sasa1 = pdbinfo_vec[pos1][6]
        sasa2 = pdbinfo_vec[pos2][6]
        
        if libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            libAA1 = lib_pdbinfo_vec[libpos1][1]
            libAA2 = lib_pdbinfo_vec[libpos2][1]
            
            try:
            scountsL[j][libAA1] += 1
                scountsR[j][libAA2] += 1
                dcounts[j][libAA1][libAA2] += 1
            except:
            print Nuse, j, libAA1, libAA2
            
    if count % 10 == 0:
        print 100.0 * float(count) / float(len(seqdata_list))
        
    if count % 10 == 0:
            atotal = 0
        for i in range(20):
        atotal += acounts[i]
        
        for i in range(20):
        aprobs[i] = float(acounts[i]) / float(atotal)
        
            abtotal = 0
        for i in range(20):
        abtotal += abcounts[i]
        
        for i in range(20):
        abprobs[i] = float(abcounts[i]) / float(abtotal)
            
        for pos in range(Nuse):
        
                stotalL = 0
            for i in range(20):
            stotalL += scountsL[pos][i]
        
                stotalR = 0
            for i in range(20):
            stotalR += scountsR[pos][i]
        
            for i in range(20):
            if stotalL > 0: sprobsL[pos][i] = float(scountsL[pos][i]) / float(stotalL)
            else: sprobsL[pos][i] = 0.0
        
        
            for i in range(20):
            if stotalR > 0: sprobsR[pos][i] = float(scountsR[pos][i]) / float(stotalR)
            else: sprobsR[pos][i] = 0.0
        
            for i in range(20):
                totalR = 0
                for j in range(20):
                totalR += dcounts[pos][i][j]
            for j in range(20):
                if totalR > 0: dprobsR[pos][i][j] = float(dcounts[pos][i][j]) / float(totalR)
                else: dprobsR[pos][i][j] = 0.0
            
            for i in range(20):
                totalL = 0
                for j in range(20):
                totalL += dcounts[pos][j][i]
            for j in range(20):
                if totalL > 0: dprobsL[pos][j][i] = float(dcounts[pos][j][i]) / float(totalL)
                else: dprobsL[pos][j][i] = 0.0
         
            probL_file = open('/home/secoops/web/1vjq/bayes/' + str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Lprobs.txt', 'w')
        probR_file = open('/home/secoops/web/1vjq/bayes/' + str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Rprobs.txt', 'w')
            probL_file.write('AA\t')
        probR_file.write('AA\t')
            for i in range(20):
            probL_file.write(AAChar_fasta(i) + '\t')
            probR_file.write(AAChar_fasta(i) + '\t')
            probL_file.write('\n')
        probR_file.write('\n')
            for i in range(20):
            probL_file.write(AAChar_fasta(i) + '\t')
            probR_file.write(AAChar_fasta(i) + '\t')
            for j in range(20):
                if sprobsR[pos][j] > 0.0:
                if sprobsR[pos][j] / aprobs[j] > 1.0:
                        probR = (dprobsR[pos][i][j] / sprobsR[pos][j])
                else: probR = 0.0
                else: probR = 0.0
                if sprobsL[pos][i] > 0.0:
                if sprobsL[pos][i] / aprobs[i] > 1.0:
                       probL = (dprobsL[pos][i][j] / sprobsL[pos][i])
                else: probL = 0.0
                else: probL = 0.0
            if probL == 0.0: probR = 0.0
            if probR == 0.0: probL = 0.0
                probL_file.write(str(probL)[0:4] + '\t')
            probR_file.write(str(probR)[0:4] + '\t')
            probL_file.write('\n')
            probR_file.write('\n')
            probL_file.close()
        probR_file.close()
        
        for i in range(1, N):
                btotal = 0
            for j in range(20):
            btotal += backvec[i][j]
        prob_file = open('/home/secoops/web/1vjq/bayes/back_' + str(i + 1) + '_probs.txt', 'w')
        for j in range(20):
            if btotal > 0: backprobs[i][j] = float(backvec[i][j]) / float(btotal)
            else: backprobs[i][j] = 0.0
            if abprobs[j] > 0.0: bprob = backprobs[i][j] / abprobs[j]
            else: bprob = 0.0
            prob_file.write(AAChar_fasta(j) + '\t' + str(bprob)[0:5] + '\n')
        prob_file.close()
        
def bayesian_preset(preset_dir, template_pdb_path, template_seqdata_path, param_path, out_path):
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    print N
    
    comp = [0.1, 0.0, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.1, 0.15, 0.02, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.15, 0.02, 0.1]
    dipep = ['WM', 'WH', 'WN', 'WL', 'CW', 'CM', 'CH', 'CD', 'CP', 'CT', 'CL', 'MH', 'MY', 'MP', 'MS', 'MA', 'HY', 'HN', 'HI', 'HK', 'YM', 'YH', 'YD', 'YP', 'YA', 'FY', 'FD', 'FP', 'QQ', 'QD', 'QP', 'QE', 'QS', 'NI', 'NK', 'IH', 'IE', 'IL', 'RW', 'RH', 'RQ', 'RN', 'RR', 'RP', 'RS', 'DS', 'PF', 'PQ', 'PP', 'PE', 'PS', 'PV', 'PA', 'TF', 'TE', 'KM', 'KQ', 'KR', 'EC', 'EQ', 'EI', 'ED', 'EP', 'EE', 'ES', 'VP', 'SC', 'SQ', 'SR', 'SP', 'SE', 'SS', 'GW', 'GG', 'AC', 'AP', 'LW', 'LQ', 'LR', 'LP']
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][4] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][4] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    paramlines = readlines(param_path)
    pline = paramlines[0].strip()
    pro = []
    for i in range(len(pline)): pro.append(int(pline[i]))
    
    bury = []
    buryline = paramlines[1].strip().split(',')
    for i in range(len(buryline)): bury.append(int(buryline[i]))
    
    
    preset_list = os.listdir(preset_dir)
    
    back_list = []
    pair_list = []
    back_labels = []
    pair_labels = []
    pp_list = []
    pp_labels = []
    
    for file in preset_list:
    file_path = os.path.join(preset_dir, file)
    if len(file.split('_')) == 3:
        lines = readlines(file_path)
        if file[0:4] == 'back':
        back_labels.append(int(file.split('_')[1]) - 1)
        back = []
        for line in lines: back.append(float(line.split()[1]))
        back_list.append(back)
        else:
        if file[-10] == 'L':
            pair_pos = []
            for i in range(1, len(lines)):
                line = lines[i].split()
                pair = []
                for j in range(1, len(line)): pair.append(float(line[j]))
                pair_pos.append(pair)
            pair_list.append(pair_pos)
            pair_labels.append([int(file.split('_')[0]) - 1, int(file.split('_')[1]) - 1])
        if file[-11] == 'p' and file[-10] == 'L':
            pair_pos = []
            for i in range(1, len(lines)):
                line = lines[i].split()
                pair = []
                for j in range(1, len(line)): pair.append(float(line[j]))
                pair_pos.append(pair)
            pp_list.append(pair_pos)
            pp_labels.append([int(file.split('_')[0]) - 1, int(file.split('_')[1]) - 1])
    
    not_allowed = []
    for i in range(N): not_allowed.append([])
    
    for i in range(len(pro)):
    if pro[i] == 0: not_allowed[i].append(AAChar_int('P'))
    for i in range(N):
    not_allowed[i].append(AAChar_int('C'))
    
    for i in range(len(back_list) - 2):
    pos = back_labels[i + 1]
    for j in range(20):
        if back_list[i + 1][j] < 0.8 and not j in not_allowed[pos]: not_allowed[pos].append(j)
    
    pair_count = []
    for i in range(N):
    aa = []
    for j in range(20): aa.append(0)
    pair_count.append([0, aa])
    
    for i in range(len(pair_list)):
    pos1 = pair_labels[i][0]
    pos2 = pair_labels[i][1]    
        pair_count[pos1][0] += 1
    pair_count[pos2][0] += 1
   
    thresh = 0.0
    
#    while True:
    
#        change = 0
    
#        for i in range(len(pair_list)):
#        pos1 = pair_labels[i][0]
#        pos2 = pair_labels[i][1]
    
#        for j in range(20):
#            countL = 0
#            countR = 0
#            for k in range(20):
#            if pair_list[i][j][k] == thresh or k in not_allowed[pos2]: countL += 1
#            if pair_list[i][k][j] == thresh or k in not_allowed[pos1]: countR += 1
#        if countL == 20: pair_count[pos1][1][j] += 1
#        if countR == 20: pair_count[pos2][1][j] += 1
    
#    for i in range(len(pair_count)):
#        if AAChar_fasta(pdbinfo_vec[i][1]) == 'G': continue
#        for j in range(20):
#        if float(pair_count[i][1][j]) / float(pair_count[i][0]) >= 0.9:
#            if not j in not_allowed[i]:
#                not_allowed[i].append(j)
#                change += 1
#        pair_count[i][1][j] = 0
    
#    if change == 0: break
    
    psamp = []
    for i in range(N):
    psamp.append([])
    for i in range(len(pair_list)):
    pos1 = pair_labels[i][0]
    pos2 = pair_labels[i][1]
    psamp[pos1].append(i)
    psamp[pos2].append(i)
    
    ppsamp = []
    for i in range(N):
    ppsamp.append([])
    for i in range(len(pp_list)):
    pos1 = pp_labels[i][0]
    pos2 = pp_labels[i][1]
    ppsamp[pos1].append(i)
    ppsamp[pos2].append(i)
    
    for i in range(len(bury)):
    pos = bury[i] - 1
    for j in range(20):
        if not j in not_allowed[pos] and not AAChar_fasta(j) in 'LIVFMW': not_allowed[pos].append(j)
    
    allowed = []
    for i in range(N):
    print i+1,
    allowed.append([])
    allowi = ''
    for j in range(20):
        if not j in not_allowed[i]:
        allowed[i].append(j)
        allowi += AAChar_fasta(j)
    print allowi
    
    aa_comp = []
    for i in range(20): aa_comp.append(0)
        
    AA0 = []
    for i in range(N): AA0.append(0)
    AA1 = []
    for i in range(N): AA1.append(0)
    wt = []
    for i in range(N):
    wt.append(pdbinfo_vec[i][1])
    aa_comp[pdbinfo_vec[i][1]] += 1
    AA = []
    for i in range(N): AA.append(0)
    
    num_str = ''
    for i in range(N): num_str += str(i + 1)[-1]
    
    ewt = 0.0
    for i in range(N):
    for j in psamp[i]:
        e = pair_list[j][wt[pair_labels[j][0]]][wt[pair_labels[j][1]]]
        if e > 1.1: e = 10.0
        if e == 0.0: e = -10.0
        if e < 1.1 and charge_pair(wt[pair_labels[j][0]], wt[pair_labels[j][1]]): e = -1000.0
        
        ewt -= e
    for j in ppsamp[i]:
        e = pp_list[j][wt[pp_labels[j][0]]][wt[pp_labels[j][1]]]
        if e > 1.1: e = 10.0
        if e == 0.0: e = -10.0
        ewt -= e
    for j in range(20):
    if (float(aa_comp[j]) / float(N)) > comp[j]: ewt += 10000.0
    if math.fabs(aa_comp[2] + aa_comp[3] - aa_comp[8] - aa_comp[14]) < 2: ewt += 100.0
    for j in range(20): aa_comp[j] = 0
    for i in range(0, N - 2):
        if wt[i] == wt[i + 1] == wt[i + 2]: ewt += 100.0
    for i in range(0, N - 1):
    if str(AAChar_fasta(wt[i])) + str(AAChar_fasta(wt[i + 1])) in dipep: ewt += 100.0
    
    
    E0 = 0.0
    steps = 0
    while True:
    steps += 1
            
        #generate initial sequence
        for i in range(N):
        L = len(allowed[i])
        if L > 1: randi = random.randint(0, L - 1)
        else: randi = 0
        aa_chg = allowed[i][randi]
        AA0[i] = aa_chg
        AA1[i] = aa_chg
        
        aa_comp[aa_chg] += 1
    
        #calculate e0
        e0 = 0.0
        for i in range(N):
        for j in psamp[i]:
            e = pair_list[j][AA0[pair_labels[j][0]]][AA0[pair_labels[j][1]]]
            if e > 1.1: e = 10.0
            if e < 0.8: e = -10.0
        if e < 1.1 and charge_pair(AA0[pair_labels[j][0]], AA0[pair_labels[j][1]]): e = -1000.0
            e0 -= e
        for j in ppsamp[i]:
            e = pp_list[j][AA0[pp_labels[j][0]]][AA0[pp_labels[j][1]]]
            if e < 0.8: e = -10.0
            e0 -= e
    for j in range(20):
        if (float(aa_comp[j]) / float(N)) > comp[j]: e0 += 10000.0
    if math.fabs(aa_comp[2] + aa_comp[3] - aa_comp[8] - aa_comp[14]) < 2: e0 += 100.0
    for j in range(20): aa_comp[j] = 0
    for i in range(0, N - 2):
        if AA0[i] == AA0[i + 1] == AA0[i + 2]: e0 += 100.0
    for i in range(0, N - 1):
        if str(AAChar_fasta(AA0[i])) + str(AAChar_fasta(AA0[i + 1])) in dipep: e0 += 100.0
        
    if steps == 1: E0 = e0
        
        rejected = 0
        while True:
    
        while True:
            pos_chg = random.randint(0, N - 1)
            L = len(allowed[pos_chg])
        if L > 1:
            randi = random.randint(0, L - 1)
            aa_chg = allowed[pos_chg][randi]
            if aa_chg != AA1[pos_chg]: break
        
        
        AA1[pos_chg] = aa_chg
    
        e_chg0 = 0.0
        for j in psamp[pos_chg]:
            e = pair_list[j][AA0[pair_labels[j][0]]][AA0[pair_labels[j][1]]]
            if e > 1.1: e = 10.0
            if e < 0.8: e = -10.0
        if e < 1.1 and charge_pair(AA0[pair_labels[j][0]], AA0[pair_labels[j][1]]): e = -1000.0
            e_chg0 -= e
        for j in ppsamp[pos_chg]:
            e = pp_list[j][AA0[pp_labels[j][0]]][AA0[pp_labels[j][1]]]
            if e < 0.8: e = -10.0
            e_chg0 -= e

        e_chg1 = 0.0
        for j in psamp[pos_chg]:
            e = pair_list[j][AA1[pair_labels[j][0]]][AA1[pair_labels[j][1]]]
            if e > 1.1: e = 10.0
            if e < 0.8: e = -10.0
        if e < 1.1 and charge_pair(AA1[pair_labels[j][0]], AA1[pair_labels[j][1]]): e = -1000.0
            e_chg1 -= e
        for j in ppsamp[pos_chg]:
            e = pp_list[j][AA1[pp_labels[j][0]]][AA1[pp_labels[j][1]]]
            if e < 0.8: e = -10.0
            e_chg1 -= e
        
        penalty0 = 0
        for i in range(N): aa_comp[AA0[i]] += 1
        for j in range(20):
        if (float(aa_comp[j]) / float(N)) > comp[j]: penalty0 += 10000.0
        if math.fabs(aa_comp[2] + aa_comp[3] - aa_comp[8] - aa_comp[14]) < 2: penalty0 += 100.0
        for j in range(20): aa_comp[j] = 0
        for i in range(0, N - 2):
            if AA0[i] == AA0[i + 1] == AA0[i + 2]: penalty0 += 100.0
        for i in range(0, N - 1):
            if str(AAChar_fasta(AA0[i])) + str(AAChar_fasta(AA0[i + 1])) in dipep: penalty0 += 100.0
        
        penalty = 0
        for i in range(N): aa_comp[AA1[i]] += 1
        for j in range(20):
        if (float(aa_comp[j]) / float(N)) > comp[j]: penalty += 10000.0
        if math.fabs(aa_comp[2] + aa_comp[3] - aa_comp[8] - aa_comp[14]) < 2: penalty += 100.0
        for j in range(20): aa_comp[j] = 0
        for i in range(0, N - 2):
            if AA1[i] == AA1[i + 1] == AA1[i + 2]: penalty += 100.0
        for i in range(0, N - 1):
            if str(AAChar_fasta(AA1[i])) + str(AAChar_fasta(AA1[i + 1])) in dipep: penalty += 100.0
        
        ediff = e_chg1 - e_chg0 + penalty - penalty0
        if ediff < 0.0:
            
            AA0[pos_chg] = aa_chg
        e0 += ediff
            rejected = 0
        else:
            AA1[pos_chg] = AA0[pos_chg]
                rejected += 1
        
        if rejected == 10000:
        break
        
    if e0 <= E0:
        E0 = e0
            for i in range(N): AA[i] = AA0[i]
        
            for i in range(N):
            for j in psamp[i]:
                e = pair_list[j][AA[pair_labels[j][0]]][AA[pair_labels[j][1]]]
            if charge_pair(AA[pair_labels[j][0]], AA[pair_labels[j][1]]) and e < 1.1:
                print pair_labels[j][0] + 1, AAChar_fasta(AA[pair_labels[j][0]]), pair_labels[j][1] + 1, AAChar_fasta(AA[pair_labels[j][1]]), e
        
        out_file = open(out_path, 'w')
            aa_str = ''
            for i in range(N): aa_str += AAChar_fasta(wt[i])
        out_file.write(num_str + '\n' + aa_str + '\t' + str(ewt) + '\n')
        
        print num_str
        print aa_str, ewt
        
            aa_str = ''
        secstr_str = ''
        for i in range(N): aa_str += AAChar_fasta(AA[i])
        for i in range(N): secstr_str += pdbinfo_vec[i][4]
        print aa_str, E0
        print secstr_str
        print
        out_file.write(aa_str + '\t' + str(E0) + '\n' + secstr_str + '\n\n')
            out_file.close()
        
        #e0 = 0.0
    
        #for i in range(N):
        #for j in psamp[i]:
            #e = pair_list[j][AA[pair_labels[j][0]]][AA[pair_labels[j][1]]]
            #if e > 1.1: print pair_labels[j][0] + 1, AA[pair_labels[j][1], '-10'
            #if e == 0.0: print pair_labels[j][0] + 1, AA[pair_labels[j][1], '10'
        #for j in ppsamp[i]:
            #e = pp_list[j][AA0[pp_labels[j][0]]][AA0[pp_labels[j][1]]]
            #if e > 1.1: print 
            #if e == 0.0: e = -10.0
            #e0 -= e
    #for j in range(20):
        #if (float(aa_comp[j]) / float(N)) > comp[j]: e0 += 10000.0
    #if math.fabs(aa_comp[2] + aa_comp[3] - aa_comp[8] - aa_comp[14]) < 2: e0 += 100.0
    #for j in range(20): aa_comp[j] = 0
    #for i in range(0, N - 2):
        #if AA0[i] == AA0[i + 1] == AA0[i + 2]: e0 += 100.0
    #for i in range(0, N - 1):
        #if str(AAChar_fasta(AA0[i])) + str(AAChar_fasta(AA0[i + 1])) in dipep: e0 += 100.0
        
def residue_specific_design(preset_dir):
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
        
    mask_vec = []
    mask_lines = readlines(mask_path)
    for line in mask_lines:
        mask_vec.append(int(line.strip()) - 1)
    
    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][4] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][4] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])
    
    use_index = []
    Spos_list = [[], [], []]
    for i in range(N):
    for j in range(i + 1, N):
        if not i in res_vec and not j in res_vec: continue
        if i in mask_vec or j in mask_vec: continue
        if template_distance_matrix[i][j] < 10.0 and ((template_distance_matrix[i][j] < template_CAdistance_matrix[i][j]) or  template_angle_matrix[i][j] < 120.0) and template_distance_matrix[i][j] > 0.0:
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)
    
    scountsL2 = []
    for i in range(Nuse):
        scountsL2.append([])
        for j in range(20): scountsL2[i].append(0)

    scountsR2 = []
    for i in range(Nuse):
        scountsR2.append([])
        for j in range(20): scountsR2[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
    
    count = 0
    for file in seqdata_list:
        count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][4] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][4] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
        if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][6]
        libsasa2 = lib_pdbinfo_vec[libpos2][6]
        libcontinuous = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
            distance = template_distance_matrix[pos1][pos2]
            angle = template_angle_matrix[pos1][pos2]
        sasa1 = pdbinfo_vec[pos1][6]
        sasa2 = pdbinfo_vec[pos2][6]
        continuous = (cont_vec[pos1] == cont_vec[pos2])
        
        cont_match = (libcontinuous and continuous) or (not libcontinuous and not continuous)
        
        try:
            libAA1 = int(lib_pdbinfo_vec[libpos1][1])
            libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        except: continue
        if libAA1 < 0 or libAA2 < 0 or libAA1 > 19 or libAA2 > 19: continue
        
        if cont_match and lib_ss_vec[libpos1] == ss_vec[pos1] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10:
            scountsL[j][libAA1] += 1
        if cont_match and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            scountsR[j][libAA2] += 1
        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0:
            scountsL2[j][libAA1] += 1
            scountsR2[j][libAA2] += 1

        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            dcounts[j][libAA1][libAA2] += 1
            
    if count % 100 == 0 or file == seqdata_list[-1]:
        print (float(count) / float(len(seqdata_list))) * 100.0, 'finished'
            
        for pos in range(Nuse):
          
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Scounts.txt'), 'w')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t' + str(scountsL[pos][i]) + '\t' + str(scountsR[pos][i]) + '\t' + str(scountsL2[pos][i]) + '\t' + str(scountsR2[pos][i]) +'\n')
        counts_file.close()
         
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt'), 'w')
            counts_file.write('AA\t')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
        counts_file.write('\n')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
            for j in range(20):
            counts_file.write(str(dcounts[pos][i][j]) + '\t')
            counts_file.write('\n')
        counts_file.close()
        
def statium_PDZ(preset_dir):
        
    if not os.path.exists(preset_dir): os.mkdir(preset_dir)
        
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
        
    mask_vec = []
    mask_lines = readlines(mask_path)
    for line in mask_lines:
        mask_vec.append(int(line.strip()) - 1)
    
    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    
    pdbinfo_vec = pdb_info2(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][4] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][4] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])
    
    use_index = []
    Spos_list = [[], [], []]
    for i in range(N):
    for j in range(i + 1, N):
        if not i in res_vec and not j in res_vec: continue
        if i in mask_vec or j in mask_vec: continue
        if template_distance_matrix[i][j] < 10.0 and ((template_distance_matrix[i][j] < template_CAdistance_matrix[i][j]) or  template_angle_matrix[i][j] < 120.0) and template_distance_matrix[i][j] > 0.0:
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)
    
    scountsL2 = []
    for i in range(Nuse):
        scountsL2.append([])
        for j in range(20): scountsL2[i].append(0)

    scountsR2 = []
    for i in range(Nuse):
        scountsR2.append([])
        for j in range(20): scountsR2[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
    
    count = 0
    for file in seqdata_list:
        count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][4] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][4] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
        if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][6]
        libsasa2 = lib_pdbinfo_vec[libpos2][6]
        libcontinuous = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
            distance = template_distance_matrix[pos1][pos2]
            angle = template_angle_matrix[pos1][pos2]
        sasa1 = pdbinfo_vec[pos1][5]
        sasa2 = pdbinfo_vec[pos2][5]
        continuous = (cont_vec[pos1] == cont_vec[pos2])
        
        cont_match = (libcontinuous and continuous) or (not libcontinuous and not continuous)
        
        try:
            libAA1 = int(lib_pdbinfo_vec[libpos1][1])
            libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        except: continue
        if libAA1 < 0 or libAA2 < 0 or libAA1 > 19 or libAA2 > 19: continue
        
        if cont_match and lib_ss_vec[libpos1] == ss_vec[pos1]:
            scountsL[j][libAA1] += 1
        if cont_match and lib_ss_vec[libpos2] == ss_vec[pos2]:
            scountsR[j][libAA2] += 1
        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
            scountsL2[j][libAA1] += 1
            scountsR2[j][libAA2] += 1

        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            dcounts[j][libAA1][libAA2] += 1
            
    if count % 100 == 0 or file == seqdata_list[-1]:
        print (float(count) / float(len(seqdata_list))) * 100.0, 'finished'
            
        for pos in range(Nuse):
          
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Scounts.txt'), 'w')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t' + str(scountsL[pos][i]) + '\t' + str(scountsR[pos][i]) + '\t' + str(scountsL2[pos][i]) + '\t' + str(scountsR2[pos][i]) +'\n')
        counts_file.close()
         
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt'), 'w')
            counts_file.write('AA\t')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
        counts_file.write('\n')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
            for j in range(20):
            counts_file.write(str(dcounts[pos][i][j]) + '\t')
            counts_file.write('\n')
        counts_file.close()
        
def seq_columns(seq_path):
    line = readline(seq_path, 1)
    if len(line.split()) == 6: return 0
    else: return 1
        
def statium_coyote(preset, out_dir, runf, ns, runp):
  
    paths = []
    
    if runf == 'CC':
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG_CC':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    else:
        print runf + ' is not a valid option.'
        return
    
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    v = []
    count = 0
    for pair in paths:
        v.append(pair)
        if len(v) == ns or pair == paths[-1]:
        count += 1
        seqp = os.path.join(out_dir, 'seq_' + str(count) + '.txt')
        of = open(seqp, 'w')
        for sub_pair in v: of.write(sub_pair[0] + '\t' + sub_pair[1] + '\n')
        of.close()
        
        sp = os.path.join(out_dir, 'seq_' + str(count) + '.sh')
        of = open(sp, 'w')
        of.write('#PBS -S /bin/sh\n' + runp + ' -statium ' + preset + ' ' + seqp + ' ' + out_dir + ' ' + str(count) + '\n')
        of.close()
        
        os.system('chmod u+x ' + sp)
        os.system('qsub -q quick ' + sp)
        v = []
        
def statium_sidechain_coyote(preset, runf, ns, runp):
  
    paths = []

    out_dir = preset + '_coyote'
    
    if runf == 'CC':
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG':
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        pdb_list = os.listdir(pdb_dir)
        for pdb in pdb_list: paths.append(os.path.join(pdb_dir, pdb))
            
    else:
        print runf + ' is not a valid option.'
        return
    
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    olist = os.listdir(out_dir)
    v = []
    seqp = os.path.join(out_dir, 'seq_' + str(1) + '.txt')
    of = open(seqp, 'w')
    for path in paths: of.write(path + '\n')
    of.close()
    sp = os.path.join(out_dir, 'seq_' + str(1) + '.sh')
    of = open(sp, 'w')
    of.write('#PBS -S /bin/sh\n' + runp + ' -statium_sidechain ' + preset + ' ' + seqp + ' ' + out_dir + ' ' + str(1) + '\n')
    of.close()
        
    os.system('chmod u+x ' + sp)
    os.system(sp)

def statium_intrapep_coyote(preset, runf, ns, runp):
  
    paths = []

    out_dir = preset + '_coyote'
    
    if runf == 'CC':
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG_CC':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    else:
        print runf + ' is not a valid option.'
        return
    
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    olist = os.listdir(out_dir)
    v = []
    count = 0
    for pair in paths:
        v.append(pair)
        if len(v) == ns or pair == paths[-1]:
        count += 1
        runit = True
        for t in olist:
            if t.split('_')[-1] == str(count):
            runit = False
            break
        if not runit:
            v = []
            continue
        seqp = os.path.join(out_dir, 'seq_' + str(count) + '.txt')
        of = open(seqp, 'w')
        for sub_pair in v: of.write(sub_pair[0] + '\t' + sub_pair[1] + '\n')
        of.close()
        
        sp = os.path.join(out_dir, 'seq_' + str(count) + '.sh')
        of = open(sp, 'w')
        of.write('#PBS -S /bin/sh\n' + runp + ' -statium_sidechain_intrapep ' + preset + ' ' + seqp + ' ' + out_dir + ' ' + str(count) + '\n')
        of.close()
        
        os.system('chmod u+x ' + sp)
        #os.system('qsub -q speedy ' + sp)
        v = []

def statium_local_coyote(preset, runf, ns, runp):
  
    paths = []

    out_dir = preset + '_coyote'
    
    if runf == 'CC':
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    elif runf == 'REG_CC':
        seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
        pdb_dir = '/home/bartolo/web/PDB/culled_90'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
        seqdata_dir = '/home/bartolo/web/BA_CC_seq'
        seqdata_list = os.listdir(seqdata_dir)
        pdb_dir = '/home/bartolo/web/BA_CC'
        pdb_list = os.listdir(pdb_dir)
        for seqd in seqdata_list:
            name = seqd.split('.')[0]
            paths.append([os.path.join(seqdata_dir, seqd), os.path.join(pdb_dir, name + '.pdb')])
            
    else:
        print runf + ' is not a valid option.'
        return
    
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    olist = os.listdir(out_dir)
    v = []
    count = 0
    for pair in paths:
        v.append(pair)
        if pair == paths[-1]:
        seqp = os.path.join(out_dir, 'seq_' + str(count) + '.txt')
        of = open(seqp, 'w')
        for sub_pair in v: of.write(sub_pair[0] + '\t' + sub_pair[1] + '\n')
        of.close()
        
        sp = os.path.join(out_dir, 'seq_' + str(count) + '.sh')
        of = open(sp, 'w')
        of.write('#PBS -S /bin/sh\n' + runp + ' -statium_sidechain_local ' + preset + ' ' + seqp + ' ' + out_dir + ' ' + str(count) + '\n')
        of.close()
        
        os.system('chmod u+x ' + sp)
        #os.system('qsub -q speedy ' + sp)
        v = []
        
def statium_coyote_compile(preset):

    compile_dir = preset + '_coyote'
    out_dir = preset + '_coyote_counts'
  
    cl = os.listdir(compile_dir)
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    tl = []
    sl = []
    for c in cl:
        if c.find('count') > -1:
        if c.find('Scount') > -1:
            if not c.split('.')[0] in sl: sl.append(c.split('.')[0])
        else:
            if not c.split('.')[0] in tl: tl.append(c.split('.')[0])
        
    for t in tl:
        print t
        counts = []
        for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        for c in cl:
            if c.split('.')[0] == t:
            path = os.path.join(compile_dir, c)
            data = lines2list(path)
            for i in range(20):
            for j in range(20):
                counts[i][j] += int(data[i + 1][j + 1])
    op = os.path.join(out_dir, t + '.txt')
    of = open(op, 'w')
    of.write('AA\t')
    for i in range(20): of.write(AAChar_fasta(i) + '\t')
    of.write('\n')
    for i in range(20):
        of.write(AAChar_fasta(i) + '\t')
        for j in range(20): of.write(str(counts[i][j]) + '\t')
        of.write('\n')
    of.close()
    
    for s in sl:
        print s
        counts = []
        for i in range(20):
        counts.append([])
        for j in range(2): counts[i].append(0)
        for c in cl:
            if c.split('.')[0] == s:
            path = os.path.join(compile_dir, c)
            data = lines2list(path)
            for i in range(20):
            for j in range(2):
                counts[i][j] += int(data[i][j + 1])
    op = os.path.join(out_dir, s + '.txt')
    of = open(op, 'w')
    for i in range(20):
        of.write(AAChar_fasta(i) + '\t' + str(counts[i][0]) + '\t' + str(counts[i][1]) + '\n')
    of.close()
    
def statium_sidechain_coyote_compile(preset):

    compile_dir = preset + '_coyote'
    out_dir = preset + '_coyote_counts'

    cl = os.listdir(compile_dir)
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    tl = []
    for c in cl:
        if c.find('count') > -1:
        if not c.split('.')[0] in tl: tl.append(c.split('.')[0])
        
    for t in tl:
        print t
        counts = []
        for i in range(20): counts.append(0)
        for c in cl:
            if c.split('.')[0] == t:
            path = os.path.join(compile_dir, c)
            data = lines2list(path)
            for i in range(20): counts[i] += int(data[i][1])
    op = os.path.join(out_dir, t + '.txt')
    of = open(op, 'w')
    for i in range(20): of.write(AAChar_fasta(i) + '\t' + str(counts[i]) + '\n')
    of.close()
    
def statium_coyote_compilet(compile_dir, out_dir):

    cl = os.listdir(compile_dir)
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    
    tl = []
    sl = []
    for c in cl:
        if c.find('count') > -1:
        if c.find('Scount') > -1:
            if not c.split('.')[0] in sl: sl.append(c.split('.')[0])
        else:
            if not c.split('.')[0] in tl: tl.append(c.split('.')[0])
        
    for t in tl:
        print t
        counts = []
        for i in range(20):
        for j in range(20):
            for k in range(20): counts.append(0)
        for c in cl:
            if c.split('.')[0] == t:
            path = os.path.join(compile_dir, c)
            data = lines2list(path)
            for i in range(len(data)): counts[i] += int(data[i][0])
            
    op = os.path.join(out_dir, t + '.txt')
    of = open(op, 'w')
    tab = 0
    for i in range(20):
        for j in range(20):
            for k in range(20):
            of.write(str(counts[tab]) + '\n')
            tab += 1
    of.close()
    
    for s in sl:
        print s
        counts = []
        for i in range(20):
        counts.append([])
        for j in range(3): counts[i].append(0)
        for c in cl:
            if c.split('.')[0] == s:
            path = os.path.join(compile_dir, c)
            data = lines2list(path)
            for i in range(20):
            for j in range(3):
                counts[i][j] += int(data[i][j + 1])
    op = os.path.join(out_dir, s + '.txt')
    of = open(op, 'w')
    for i in range(20):
        of.write(AAChar_fasta(i) + '\t' + str(counts[i][0]) + '\t' + str(counts[i][1]) + '\t' + str(counts[i][2]) + '\n')
    of.close()
        
def statium(preset_dir, seqdata_file, out_dir, num):
  
    ip = False
  
    paths = lines2list(seqdata_file)
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    ip_path = os.path.join(file_dir, file_base + '.ip')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    mask_vec = []
    if os.path.exists(mask_path):
        mask_lines = readlines(mask_path)
        for line in mask_lines:
            mask_vec.append([int(line.strip().split()[0]) - 1, int(line.strip().split()[1]) - 1])
    
    pdbinfo_vec = structure_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_CACBdistance_matrix = distance_matrixCACB(pdbinfo_vec)
    template_CBCAdistance_matrix = distance_matrixCBCA(pdbinfo_vec)
    template_Ndistance_matrix = distance_matrixN(pdbinfo_vec)
    template_Cdistance_matrix = distance_matrixC(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    template_pw_matrix = pw_matrix(pdbinfo_vec)
    template_backbone_angle_matrix = backbone_angle_matrix(pdbinfo_vec)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][6] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][6] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])

    if os.path.exists(ip_path) and ip:
        use_index = []
        ip_lines = readlines(ip_path)
        for line in ip_lines:
            pos0 = line.split()[0]
            pos1 = line.split()[1]
            use_index.append([int(pos0) - 1, int(pos1) - 1])
    else:
        use_index = []
        Spos_list = [[], [], []]
        for i in range(N):
        for j in range(i + 1, N):
            if not i in res_vec and not j in res_vec: continue
            if [i, j] in mask_vec: continue
            #if i in res_vec and j in res_vec: continue
            if template_distance_matrix[i][j] < 10.0 and ((template_distance_matrix[i][j] < template_CAdistance_matrix[i][j]) or  template_angle_matrix[i][j] < 120.0) and template_distance_matrix[i][j] > 0.0:
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
    
    count = 0
    for pair in paths:
        count += 1
    seqdata_path = pair[0]
    pdb_path = pair[1]
    
    try: lib_pdbinfo_vec = structure_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
    lib_CACBdistance_matrix = distance_matrixCACB(lib_pdbinfo_vec)
    lib_CBCAdistance_matrix = distance_matrixCBCA(lib_pdbinfo_vec)
    lib_Ndistance_matrix = distance_matrixN(lib_pdbinfo_vec)
    lib_Cdistance_matrix = distance_matrixC(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
        try: lib_pw_matrix = pw_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    try: lib_backbone_angle_matrix = backbone_angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][6] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][6] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
            if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libCAdistance = lib_CAdistance_matrix[libpos1][libpos2]
        libCACBdistance = lib_CACBdistance_matrix[libpos1][libpos2]
        libCBCAdistance = lib_CBCAdistance_matrix[libpos1][libpos2]
        libNdistance = lib_Ndistance_matrix[libpos1][libpos2]
        libCdistance = lib_Cdistance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libbackbone_angle = lib_backbone_angle_matrix[libpos1][libpos2]
        libpw = lib_pw_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][7]
        libsasa2 = lib_pdbinfo_vec[libpos2][7]
        libcontinuous = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        try:
        libAA1 = int(lib_pdbinfo_vec[libpos1][1])
        libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        except: continue
        
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
            distance = template_distance_matrix[pos1][pos2]
            CAdistance = template_CAdistance_matrix[pos1][pos2]
            CACBdistance = template_CACBdistance_matrix[pos1][pos2]
            CBCAdistance = template_CBCAdistance_matrix[pos1][pos2]
            Ndistance = template_Ndistance_matrix[pos1][pos2]
            Cdistance = template_Cdistance_matrix[pos1][pos2]
            angle = template_angle_matrix[pos1][pos2]
            backbone_angle = template_backbone_angle_matrix[pos1][pos2]
            pw = template_pw_matrix[pos1][pos2]
        sasa1 = pdbinfo_vec[pos1][7]
        sasa2 = pdbinfo_vec[pos2][7]
        continuous = (cont_vec[pos1] == cont_vec[pos2])
        
        cont_match = (libcontinuous and continuous) or (not libcontinuous and not continuous)
        

        if libAA1 < 0 or libAA2 < 0 or libAA1 > 19 or libAA2 > 19: continue
    
                # original S
        #if cont_match and lib_ss_vec[libpos1] == ss_vec[pos1]:
            #scountsL[j][libAA1] += 1
        #if cont_match and lib_ss_vec[libpos2] == ss_vec[pos2]:
            #scountsR[j][libAA2] += 1
         
##############################################
################################FROM JMB PAPER
        if cont_match: scountsL[j][libAA1] += 1
        if cont_match: scountsR[j][libAA2] += 1
##############################################
##############################################
            
        #original D
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10: dcounts[j][libAA1][libAA2] += 1
        
        #with PW (best so far)
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10 and libpw < pw + 10.0 and libpw > pw - 10.0: dcounts[j][libAA1][libAA2] += 1

        #t15 with PW (best so far), no SecStr
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10 and libpw < pw + 10.0 and libpw > pw - 10.0: dcounts[j][libAA1][libAA2] += 1
        
        #t16 just 0.05 CB
        #if cont_match and libdistance < distance + 0.05 and libdistance > distance - 0.05: dcounts[j][libAA1][libAA2] += 1

                #t17 CACB 0.25 with sasa
                #if cont_match and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25 and libsasa1 < sasa1 + 0.15 and libsasa1 > sasa1 - 0.15 and libsasa2 < sasa2 + 0.15 and libsasa2 > sasa2 - 0.15: dcounts[j][libAA1][libAA2] += 1

        #with PW (best so far), no sasa
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libpw < pw + 10.0 and libpw > pw - 10.0:
            #dcounts[j][libAA1][libAA2] += 1

        #with PW (best so far), no sasa, no CACB
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libpw < pw + 10.0 and libpw > pw - 10.0:
            #dcounts[j][libAA1][libAA2] += 1
            
        #with PW and CACA
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10 and libpw < pw + 10.0 and libpw > pw - 10.0:
         #   dcounts[j][libAA1][libAA2] += 1
         
        #just CACA
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
         #   dcounts[j][libAA1][libAA2] += 1
         
        #t1
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
         #   dcounts[j][libAA1][libAA2] += 1

                #t2 0.25 dist
                #if cont_match and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
                 #   dcounts[j][libAA1][libAA2] += 1

                #t3 0.15 dist
                #if cont_match and libdistance < distance + 0.15 and libdistance > distance - 0.15 and libCAdistance < CAdistance + 0.15 and libCAdistance > CAdistance - 0.15 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
                    #dcounts[j][libAA1][libAA2] += 1
                   
        #t4 t1 + backbone angle
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libbackbone_angle < backbone_angle + 20.0 and libbackbone_angle > backbone_angle - 20.0 and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
         #   dcounts[j][libAA1][libAA2] += 1
         
                #t5 t2 + sasa in numerator
                #if cont_match and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
                 #   dcounts[j][libAA1][libAA2] += 1
                    
                #t6 t2 with no SecStr (bestest)
                #if cont_match and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25: dcounts[j][libAA1][libAA2] += 1
                 
                #t7 t6 with 0.15 bins
                #if cont_match and libdistance < distance + 0.15 and libdistance > distance - 0.15 and libCAdistance < CAdistance + 0.15 and libCAdistance > CAdistance - 0.15: dcounts[j][libAA1][libAA2] += 1
                
                #t8 t7 with loose interacting pair definition
                
                #t9 t7 with sasa added
                #if cont_match and libdistance < distance + 0.15 and libdistance > distance - 0.15 and libCAdistance < CAdistance + 0.15 and libCAdistance > CAdistance - 0.15 and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10: dcounts[j][libAA1][libAA2] += 1
#############################################               
#############################################
######################STANDARD FROM JMB PAPER
                if cont_match and libdistance < distance + 0.1 and libdistance > distance - 0.1 and libCAdistance < CAdistance + 0.1 and libCAdistance > CAdistance - 0.1: dcounts[j][libAA1][libAA2] += 1
#############################################                
#############################################               
                #t10pw
                #if cont_match and libdistance < distance + 0.2 and libdistance > distance - 0.2 and libCAdistance < CAdistance + 0.2 and libCAdistance > CAdistance - 0.2 and libpw < pw + 10.0 and libpw > pw - 10.0: dcounts[j][libAA1][libAA2] += 1
                
                #t11 t6 with 0.05 bins
                #if cont_match and libdistance < distance + 0.05 and libdistance > distance - 0.05 and libCAdistance < CAdistance + 0.05 and libCAdistance > CAdistance - 0.05: dcounts[j][libAA1][libAA2] += 1
                
        #t12
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and libpw < pw + 10.0 and libpw > pw - 10.0: dcounts[j][libAA1][libAA2] += 1
        
        #t13, t10 with added CACB CBCA distances (0.1)
                #if cont_match and libdistance < distance + 0.1 and libdistance > distance - 0.1 and libCAdistance < CAdistance + 0.1 and libCAdistance > CAdistance - 0.1 and libCACBdistance < CACBdistance + 0.1 and libCACBdistance > CACBdistance - 0.1 and libCBCAdistance < CBCAdistance + 0.1 and libCBCAdistance > CBCAdistance - 0.1: dcounts[j][libAA1][libAA2] += 1
                
                #t14, t10 with added CACB CBCA distances (0.25)
                #if cont_match and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25 and libCACBdistance < CACBdistance + 0.25 and libCACBdistance > CACBdistance - 0.25 and libCBCAdistance < CBCAdistance + 0.25 and libCBCAdistance > CBCAdistance - 0.25: dcounts[j][libAA1][libAA2] += 1
                
        #no SASA
        #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]:
         #   dcounts[j][libAA1][libAA2] += 1
        
        #no CB
                #if cont_match and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
                    #dcounts[j][libAA1][libAA2] += 1        
          
        #no CACB angle
                #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
                 #   dcounts[j][libAA1][libAA2] += 1

                #nothing
        #if cont_match:
                #dcounts[j][libAA1][libAA2] += 1
                
                #CBonly
                #if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5: dcounts[j][libAA1][libAA2] += 1
                
        #CACB only
                #if cont_match and libangle < angle + 20.0 and libangle > angle - 20.0: dcounts[j][libAA1][libAA2] += 1
                
                #SASA only
                #if cont_match and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10: dcounts[j][libAA1][libAA2] += 1
                
                #pw only
                #if cont_match and libpw < pw + 10.0 and libpw > pw - 10.0: dcounts[j][libAA1][libAA2] += 1
                
                #ss only
                #if cont_match and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]: dcounts[j][libAA1][libAA2] += 1
                
        #CA only
                #if cont_match and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5: dcounts[j][libAA1][libAA2] += 1
                
        #CaCbBss
        #if cont_match and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and libdistance < distance + 0.5 and libdistance > distance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            #dcounts[j][libAA1][libAA2] += 1
            
        #all distances and no sasa
        #if cont_match and libCAdistance < CAdistance + 0.5 and libCAdistance > CAdistance - 0.5 and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libNdistance < Ndistance + 0.5 and libNdistance > Ndistance - 0.5 and libCdistance < Cdistance + 0.5 and libCdistance > Cdistance - 0.5 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2]: dcounts[j][libAA1][libAA2] += 1

        #all distances
        #if cont_match and libCAdistance < CAdistance + 0.25 and libCAdistance > CAdistance - 0.25 and libdistance < distance + 0.25 and libdistance > distance - 0.25 and libNdistance < Ndistance + 0.25 and libNdistance > Ndistance - 0.25 and libCdistance < Cdistance + 0.25 and libCdistance > Cdistance - 0.25: dcounts[j][libAA1][libAA2] += 1

    for pos in range(Nuse):
          
    counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Scounts.txt_' + str(num)), 'w')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t' + str(scountsL[pos][i]) + '\t' + str(scountsR[pos][i]) + '\n')
    counts_file.close()
    counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt_' + str(num)), 'w')
    counts_file.write('AA\t')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t')
    counts_file.write('\n')
    for i in range(20):
        counts_file.write(AAChar_fasta(i) + '\t')
        for j in range(20): counts_file.write(str(dcounts[pos][i][j]) + '\t')
        counts_file.write('\n')
    counts_file.close()

def helix_probabilities():

    matrix = []
    for i in range(20): matrix.append(0)
    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    seqdata_list = os.listdir(seqdata_dir)
  
    count = 0
    for file in seqdata_list:
        count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        count += 1
    
    try: lib_pdbinfo_vec = structure_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][6] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][6] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        if lib_ss_vec[i] == 'H': matrix[int(lib_pdbinfo_vec[i][1])] += 1

        if count > 0 and count % 500 == 0:
        tot = 0
            for i in range(20): tot += matrix[i]
        for i in range(20):
            print AAChar_fasta(i), '\t', str(float(matrix[i]) / float(tot))
        print
        print

    for i in range(20):
    print AAChar_fasta(i), '\t', str(matrix[i])
    
def atoms_within_cutoff(distance_matrix_sub, cutoff):
  
    for k in range(len(distance_matrix_sub[1])):
        if distance_matrix_sub[1][k] < cutoff: return True
    return False
    
def select_sidechain_distances(pos1_list, pos2_list, distance_matrix, forward):
  
    pair_list = [[], []]
    for atomi in pos1_list:
        for atomj in pos2_list:
        idx = distance_matrix[0].index([atomi, atomj])
        if forward: pair_list[0].append([atomi, atomj])
        else: pair_list[0].append([atomj, atomi])
        pair_list[1].append(distance_matrix[1][idx])
    return pair_list

def stub_intact(atom_list):
  
    if not 'CA' in atom_list or not 'CB' in atom_list: return False
    return True
    
def matching_sidechain_pair(distances1, distances2, cutoff):
  
    sd = 0.0
    count = 0.0
    #CA_match = False
    #CB_match = False
    for i in range(len(distances1[0])):
        pair_i = distances1[0][i]
        di = distances1[1][i]
        for j in range(len(distances2[0])): 
        pair_j = distances2[0][j]
        dj = distances2[1][j]
        #if pair_i == ['CB', 'CB'] and pair_i == ['CB', 'CB']:
            #if di < dj + 0.1 and di > dj - 0.1: CB_match = True
        #if pair_i == ['CA', 'CA'] and pair_i == ['CA', 'CA']:
            #if di < dj + 0.1 and di > dj - 0.1: CA_match = True
        if pair_j == pair_i:
            sd += ((di - dj) ** 2)
            count += 1.0

    #if math.sqrt(sd / count) < cutoff and CA_match and CB_match: return True
    if math.sqrt(sd / count) < cutoff: return True
    else: return False
    
def matching_sidechain_pair_value(distances1, distances2, cutoff):
  
    sd = 0.0
    count = 0.0
    #CA_match = False
    #CB_match = False
    for i in range(len(distances1[0])):
        pair_i = distances1[0][i]
        di = distances1[1][i]
        for j in range(len(distances2[0])): 
        pair_j = distances2[0][j]
        dj = distances2[1][j]
        #if pair_i == ['CB', 'CB'] and pair_i == ['CB', 'CB']:
            #if di < dj + 0.1 and di > dj - 0.1: CB_match = True
        #if pair_i == ['CA', 'CA'] and pair_i == ['CA', 'CA']:
            #if di < dj + 0.1 and di > dj - 0.1: CA_match = True
        if pair_j == pair_i:
            sd += ((di - dj) ** 2)
            count += 1.0

    return math.sqrt(sd / count)
    
def retrieve_sidechain_distance(sub, pair):
  
    try: return sub[1][sub[0].index(pair)]
    except: return 10000000.0
    
def upload_interacting_pairs(ip_path):
  
    v = []
    lines = readlines(ip_path)
    for line in lines:
        items = line.strip().split()
    pos1 = int(items[0])
    pos2 = int(items[1])
        v.append([pos1, pos2])
    return v

def create_intra_use_list(use_list):

    rec_list = []
    pep_list = []
    for i in range(len(use_list)):
        if not use_list[i][0] in rec_list:
        rec_list.append(use_list[i][0])
        pep_list.append([])

    rec_list.sort()

    for i in range(len(use_list)):
    rec_idx = rec_list.index(use_list[i][0])
    pep_pos = use_list[i][1]
    pep_list[rec_idx].append(pep_pos)

    intra_list = []
    for i in range(len(rec_list)):  
        for j in range(len(pep_list[i])):
        for k in range(j + 1, len(pep_list[i])):
            intra_list.append([rec_list[i], pep_list[i][j], pep_list[i][k]])

    return intra_list

def statium_sidechain_intrapep(preset_dir, pdb_paths, out_dir, num):
  
    ip = False
    pair_def_cutoff = 6.0
    sidechain_match_cutoff = 0.4
  
    paths = lines2list(pdb_paths)
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    ip_path = os.path.join(file_dir, file_base + '.ip')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    mask_vec = []
    if os.path.exists(mask_path):
        mask_lines = readlines(mask_path)
        for line in mask_lines:
            mask_vec.append([int(line.strip().split()[0]) - 1, int(line.strip().split()[1]) - 1])
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrix_sidechain(pdbinfo_vec)

    if os.path.exists(ip_path) and ip:
        use_index = []
        ip_lines = readlines(ip_path)
        for line in ip_lines:
            pos0 = line.split()[0]
            pos1 = line.split()[1]
            use_index.append([int(pos0) - 1, int(pos1) - 1])
    else:
        use_index = []
        for i in range(N):
        for j in range(i + 1, N):
            if not i in res_vec and not j in res_vec: continue
            if [i, j] in mask_vec: continue
            if i in res_vec and j in res_vec: continue
            if AAChar_fasta(pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(pdbinfo_vec[j][1]) == 'G': continue
            if atoms_within_cutoff(template_distance_matrix[i][j], pair_def_cutoff):
            use_index.append([i, j])

    intra_use_index = create_intra_use_list(use_index)
    
    Nuse = len(use_index)
    intra_Nuse = len(intra_use_index)

    intra_use_index_pep = []
    for i in range(intra_Nuse): intra_use_index_pep.append([intra_use_index[i][1], intra_use_index[i][2]])
    intra_Nuse_pep = len(intra_use_index_pep)

    dcounts = []
    for i in range(intra_Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0.0)
        
    template_distances = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = pdbinfo_vec[pos1][2][0]
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]): template_distances.append([])
    else: template_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    template_intra_distances = []
    for i in range(intra_Nuse_pep):
    pos1 = intra_use_index_pep[i][0]
    pos2 = intra_use_index_pep[i][1]
    pos1_list = ['CA', 'CB']
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]) or not stub_intact(pdbinfo_vec[pos1][2][0]): template_intra_distances.append([])
    else: template_intra_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    for path in range(len(paths)):
    print path
        pdb_path = paths[path][1]
        lib_ip_path = os.path.join('/home/bartolo/web/PDB/ip_90', os.path.split(paths[path][1])[1].split('.')[0] + '.ip')
    lib_pdbinfo_vec = store_pdb_info(pdb_path)
        
        libN = len(lib_pdbinfo_vec)
    
    lib_use_index = upload_interacting_pairs(lib_ip_path)
    lib_distance_matrix = distance_matrix_sidechain_use(lib_pdbinfo_vec, lib_use_index)

    intra_lib_use_index = create_intra_use_list(lib_use_index)

    intra_libNuse = len(intra_lib_use_index)

        intra_lib_use_index_pep = []
        for i in range(intra_libNuse): intra_lib_use_index_pep.append([intra_lib_use_index[i][1], intra_lib_use_index[i][2]])
        intra_libNuse_pep = len(intra_lib_use_index_pep)
    lib_intra_pep_distance_matrix = distance_matrix_sidechain_use(lib_pdbinfo_vec, intra_lib_use_index_pep)

    for i in range(intra_libNuse):
        lib_pos1 = intra_lib_use_index[i][0]
        lib_pos2 = intra_lib_use_index[i][1]
        lib_pos3 = intra_lib_use_index[i][2]
        lib_AA1 = lib_pdbinfo_vec[lib_pos1][1]
        lib_AA2 = lib_pdbinfo_vec[lib_pos2][1]
        lib_AA3 = lib_pdbinfo_vec[lib_pos3][1]
        if lib_AA1 < 0 or lib_AA2 < 0  or lib_AA3 < 0 or lib_AA1 > 19 or lib_AA2 > 19 or lib_AA3 > 19: continue
        for j in range(intra_Nuse):
            pos1 = intra_use_index[j][0]
            pos2 = intra_use_index[j][1]
        pos3 = intra_use_index[j][2]
            AA1 = pdbinfo_vec[pos1][1]
        if not lib_AA1 == AA1: continue
            if stub_intact(lib_pdbinfo_vec[lib_pos2][2][0]) and stub_intact(lib_pdbinfo_vec[lib_pos3][2][0]):
                lib_dist_for = select_sidechain_distances(['CA', 'CB'], ['CA', 'CB'], lib_intra_pep_distance_matrix[lib_pos2][lib_pos3], True)
            if matching_sidechain_pair(template_intra_distances[j], lib_dist_for, sidechain_match_cutoff):
                dcounts[j][lib_AA2][lib_AA3] += 1

    for pos in range(intra_Nuse):

    counts_file = open(os.path.join(out_dir, str(intra_use_index[pos][0] + 1) + '_' + str(intra_use_index[pos][1] + 1) + '_' + str(intra_use_index[pos][2] + 1) + '_counts.txt_' + str(num)), 'w')
    counts_file.write('AA\t')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t')
    counts_file.write('\n')
    for i in range(20):
        counts_file.write(AAChar_fasta(i) + '\t')
        for j in range(20): counts_file.write(str(dcounts[pos][i][j]) + '\t')
        counts_file.write('\n')
    counts_file.close()

def statium_sidechain_local(preset_dir, pdb_paths, out_dir, num):
  
    ip = False
    pair_def_cutoff = 6.0
    sidechain_match_cutoff = 0.4
  
    paths = lines2list(pdb_paths)
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    ip_path = os.path.join(file_dir, file_base + '.ip')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    mask_vec = []
    if os.path.exists(mask_path):
        mask_lines = readlines(mask_path)
        for line in mask_lines:
            mask_vec.append([int(line.strip().split()[0]) - 1, int(line.strip().split()[1]) - 1])
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrix_sidechain(pdbinfo_vec)

    if os.path.exists(ip_path) and ip:
        use_index = []
        ip_lines = readlines(ip_path)
        for line in ip_lines:
            pos0 = line.split()[0]
            pos1 = line.split()[1]
            use_index.append([int(pos0) - 1, int(pos1) - 1])
    else:
        use_index = []
        for i in range(N):
        for j in [i + 3, i + 4]:
        if j > N - 1: break
            if not i in res_vec or not j in res_vec: continue
            if [i, j] in mask_vec: continue
            if AAChar_fasta(pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(pdbinfo_vec[j][1]) == 'G': continue
            use_index.append([i, j])

    Nuse = len(use_index)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0.0)
        
    template_distances = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = ['CA', 'CB']
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]) or not stub_intact(pdbinfo_vec[pos1][2][0]): template_distances.append([])
    else: template_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    for path in range(len(paths)):
    print path
        pdb_path = paths[path][1]        

    lib_pdbinfo_vec = store_pdb_info(pdb_path)
        
        libN = len(lib_pdbinfo_vec)
    
        lib_use_index = []
        for i in range(libN):
        for j in [i + 3, i + 4]:
        if j > libN - 1: break
            if AAChar_fasta(lib_pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(lib_pdbinfo_vec[j][1]) == 'G': continue
            lib_use_index.append([i, j])

    lib_distance_matrix = distance_matrix_sidechain_use(lib_pdbinfo_vec, lib_use_index)

    libNuse = len(lib_use_index)
    for i in range(libNuse):
        lib_pos1 = lib_use_index[i][0]
        lib_pos2 = lib_use_index[i][1]
        lib_AA1 = lib_pdbinfo_vec[lib_pos1][1]
        lib_AA2 = lib_pdbinfo_vec[lib_pos2][1]
        if lib_AA1 < 0 or lib_AA2 < 0  or lib_AA1 > 19 or lib_AA2 > 19: continue
        for j in range(Nuse):
            pos1 = use_index[j][0]
            pos2 = use_index[j][1]
        if pos2 - pos1 != lib_pos2 - lib_pos1: continue
            AA1 = pdbinfo_vec[pos1][1]
        AA2 = pdbinfo_vec[pos2][1]
            if stub_intact(lib_pdbinfo_vec[lib_pos1][2][0]) and stub_intact(lib_pdbinfo_vec[lib_pos2][2][0]):
                lib_dist = select_sidechain_distances(['CA', 'CB'], ['CA', 'CB'], lib_distance_matrix[lib_pos1][lib_pos2], True)
            if matching_sidechain_pair(template_distances[j], lib_dist, sidechain_match_cutoff):
                dcounts[j][lib_AA1][lib_AA2] += 1

    for pos in range(Nuse):

    counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt_' + str(num)), 'w')
    counts_file.write('AA\t')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t')
    counts_file.write('\n')
    for i in range(20):
        counts_file.write(AAChar_fasta(i) + '\t')
        for j in range(20): counts_file.write(str(dcounts[pos][i][j]) + '\t')
        counts_file.write('\n')
    counts_file.close()
        
def statium_sidechain(preset_dir, pdb_paths, out_dir, num):
  
    ip = False
    pair_def_cutoff = 6.0
    sidechain_match_cutoff = 0.4
  
    paths = lines2list(pdb_paths)
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    ip_path = os.path.join(file_dir, file_base + '.ip')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    mask_vec = []
    if os.path.exists(mask_path):
        mask_lines = readlines(mask_path)
        for line in mask_lines:
            mask_vec.append([int(line.strip().split()[0]) - 1, int(line.strip().split()[1]) - 1])
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrix_sidechain(pdbinfo_vec)

    if os.path.exists(ip_path) and ip:
        use_index = []
        ip_lines = readlines(ip_path)
        for line in ip_lines:
            pos0 = line.split()[0]
            pos1 = line.split()[1]
            use_index.append([int(pos0) - 1, int(pos1) - 1])
    else:
        use_index = []
        for i in range(N):
        for j in range(i + 1, N):
            if not i in res_vec and not j in res_vec: continue
            if [i, j] in mask_vec: continue
            if i in res_vec and j in res_vec: continue
            #if AAChar_fasta(pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(pdbinfo_vec[j][1]) == 'G': continue
            if atoms_within_cutoff(template_distance_matrix[i][j], pair_def_cutoff):
            use_index.append([i, j])
    
    Nuse = len(use_index)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append(0)
        
    template_distances = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = pdbinfo_vec[pos1][2][0]
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]): template_distances.append([])
    else: template_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    ip_res = []
    for i in range(20): ip_res.append(0)

    for path in range(len(paths)):
    print path
        pdb_path = paths[path][0]
        lib_ip_path = os.path.join('/home/bartolo/web/PDB/ip_90_wGLY', os.path.split(paths[path][0])[1].split('.')[0] + '.ip')
    lib_pdbinfo_vec = store_pdb_info(pdb_path)
        
        libN = len(lib_pdbinfo_vec)
    
    lib_use_index = upload_interacting_pairs(lib_ip_path)
    lib_distance_matrix = distance_matrix_sidechain_use(lib_pdbinfo_vec, lib_use_index)

    #lib_distance_matrix = distance_matrix_sidechain(lib_pdbinfo_vec)
        #lib_use_index = []
        #ip_file = open(lib_ip_path, 'w')
        #for i in range(libN):
     #   for j in range(i + 1, libN):
            #if AAChar_fasta(lib_pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(lib_pdbinfo_vec[j][1]) == 'G': continue
      #      if atoms_within_cutoff(lib_distance_matrix[i][j], pair_def_cutoff):
    #        lib_use_index.append([i, j])
    #        ip_file.write(str(i) + '\t' + str(j) + '\n')
    #ip_file.close()
    #continue

    libNuse = len(lib_use_index)
    for i in range(libNuse):
        lib_pos1 = lib_use_index[i][0]
        lib_pos2 = lib_use_index[i][1]
        if lib_pos2 - lib_pos1 <= 4: continue
        lib_AA1 = lib_pdbinfo_vec[lib_pos1][1]
        lib_AA2 = lib_pdbinfo_vec[lib_pos2][1]
        if lib_AA1 < 0 or lib_AA2 < 0 or lib_AA1 > 19 or lib_AA2 > 19: continue
            ip_res[lib_AA1] += 1
            ip_res[lib_AA2] += 1
        for j in range(Nuse):
            pos1 = use_index[j][0]
            pos2 = use_index[j][1]
            AA1 = pdbinfo_vec[pos1][1]
            if stub_intact(lib_pdbinfo_vec[lib_pos2][2][0]):
                if lib_AA1 == AA1:
                       lib_dist_for = select_sidechain_distances(lib_pdbinfo_vec[lib_pos1][2][0], ['CA', 'CB'], lib_distance_matrix[lib_pos1][lib_pos2], True)
                if matching_sidechain_pair(template_distances[j], lib_dist_for, sidechain_cutoff_dist(AAChar_fasta(AA1))):
                dcounts[j][lib_AA2] += 1
            if stub_intact(lib_pdbinfo_vec[lib_pos1][2][0]):
                if lib_AA2 == AA1:
                       lib_dist_rev = select_sidechain_distances(['CA', 'CB'], lib_pdbinfo_vec[lib_pos2][2][0], lib_distance_matrix[lib_pos1][lib_pos2], False)
                if matching_sidechain_pair(template_distances[j], lib_dist_rev, sidechain_cutoff_dist(AAChar_fasta(AA1))):
                dcounts[j][lib_AA1] += 1

    counts_file = open(os.path.join(out_dir, 'ip_res.txt_' + str(num)), 'w')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t' + str(ip_res[i]) + '\n')
    counts_file.close()

    for pos in range(Nuse):
          
    counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt_' + str(num)), 'w')
    for i in range(20): counts_file.write(AAChar_fasta(i) + '\t' + str(dcounts[pos][i]) + '\n')
    counts_file.close()
    
def structure_comp(residue_path, pdb_path1, pdb_path2):
  
    pair_def_cutoff = 6.0
    sidechain_match_cutoff = 0.4
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    pdbinfo_vec = store_pdb_info(pdb_path1)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrix_sidechain(pdbinfo_vec)

    pdbinfo_vec2 = store_pdb_info(pdb_path2)
    N = len(pdbinfo_vec2)
    template_distance_matrix2 = distance_matrix_sidechain(pdbinfo_vec2)

    if True:
        use_index = []
        for i in range(N):
        for j in range(i + 1, N):
            if not i in res_vec and not j in res_vec: continue
            if i in res_vec and j in res_vec: continue
            if AAChar_fasta(pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(pdbinfo_vec[j][1]) == 'G': continue
            if atoms_within_cutoff(template_distance_matrix[i][j], pair_def_cutoff):
            use_index.append([i, j])
    
    Nuse = len(use_index)
        
    template_distances = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = pdbinfo_vec[pos1][2][0]
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]): template_distances.append([])
    else: template_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    template_distances2 = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = pdbinfo_vec2[pos1][2][0]
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec2[pos2][2][0]): template_distances.append([])
    else: template_distances2.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix2[pos1][pos2], True))


    livc = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    
    #print AAChar_fasta(pdbinfo_vec[pos1][1]), AAChar_fasta(pdbinfo_vec[pos2][1]),
    #print AAChar_fasta(pdbinfo_vec2[pos1][1]), AAChar_fasta(pdbinfo_vec2[pos2][1]),
    
    try:
      msv = matching_sidechain_pair_value(template_distances[i], template_distances2[i], sidechain_match_cutoff)
      #if pos1 >= 79 and pos1 <= 89: livc.append(msv)
      #if pos2 >= 145 and pos2 <= 154: livc.append(msv)
      #if pos2 >= 139 and pos2 <= 148: livc.append(msv)
      livc.append(msv)
      #print pos1 + 1, pos2 + 1, msv
    except:
      continue
      print pos1 + 1, pos2 + 1, 'error'
    import pylab
    print average(livc), len(livc)
    
def statium_sidechain_resopt(preset_dir, out_dir):
  
    pdb_paths = []
    pdb_list = os.listdir('/home/bartolo/web/PDB/culled_90')
    for i in range(len(pdb_list)): pdb_paths.append(os.path.join('/home/bartolo/web/PDB/culled_90', pdb_list[i]))
    
  
    aa_rmsd = []
    for i in range(20): aa_rmsd.append([])
    
    aa_type = []
    for i in range(20): aa_type.append([])
  
    ip = False
    pair_def_cutoff = 6.0
    sidechain_match_cutoff = 0.4
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    ip_path = os.path.join(file_dir, file_base + '.ip')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
       
    mask_vec = []
    if os.path.exists(mask_path):
        mask_lines = readlines(mask_path)
        for line in mask_lines:
            mask_vec.append([int(line.strip().split()[0]) - 1, int(line.strip().split()[1]) - 1])
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrix_sidechain(pdbinfo_vec)

    if os.path.exists(ip_path) and ip:
        use_index = []
        ip_lines = readlines(ip_path)
        for line in ip_lines:
            pos0 = line.split()[0]
            pos1 = line.split()[1]
            use_index.append([int(pos0) - 1, int(pos1) - 1])
    else:
        use_index = []
        for i in range(N):
        for j in range(i + 1, N):
            if not i in res_vec and not j in res_vec: continue
            if [i, j] in mask_vec: continue
            if i in res_vec and j in res_vec: continue
            if AAChar_fasta(pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(pdbinfo_vec[j][1]) == 'G': continue
            if atoms_within_cutoff(template_distance_matrix[i][j], pair_def_cutoff):
            use_index.append([i, j])
    
    Nuse = len(use_index)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append(0)
        
    template_distances = []
    for i in range(Nuse):
    pos1 = use_index[i][0]
    pos2 = use_index[i][1]
    pos1_list = pdbinfo_vec[pos1][2][0]
    pos2_list = ['CA', 'CB']
    if not stub_intact(pdbinfo_vec[pos2][2][0]): template_distances.append([])
    else: template_distances.append(select_sidechain_distances(pos1_list, pos2_list, template_distance_matrix[pos1][pos2], True))

    count = 0
    for pdb_path in pdb_paths:
        
        count += 1
        #print pdb_path
      
        lib_ip_path = os.path.join('/home/bartolo/web/PDB/ip_90', os.path.split(pdb_path)[1].split('.')[0] + '.ip')
    lib_pdbinfo_vec = store_pdb_info(pdb_path)
        
        libN = len(lib_pdbinfo_vec)
    
    lib_use_index = upload_interacting_pairs(lib_ip_path)
    lib_distance_matrix = distance_matrix_sidechain_use(lib_pdbinfo_vec, lib_use_index)
    
        #lib_use_index = []
        #ip_file = open(ip_path, 'w')
        #for i in range(libN):
        #for j in range(i + 1, libN):
            #if AAChar_fasta(lib_pdbinfo_vec[i][1]) == 'G' or AAChar_fasta(lib_pdbinfo_vec[j][1]) == 'G': continue
            #if atoms_within_cutoff(lib_distance_matrix[i][j], pair_def_cutoff):
            #lib_use_index.append([i, j])
            #ip_file.write(str(i) + '\t' + str(j) + '\n')
    #ip_file.close()

    libNuse = len(lib_use_index)
    for i in range(libNuse):
        lib_pos1 = lib_use_index[i][0]
        lib_pos2 = lib_use_index[i][1]
        lib_AA1 = lib_pdbinfo_vec[lib_pos1][1]
        lib_AA2 = lib_pdbinfo_vec[lib_pos2][1]
        if lib_AA1 < 0 or lib_AA2 < 0 or lib_AA1 > 19 or lib_AA2 > 19: continue
        for j in range(Nuse):
            pos1 = use_index[j][0]
            pos2 = use_index[j][1]
            AA1 = pdbinfo_vec[pos1][1]
            if stub_intact(lib_pdbinfo_vec[lib_pos2][2][0]):
                if not lib_AA1 == AA1: continue
                   lib_dist_for = select_sidechain_distances(lib_pdbinfo_vec[lib_pos1][2][0], ['CA', 'CB'], lib_distance_matrix[lib_pos1][lib_pos2], True)
            opt_val = matching_sidechain_pair_value(template_distances[j], lib_dist_for, sidechain_match_cutoff)
            aa_rmsd[lib_AA1].append(opt_val)
            aa_type[lib_AA1].append(AAChar_fasta(AA1))
            #if opt_val < 0.4:
                #if pos1 == 135 and pos2 == 156:
                #print pdb_path
                #print lib_pdbinfo_vec[lib_pos1][2][1][0]
                #print lib_pdbinfo_vec[lib_pos2][2][1][0]
                
                
            #if stub_intact(lib_pdbinfo_vec[lib_pos1][2][0]):
                #if not lib_AA2 == AA1: continue
                   #lib_dist_rev = select_sidechain_distances(['CA', 'CB'], lib_pdbinfo_vec[lib_pos2][2][0], lib_distance_matrix[lib_pos1][lib_pos2], False)
            #opt_val = matching_sidechain_pair_value(template_distances[j], lib_dist_rev, sidechain_match_cutoff)
            #aa_rmsd[lib_AA2].append(opt_val)

    if count != 10: continue
    count = 0
        for i in range(20):
            out_path = os.path.join(out_dir, AAChar_fasta(i) + '_rmsds.txt')
            of = open(out_path, 'w')
            for j in range(len(aa_rmsd[i])):
            of.write(AAChar_fasta(i) + '\t' + str(aa_rmsd[i][j]) + '\t' + aa_type[i][j] + '\n')
        of.close()
    
def plot_params():
  
    params = []
    for i in range(20):
    params.append([])
    for j in range(20): params[i].append([[], []])
  
    seqdata_dir = '/home/bartolo/web/PDB/seqdata_90_reformat'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/bartolo/web/PDB/culled_90'
    
    count = 0
    for file in seqdata_list:
        count += 1
        print seqdata_list.index(file), 'of', len(seqdata_list)
    if count % 10 == 0:
        print 'Making plot...'

            import matplotlib
            matplotlib.use( 'Agg' )
            import pylab
            pylab.rcParams['xtick.labelsize'] = '20'
            pylab.rcParams['ytick.labelsize'] = '20'
        
        a1 = pylab.array(params[AAChar_int('Y')][AAChar_int('N')][0])
        a2 = pylab.array(params[AAChar_int('Y')][AAChar_int('N')][1])
            pylab.hexbin(a1,a2,bins='log')
            pylab.xlim(min(a1), max(a1))
            pylab.ylim(min(a2), max(a2))
            
            pylab.savefig('/home/bartolo/web/paramsYN.png')
            pylab.close()
            
            import matplotlib
            matplotlib.use( 'Agg' )
            import pylab
            pylab.rcParams['xtick.labelsize'] = '20'
            pylab.rcParams['ytick.labelsize'] = '20'
        
        a1 = pylab.array(params[AAChar_int('H')][AAChar_int('N')][0])
        a2 = pylab.array(params[AAChar_int('H')][AAChar_int('N')][1])
            pylab.hexbin(a1,a2,bins='log')
            pylab.xlim(min(a1), max(a1))
            pylab.ylim(min(a2), max(a2))
            
            pylab.savefig('/home/bartolo/web/paramsHN.png')
            pylab.close()
        
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
    
    try: lib_pdbinfo_vec = structure_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
    lib_CACBdistance_matrix = distance_matrixCACB(lib_pdbinfo_vec)
    lib_CBCAdistance_matrix = distance_matrixCBCA(lib_pdbinfo_vec)
    lib_Ndistance_matrix = distance_matrixN(lib_pdbinfo_vec)
    lib_Cdistance_matrix = distance_matrixC(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
        try: lib_pw_matrix = pw_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    try: lib_backbone_angle_matrix = backbone_angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][6] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][6] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
        if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libCAdistance = lib_CAdistance_matrix[libpos1][libpos2]
        libCACBdistance = lib_CACBdistance_matrix[libpos1][libpos2]
        libCBCAdistance = lib_CBCAdistance_matrix[libpos1][libpos2]
        libNdistance = lib_Ndistance_matrix[libpos1][libpos2]
        libCdistance = lib_Cdistance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libbackbone_angle = lib_backbone_angle_matrix[libpos1][libpos2]
        libpw = lib_pw_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][7]
        libsasa2 = lib_pdbinfo_vec[libpos2][7]
        libcontinuous = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        try:
        libAA1 = int(lib_pdbinfo_vec[libpos1][1])
        libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        except: continue
        
        if not libcontinuous:
            params[libAA1][libAA2][0].append(libCAdistance)
            params[libAA1][libAA2][1].append(libdistance)
        
def statiumt(preset_dir, seqdata_file, out_dir, num):
  
    paths = lines2list(seqdata_file)
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = structure_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][6] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][6] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])
    
    use_index = []
    Spos_list = [[], [], []]
    for i in range(N):
    for j in range(i + 1, N):
        for k in range(j + 1, N):
            if not i in res_vec and not j in res_vec  and not k in res_vec: continue
            if template_distance_matrix[i][j] < 10.0 and template_distance_matrix[i][k] < 10.0 and template_distance_matrix[j][k] < 10.0 and template_distance_matrix[i][j] > 0.0 and template_distance_matrix[i][k] > 0.0 and template_distance_matrix[j][k] > 0.0:
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            sub_vec.append(k)
            use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts1 = []
    for i in range(Nuse):
    scounts1.append([])
    for j in range(20): scounts1[i].append(0)
    
    scounts2 = []
    for i in range(Nuse):
    scounts2.append([])
    for j in range(20): scounts2[i].append(0)
    
    scounts3 = []
    for i in range(Nuse):
    scounts3.append([])
    for j in range(20): scounts3[i].append(0)

    tcounts = []
    for i in range(Nuse):
    tcounts.append([])
    for j in range(20):
        tcounts[i].append([])
        for k in range(20):
            tcounts[i][j].append([])
            for l in range(20): tcounts[i][j][k].append(0)
    
    count = 0
    for pair in paths:
        print pair, len(paths)
        count += 1
    seqdata_path = pair[0]
    pdb_path = pair[1]
    
    try: lib_pdbinfo_vec = structure_info(pdb_path, seqdata_path)
    except: continue
        
        libN = len(lib_pdbinfo_vec)
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][6] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][6] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
            for k in range(j + 1, libN):
            if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][k] < 10.0 and lib_distance_matrix[j][k] < 10.0 and lib_distance_matrix[i][j] > 0.0 and lib_distance_matrix[i][k] > 0.0 and lib_distance_matrix[j][k] > 0.0:
                sub_vec = []
                sub_vec.append(i)
                sub_vec.append(j)
                sub_vec.append(k)
                lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libpos3 = lib_use_index[i][2]
        libdistance12 = lib_distance_matrix[libpos1][libpos2]
        libdistance13 = lib_distance_matrix[libpos1][libpos3]
        libdistance23 = lib_distance_matrix[libpos2][libpos3]
        libCAdistance12 = lib_CAdistance_matrix[libpos1][libpos2]
        libCAdistance13 = lib_CAdistance_matrix[libpos1][libpos3]
        libCAdistance23 = lib_CAdistance_matrix[libpos2][libpos3]
        libcontinuous12 = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        libcontinuous13 = (lib_cont_vec[libpos1] == lib_cont_vec[libpos3])
        libcontinuous23 = (lib_cont_vec[libpos2] == lib_cont_vec[libpos3])
        try:
        libAA1 = int(lib_pdbinfo_vec[libpos1][1])
        libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        libAA3 = int(lib_pdbinfo_vec[libpos3][1])
        except: continue
        
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
        pos3 = use_index[j][2]
            distance12 = template_distance_matrix[pos1][pos2]
            distance13 = template_distance_matrix[pos1][pos3]
            distance23 = template_distance_matrix[pos2][pos3]
            CAdistance12 = template_CAdistance_matrix[pos1][pos2]
            CAdistance13 = template_CAdistance_matrix[pos1][pos3]
            CAdistance23 = template_CAdistance_matrix[pos2][pos3]
        continuous12 = (cont_vec[pos1] == cont_vec[pos2])
        continuous13 = (cont_vec[pos1] == cont_vec[pos3])
        continuous23 = (cont_vec[pos2] == cont_vec[pos3])
        
        cont_match12 = (libcontinuous12 and continuous12) or (not libcontinuous12 and not continuous12)
        cont_match13 = (libcontinuous13 and continuous13) or (not libcontinuous13 and not continuous13)
        cont_match23 = (libcontinuous23 and continuous23) or (not libcontinuous23 and not continuous23)
        
        if libAA1 < 0 or libAA2 < 0 or libAA1 > 19 or libAA2 > 19 or not cont_match12 or not cont_match13 or not cont_match23: continue
            
        scounts1[j][libAA1] += 1
        scounts2[j][libAA2] += 1
        scounts3[j][libAA3] += 1
            
        if libdistance12 < distance12 + 0.25 and libdistance12 > distance12 - 0.25 and libdistance13 < distance13 + 0.25 and libdistance13 > distance13 - 0.25 and libdistance23 < distance23 + 0.25 and libdistance23 > distance23 - 0.25: tcounts[j][libAA1][libAA2][libAA3] += 1

    if pair == paths[-1]:
            
        for pos in range(Nuse):
          
            counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_' + str(use_index[pos][2] + 1) + '_Scounts.txt_' + str(num)), 'w')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t' + str(scounts1[pos][i]) + '\t' + str(scounts2[pos][i]) + '\t' + str(scounts3[pos][i]) + '\n')
        counts_file.close()
            #print os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt_' + str(num))
            counts_file = open(os.path.join(out_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_' + str(use_index[pos][2] + 1) + '_counts.txt_' + str(num)), 'w')
            for i in range(20):
            for j in range(20):
                for k in range(20): counts_file.write(str(tcounts[pos][i][j][k]) + '\n')
        counts_file.close()
        
def deep_coupling(seq_path, eval_path, out_path):
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
   
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)

    dprobs = []
    for i in range(Nuse):
    dprobs.append([])
    for j in range(20):
        dprobs[i].append([])
        for k in range(20): dprobs[i][j].append(0.0)
        
    energy = []
    for i in range(Nuse):
    energy.append([])
    for j in range(20):
        energy[i].append([])
        for k in range(20): energy[i][j].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
    for j in range(Nuse):
        idx0 = idxs[use_index[j][0]]
        idx1 = idxs[use_index[j][1]]
        dcounts[j][AAChar_int(seq[idx0])][AAChar_int(seq[idx1])] += 1
    
    for i in range(Nuse):
        total = 0
        for j in range(20):
        for k in range(20): total += dcounts[i][j][k]
    for j in range(20):
        for k in range(20):
            if total > 0: dprobs[i][j][k] += float(dcounts[i][j][k]) / float(total)

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
       
    for i in range(Nuse):        
    for j in range(20):
        for k in range(20):
            ps0 = sprobs[use_index[i][0]][j]
            ps1 = sprobs[use_index[i][1]][k]
            pd = dprobs[i][j][k]
            if pd > 0.0: energy[i][j][k] = -1.0 * math.log(pd / (ps0 * ps1))
            
    el = lines2list(eval_path)
    o = open(out_path, 'w')
    for i in range(len(el)):
        seq = el[i][0]
        e = 0.0
        for i in range(Nuse):
        aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
        aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
        if energy[i][aa0][aa1] > 0.0: e += energy[i][aa0][aa1]
    o.write(seq + '\t' + str(e) + '\n')
    o.close()
    
    test = [['PEIWVAQEIGRIGDETNAYYARR']]
    for i in range(len(test)):
        seq = test[i][0]
        e = 0.0
        for i in range(Nuse):
        aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
        aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
        if energy[i][aa0][aa1] > 0.0: e += energy[i][aa0][aa1]
    print e
        
    for i in range(Nuse):
          
    out_dir = '/home/bartolo/web/statium/data/deep_bclxl_cpl'
    counts_file = open(os.path.join(out_dir, str(idxs[use_index[i][0]] + 1) + '_' + str(idxs[use_index[i][1]] + 1) + '_probs.txt'), 'w')
    counts_file.write('AA\t')
    for j in range(20):
        counts_file.write(AAChar_fasta(j) + '\t')
    counts_file.write('\n')
    for j in range(20):
        counts_file.write(AAChar_fasta(j) + '\t')
        for k in range(20):
        counts_file.write(str(energy[i][j][k])[0:min(5, len(str(energy[i][j][k])))] + '\t')
        counts_file.write('\n')
    counts_file.close()
    
def deepcpl_mcl1(eval_vec):
  
    seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
   
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)

    dprobs = []
    for i in range(Nuse):
    dprobs.append([])
    for j in range(20):
        dprobs[i].append([])
        for k in range(20): dprobs[i][j].append(0.0)
        
    energy = []
    for i in range(Nuse):
    energy.append([])
    for j in range(20):
        energy[i].append([])
        for k in range(20): energy[i][j].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
    for j in range(Nuse):
        idx0 = idxs[use_index[j][0]]
        idx1 = idxs[use_index[j][1]]
        dcounts[j][AAChar_int(seq[idx0])][AAChar_int(seq[idx1])] += 1
    
    for i in range(Nuse):
        total = 0
        for j in range(20):
        for k in range(20): total += dcounts[i][j][k]
    for j in range(20):
        for k in range(20):
            if total > 0: dprobs[i][j][k] += float(dcounts[i][j][k]) / float(total)

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
       
    for i in range(Nuse):        
    for j in range(20):
        for k in range(20):
            ps0 = sprobs[use_index[i][0]][j]
            ps1 = sprobs[use_index[i][1]][k]
            pd = dprobs[i][j][k]
            if pd > 0.0: energy[i][j][k] = -1.0 * math.log(pd / (ps0 * ps1))
            
    seq = wt
    wte = 0.0
    for i in range(Nuse):
    aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
    aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
    if energy[i][aa0][aa1] > 0.0: wte += energy[i][aa0][aa1]
    
    ovec = []
    for i in range(len(eval_vec)):
        seq = eval_vec[i]
        if check_BH3(seq):
            e = 0.0
            for i in range(Nuse):
            aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
            aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
            if energy[i][aa0][aa1] > 0.0: e += energy[i][aa0][aa1]
        ovec.append(e)
    else: ovec.append(-99999.0)
    
    return ovec
    
def deepcpl_matrix(r):
  
    if r == 'm': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
    if r == 'x': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
   
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)

    dprobs = []
    for i in range(Nuse):
    dprobs.append([])
    for j in range(20):
        dprobs[i].append([])
        for k in range(20): dprobs[i][j].append(0.0)
        
    energy = []
    for i in range(Nuse):
    energy.append([])
    for j in range(20):
        energy[i].append([])
        for k in range(20): energy[i][j].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
    for j in range(Nuse):
        idx0 = idxs[use_index[j][0]]
        idx1 = idxs[use_index[j][1]]
        dcounts[j][AAChar_int(seq[idx0])][AAChar_int(seq[idx1])] += 1
    
    for i in range(Nuse):
        total = 0
        for j in range(20):
        for k in range(20): total += dcounts[i][j][k]
    for j in range(20):
        for k in range(20):
            if total > 0: dprobs[i][j][k] += float(dcounts[i][j][k]) / float(total)

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
       
    for i in range(Nuse):        
    for j in range(20):
        for k in range(20):
            ps0 = sprobs[use_index[i][0]][j]
            ps1 = sprobs[use_index[i][1]][k]
            pd = dprobs[i][j][k]
            if pd > 0.0: energy[i][j][k] = -1.0 * math.log(pd / (ps0 * ps1))
    
    return energy
    
def deepe_matrix(r):
  
    if r == 'm': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
    if r == 'x': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
    if r == 'ma': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt'
    if r == 'xa': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt'
    if r == 'me': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro_exclusive.txt'
    if r == 'xe': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro_exclusive.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
   
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)

    dprobs = []
    for i in range(Nuse):
    dprobs.append([])
    for j in range(20):
        dprobs[i].append([])
        for k in range(20): dprobs[i][j].append(0.0)
        
    energy = []
    for i in range(Nuse):
    energy.append([])
    for j in range(20):
        energy[i].append([])
        for k in range(20): energy[i][j].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
    for j in range(Nuse):
        idx0 = idxs[use_index[j][0]]
        idx1 = idxs[use_index[j][1]]
        dcounts[j][AAChar_int(seq[idx0])][AAChar_int(seq[idx1])] += 1
    
    for i in range(Nuse):
        total = 0
        for j in range(20):
        for k in range(20): total += dcounts[i][j][k]
    for j in range(20):
        for k in range(20):
            if total > 0: dprobs[i][j][k] += float(dcounts[i][j][k]) / float(total)

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
       
    for i in range(Nuse):        
    for j in range(20):
        for k in range(20):
            ps0 = sprobs[use_index[i][0]][j]
            ps1 = sprobs[use_index[i][1]][k]
            pd = dprobs[i][j][k]
            if pd > 0.0: energy[i][j][k] = -1.0 * math.log(pd / dprobs[i][AAChar_int(wt[idxs[use_index[i][0]]])][AAChar_int(wt[idxs[use_index[i][1]]])])
            else: energy[i][j][k] = 0.0
    
    return energy
    
def deepe_matrix_single_bfl1(r):
  
    if r == 'f': seq_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr.txt'
    if r == 'fa': seq_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 5, 7, 8, 11, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3d', '3g', '4a']
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0 / sprobs[i][AAChar_int(wt[idxs[i]])])
        else: energy[i][j] = 0.0
    
    return energy
    
def deepe_matrix_coupling_f(r):
  
    if r == 'f': seq_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr.txt'
    if r == 'fa': seq_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 5, 7, 8, 11, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3d', '3g', '4a']
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
    
    ccounts = []
    for i in range(N):
        ccounts.append([])
        for j in range(N):
        ccounts[i].append([])
        for k in range(20):
            ccounts[i][j].append([])
            for l in range(20): ccounts[i][j][k].append(0)
        
    cprobs = []
    for i in range(N):
        cprobs.append([])
        for j in range(N):
        cprobs[i].append([])
        for k in range(20):
            cprobs[i][j].append([])
            for l in range(20): cprobs[i][j][k].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    cenergy = []
    for i in range(N):
        cenergy.append([])
        for j in range(N):
        cenergy[i].append([])
        for k in range(20):
            cenergy[i][j].append([])
            for l in range(20): cenergy[i][j][k].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
        
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        for k in range(N):
            idxj = idxs[j]
            idxk = idxs[k]
            ccounts[j][k][AAChar_int(seq[idxj])][AAChar_int(seq[idxk])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
        
    for i in range(N):
        for j in range(N):
            for k in range(20):
            total = 0
            for l in range(20): total += ccounts[i][j][k][l]
            if total > 0:
                for l in range(20): cprobs[i][j][k][l] = float(ccounts[i][j][k][l]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0 / sprobs[i][AAChar_int(wt[idxs[i]])])
        else: energy[i][j] = 0.0
        
    for i in range(N):
        for j in range(i + 1, N):
            for k in range(20):
            for l in range(20):
                ps0 = cprobs[i][j][k][l]
                if ps0 > 0.0: cenergy[i][j][k][l] = -1.0 * math.log(ps0 / cprobs[i][j][AAChar_int(wt[idxs[i]])][AAChar_int(wt[idxs[j]])])
    
    return [energy, cenergy]
    
def deepe_matrix_single_w2(r):
  
    if r == '2a': seq_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt'
    if r == 'wa': seq_path = '/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0 / sprobs[i][AAChar_int(wt[idxs[i]])])
        else: energy[i][j] = 0.0
    
    return energy
    
def deepe_matrix_coupling_w2(r):
  
    if r == '2a': seq_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt'
    if r == 'wa': seq_path = '/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
    
    ccounts = []
    for i in range(N):
        ccounts.append([])
        for j in range(N):
        ccounts[i].append([])
        for k in range(20):
            ccounts[i][j].append([])
            for l in range(20): ccounts[i][j][k].append(0)
        
    cprobs = []
    for i in range(N):
        cprobs.append([])
        for j in range(N):
        cprobs[i].append([])
        for k in range(20):
            cprobs[i][j].append([])
            for l in range(20): cprobs[i][j][k].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    cenergy = []
    for i in range(N):
        cenergy.append([])
        for j in range(N):
        cenergy[i].append([])
        for k in range(20):
            cenergy[i][j].append([])
            for l in range(20): cenergy[i][j][k].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
        
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        for k in range(N):
            idxj = idxs[j]
            idxk = idxs[k]
            ccounts[j][k][AAChar_int(seq[idxj])][AAChar_int(seq[idxk])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
        
    for i in range(N):
        for j in range(N):
            for k in range(20):
            total = 0
            for l in range(20): total += ccounts[i][j][k][l]
            if total > 0:
                for l in range(20): cprobs[i][j][k][l] = float(ccounts[i][j][k][l]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0 / sprobs[i][AAChar_int(wt[idxs[i]])])
        else: energy[i][j] = 0.0
        
    for i in range(N):
        for j in range(N):
            for k in range(20):
            for l in range(20):
                ps0 = cprobs[i][j][k][l]
                if ps0 > 0.0: cenergy[i][j][k][l] = -1.0 * math.log(ps0 / cprobs[i][j][AAChar_int(wt[idxs[i]])][AAChar_int(wt[idxs[j]])])
    
    return [energy, cenergy]
    
def deepe_matrix_single(r):
  
    if r == 'm': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
    if r == 'x': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
    if r == 'ma': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt'
    if r == 'xa': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt'
    if r == 'me': seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro_exclusive.txt'
    if r == 'xe': seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro_exclusive.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = math.log(ps0)
        else: energy[i][j] = 0.0
    
    return energy
    
def deepe_matrix_glenna(seq_path):
  
    seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'

    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    #names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0)
        else: energy[i][j] = 0.0
    
    return energy
    
def deepe_calc_glenna(energy, seq):
    
    idxs = [4, 8, 9, 11, 13, 15]
    N = len(idxs)

    e = 0.0
    for i in range(len(idxs)):
    aa0 = AAChar_int(seq[idxs[i]])
    e += energy[i][aa0]
    return e
    
def deep_test(seq):
  
    energy_matrix = deepe_matrix_glenna('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    
    print deepe_calc_glenna(energy_matrix, seq)
    
def deep_duplicate(seq_path, r):
  
    seqs = lines2list(seq_path)
  
    if r in 'xm':
        idxs = [4, 8, 9, 11, 13, 15]
    
    if r in 'w2':
        idxs = [4, 7, 8, 9, 11, 12, 14]
        
    if r in 'f':
        idxs = [4, 5, 7, 8, 11, 14, 15]    

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    N = len(idxs)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0)
        else: energy[i][j] = 0.0
        
    return sprobs
    
def deep_duplicates():
  
    dp = '/home/bartolo/web/statium/deepseq/duplicates/allowed'
    dups = ['ms4', 'ms4_xn3', 'ms6', 'xs4', 'fs4', 'ws4', 'xs4_mn1', 'xs4_mn3_xs1']
    names = ['Mcl-1 pos. sort 4', 'Bcl-xL neg. sort 3', 'Mcl-1 pos. sort 6', 'Bcl-xL pos. sort 4', 'Bfl-1 pos. sort 4', 'Bcl-w pos. sort 4', 'Mcl-1 neg. sort 1', 'Bcl-xL pos. sort\nafter Mcl-1 neg. sort 3']
    rs = ['m', 'm', 'm', 'x', 'f', 'w', 'x', 'x']
  
    colors = ['b', 'r', 'g', 'k', 'c', 'm', 'y', 'purple']
  
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='8'
    pylab.rcParams['ytick.major.pad']='8'
    dh = []
    for dup in dups:
        
        p1 = os.path.join(dp, dup + '_i')
        p2 = os.path.join(dp, dup + '_ii')
      
        e1 = deep_duplicate(p1, rs[dups.index(dup)])
        e2 = deep_duplicate(p2, rs[dups.index(dup)])
        
        r = rs[dups.index(dup)]
        
        if r in 'xm':
            idxs = [4, 8, 9, 11, 13, 15]
    
        if r in 'w2':
            idxs = [4, 7, 8, 9, 11, 12, 14]
        
        if r in 'f':
            idxs = [4, 5, 7, 8, 11, 14, 15]
            
        N = len(idxs)
    
        dh.append([[], []])
        for i in range(N):
            for j in range(20):
            eval1 = e1[i][j]
            eval2 = e2[i][j]
        
            if eval1 and eval2 > 0.0:
                #print names[i], AAChar_fasta(j), abs(eval1 - eval2)
                dh[-1][0].append(eval1)
                dh[-1][1].append(eval2)
    
    R=stats.pearsonr(pylab.array(dh[-1][0]), pylab.array(dh[-1][1]))[0]
        pylab.scatter(dh[-1][0], dh[-1][1], label=names[dups.index(dup)] + ', ' + str(round(R, 2)), color=colors[dups.index(dup)], s=5)
        pylab.legend(loc='lower right')
        pylab.ylim(-0.5, 1.05)
        pylab.xlim(-0.1, 2.0)
        print dup, stats.pearsonr(pylab.array(dh[-1][0]), pylab.array(dh[-1][1]))
    pylab.savefig('/home/bartolo/web/statium/duplicate_diff.png')
    
def deep_duplicatesII():
  
    dp = '/home/bartolo/web/statium/deepseq/duplicates/conv_vs_deep'
    dups = ['A', 'B']
  
    colors = ['b', 'r', 'g', 'k', 'c', 'm', 'y', 'purple']
  
    import pylab
    dh = []
    for dup in dups:
        
        p1 = os.path.join(dp, dup + '_i.txt')
        p2 = os.path.join(dp, dup + '_ii.txt')
      
        e1 = deep_duplicate(p1, 'x')
        e2 = deep_duplicate(p2, 'm')
        
        idxs = [4, 8, 9, 11, 13, 15]
            
        N = len(idxs)
    
        dh.append([[], []])
        for i in range(N):
            for j in range(20):
            eval1 = e1[i][j]
            eval2 = e2[i][j]
        
            if eval1 and eval2 > 0.0:
                #print names[i], AAChar_fasta(j), abs(eval1 - eval2)
                dh[-1][0].append(eval1)
                dh[-1][1].append(eval2)
    
    R=stats.pearsonr(pylab.array(dh[-1][0]), pylab.array(dh[-1][1]))[0]
    print R
    
def deepe_matrix_coupling(r):
  
    if r == 'fa':
        seq_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt'
        idxs = [4, 5, 7, 8, 11, 14, 15]
        names = ['2d', '2e', '2g', '3a', '3d', '3g', '4a']
        xpath = '/home/bartolo/web/statium/bfl1_sorts/express_nr.txt'
        aas = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    if r == '2a':
        seq_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt'
        idxs = [4, 7, 8, 9, 11, 12, 14]
        xpath = '/home/bartolo/web/statium/deepseq/w2/expressing_nr.txt'
        aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    if r == 'wa':
        seq_path = '/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt'
        idxs = [4, 7, 8, 9, 11, 12, 14]
        xpath = '/home/bartolo/web/statium/deepseq/w2/expressing_nr.txt'
        aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    if r == 'm':
        seq_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
        xpath = '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt'
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    if r == 'x':
        seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
        xpath = '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt'
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    if r == 'ma':
        seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt'
        xpath = '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt'
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    if r == 'xa':
        seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt'
        xpath = '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt'
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
        
    seqs = lines2list(seq_path)
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    N = len(idxs)
 #   xseqs = lines2list(xpath)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)
    
#    xcounts = []
 #   for i in range(N):
#    xcounts.append([])
#    for j in range(20): xcounts[i].append(0)
#        
    xprobs = []
    for i in range(N):
     xprobs.append([])
        chs = aas[i]
     for j in range(20):
            if AAChar_fasta(j) in chs: xprobs[i].append(1.0 / float(len(chs)))
        else:  xprobs[i].append(0.0)
    
    ccounts = []
    for i in range(N):
        ccounts.append([])
        for j in range(N):
        ccounts[i].append([])
        for k in range(20):
            ccounts[i][j].append([])
            for l in range(20): ccounts[i][j][k].append(0)
            
 #   xccounts = []
  #  for i in range(N):
   #     xccounts.append([])
    #    for j in range(N):
#        xccounts[i].append([])
#        for k in range(20):
#            xccounts[i][j].append([])
#            for l in range(20): xccounts[i][j][k].append(0)
        
    cprobs = []
    for i in range(N):
        cprobs.append([])
        for j in range(N):
        cprobs[i].append([])
        for k in range(20):
            cprobs[i][j].append([])
            for l in range(20): cprobs[i][j][k].append(0.0)
            
#    xcprobs = []
 #   for i in range(N):
  #      xcprobs.append([])
   #     for j in range(N):
#        xcprobs[i].append([])
#        for k in range(20):
#            xcprobs[i][j].append([])
#            for l in range(20): xcprobs[i][j][k].append(0.0)
        
    energy = []
    for i in range(N):
    energy.append([])
    for j in range(20): energy[i].append(0.0)
    
   # xenergy = []
   # for i in range(N):
#    xenergy.append([])
#    for j in range(20): xenergy[i].append(0.0)
    
    cenergy = []
    for i in range(N):
        cenergy.append([])
        for j in range(N):
        cenergy[i].append([])
        for k in range(20):
            cenergy[i][j].append([])
            for l in range(20): cenergy[i][j][k].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
        
 #   for i in range(len(xseqs)):
  #      seq = xseqs[i][0]
   #     for j in range(N):
#        idx = idxs[j]
#        xcounts[j][AAChar_int(seq[idx])] += 1
        
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        for k in range(N):
            idxj = idxs[j]
            idxk = idxs[k]
            ccounts[j][k][AAChar_int(seq[idxj])][AAChar_int(seq[idxk])] += 1
            
 #   for i in range(len(xseqs)):
   #     seq = xseqs[i][0]
    #    for j in range(N):
#        for k in range(N):
#            idxj = idxs[j]
#            idxk = idxs[k]
#            xccounts[j][k][AAChar_int(seq[idxj])][AAChar_int(seq[idxk])] += 1

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
        
 #   for i in range(N):
  #      total = 0
#    for j in range(20): total += xcounts[i][j]
#    for j in range(20):
#        if total > 0: xprobs[i][j] = float(xcounts[i][j]) / float(total)
        
    for i in range(N):
        for j in range(N):
            for k in range(20):
            total = 0
            for l in range(20): total += ccounts[i][j][k][l]
            if total > 0:
                for l in range(20): cprobs[i][j][k][l] = float(ccounts[i][j][k][l]) / float(total)
                
 #   for i in range(N):
  #      for j in range(N):
   #         for k in range(20):
#            total = 0
#            for l in range(20): total += xccounts[i][j][k][l]
#            if total > 0:
#                for l in range(20): xcprobs[i][j][k][l] = float(xccounts[i][j][k][l]) / float(total)
      
    for i in range(N):
        for j in range(20):
        ps0 = sprobs[i][j]
        if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0)
        #if ps0 > 0.0: energy[i][j] = -1.0 * math.log(ps0 / sprobs[i][AAChar_int(wt[idxs[i]])])
        #if ps0 > 0.0 and xprobs[i][j] > 0.0 and AAChar_int(wt[idxs[i]]) != j: energy[i][j] = -1.0 * math.log(ps0 / xprobs[i][j])
        else: energy[i][j] = 0.0
            
    for i in range(N):
        for j in range(i + 1, N):
            for k in range(20):
            for l in range(20):
                ps0 = cprobs[i][j][k][l]
                if cprobs[i][j][AAChar_int(wt[idxs[i]])][AAChar_int(wt[idxs[j]])] == 0.0 or ps0 == 0.0: continue
                ec = -1.0 * math.log(ps0 / cprobs[i][j][AAChar_int(wt[idxs[i]])][AAChar_int(wt[idxs[j]])])
#                if xcprobs[i][j][k][l] == 0.0 or ps0 == 0.0: continue
#                ecx = -1.0 * math.log(ps0 / xcprobs[i][j][k][l])
                cenergy[i][j][k][l] = ec
    
    return [energy, cenergy]
    
def deepe_calc(energy, seq):
    
    idxs = [4, 8, 9, 11, 13, 15]
    N = len(idxs)
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    if check_BH3(seq):
        e = 0.0
        for i in range(Nuse):
        aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
        aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
        e += energy[i][aa0][aa1]
    return e
    else: return -99999.0
    
def deepe_calc_singlef(energy, seq):
  
    idxs = [4, 5, 7, 8, 11, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3d', '3g', '4a']
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        e += energy[i][aa0]
    return e
    else: return -99999.0
    
def deepe_calc_singlew2(energy, seq):
  
    idxs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        e += energy[i][aa0]
    return e
    else: return -99999.0
    
def deepe_calc_single(energy, seq):
    
    idxs = [4, 8, 9, 11, 13, 15]
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        e += energy[i][aa0]
    return e
    else: return -99999.0
    
def deepe_calc_coupling(energy_vec, seq, x, cx):
  
    energy = energy_vec[0]
    r = energy_vec[1]
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    #wt = 'AAQRYGRELRRMSDEFVDSFKKG'
    #wt = 'LEVECATQLRRFGDKLNFRQKLL'
    if r == 'fa': idxs = [4, 5, 7, 8, 11, 14, 15]
    if r in ['wa', '2a']: idxs = [4, 7, 8, 9, 11, 12, 14]
    if r in ['ma', 'xa', 'm', 'x']: idxs = [4, 8, 9, 11, 13, 15]
    
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        for j in range(i + 1, N):
            aa0 = AAChar_int(seq[idxs[i]])
            aa1 = AAChar_int(seq[idxs[j]])
            e += cx * energy[1][i][j][aa0][aa1]
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        if seq[idxs[i]] == wt[idxs[i]]: continue
        if seq[idxs[i]] != wt[idxs[i]] and energy[0][i][aa0] == 0.0: return -999.0
        e += x * 1.0 * energy[0][i][aa0]
    return e
    else: return -99999.0
    
def deepe_calc_coupling_f(energy, seq, x, cx):
    
    idxs = [4, 5, 7, 8, 11, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3d', '3g', '4a']
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        for j in range(N):
            if i == j: continue
            aa0 = AAChar_int(seq[idxs[i]])
            aa1 = AAChar_int(seq[idxs[j]])
            e += cx * energy[1][i][j][aa0][aa1]
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        e += x * energy[0][i][aa0]
    return e
    else: return -99999.0
    
def deepe_calc_coupling_w2(energy, seq, x, cx):
    
    idxs = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    N = len(idxs)
    if check_BH3(seq):
        e = 0.0
        for i in range(N):
        for j in range(N):
            if i == j: continue
            aa0 = AAChar_int(seq[idxs[i]])
            aa1 = AAChar_int(seq[idxs[j]])
            e += cx * energy[1][i][j][aa0][aa1]
        for i in range(N):
        aa0 = AAChar_int(seq[idxs[i]])
        e += x * energy[0][i][aa0]
    return e
    else: return -99999.0
    
def deepcpl_calc(energy, seq):
    
    idxs = [4, 8, 9, 11, 13, 15]
    N = len(idxs)
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    if check_BH3(seq):
        e = 0.0
        for i in range(Nuse):
        aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
        aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
        if energy[i][aa0][aa1] > 0.0: e += energy[i][aa0][aa1]
    return e
    else: return -99999.0
    
def deepcpl_bclxl(eval_vec):
  
    seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
  
    #if not os.path.exists(out_dir): os.mkdir(out_dir)
    seqs = lines2list(seq_path)
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    N = len(idxs)
    
   
    use_index = []
    for i in range(N):
    for j in range(i + 1, N):
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scounts = []
    for i in range(N):
    scounts.append([])
    for j in range(20): scounts[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
        
    sprobs = []
    for i in range(N):
    sprobs.append([])
    for j in range(20): sprobs[i].append(0.0)

    dprobs = []
    for i in range(Nuse):
    dprobs.append([])
    for j in range(20):
        dprobs[i].append([])
        for k in range(20): dprobs[i][j].append(0.0)
        
    energy = []
    for i in range(Nuse):
    energy.append([])
    for j in range(20):
        energy[i].append([])
        for k in range(20): energy[i][j].append(0.0)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        for j in range(N):
        idx = idxs[j]
        scounts[j][AAChar_int(seq[idx])] += 1
    for j in range(Nuse):
        idx0 = idxs[use_index[j][0]]
        idx1 = idxs[use_index[j][1]]
        dcounts[j][AAChar_int(seq[idx0])][AAChar_int(seq[idx1])] += 1
    
    for i in range(Nuse):
        total = 0
        for j in range(20):
        for k in range(20): total += dcounts[i][j][k]
    for j in range(20):
        for k in range(20):
            if total > 0: dprobs[i][j][k] += float(dcounts[i][j][k]) / float(total)

    for i in range(N):
        total = 0
    for j in range(20): total += scounts[i][j]
    for j in range(20):
        if total > 0: sprobs[i][j] = float(scounts[i][j]) / float(total)
       
    for i in range(Nuse):        
    for j in range(20):
        for k in range(20):
            ps0 = sprobs[use_index[i][0]][j]
            ps1 = sprobs[use_index[i][1]][k]
            pd = dprobs[i][j][k]
            if pd > 0.0: energy[i][j][k] = -1.0 * math.log(pd / (ps0 * ps1))
            
    seq = wt
    wte = 0.0
    for i in range(Nuse):
    aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
    aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
    if energy[i][aa0][aa1] > 0.0: wte += energy[i][aa0][aa1]
    
    ovec = []
    for i in range(len(eval_vec)):
        seq = eval_vec[i]
        if check_BH3(seq):
            e = 0.0
            for i in range(Nuse):
            aa0 = AAChar_int(seq[idxs[use_index[i][0]]])
            aa1 = AAChar_int(seq[idxs[use_index[i][1]]])
            if energy[i][aa0][aa1] > 0.0: e += energy[i][aa0][aa1]
        ovec.append(e)
    else: ovec.append(-99999.0)
    
    return ovec

def combine_lines(f1, f2, op):
  
    l1 = lines2list(f1)
    l2 = lines2list(f2)
    
    o = open(op, 'w')
    for i in range(len(l1)):
        o.write(l1[i][0] + '\t' + str(l2[i][0]) + '\n')
    o.close()
    
def filter_lists(l1p, l2p, l3p, op):
  
    l1 = readlines(l1p)
    l2 = readlines(l2p)
    l3 = readlines(l3p)
    
    count = 0
    o = open(op, 'w')
    for line in l3:
        if not line in l1 and not line in l2:
        o.write(line)
        count += 1
    o.close()
    
    print count, len(l3)
        
def statium_coils(preset_dir):
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
        
    mask_vec = []
    mask_lines = readlines(mask_path)
    for line in mask_lines:
        mask_vec.append(int(line.strip()) - 1)
    
    seqdata_dir = '/home/bartolo/web/BA_CC_seq'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/bartolo/web/BA_CC'
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    template_distance_matrix = distance_matrixCB(pdbinfo_vec)
    template_CAdistance_matrix = distance_matrixCA(pdbinfo_vec)
    template_angle_matrix = angle_matrix(pdbinfo_vec)
    
    ss_vec = []
    for i in range(N):
    if pdbinfo_vec[i][4] == 'H': ss_vec.append('H')
    elif pdbinfo_vec[i][4] == 'E': ss_vec.append('E')
    else: ss_vec.append('C')
    
    cont_vec = []
    cont_vec.append(0)
    for i in range(1, N):
    if ss_vec[i] != ss_vec[i - 1]: cont_vec.append(cont_vec[-1] + 1)
    else: cont_vec.append(cont_vec[-1])
    
    use_index = []
    Spos_list = [[], [], []]
    for i in range(N):
    for j in range(i + 1, N):
        if not i in res_vec and not j in res_vec: continue
        if i in mask_vec or j in mask_vec: continue
        if template_distance_matrix[i][j] < 10.0 and ((template_distance_matrix[i][j] < template_CAdistance_matrix[i][j]) or  template_angle_matrix[i][j] < 120.0) and template_distance_matrix[i][j] > 0.0:
        sub_vec = []
        sub_vec.append(i)
        sub_vec.append(j)
        use_index.append(sub_vec)

    Nuse = len(use_index)
    
    scountsL = []
    for i in range(Nuse):
    scountsL.append([])
    for j in range(20): scountsL[i].append(0)
    
    scountsR = []
    for i in range(Nuse):
    scountsR.append([])
    for j in range(20): scountsR[i].append(0)
    
    scountsL2 = []
    for i in range(Nuse):
        scountsL2.append([])
        for j in range(20): scountsL2[i].append(0)

    scountsR2 = []
    for i in range(Nuse):
        scountsR2.append([])
        for j in range(20): scountsR2[i].append(0)

    dcounts = []
    for i in range(Nuse):
    dcounts.append([])
    for j in range(20):
        dcounts[i].append([])
        for k in range(20): dcounts[i][j].append(0)
    
    count = 0
    for file in seqdata_list:
        print file
        count += 1
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb1')
        try: lib_pdbinfo_vec = pdb_info2(pdb_path, seqdata_path)
    except: continue
        lib_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    lib_CAdistance_matrix = distance_matrixCA(lib_pdbinfo_vec)
        try: lib_angle_matrix = angle_matrix(lib_pdbinfo_vec)
    except:
        print file
        continue
      
        libN = len(lib_pdbinfo_vec)
    
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][4] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][4] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]: lib_cont_vec.append(lib_cont_vec[-1] + 1)
        else: lib_cont_vec.append(lib_cont_vec[-1])
    
        lib_use_index = []
        for i in range(libN):
        for j in range(i + 1, libN):
        if lib_distance_matrix[i][j] < 10.0 and lib_distance_matrix[i][j] > 0.0 and ((lib_distance_matrix[i][j] < lib_CAdistance_matrix[i][j]) or lib_angle_matrix[i][j] < 120.0):
            sub_vec = []
            sub_vec.append(i)
            sub_vec.append(j)
            lib_use_index.append(sub_vec)
            
        libNuse = len(lib_use_index)
    for i in range(libNuse):
        libpos1 = lib_use_index[i][0]
        libpos2 = lib_use_index[i][1]
        libdistance = lib_distance_matrix[libpos1][libpos2]
        libangle = lib_angle_matrix[libpos1][libpos2]
        libsasa1 = lib_pdbinfo_vec[libpos1][5]
        libsasa2 = lib_pdbinfo_vec[libpos2][5]
        libcontinuous = (lib_cont_vec[libpos1] == lib_cont_vec[libpos2])
        for j in range(Nuse):
        pos1 = use_index[j][0]
        pos2 = use_index[j][1]
            distance = template_distance_matrix[pos1][pos2]
            angle = template_angle_matrix[pos1][pos2]
        sasa1 = pdbinfo_vec[pos1][6]
        sasa2 = pdbinfo_vec[pos2][6]
        continuous = (cont_vec[pos1] == cont_vec[pos2])
        
        cont_match = (libcontinuous and continuous) or (not libcontinuous and not continuous)
        
        try:
            libAA1 = int(lib_pdbinfo_vec[libpos1][1])
            libAA2 = int(lib_pdbinfo_vec[libpos2][1])
        except: continue
        if libAA1 < 0 or libAA2 < 0 or libAA1 > 19 or libAA2 > 19: continue
        
        if cont_match and lib_ss_vec[libpos1] == ss_vec[pos1] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10:
            scountsL[j][libAA1] += 1
        if cont_match and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            scountsR[j][libAA2] += 1
        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0:
            scountsL2[j][libAA1] += 1
            scountsR2[j][libAA2] += 1

        if cont_match and libdistance < distance + 0.5 and libdistance > distance - 0.5 and libangle < angle + 20.0 and libangle > angle - 20.0 and lib_ss_vec[libpos1] == ss_vec[pos1] and lib_ss_vec[libpos2] == ss_vec[pos2] and libsasa1 < sasa1 + 0.10 and libsasa1 > sasa1 - 0.10 and libsasa2 < sasa2 + 0.10 and libsasa2 > sasa2 - 0.10:
            dcounts[j][libAA1][libAA2] += 1
            
            if pos1 + 1 == 48 and pos2 + 1 == 149:
                print AAChar_fasta(libAA1), AAChar_fasta(libAA2)
                print distance, libdistance
                print angle, libangle
                print sasa1, libsasa1
                print sasa2, libsasa2
                print file, lib_pdbinfo_vec[libpos1][0], lib_pdbinfo_vec[libpos2][0]
                print
            
    if count % 100 == 0 or file == seqdata_list[-1]:
        print (float(count) / float(len(seqdata_list))) * 100.0, 'finished'
            
        for pos in range(Nuse):
          
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_Scounts.txt'), 'w')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t' + str(scountsL[pos][i]) + '\t' + str(scountsR[pos][i]) + '\t' + str(scountsL2[pos][i]) + '\t' + str(scountsR2[pos][i]) +'\n')
        counts_file.close()
         
            counts_file = open(os.path.join(preset_dir, str(use_index[pos][0] + 1) + '_' + str(use_index[pos][1] + 1) + '_counts.txt'), 'w')
            counts_file.write('AA\t')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
        counts_file.write('\n')
            for i in range(20):
            counts_file.write(AAChar_fasta(i) + '\t')
            for j in range(20):
            counts_file.write(str(dcounts[pos][i][j]) + '\t')
            counts_file.write('\n')
        counts_file.close()
        
def load_design_counts(counts_path, out_path):

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)
        
    probsL = []
    for i in range(20): probsL.append(0.0)
    probsR = []
    for i in range(20): probsR.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        
        for i in range(20):
        counts[line_idx][i] = int(items[i + 1])
        
    line_idx += 1
        
    total = 0
    dmax = 0
    for i in range(20):
    for j in range(20):
        total += counts[i][j]
        if counts[i][j] > dmax: dmax = counts[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probs[i][j] = float(counts[i][j]) / float(total)
        else: probs[i][j] = 0.0
    
    for i in range(20):
        totalL = 0
        for j in range(20): totalL += counts[i][j]
        probsL[i] = float(totalL) / float(total)
        
    for i in range(20):
        totalR = 0
        for j in range(20): totalR += counts[j][i]
        probsR[i] = float(totalR) / float(total)
    outfile = open(out_path, 'w')
    
    if total < 100: print counts_path
    
    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if total > 100:
            coupled_energy = 0.0
            normal_energy = 0.0
            if probsL[i] > 0.0 and probsR[j] > 0.0 and probs[i][j] > 0.0:
                coupled_prob = probs[i][j] / (probsL[i] * probsR[j])
                normal_prob = float(counts[i][j]) / float(dmax)
                #print AAChar_fasta(i), AAChar_fasta(j), probsL[i], probsR[j], probs[i][j], coupled_prob, normal_prob
                if normal_prob >= 0.05 and coupled_prob > 0.90: normal_energy = coupled_prob * math.log(1.05 - normal_prob)
                else: normal_energy = 0.0
                coupled_energy = -4.0 * math.log(coupled_prob)
                if coupled_energy < 0.0: coupled_energy = normal_prob * coupled_energy
            
                energy = coupled_energy + normal_energy
            else: energy = 4.6
        else: energy = 0.0
        outfile.write(str(energy)[0:min(6, len(str(energy)))] + '\t')
    outfile.write('\n')
    outfile.close()
    
def coyote_convert_counts(counts_dir, out_dir, ref_flag, ncalc, runp):
  
    sdir = os.path.join(counts_dir, 'convert_scripts')
    if not os.path.exists(sdir): os.mkdir(sdir)
    olist = os.listdir(out_dir)
    for file in olist:
        os.remove(os.path.join(out_dir, file))
       

    if not os.path.exists(out_dir): os.mkdir(out_dir)
    clist = os.listdir(counts_dir)
    v = []
    count = 0
    end = False
    for count_file in clist:
        if count_file == clist[-1]: end = True
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            v.append([os.path.join(counts_dir, count_file), os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')])
            if len(v) == ncalc or end:
            count += 1
            spath = os.path.join(sdir, 'T' + str(count) + '.sh')
            of = open(spath, 'w')
            of.write('#PBS -S /bin/sh\n')
            for i in range(len(v)): of.write(runp + ' -load_gen2_counts ' + v[i][0] + ' ' + v[i][1] + ' ' + ref_flag + '\n')
                of.close()
                os.system('chmod u+x ' + spath)
                os.system('qsub -q short ' + spath)
                v = []

def process_ipres():

    ip_res = []
    for i in range(20): ip_res.append(0)

    for i in range(97):
    ip_path = '/home/bartolo/web/statium_sidechain_wGly/ip/ip_res.txt_' + str(i + 1)
    data = lines2list(ip_path)
    for j in range(20): ip_res[j] += int(data[j][1])

    for j in range(20): print AAChar_fasta(j), ip_res[j]

def convert_counts_sidechain(preset):

    counts_dir = preset + '_coyote_counts'
    out_dir = preset
  
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    olist = os.listdir(out_dir)
    for file in olist:
        os.remove(os.path.join(out_dir, file))
        
    pdball_data = lines2list('/home/bartolo/web/statium_sidechain_wGly/single_counts_ip.txt')
    pdball_total = 0.0
    for i in range(20): pdball_total += pdball_data[i][1]
    pdballAA_probs = [0.0] * 20
    for i in range(20): pdballAA_probs[i] = pdball_data[i][1] / pdball_total
    
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            data = lines2list(counts_path)
    
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            data = lines2list(counts_path)
            total = 0
            for i in range(20): total += data[i][1]
            if total < 100: continue
            of = open(out_path, 'w')
            AA_probs = [0.0] * 20
            for i in range(20):
            c = data[i][1]
            if c == 0: c = 1
            AA_probs[i] = c / total
        for i in range(20):
            e = -1.0 * math.log(AA_probs[i] / pdballAA_probs[i])
            of.write(AAChar_fasta(i) + '\t' + str(e) + '\n')
        of.close()        
    
def convert_counts(counts_dir, out_dir, ref_flag):
  
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    olist = os.listdir(out_dir)
    for file in olist:
        os.remove(os.path.join(out_dir, file))
      
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            load_gen2_counts(counts_path, out_path, ref_flag)
            
    #statium_config(out_dir)

def load_gen2_counts(counts_path, out_path, ref_flag):
  
    opath = os.path.split(out_path)[0]
    seqint_path = opath + '.seqint'
    res_path = opath + '.res'
    
    res_vec = []
    data = lines2list(res_path)
    for i in range(len(data)): res_vec.append(int(data[i][0]))
    
    if ref_flag == 'B':
        aa_vec = []
        data = lines2list(seqint_path)
        for i in range(len(data)): aa_vec.append(int(data[i][0]))
  
    scounts = [[], []]
    sprobs = [[], []]
    for i in range(20):
        scounts[0].append(0)
        scounts[1].append(0)
        sprobs[0].append(0.0)
    sprobs[1].append(0.0)
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')
    #singles_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_S' + root_items[2])
    singles_path = '/home/bartolo/web/statium_noref/single_counts.txt'
    lines = readlines(singles_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
        scounts[0][AA] = int(items[1])
        #scounts[1][AA] = int(items[2])
        scounts[1][AA] = int(items[1])
        
    pos0 = int(root_items[0])
    pos1 = int(root_items[1])
    
    if ref_flag == 'B': AAL = aa_vec[pos0 - 1]
        
    ltot = 0
    rtot = 0
    for i in range(20):
        ltot += scounts[0][i]
        rtot += scounts[1][i]
    for i in range(20):
        sprobs[0][i] = float(scounts[0][i]) / float(ltot)
        sprobs[1][i] = float(scounts[1][i]) / float(rtot)

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)
        
    probsL = []
    for i in range(20): probsL.append(0.0)
    probsR = []
    for i in range(20): probsR.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        
        for i in range(20):
        counts[line_idx][i] = int(items[i + 1])
        
    line_idx += 1
        
    total = 0
    for i in range(20):
    for j in range(20):
        total += counts[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probs[i][j] = float(counts[i][j]) / float(total)
        else: probs[i][j] = 0.0
    
    for i in range(20):
        totalL = 0
        for j in range(20): totalL += counts[i][j]
    if total > 0: probsL[i] = float(totalL) / float(total)
        
    for i in range(20):
        totalR = 0
        for j in range(20): totalR += counts[j][i]
        if total > 0: probsR[i] = float(totalR) / float(total)
    
    if ref_flag == 'B':       
        btotal = 0
        for j in range(20): btotal += counts[AAL][j]
    
        bprobs = []
        for i in range(20): bprobs.append(0.0)
        for i in range(20):
            if btotal > 0: bprobs[i] = float(counts[AAL][i]) / float(btotal)
        
    if total < 500:
        print counts_path
        return
        
    penalty = 4.6
    outfile = open(out_path, 'w')
    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if ref_flag == 'N':
        if probs[i][j] > 0.0: energy = -1.0 * math.log(probs[i][j])
            else: energy = penalty
        elif ref_flag == 'X':
        if probs[i][j] > 0.0 and probsL[i] > 0.0 and probsR[j] > 0.0: energy = -1.0 * math.log(probs[i][j] / (probsL[i] * probsR[j]))
            else: energy = penalty
        elif ref_flag == 'B' and not pos0 in res_vec:
            if i == AAL:
            if bprobs[j] > 0.0 and sprobs[1][j] > 0.0: energy = -1.0 * math.log(bprobs[j] / (sprobs[1][j]))
            else: energy = penalty
            else: energy = penalty
        else:
        if probs[i][j] > 0.0 and sprobs[0][i] > 0.0 and sprobs[1][j] > 0.0: energy = -1.0 * math.log(probs[i][j] / (sprobs[0][i] * sprobs[1][j]))
            else: energy = penalty
        
        outfile.write(str(energy) + '\t')
    outfile.write('\n')
    outfile.close()

def convert_counts_intra(preset):

    counts_dir = preset + '_coyote_counts'
    out_dir = preset
  
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    olist = os.listdir(out_dir)
    for file in olist:
        os.remove(os.path.join(out_dir, file))
      
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[3] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_' + items[2] + '_probs.txt')
            load_matrix_counts(counts_path, out_path, 2)
            
    #statium_config(out_dir)

def convert_counts_local(preset):

    counts_dir = preset + '_coyote_counts'
    out_dir = preset

    if not os.path.exists(out_dir): os.mkdir(out_dir)
    olist = os.listdir(out_dir)
    for file in olist:
        os.remove(os.path.join(out_dir, file))

    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
            if items[2] == 'counts.txt':
                counts_path = os.path.join(counts_dir, count_file)
                out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
                load_matrix_counts(counts_path, out_path)

def load_matrix_counts(counts_path, out_path):

    opath = os.path.split(out_path)[0]
    
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')

    scounts = [[], []]
    sprobs = [[], []]
    for i in range(20):
        scounts[0].append(0)
        scounts[1].append(0)
        sprobs[0].append(0.0)
    sprobs[1].append(0.0)

    singles_path = '/home/bartolo/web/statium_noref/single_counts.txt'
    singles2_path = '/home/bartolo/web/statium_local/helix_AAprobs.txt'
    lines = readlines(singles_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
    count = int(items[1])
    if items[0] == 'G': count = 0
        scounts[0][AA] = count

    lines = readlines(singles2_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
    count = int(items[1])
    if items[0] == 'G': count = 0
        scounts[1][AA] = count

    ltot = 0
    rtot = 0
    for i in range(20):
        ltot += scounts[0][i]
        rtot += scounts[1][i]
    for i in range(20):
        sprobs[0][i] = float(scounts[0][i]) / float(ltot)
        sprobs[1][i] = float(scounts[1][i]) / float(rtot)
        
    pos0 = int(root_items[0])
    pos1 = int(root_items[1])

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)

    probsL = []
    for i in range(20): probsL.append(0.0)
    probsR = []
    for i in range(20): probsR.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        
        for i in range(20):
        c = int(items[i + 1])
        if c == 0: c = 1
        counts[line_idx][i] = c
        
    line_idx += 1
        
    total = 0
    for i in range(20):
    for j in range(20):
        total += counts[i][j]
    for i in range(20):
    for j in range(20): probs[i][j] = float(counts[i][j]) / float(total)
        
    if total < 500:
        print counts_path
        return

    for i in range(20):
        totalL = 0
        for j in range(20): totalL += counts[i][j]
    if total > 0: probsL[i] = float(totalL) / float(total)
        
    for i in range(20):
        totalR = 0
        for j in range(20): totalR += counts[j][i]
        if total > 0: probsR[i] = float(totalR) / float(total)
        
    outfile = open(out_path, 'w')
    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if AAChar_fasta(i) == 'G' or AAChar_fasta(j) == 'G': energy = 4.6 
        else: energy = -1.0 * math.log(probs[i][j] / (sprobs[0][i] * sprobs[0][j])) - 1.0 * math.log(probs[i][j] / (probsL[i] * probsR[j])) - 1.0 * math.log(probs[i][j] / (sprobs[1][i] * sprobs[1][j]))

        outfile.write(str(round(energy, 3)) + '\t')
    outfile.write('\n')
    outfile.close()
    
def convert_countst(counts_dir, out_dir, ref_flag):

    if not os.path.exists(out_dir): os.mkdir(out_dir)
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 3:
        if items[3] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_' + items[2] + '_probs.txt')
            load_gen2_countst(counts_path, out_path, ref_flag)

def load_gen2_countst(counts_path, out_path, ref_flag):
  
    scounts = [[], [], []]
    sprobs = [[], [], []]
    for i in range(20):
        scounts[0].append(0)
        scounts[1].append(0)
        scounts[2].append(0)
        sprobs[0].append(0.0)
    sprobs[1].append(0.0)
    sprobs[2].append(0.0)
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')
    singles_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_' + root_items[2] + '_S' + root_items[3])
    lines = readlines(singles_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
        scounts[0][AA] = int(items[1])
        scounts[1][AA] = int(items[2])
        scounts[2][AA] = int(items[3])
        
    pos0 = int(root_items[0])
    pos1 = int(root_items[1])
    pos2 = int(root_items[2])
        
    tot1 = 0
    tot2 = 0
    tot3 = 0
    for i in range(20):
        tot1 += scounts[0][i]
        tot2 += scounts[1][i]
        tot3 += scounts[2][i]
    for i in range(20):
        sprobs[0][i] = float(scounts[0][i]) / float(tot1)
        sprobs[1][i] = float(scounts[1][i]) / float(tot2)
        sprobs[2][i] = float(scounts[2][i]) / float(tot3)

    counts = []
    for i in range(20):
        for j in range(20):
      for k in range(20): counts.append(0)
        
    probs = []
    for i in range(20):
        for j in range(20):
      for k in range(20): probs.append(0.0)
        
    probs1 = []
    for i in range(20): probs1.append(0.0)
    probs2 = []
    for i in range(20): probs2.append(0.0)
    probs3 = []
    for i in range(20): probs3.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        count = int(line.strip())
        counts[line_idx] = count
    line_idx += 1
        
    total = 0
    for i in range(len(counts)): total += counts[i]
    for i in range(len(counts)):
        if total > 0: probs[i] = float(counts[i]) / float(total)
    else: probs[i] = 0.0

    print total
    print counts_path
    outfile = open(out_path, 'w')
    
    if total < 500:
        for i in range(20):
        for j in range(20):
            for k in range(20): outfile.write(AAChar_fasta(i) + AAChar_fasta(j) + AAChar_fasta(k) + '\t' + str(0.0) + '\n')

    else:
        tab = 0
        for i in range(20):
        for j in range(20):
            for k in range(20):
            
                    if ref_flag == 'N':
                    if probs[tab] > 0.0: energy = -1.0 * math.log(probs[tab])
                    else: energy = 4.6
                else:
                if probs[tab] > 0.0 and sprobs[0][i] > 0.0 and sprobs[1][j] > 0.0 and sprobs[2][k] > 0.0:
                    energy = -1.0 * math.log(probs[tab] / (sprobs[0][i] * sprobs[1][j] * sprobs[2][k]))
                    else: energy = 4.6
                tab += 1
                outfile.write(AAChar_fasta(i) + AAChar_fasta(j) + AAChar_fasta(k) + '\t' + str(energy) + '\n')
                
    outfile.close()
    
def statium_bind_conversion(preset_dir, counts_dir, out_dir):

    if not os.path.exists(out_dir): os.mkdir(out_dir)
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            statium_convert(preset_dir, counts_path, out_path)

def statium_convert(preset_dir, counts_path, out_path):
  
    AA_vec = []
    seq_path = os.path.join(os.path.split(preset_dir)[0], os.path.split(preset_dir)[1] + '.seq')
    seq_data = lines2list(seq_path)
    for i in range(len(seq_data)): AA_vec.append(AACode(seq_data[i][2]))
  
    scounts = [[], [], [], []]
    sprobs = [[], [], [], []]
    for i in range(20):
        scounts[0].append(0)
        scounts[1].append(0)
    scounts[2].append(0)
    scounts[3].append(0)
        sprobs[0].append(0.0)
    sprobs[1].append(0.0)
    sprobs[2].append(0.0)
    sprobs[3].append(0.0)
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')
    singles_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_S' + root_items[2])
    lines = readlines(singles_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
        scounts[0][AA] = int(items[1])
        scounts[1][AA] = int(items[2])
    scounts[2][AA] = int(items[3])
    scounts[3][AA] = int(items[4])
        
    pos0 = int(root_items[0])
    pos1 = int(root_items[1])
    
    AAL = AA_vec[int(root_items[0]) - 1]
        
    ltot = 0
    rtot = 0
    l2tot = 0
    r2tot = 0
    for i in range(20):
        ltot += scounts[0][i]
        rtot += scounts[1][i]
    l2tot += scounts[2][i]
    r2tot += scounts[3][i]
    for i in range(20):
        sprobs[0][i] = float(scounts[0][i]) / float(ltot)
        sprobs[1][i] = float(scounts[1][i]) / float(rtot)
    sprobs[2][i] = float(scounts[2][i]) / float(l2tot)
    sprobs[3][i] = float(scounts[3][i]) / float(r2tot)

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)
        
    probsL = []
    for i in range(20): probsL.append(0.0)
    probsR = []
    for i in range(20): probsR.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        
        for i in range(20):
        counts[line_idx][i] = int(items[i + 1])
        
    line_idx += 1
        
    total = 0
    for i in range(20): total += counts[AAL][i]
    for i in range(20):
    if total > 0: probs[AAL][i] = float(counts[AAL][i]) / float(total)
    else: probs[AAL][i] = 0.0
    
    for i in range(20):
        totalL = 0
        for j in range(20): totalL += counts[i][j]
    if total > 0: probsL[i] = float(totalL) / float(total)
        
    for i in range(20):
        totalR = 0
        for j in range(20): totalR += counts[j][i]
        if total > 0: probsR[i] = float(totalR) / float(total)
    outfile = open(out_path, 'w')
    
    if total < 100: print counts_path
    coupled_prob = 0.0

    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if total > 100:
        if probs[i][j] > 0.0 and probs[i] > 0.0 and probsR[j] > 0.0 and sprobs[0][i] > 0.0 and sprobs[1][j] > 0.0:
            energy = -1.0 * math.log(probs[i][j] / (sprobs[1][j]))
            else: energy = 0.0
        else: energy = 0.0
        
        outfile.write(str(energy) + '\t')
    outfile.write('\n')
    outfile.close()
    
def BimRef(counts_dir, out_dir, seq_path):
  
    AA = []
    seq_lines = readlines(seq_path)
    for line in seq_lines:
        items = line.split()
        AA.append(AAChar_int(AAConvertTS(items[2])))

    if not os.path.exists(out_dir): os.mkdir(out_dir)
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'counts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            bim_ref_counts(counts_path, out_path, AA)

def bim_ref_counts(counts_path, out_path, AAv):
  
    scounts = [[], [], [], []]
    sprobs = [[], [], [], []]
    for i in range(20):
        scounts[0].append(0)
        scounts[1].append(0)
    scounts[2].append(0)
    scounts[3].append(0)
        sprobs[0].append(0.0)
    sprobs[1].append(0.0)
    sprobs[2].append(0.0)
    sprobs[3].append(0.0)
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')
    singles_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_S' + root_items[2])
    lines = readlines(singles_path)
    for i in range(len(lines)):
        items = lines[i].split()
        AA = AAChar_int(items[0])
        scounts[0][AA] = int(items[1])
        scounts[1][AA] = int(items[2])
    scounts[2][AA] = int(items[3])
    scounts[3][AA] = int(items[4])
        
    pos0 = int(root_items[0])
    pos1 = int(root_items[1])
    
    bim_aa0 = AAv[pos0 - 1]
    bim_aa1 = AAv[pos1 - 1]
        
    ltot = 0
    rtot = 0
    l2tot = 0
    r2tot = 0
    for i in range(20):
        ltot += scounts[0][i]
        rtot += scounts[1][i]
    l2tot += scounts[2][i]
    r2tot += scounts[3][i]
    for i in range(20):
        sprobs[0][i] = float(scounts[0][i]) / float(ltot)
        sprobs[1][i] = float(scounts[1][i]) / float(rtot)
    sprobs[2][i] = float(scounts[2][i]) / float(l2tot)
    sprobs[3][i] = float(scounts[3][i]) / float(r2tot)

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)
        
    probsL = []
    for i in range(20): probsL.append(0.0)
    probsR = []
    for i in range(20): probsR.append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        
        for i in range(20):
        counts[line_idx][i] = int(items[i + 1])
        
    line_idx += 1
        
    total = 0
    dmax = 0
    for i in range(20):
    for j in range(20):
        total += counts[i][j]
        if counts[i][j] > dmax: dmax = counts[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probs[i][j] = float(counts[i][j]) / float(total)
        else: probs[i][j] = 0.0
    
    for i in range(20):
        totalL = 0
        for j in range(20): totalL += counts[i][j]
    if total > 0: probsL[i] = float(totalL) / float(total)
        
    for i in range(20):
        totalR = 0
        for j in range(20): totalR += counts[j][i]
        if total > 0: probsR[i] = float(totalR) / float(total)
    outfile = open(out_path, 'w')
    
    if total < 500: print counts_path
    coupled_prob = 0.0

    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if total > 500:
        if probs[i][j] > 0.0 and probs[bim_aa0][bim_aa1] > 0.0:
            energy = -1.0 * math.log(probs[i][j] / probs[bim_aa0][bim_aa1])
            else:
            coupled_prob = 0.0
            energy = 4.6
        else: energy = 0.0
        
        outfile.write(str(energy) + '\t')
    outfile.write('\n')
    outfile.close()
    
def convert_statium(counts_dir, out_dir):
 
    if not os.path.exists(out_dir): os.mkdir(out_dir)
    clist = os.listdir(counts_dir)
    for count_file in clist:
        items = count_file.split('_')
        if len(items) > 2:
        if items[2] == 'Dcounts.txt':
            counts_path = os.path.join(counts_dir, count_file)
            out_path = os.path.join(out_dir, items[0] + '_' + items[1] + '_probs.txt')
            load_statium_counts(counts_path, out_path)

def load_statium_counts(counts_path, out_path):
  
    root = os.path.split(counts_path)[0]
    name = os.path.split(counts_path)[1]
    root_items = name.split('_')
    countsR1_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_R1' + root_items[2][1:len(root_items[2])])
    countsR2_path = os.path.join(root, root_items[0] + '_' + root_items[1] + '_R2' + root_items[2][1:len(root_items[2])])

    counts = []
    for i in range(20):
        counts.append([])
        for j in range(20): counts[i].append(0)
        
    countsR1 = []
    for i in range(20):
        countsR1.append([])
        for j in range(20): countsR1[i].append(0)
        
    countsR2 = []
    for i in range(20):
        countsR2.append([])
        for j in range(20): countsR2[i].append(0)
        
    probs = []
    for i in range(20):
        probs.append([])
        for j in range(20): probs[i].append(0.0)
        
    probsR1 = []
    for i in range(20):
        probsR1.append([])
        for j in range(20): probsR1[i].append(0.0)
        
    probsR2 = []
    for i in range(20):
        probsR2.append([])
        for j in range(20): probsR2[i].append(0.0)
        
    lines = readlines(counts_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        for i in range(20):
        counts[line_idx][i] = int(items[i + 1])
    line_idx += 1
    
    lines = readlines(countsR1_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        for i in range(20):
        countsR1[line_idx][i] = int(items[i + 1])
    line_idx += 1
    
    lines = readlines(countsR2_path)
    line_idx = 0
    for line in lines:
        items = line.split()
        try: int(items[1])
        except: continue
        for i in range(20):
        countsR2[line_idx][i] = int(items[i + 1])
    line_idx += 1
        
    total = 0
    dmax = 0
    for i in range(20):
    for j in range(20):
        total += counts[i][j]
        if counts[i][j] > dmax: dmax = counts[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probs[i][j] = float(counts[i][j]) / float(total)
        else: probs[i][j] = 0.0
        
    total = 0
    for i in range(20):
    for j in range(20):
        total += countsR1[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probsR1[i][j] = float(countsR1[i][j]) / float(total)
        else: probsR1[i][j] = 0.0
        
    total = 0
    for i in range(20):
    for j in range(20):
        total += countsR2[i][j]
    for i in range(20):
    for j in range(20):
        if total > 0: probsR2[i][j] = float(countsR2[i][j]) / float(total)
        else: probsR2[i][j] = 0.0
    
    outfile = open(out_path, 'w')
    
    if total < 500: print counts_path
    coupled_prob = 0.0

    outfile.write('AA\t')
    for i in range(20): outfile.write(AAChar_fasta(i) + '\t')
    outfile.write('\n')
    for i in range(20):
        outfile.write(AAChar_fasta(i) + '\t')
        for j in range(20):
        if total > 500:
        if probs[i][j] > 0.0 and probsR1[i][j] > 0.0:
            energy = -0.0 * math.log(probs[i][j] / probsR1[i][j])
            energy += -1.0 * math.log(probs[i][j] / probsR2[i][j])
            normal_prob = float(counts[i][j]) / float(dmax)
                if energy < 0.0: energy = normal_prob * energy
                else: energy = (1 - normal_prob) * energy
            else:
            coupled_prob = 0.0
            energy = 4.6
        else: energy = 0.0
        
        outfile.write(str(energy)[0:min(5, len(str(energy)))] + '\t')
    outfile.write('\n')
    outfile.close()

def ave_composition(matrix_path):

    matrix_lines = readlines(matrix_path)
    
    dipep = ['WM', 'WH', 'WN', 'WL', 'CW', 'CM', 'CH', 'CD', 'CP', 'CT', 'CL', 'MH', 'MY', 'MP', 'MS', 'MA', 'HY', 'HN', 'HI', 'HK', 'YM', 'YH', 'YD', 'YP', 'YA', 'FY', 'FD', 'FP', 'QQ', 'QD', 'QP', 'QE', 'QS', 'NI', 'NK', 'IH', 'IE', 'IL', 'RW', 'RH', 'RQ', 'RN', 'RR', 'RP', 'RS', 'DS', 'PF', 'PQ', 'PP', 'PE', 'PS', 'PV', 'PA', 'TF', 'TE', 'KM', 'KQ', 'KR', 'EC', 'EQ', 'EI', 'ED', 'EP', 'EE', 'ES', 'VP', 'SC', 'SQ', 'SR', 'SP', 'SE', 'SS', 'GW', 'GG', 'AC', 'AP', 'LW', 'LQ', 'LR', 'LP']
    
    comp = []
    for i in range(20): comp.append(0.0)
    tot = 0
    charge = 0
    
    for line in matrix_lines:
    L = 0
    compi = []
    for i in range(20): compi.append(0)
    for i in range(len(line)):
            if AAChar_int(line[i]) < 20:
        L += 1
        compi[AAChar_int(line[i])] += 1
    pp = 0
    for i in range(len(line) - 1):
            if AAChar_int(line[i]) < 20 and AAChar_int(line[i + 1]) < 20:
        if line[i] + line[i + 1] in dipep: pp += 1
    
    
    if L > 65:
        print pp
        chargei = compi[AAChar_int('R')] + compi[AAChar_int('K')] - compi[AAChar_int('E')] - compi[AAChar_int('D')]
        #if chargei > 0: print chargei
        charge += chargei
        tot += 1
        for i in range(20):
        comp[i] += float(compi[i]) / float(L)
        #print
        #print tot    
            #for i in range(20):
        #print AAChar_fasta(i), float(comp[i]) / float(tot)
        
def parse_data(path1, path2):

    lines = readlines(path1)

    file = open(path2, 'w')

    for i in range(1, len(lines)):
        line = lines[i].split()
    file.write(line[1] + '\t' + line[2] + '\t' + line[3] + '\t' + line[4] + '\n')
    file.close()

def cluster_sequences(data_path):

    data_lines = readlines(data_path)
    L = len(data_lines)

    wt = data_lines[1].split()[0]
    N = len(wt) - 1

    print wt

    for i in range(L):
        
    var = 0
    for j in range(N):
        if data_lines[i].split()[0][j] != wt[j]: var += 1
    print var

def coyote_job(cmd_str, name):

    job_dir = '/home/bartolo/web/jobs'
    job_path = os.path.join(job_dir, name + '.pbs')
    
    pbs_str = '#!/bin/bash\n#PBS -l nodes=1:ppn=1\n#PBS -q speedy\n#PBS -l cput=10:00\n#PBS -j oe\n#PBS -m n\n\n'
    write_file(pbs_str + cmd_str, job_path)
    currdir = os.getcwd()
    os.chdir(job_dir)
    os.system('qsub ' + job_path)
    os.chdir(currdir)
    
def DFIRE(pdb_path):
    currdir = os.getcwd()
    os.chdir('/home/bartolo/web/dDFIRE3')
    tmp_path = coyote_temp('.txt')
    os.system('./score ' + pdb_path + ' > ' + tmp_path)
    lines = readlines(tmp_path)
    energy = float(lines[-1].split()[-5])
    os.remove(tmp_path)
    os.chdir(currdir)
    return energy
    
def name_yeast(f1, f2):
  
    lines = readlines(f1)
    out = open(f2, 'w')
    count = 0
    for line in lines:
        count += 1
        out.write(line.strip() + '\t' + str(count) + '\n')
    out.close()
    
def yeast_dir(d, o):
    l = os.listdir(d)
    o = open(o, 'w')
    for f in l:
        p = os.path.join(d, f)
        o.write(p + '\n')
    o.close()

def dfire_yeast_nmf(mm, mb, bm, bb):

    bwte = -2.978
    mwte = -3.301

    mml = lines2list(mm)
    mmln = len(mml)
    mme = []
    for i in range(mmln): mme.append(0.0)
    for i in range(mmln):
    mmp = mml[i][0]
    print mmp
    mmei = mml[i][1]
    idx = int(mmp.split('_')[-1].split('.')[0]) - 1
    mme[idx] = mmei - mwte

    mbl = lines2list(mb)
    mbln = len(mbl)
    mbe = []
    for i in range(mbln): mbe.append(0.0)
    for i in range(mbln):
        mbp = mbl[i][0]
        mbei = mbl[i][1]
        idx = int(mbp.split('_')[-1].split('.')[0]) - 1
        mbe[idx] = mbei - bwte

    bml = lines2list(bm)
    bmln = len(bml)
    bme = []
    for i in range(bmln): bme.append(0.0)
    for i in range(bmln):
        bmp = bml[i][0]
        bmei = bml[i][1]
        idx = int(bmp.split('_')[-1].split('.')[0]) - 1
        bme[idx] = bmei - mwte

    bbl = lines2list(bb)
    bbln = len(bbl)
    bbe = []
    for i in range(bbln): bbe.append(0.0)
    for i in range(bbln):
        bbp = bbl[i][0]
        bbei = bbl[i][1]
        idx = int(bbp.split('_')[-1].split('.')[0]) - 1
        bbe[idx] = bbei - bwte

    mes = []
    bes = []
    for i in range(mmln):
        mes.append(mbe[i] - mme[i])
    for i in range(bmln):
        bes.append(bbe[i] - bme[i])

    import matplotlib
    matplotlib.use( 'Agg' )

    import pylab
    ma = pylab.array(mes)
    ba = pylab.array(bes)
    pylab.hist(ma, normed=1, facecolor='blue', alpha=0.45)
    pylab.hist(ba, normed=1, facecolor='red', alpha=0.45)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.savefig('/home/bartolo/web/tmperw/sanjib_dfire_nmf.png')
    pylab.close()

def dfire_yeast(mm, mb, bm, bb):
  
    bwt = '/home/bartolo/web/full_house2/bclxl/bclxl_3io8.pdb'
    mwt = '/home/bartolo/web/full_house2/mcl1/mcl1_2pqk.pdb'
    
    bwte = DFIRE(bwt)
    mwte = DFIRE(mwt)
  
    ml = os.listdir(mm)
    bl = os.listdir(bm)
    
    mes = []
    bes = []
    count = 0
    for i in range(len(ml)):
        count += 1
        m1 = os.path.join(mm, 'yeast_mcl1_spec_' + str(count) + '.pdb')
        m2 = os.path.join(mb, 'yeast_mcl1_spec_' + str(count) + '.pdb')
        mes.append(DFIRE(m2) - bwte - DFIRE(m1) - mwte)
    count = 0
    for i in range(len(bl)):
        count += 1
        b1 = os.path.join(bm, 'yeast_bclxl_spec_' + str(count) + '.pdb')
        b2 = os.path.join(bb, 'yeast_bclxl_spec_' + str(count) + '.pdb')
        bes.append(DFIRE(b2) - bwte - DFIRE(b1) - mwte)
        
    import pylab
    ma = pylab.array(mes)
    ba = pylab.array(bes)
    pylab.hist(ma, normed=1, facecolor='blue', alpha=0.45)
    pylab.hist(ba, normed=1, facecolor='red', alpha=0.45)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.savefig('/home/bartolo/web/tmperw/sanjib_dfire.png')
    pylab.close()     
        
def model_bcl2(wt_pdb_path, res_path, data_path):

    models_dir = os.path.join(os.path.split(wt_pdb_path)[0], os.path.split(data_path)[1].split('.')[0] + '_models')
    if not os.path.exists(models_dir): os.mkdir(models_dir)
    data_name = os.path.split(data_path)[1].split('.')[0]
    
    res_vec = []
    res_lines = readlines(res_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    chain_break = -1
    cfg_lines = readlines(res_path.split('.')[0] + '.cfg')
    for line in cfg_lines:
        if line.split('=')[0] == 'CHAIN_BREAK': chain_break = int(line.split('=')[1])
        
    line = readline(res_path.split('.')[0] + '.cfg', 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]

    data_vec = []
    data_lines = readlines(data_path)
    for line in data_lines:
        items = line.split()
        dv = []
        dv.append(items[0])
    dv.append(items[1])
    data_vec.append(dv)

    for i in range(len(data_vec)):
    bim_seq = data_vec[i][0]
    name = data_vec[i][1]

        sequence = FASTA_from_structure(wt_pdb_path)
    mut_sequence = ''
    for j in range(len(sequence)):
        if j in res_vec:
            mut_sequence += bim_seq[j - seq_ref[0] + seq_ref[1]]
        else: mut_sequence += sequence[j]

    mut_fasta_path = os.path.join('/home/bartolo/tmp', str(random.randint(0, 100000)) + '.fasta')
    write_file('> seq\n' + mut_sequence, mut_fasta_path)
    tmp_mut_pdb_path = coyote_temp('.pdb')
    mut_pdb_path = os.path.join(models_dir, data_name + '_' + name + '.pdb')
    if os.path.exists(mut_pdb_path):
        if len(readlines(mut_pdb_path)) > 0: continue
    cmd_str = '/home/bartolo/web/build.py -automodel ' + mut_fasta_path + ' ' + wt_pdb_path + ' ' + tmp_mut_pdb_path + ' ' + str(chain_break) + '\n/home/bartolo/web/build.py -renumberAB ' + tmp_mut_pdb_path + ' ' + mut_pdb_path + ' ' + str(chain_break) + '\nrm ' + mut_fasta_path + ' ' + tmp_mut_pdb_path
    coyote_job(cmd_str, 'model_' + data_name + '_' + name)
    
def random_string():
   
    alphabet = 'abcdefghijklmnopqrstuvwxyz'
    L = 10
    string = ''

    for count in range(L):
        string += alphabet[random.randint(0, 25)]
        
    return string
    
def coyote_temp(extension):
    
    if extension == 'dir':
        dir_path = os.path.join('/home/bartolo/tmp', random_string())
        os.mkdir(dir_path)
        return dir_path
    return os.path.join('/home/bartolo/tmp', random_string() + extension)
        
def SPOT_analysis(preset_dir, template_pdb_path, template_seqdata_path, residue_path, data_path, out_path, data_ref):

    CALC_BURIAL = True
    if out_path[-3] + out_path[-2] + out_path[-1] == '360': data360 = True
    else: data360 = False

    import matplotlib
    matplotlib.use( 'Agg' )
    
    models_dir = out_path + '_models'
    model_label = os.path.split(out_path)[1]

    data_lines = readlines(data_path)
    data_vec = []
    for i in range(len(data_lines) - 1):
        line = data_lines[i].split()
    data = []
    for j in range(len(line)):
        data.append(line[j])
    data_vec.append(data)
    
    calc_burial = False
    data_out_path = out_path + '_burial.txt'
    data_out_vec = []
    if os.path.exists(data_out_path):
        data_out_lines = readlines(data_out_path)
        for line in data_out_lines:
        data = []
        items = line.split()
        for j in range(len(items)):
            data.append(items[j])
        data_out_vec.append(data)
    else: calc_burial = True
    
    print len(data_out_vec)

    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    N = len(pdbinfo_vec)
    preset_list = os.listdir(preset_dir)
    
    pair_list = []
    pair_labels = []
    
    for file in preset_list:
    file_path = os.path.join(preset_dir, file)
    if len(file.split('_')) == 3:
        if file[-10] == 'L':
            lines = readlines(file_path)
        pair_pos = []
        for i in range(1, len(lines)):
            line = lines[i].split()
            pair = []
            for j in range(1, len(line)): pair.append(float(line[j]))
            pair_pos.append(pair)
        pair_list.append(pair_pos)
        pair_labels.append([int(file.split('_')[0]) - 1, int(file.split('_')[1]) - 1])
    
    psamp = []
    for i in range(N):
    psamp.append([])
    for i in range(len(pair_list)):
    pos1 = pair_labels[i][0]
    pos2 = pair_labels[i][1]
    psamp[pos1].append(i)
    psamp[pos2].append(i)
    
    if data360:
    
        e_permute = []
        e_permuteR = []
        idx = 0
        for i in 'RD':
            for j in 'DNX':
            for k in 'NX':
                eperm = i + j + k
                e_permute.append([eperm, idx])
                e_permuteR.append([idx, eperm])
                idx += 1
        Nperm = idx
        perm_dict = dict(e_permute)
        perm_dictR = dict(e_permuteR)
    
        perm_vec = []
        for i in range(Nperm):
            perm_vec.append([])
            for j in range(7): perm_vec[i].append([])

    energy_vec = []
    signal_vec = []
    seq_vec = []
    name_vec = []
    burial_vec = []


    wt = data_vec[0][0]

    #seq_ref = 141
    #seq_ref = 136
    seq_ref = res_vec[0] - 6
    wts = 0.0
    wt_energy = 0.0
    wt_signal = 0.0
    for i in range(len(data_vec)):
        seq = data_vec[i][0]
    signal = float(data_vec[i][data_ref])
    name = data_vec[i][1]

    skip = False
    
    if not data360:
          for j in range(len(seq)):
            if seq[j] == 'G' and wt[j] != 'G':
                skip = True
            break
            if wt[j] == 'G' and seq[j] != 'G':
                skip = True
              break
     #   if wt[j] == 'D' and seq[j] != 'D':
      #      skip = True
     #    break

        #phob = ['A', 'F', 'I', 'L', 'V', 'W', 'Y']
        #for j in range(len(wt)):
         #   if wt[j] != seq[j] and not seq[j] in phob: skip = True

    #if (seq[11] != 'R' or seq[13] != 'D' or seq[17] != 'N') and i != 0: skip = True

    if skip: continue
        
    energy = 0.0
        for j in range(len(pair_list)):
        pos0 = pair_labels[j][0]
        pos1 = pair_labels[j][1]
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref])
        else: aa1 = pdbinfo_vec[pos1][1]
            
        e = pair_list[j][aa0][aa1]
        if charge_pair(aa0, aa1): e = e * 30.0
        energy += e
    if seq == wt:
        wts += 1.0
        wt_signal += signal
        wt_energy += energy
       
    if CALC_BURIAL:
        if calc_burial: bury_term = buried_apolar_SA(os.path.join(models_dir, model_label + '_' + data_vec[i][1] + '.pdb'), residue_path)
        else:
            found = False
            for j in range(len(data_out_vec)):
            if data_out_vec[j][1] == name:
                    bury_term = float(data_out_vec[j][4])
                    found = True
                    break
            if not found: bury_term = 0.0
    else: bury_term = 0.0
    
    if data360:
        
        permvar1 = seq[11] + seq[13] + seq[17]
        permvar2 = ''
        for k in range(3):
            if not permvar1[k] in 'RDN': permvar2 += 'X'
            else: permvar2 += permvar1[k]
        permidx = perm_dict[permvar2]
    
        perm_vec[permidx][0].append(energy)
        perm_vec[permidx][1].append(signal)
        perm_vec[permidx][2].append(seq)
        perm_vec[permidx][3].append(data_vec[i][1])
        perm_vec[permidx][4].append(bury_term)
        
        energy_vec.append(energy)
    signal_vec.append(signal)
    seq_vec.append(seq)
    name_vec.append(data_vec[i][1])
    burial_vec.append(bury_term)


    wt_energy = wt_energy / wts
    wt_signal = wt_signal / wts

    ddenergy_vec = []
    ddsignal_vec = []
    pos = 0
    neg = 0
    for i in range(len(energy_vec)):
        
        ddg = energy_vec[i] - wt_energy + (20.0 * (burial_vec[i] - burial_vec[0]))
    if ddg < 0.000000000001 and ddg > -0.00000000001: ddg = 0.0
    ddsig = -1.0 * math.log10(signal_vec[i] / wt_signal)
    ddenergy_vec.append(ddg)
    ddsignal_vec.append(ddsig)
    
    if ddsig <= 0.5: pos += 1
    else: neg += 1
    
    if data360:
        seq = seq_vec[i]
        permvar1 = seq[11] + seq[13] + seq[17]
        permvar2 = ''
        for k in range(3):
            if not permvar1[k] in 'RDN': permvar2 += 'X'
            else: permvar2 += permvar1[k]
        permidx = perm_dict[permvar2]
    
        perm_vec[permidx][5].append(ddg)
        perm_vec[permidx][6].append(ddsig)
    
    if data360: print pos, neg, float(neg) / (float(neg) + float(pos))
    
    
    import pylab
    energy_array = pylab.array(ddenergy_vec)
    signal_array = pylab.array(ddsignal_vec)

    totalR = str(pylab.corrcoef(energy_array, signal_array)[0][1])
    print totalR


    out_file = open(out_path + '.txt', 'w')
    for i in range(len(seq_vec)):
      
    out_file.write(str(seq_vec[i]) +'\t' + str(name_vec[i]) + '\t' + str(energy_array[i])[0:7] + '\t' + str(signal_array[i])[0:7] + '\t' + str(burial_vec[i] - burial_vec[0]))
    out_file.write('\n')
    out_file.close()

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    sub_energy = []
    sub_signal = []
    sub_energy2 = []
    sub_signal2 = []
    for i in range(len(seq_vec)):
      
        use = False
        use2 = False
    phob = ['A', 'F', 'I', 'L', 'V', 'W', 'Y']
    chargy = ['H', 'N', 'P', 'Q', 'S', 'T']
    
    for j in range(len(wt)):
        if wt[j] != seq_vec[i][j] and seq_vec[i][j] in phob and wt[j] in phob: use = True
        #if wt[j] != seq_vec[i][j] and seq_vec[i][j] in chargy and wt[j] in chargy: use2 = True
    if use:
        sub_energy.append(ddenergy_vec[i])
        sub_signal.append(ddsignal_vec[i])
    #if use2:
     #   sub_energy2.append(ddenergy_vec[i])
      #  sub_signal2.append(ddsignal_vec[i])

    sub_earray = pylab.array(sub_energy)
    sub_sarray = pylab.array(sub_signal)
    #sub_earray2 = pylab.array(sub_energy2)
    #sub_sarray2 = pylab.array(sub_signal2)
    
    sub_line = stats.linregress(sub_earray, sub_sarray)
    print sub_line
    print str(pylab.corrcoef(sub_earray, sub_sarray)[0][1])
    #print str(pylab.corrcoef(sub_earray2, sub_sarray2)[0][1])
    subplot = True
    if subplot:
        pylab.scatter(sub_earray, sub_sarray, c = 'r', label = 'AFILVWY')
        #pylab.scatter(sub_earray2, sub_sarray2, c = 'b', label = 'HNPQST')
    else: pylab.scatter(energy_array, signal_array)
        
    pylab.legend(loc='lower right', labelspacing=0.1)

    #pylab.xlim(-10, 200)
    pylab.xlim(-10, 50)
    pylab.ylim(-0.75, 1.75)
    pylab.savefig(out_path + '.png')
    pylab.close()
    
    if not data360: return
    
    import pylab

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    #pylab.colormap(pylab.hsv(128))
    
    color_str = color_string()
    names = os.path.split(out_path)[1].split('_')
    pdbid = names[0]
    ligand = names[1]
    
    TP = 0
    FP = 0
    for i in range(len(perm_vec)):
      
        
        Ntot = len(perm_vec[i][0])
        e50ok = False
        for j in range(Ntot):
            if perm_vec[i][5][j] < 50.0:
            e50ok = True
            break
    
    if e50ok:
        sortv = []
        for j in range(Ntot):
            vtmp = []
            vtmp.append(perm_vec[i][5][j])
            vtmp.append(perm_vec[i][2][j])
            vtmp.append(perm_vec[i][3][j])
            vtmp.append(perm_vec[i][6][j])
            sortv.append(vtmp)
        sortv.sort()
        Ntake = int(float(Ntot) * 0.20)
        #print perm_dictR[i]

        for j in range(Ntake):
            sig = sortv[j][3]
            if sig <= 0.5: TP += 1
            else: FP += 1
            #print sortv[j][1], sortv[j][2], sortv[j][0], sortv[j][3]
        
      
        energy_array = pylab.array(perm_vec[i][5])
        signal_array = pylab.array(perm_vec[i][6])

        Rval = str(pylab.corrcoef(energy_array, signal_array)[0][1])[0:4]
        
        label_str = perm_dictR[i] + ' (R=' + Rval + ')'
        
        color = color_dictionary(color_str[i])

        pylab.scatter(energy_array, signal_array, c = color, label = label_str)
        
    pylab.legend(loc='lower right', labelspacing=0.1)
    pylab.text(120.0, 0.75, pdbid + ' (' + ligand + '), R=' + totalR[0:5], fontsize=15)

    pylab.xlim(-10, 200)
    pylab.ylim(-0.75, 1.75)
    pylab.savefig(out_path + '_stat_plus_burial.png')
    pylab.close()
    
    print 'TP =', TP, 'FP =', FP, float(FP) / (float(FP) + float(TP))
    
def lines2list(fpath):
  
    v1 = []
    lines = readlines(fpath)
    for i in range(len(lines)):
        items = lines[i].strip().split()
        sub = []
        for j in range(len(items)):
        try: sub.append(float(items[j]))
        except: sub.append(items[j])
    v1.append(sub)

    return v1
    
def dfire_spot200(dfire_path, data_path, r):
  
    receptor_vec = ['bclxl', 'mcl1', 'bclw', 'bfl1', 'bcl2']
    ridx = receptor_vec.index(r) + 2
    
    SPOT200 = lines2list(data_path)
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    L = len(bim)

    dfire = lines2list(dfire_path)
    
    bime = 0.0
    for i in range(len(dfire)):
    if os.path.split(dfire[i][0])[1].split('_')[1].split('.')[0] == 'WT':
        bime = float(dfire[i][1])
        break
    
    wt200_count = 0.0
    wt200 = 0.0
    for row in SPOT200:
        seq = row[0][0:23]
        if seq == bim:
        wt200_count += 1.0
        wt200 += row[ridx]
    wt200 = wt200 / wt200_count
    
    for row in SPOT200:
        name = row[1]
        dsig = -1.0 * math.log10(row[ridx] / wt200)
        row.append(dsig)
        e = 0.0
        for i in range(len(dfire)):
        if os.path.split(dfire[i][0])[1].split('_')[1].split('.')[0] == name:
            e = float(dfire[i][1])
            break
        ddg = e - bime
        row.append(ddg)
    
    #print rate, ratep
    import pylab
    pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    spots = ['I2d', 'A2e', 'E2g', 'L3a', 'R3b', 'I3d', 'G3e', 'D3f', 'E3g', 'F4a']
        
    corr = []
    for pos in pos_vec:
        spec200 = [[], []]
        for row in SPOT200:
            seq = row[0][0:23]
            mut = 0
            for i in range(L):
            if seq[i] != bim[i]:
                mut = i
                break
        if not mut == pos: continue
            spec200[0].append(row[7])
            spec200[1].append(row[8])
        
        corr.append(pylab.corrcoef(pylab.array(spec200[1]), pylab.array(spec200[0]))[0][1])

    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    xs = pylab.arange(len(spots))
    pylab.bar(xs, pylab.array(corr), 0.35, color='r', align='center')
    pylab.xticks(xs, spots)
    pylab.xlim(-1, len(xs))
    pylab.ylim(-0.6, 1)

    pylab.savefig('/home/bartolo/web/tmperw/dfire_nmf_bfl1.png')
    pylab.close()
    
def SPOT_comparison(pdir1, pdir2, data_path, r1, r2):
  
    SPOT_vec = PSSM5()
    deepm = deepe_matrix('m')
    deepx = deepe_matrix('x')
    deepms = deepe_matrix_single('ma')
    deepxs = deepe_matrix_single('xa')
  
    receptor_vec = ['bclxl', 'mcl1', 'bclw', 'bfl1', 'bcl2']
    r1idx = receptor_vec.index(r1) + 2
    r2idx = receptor_vec.index(r2) + 2
  
    e1 = load_design_energy(pdir1)
    e2 = load_design_energy(pdir2)
    
    SPOT200 = lines2list(data_path)
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    L = len(bim)

    bim_e1 = xenergy(e1, bim, 10.0, False)
    bim_e2 = xenergy(e2, bim, 10.0, False)
    
    wt200_count1 = 0.0
    wt2001 = 0.0
    for row in SPOT200:
        seq = row[0][0:23]
        if seq == bim:
        wt200_count1 += 1.0
        wt2001 += row[r1idx]
    wt2001 = wt2001 / wt200_count1
    
    wt200_count2 = 0.0
    wt2002 = 0.0
    for row in SPOT200:
        seq = row[0][0:23]
        if seq == bim:
        wt200_count2 += 1.0
        wt2002 += row[r2idx]
    wt2002 = wt2002 / wt200_count2
    
    for row in SPOT200:
        seq = row[0][0:23]
        dsig1 = -1.0 * math.log10(row[r1idx] / wt2001)
        dsig2 = -1.0 * math.log10(row[r2idx] / wt2002)
        row.append(dsig1)
        row.append(dsig2)
        seq_e1 = xenergy(e1, seq, 10.0, False)
        seq_e2 = xenergy(e2, seq, 10.0, False)
        ddg1 = seq_e1 - bim_e1
        ddg2 = seq_e2 - bim_e2
        deepxe = deepe_calc(deepx, seq)
        deepme = deepe_calc(deepm, seq)
        deepxes = deepe_calc_single(deepxs, seq)
        deepmes = deepe_calc_single(deepms, seq)
        row.append(deepxes)
        row.append(deepmes)
    
    #print rate, ratep
    import pylab
    pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    spots = ['I2d', 'A2e', 'E2g', 'L3a', 'R3b', 'I3d', 'G3e', 'D3f', 'E3g', 'F4a']
        
    corr = [[], []]
    for pos in pos_vec:
        spec2001 = [[], []]
        spec2002 = [[], []]
        for row in SPOT200:
            seq = row[0][0:23]
            mut = 0
            for i in range(L):
            if seq[i] != bim[i]:
                mut = i
                break
        if not mut == pos: continue
            spec2001[0].append(row[7])
            spec2001[1].append(row[9])
            spec2002[0].append(row[8])
            spec2002[1].append(row[10])
        print spots[pos_vec.index(pos)], stats.spearmanr(pylab.array(spec2001[1]), pylab.array(spec2001[0]))[0], stats.spearmanr(pylab.array(spec2002[1]), pylab.array(spec2002[0]))[0]
        corr[0].append(stats.spearmanr(pylab.array(spec2001[1]), pylab.array(spec2001[0]))[0])
        corr[1].append(stats.spearmanr(pylab.array(spec2002[1]), pylab.array(spec2002[0]))[0])
        
    spec2001 = [[], []]
    spec2002 = [[], []]
    for row in SPOT200:
        seq = row[0][0:23]
        mut = 0
        for i in range(L):
        if seq[i] != bim[i]:
            mut = i
            break
            
    #if not mut in [14]: continue
        
        ediff = row[9] - row[10]
    #if ((row[7] < 0.0 and row[8] > 0.0) or (row[7] > 0.0 and row[8] < 0.0)) and ((row[9] < -10.0 and row[10] > 10.0) or (row[9] > 10.0 and row[10] < -10.0)):
    if ((row[7] < 0.0 and row[8] > 0.0) or (row[7] > 0.0 and row[8] < 0.0)) and (ediff > 25.0 or ediff < -25.0):
            #print row[1], row[7]- row[8], row[9] - row[10]
            
            spec2001[0].append(row[7] - row[8])
            spec2001[1].append(row[9] - row[10])
            spec2002[0].append(row[8])
            spec2002[1].append(row[10])

    #print
    #print  str(pylab.corrcoef(pylab.array(spec2001[1]), pylab.array(spec2001[0]))[0][1])
    


    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    #pylab.scatter(pylab.array(spec2001[0]), pylab.array(spec2001[1]))
    xs = pylab.arange(len(spots))
    pylab.bar(xs, pylab.array(corr[0]), 0.35, color='r', align='center')
    pylab.xticks(xs, spots)
    pylab.xlim(-1, len(xs))
    pylab.ylim(-0.6, 1)

    pylab.savefig('/home/bartolo/web/statium/data/plots/deepe_200_bclxl_bar.png')
    pylab.close()
    
    import pylab
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    #pylab.scatter(pylab.array(spec2001[0]), pylab.array(spec2001[1]))
    xs = pylab.arange(len(spots))
    pylab.bar(xs, pylab.array(corr[1]), 0.35, color='r', align='center')
    pylab.xticks(xs, spots)
    pylab.xlim(-1, len(xs))
    pylab.ylim(-0.6, 1)

    pylab.savefig('/home/bartolo/web/statium/data/plots/deepe_200_mcl1_bar.png')
    pylab.close()
    
def pyroc(iv):
  
    tp = '/home/bartolo/web/' + str(random.randint(1, 100000)) + '.txt'
    op = '/home/bartolo/web/' + str(random.randint(1, 100000)) + '.txt'
    tf = open(tp, 'w')
    for i in range(len(iv[0])):
        tf.write(str(iv[0][i]) + '\t' + str(iv[1][i]) + '\n')
    tf.close()
    
    os.system('/home/bartolo/web/pyroc.py -f ' + tp + ' > ' + op)
    
    data = lines2list(op)
    
    auc = float(data[4][2])
    
    roc = [[], []]
    for i in range(6, len(data)):
        roc[0].append(data[i][0])
        roc[1].append(data[i][1])
    
    os.remove(tp)
    os.remove(op)
    
    return [roc, auc]
    
def statium_evec(preset, spath, localX):
  
    evec = []
    currdir = os.getcwd()
    opath = os.path.join(currdir, 'tmp_evec_' + str(random.randint(1, 10000))) 
    os.system('/home/bartolo/web/C/statium_list.o ' + preset + ' ' + spath + ' ' + str(localX) + ' > ' + opath)
    lines = readlines(opath)
    for line in lines: evec.append(float(line.strip()))
    os.remove(opath)
    return evec
    
def ttest(a1, a2):
  
    t = str(stats.ttest_ind(a1, a2)[0])
    if len(t.split('e')) > 1:
        return t.split('e')[0][0:min(len(t.split('e')[0]), 5)] + 'e' + t.split('e')[1]
    else: return t[0:min(len(t), 5)]
    
#def statium_lib_spec_search():
  
    #local = 0.0
    #presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bcl2', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    #yeast_full_path = '/home/bartolo/web/statium/data/yeast_full_lib.txt'
    
    #yeasts = lines2list(yeast_full_path)
    
    #x_yeast_full = statium_evec(presets[0], yeast_full_path, local)
    #m_yeast_full = statium_evec(presets[1], yeast_full_path, local)
    
    #tosort = []
    #for i in range(len(yeasts)):
    
def delta_auc():
  
    affin_data = lines2list('/home/bartolo/web/statium/affin_curves.txt')
    spec_data = lines2list('/home/bartolo/web/statium/spec_curves.txt')
    localX = []
    affin = [[], []]
    spec = [[], []]
    for i in range(len(affin_data)):
        for j in range(len(affin_data[i])): affin[i].append(affin_data[i][j] - affin_data[i][0])
    for i in range(len(spec_data)):
        for j in range(len(spec_data[i])): spec[i].append(spec_data[i][j] - spec_data[i][0])
        
    import matplotlib
    matplotlib.use( 'Agg' )

    import pylab
    pylab.rcParams['xtick.labelsize'] = '10'
    pylab.rcParams['ytick.labelsize'] = '10'
    pylab.rcParams['savefig.dpi'] = '300'
    
    for i in range(11): localX.append(0.0 + 0.5 * float(i))
    xa = pylab.array(localX)
    
    #fig = pylab.figure()
    for i in range(2):
    ya = pylab.array(affin[i])
        #if max(ya) - min(ya) < 0.1: continue
        matplotlib.pyplot.plot(xa, ya, c='r', lw='2', label='Affinity')
    for i in range(2):
        ya = pylab.array(spec[i])
    #if max(ya) - min(ya) < 0.1: continue
        matplotlib.pyplot.plot(xa, ya, c='b', lw='2', label='Specificity')

    #pylab.legend(loc='upper left')
        
    #pylab.xlabel('Weighting of intra-peptide pairs in STATIUM')
    #pylab.ylabel('Change in AUC')
        
    pylab.savefig('/home/bartolo/web/statium_noref/delta_auc.png')
    
def library_pos_percent(lib, pos_vec):
  
    c = []
    for i in range(len(pos_vec)):
        c.append([])
        for j in range(20): c[i].append(0)
  
    p = []
    for i in range(len(pos_vec)):
        p.append([])
        for j in range(20): p[i].append(0.0)
        
    for seq in lib:
        for i in range(len(pos_vec)): c[i][AAChar_int(seq[pos_vec[i]])] += 1
        
    for i in range(len(pos_vec)):
        total = 0
        for j in range(20): total += c[i][j]
        for j in range(20): p[i][j] = float(c[i][j]) / float(total)
        
    return p
        
def library_prediction(lib1, lib2, elib, pos_vec):
  
    p1 = library_pos_percent(lib1, pos_vec)
    p2 = library_pos_percent(lib2, pos_vec)
    pe = library_pos_percent(elib, pos_vec)
    
    roc = []
    for i in range(len(pos_vec)):
        roci = [[], []]
        for j in range(20):
        if p1[i][j] >= 0.10:
            roci[0].append(0)
            roci[1].append(-1.0 * p2[i][j])
        if pe[i][j] > 0.0 and p1[i][j] < 0.10:
            roci[0].append(1)
            roci[1].append(-1.0 * p2[i][j])
        roc.append(roci)
    
    auc = []
    for i in range(len(pos_vec)):
        pyroci = pyroc(roc[i])
        auc.append(round(pyroci[1], 2))
    return auc
    
def library_prediction_pcoloring(v1, xlabel, ylabel):
    
    v2 = []
    for i in range(len(v1)):
        v2.append(v1[-i - 1])
    Nx = len(xlabel)
    Ny = len(ylabel)
    
    ylabel.reverse()
    import pylab
    pylab.pcolor(pylab.array(v2), edgecolors='k', linewidths=2)
    pylab.xticks(pylab.arange(Nx) + 0.5, xlabel, rotation= 30.0)
    pylab.yticks(pylab.arange(Ny) + 0.5, ylabel, rotation= 30.0)
    ind = pylab.arange(Nx)  # the x locations for the groups
    width = 0.0       # the width of the bars

    #fig = pylab.figure()
    #ax = fig.add_subplot(111)
    #ax.set_yticks(ind+width)
    #pylab.set_yticklabels( ylabel )
    #pylab.yticks(pylab.arange(N), ylabel)
    pylab.colorbar()
    pylab.savefig('/home/bartolo/web/test_pcolor.png')
    pylab.close()
    
def genome_search():
  
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bcl2', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2']
    tests = '/home/bartolo/web/statium/BH3_test_seq.txt'
    seq_lines = readlines(tests)
    seqs = []
    for line in seq_lines: seqs.append(line.strip())
    name_lines = readlines('/home/bartolo/web/statium/BH3_test_names.txt')
    names = []
    for line in name_lines: names.append(line.strip())
  
    for i in range(5):
        energies = statium_evec(presets[i], tests, 0.0)
        data = []
        for j in range(len(energies)): data.append([energies[j], names[j], seqs[j]])
        data.sort()
        op = '/home/bartolo/web/statium/genome_scan_' + rvec[i] + '.txt'
        of = open(op, 'w')
        for j in range(len(data)): of.write(data[j][2] + '\t' + str(data[j][0]) + '\t' + data[j][1] + '\n')
        of.close()
        
def statium_enrich():

    local = 5.0
    nonlocal = 0.0
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    evec = []
    for i in range(len(presets)): evec.append(load_design_energy(presets[i]))
    
    dr = ['X', 'M', 'W', 'F', '2']
    
    jmb_xspec_path = '/home/bartolo/web/statium/data/jmb_bclxl_spec.txt'
    jmb_mspec_path = '/home/bartolo/web/statium/data/jmb_mcl1_spec.txt'
    deep_xspec_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
    deep_mspec_path = '/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt'
    
    deep_faffin_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt'
    deep_waffin_path = '/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt'
    deep_2affin_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt'
    deep_xaffin_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt'
    deep_maffin_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt'
    yeast_full_path = '/home/bartolo/web/statium/data/yeast_full_lib.txt'
    bfl1_yeast_full_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt'
    w2_yeast_full_path = '/home/bartolo/web/statium/deepseq/w2/w2_full.txt'
    
    data_vec = []
    data_vec.append(['JMB_xspec', jmb_xspec_path, yeast_full_path])
    data_vec.append(['JMB_mspec', jmb_mspec_path, yeast_full_path])
    data_vec.append(['deep_xspec', deep_xspec_path, yeast_full_path])
    data_vec.append(['deep_mspec', deep_mspec_path, yeast_full_path])
    data_vec.append(['deep_xaffin', deep_xaffin_path, yeast_full_path])
    data_vec.append(['deep_maffin', deep_maffin_path, yeast_full_path])
    data_vec.append(['deep_faffin', deep_faffin_path, bfl1_yeast_full_path])
    data_vec.append(['deep_waffin', deep_waffin_path, w2_yeast_full_path])
    data_vec.append(['deep_2affin', deep_2affin_path, w2_yeast_full_path])
    
    for i in range(len(evec)):
        for j in range(len(data_vec)):
        print dr[i], data_vec[j][0],
    
        jmb_xsort = statium_evec(presets[i], data_vec[j][1], nonlocal)
    
        x2sort = statium_evec(presets[i], data_vec[j][2], nonlocal)
        
        x2sort.sort()
        jmb_xsort.sort()
        enrich0_e_vec = []
    
        
        enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
        for k in range(len(jmb_xsort)): enrich0_e_vec.append(enrich0_e)
        enrich0 = False
        for k in range(len(jmb_xsort)):
        if jmb_xsort[k] >= enrich0_e:
            enrich_orig = round(float(k) / float(len(jmb_xsort)), 2)
            enrich0 = True
            break
        if not enrich0: enrich_orig = 1.0
        
        print enrich_orig
        op = '/home/bartolo/web/statium/bootstrap/' + dr[i] + '_' + data_vec[j][0] + '_enrich_statium_bootstrap.txt'
        if not os.path.exists(op): bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')
            elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')
        
def bootstrap_coyote(op, nstraps, vec0, val0, code):
    
    randidx = str(random.randint(0, 1000000))
    vp = '/home/bartolo/tmp/' + randidx + '_bootstrap.txt'
    jp = '/home/bartolo/tmp/' + randidx + '_bootstrap.sh'
    
    vf = open(vp, 'w')
    jf = open(jp, 'w')
    
    if code == 'auc': 
        for i in range(len(vec0[0])): vf.write(str(vec0[0][i]) + '\t' + str(vec0[1][i]) + '\n')
        jf.write('/home/bartolo/web/build.py -bootstrap_auc ' + op + ' ' + str(nstraps) + ' ' + vp + ' ' + str(val0) + '\n')

    if code == 'enrich': 
        for i in range(len(vec0[0])): vf.write(str(vec0[0][i]) + '\t' + str(vec0[1][i]) + '\n')
        jf.write('/home/bartolo/web/build.py -bootstrap_enrich ' + op + ' ' + str(nstraps) + ' ' + vp + ' ' + str(val0) + '\n')
 
    
    if code == 'R': jf.write('/home/bartolo/web/build.py -bootstrap_R ' + op + ' ' + str(nstraps) + ' ' + vp + ' ' + str(val0) + '\n')
    jf.close()
    vf.close()
    
    os.system('chmod u+x ' + jp)
    os.system('qsub -q speedy ' + jp)
        
def bootstrap_auc(op, nstraps, vp, val0):
  
    data = lines2list(vp)
    v0 = [[], []]
    for i in range(len(data)):
        v0[0].append(int(data[i][0]))
        v0[1].append(data[i][1])
  
    of = open(op, 'w')
    Rs = []
    for i in range(nstraps):
        print i
        v = [[], []]
        for j in range(len(v0[0])):
        rint = random.randint(0, len(v0[0]) - 1)
        v[0].append(v0[0][rint])
        v[1].append(v0[1][rint])
    try: roc = pyroc(v)
    except: continue
    auc = roc[1]
    Rs.append(auc)
    Rs.sort()
    for i in range(len(Rs)):
    of.write(str(val0) + '\t' + str(Rs[i]) + '\n')
    of.close()

def bootstrap_enrich(op, nstraps, vp, val0):
  
    small = []
  
    data = lines2list(vp)
    for i in range(len(data)): small.append(data[i][1])
    enrich0_e = data[0][0]
    
    Rs = []
    for i in range(nstraps):
        if i % 10000 == 0: print i
        jmb_xsort = []
        for j in range(len(small)):
        rint = random.randint(0, len(small) - 1)
        jmb_xsort.append(small[rint])
    jmb_xsort.sort()
        
    enrich0 = False
    for k in range(len(jmb_xsort)):
        if jmb_xsort[k] >= enrich0_e:
        enrich_orig = float(k) / float(len(jmb_xsort))
        enrich0 = True
        break
    if not enrich0: enrich_orig = 1.0
    Rs.append(enrich_orig)
    
    Rs.sort()
    of = open(op, 'w')
    for i in range(len(Rs)):
    of.write(str(val0) + '\t' + str(Rs[i]) + '\n')
    of.close()
    
def statium_affinity_pred():

    percut = 0.3
    local = 5.0
    nonlocal = 0.0
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    evec = []
    for i in range(len(presets)): evec.append(load_design_energy(presets[i]))

    dr = ['X', 'M', 'W', 'F', '2']
    idx_vec = [2, 3, 4, 5, 6, 7, 8]

    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')

    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-Bad', 'Mcl-1-Noxa']
    bn_rvec = ['Bcl-xL-Bad', 'Mcl-1-Noxa']

    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')


    lib_spot_sort_affm = []
    lib_spot_sort_affx = []
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]

        lib_spot_sort_affm.append([msig, seq])
        lib_spot_sort_affx.append([xsig, seq])

    lib_spot_sort_affm.sort()
    lib_spot_sort_affx.sort()


    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)

    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == bim:
                wt200_count += 1.0
                wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    for eidx in range(len(evec)):
      
        if not dr[eidx] == 'X' and not dr[eidx] == 'M': continue 
      
        print dr[eidx]
        print

        #x_lib_spot_pred = [[], []]
        #m_lib_spot_pred = [[], []]
        #for i in range(len(SPOT360)):
            #if float(i) < percut * float(len(SPOT360)):
                #x_lib_spot_pred[0].append(0)
                #m_lib_spot_pred[0].append(0)
                #x_lib_spot_pred[1].append(statium_energy_calc(evec[eidx], lib_spot_sort_affx[i][1], local))
                #m_lib_spot_pred[1].append(statium_energy_calc(evec[eidx], lib_spot_sort_affm[i][1], local))
            #if float(i) > (float(len(SPOT360)) - percut * float(len(SPOT360))):
                #x_lib_spot_pred[0].append(1)
                #m_lib_spot_pred[0].append(1)
                #x_lib_spot_pred[1].append(statium_energy_calc(evec[eidx], lib_spot_sort_affx[i][1], local))
                #m_lib_spot_pred[1].append(statium_energy_calc(evec[eidx], lib_spot_sort_affm[i][1], local))

        #x_lib_spot_roc = pyroc(x_lib_spot_pred)
        #m_lib_spot_roc = pyroc(m_lib_spot_pred)
        #print 'libX', round(x_lib_spot_roc[1], 2), len(x_lib_spot_pred[0])
        #print 'libM', round(m_lib_spot_roc[1], 2), len(m_lib_spot_pred[0])
        
        #op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Xpred_statium_bootstrap.txt'
        #if len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, x_lib_spot_pred, x_lib_spot_roc[1], 'auc')
        
        
        #op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Mpred_statium_bootstrap.txt'
        #if len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, m_lib_spot_pred, m_lib_spot_roc[1], 'auc')

        #spot200_affin = []
        #for i in range(len(idx_vec)): spot200_affin.append([])

        #for i in range(5):
        #idx = idx_vec[i]
            #for row in SPOT200:
                #seq = row[0][0:23]
        #dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
        #if seq[12] != 'G': continue
        #e = statium_energy_calc(evec[eidx], seq, local)
                #spot200_affin[i].append([dsig, e, seq])
            #spot200_affin[i].sort()
        
        #spot200_affin_pred = []
        #for i in range(len(idx_vec)): spot200_affin_pred.append([[], []])
    
        #for i in range(5):
            #N = len(spot200_affin[i])
        #for j in range(N):
                #if float(j) < percut * float(N):
                    #spot200_affin_pred[i][0].append(0)
                    #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
                #if float(j) > (float(N) - percut * float(N)):
                    #spot200_affin_pred[i][0].append(1)
                    #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])

    #for i in range(5):
            #v = pyroc(spot200_affin_pred[i])
            #auc0 = v[1]
            #print rvec[i], round(v[1], 2), len(spot200_affin_pred[i][0])
            
            #op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_' + rvec[i] + '200_pred_statium_bootstrap.txt'
            #if len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, spot200_affin_pred[i], auc0, 'auc')

        spot200_affin_bn = [[], []]

        for i in range(len(bad_data)):
            seq = bad_data[i][0]
            dsig = bad_data[i][1]
            if seq == 'AAQRYGRELRRMSDEFVDSFKKG': continue
            if not seq[12] in 'SG': continue
            e = statium_energy_calc(evec[eidx], seq, local)
            spot200_affin_bn[0].append([dsig, e, seq])
        spot200_affin_bn[0].sort()

        for i in range(len(noxa_data)):
            seq = noxa_data[i][0]
            dsig = noxa_data[i][1]
            if seq == 'LEVECATQLRRFGDKLNFRQKLL': continue
            if seq[12] != 'G': continue
            e = statium_energy_calc(evec[eidx], seq, local)
            spot200_affin_bn[1].append([dsig, e, seq])
        spot200_affin_bn[1].sort()

        spot200_affin_pred_bn = []
        for i in range(2): spot200_affin_pred_bn.append([[], []])

        for i in range(2):
            N = len(spot200_affin_bn[i])
            for j in range(N):
                if float(j) < percut * float(N):
                    spot200_affin_pred_bn[i][0].append(0)
                    spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
                if float(j) > (float(N) - percut * float(N)):
                    spot200_affin_pred_bn[i][0].append(1)
                    spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
    for i in range(2):
            v = pyroc(spot200_affin_pred_bn[i])
            auc0 = v[1]
            print bn_rvec[i], round(v[1], 2), len(spot200_affin_pred_bn[i][0])

            op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_' + rvec[i] + '_BN_pred_statium_bootstrap.txt'
            if not os.path.exists(op): bootstrap_coyote(op, 2000, spot200_affin_pred_bn[i], auc0, 'auc')
            elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, spot200_affin_pred_bn[i], auc0, 'auc')

    data = lines2list('/home/bartolo/web/statium/genome_screen_results.txt')

def statium_bench(opath):
  
    local = 5.0
    nonlocal = 0.0
    percut = 0.3
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    evec = []
    for i in range(len(presets)): evec.append(load_design_energy(presets[i]))
    idx_vec = [2, 3, 4, 5, 6, 7, 8]
    colors = ['b', 'r', 'g', 'k', 'c', 'm', 'y']
    colorsf = ['blue', 'red', 'green', 'black', 'cyan', 'magenta', 'yellow']
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-Bad', 'Mcl-1-Noxa']
    bn_rvec = ['Bcl-xL-Bad', 'Mcl-1-Noxa']
    
    jmb_xspec_lines = readlines('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_lines = readlines('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')
    deep_xspec_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    deep_mspec_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    deep_xaffin_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt')
    deep_maffin_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt')
    deep_xspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro_25.txt')
    deep_mspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro_25.txt')
    yeast_full_path = '/home/bartolo/web/statium/data/yeast_full_lib.txt'
    genome_path = '/home/bartolo/web/statium/BH3_test_seq.txt'
    bfl1_yeast_full_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt'
    bfl1_yeast_spec_path = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr_10.txt'
    w2_yeast_full_path = '/home/bartolo/web/statium/deepseq/w2/w2_full.txt'
    w_yeast_spec_path = '/home/bartolo/web/statium/deepseq/w2/bclw_sort_25.txt'
    b_yeast_spec_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort_25.txt'
    
    jmb_fspec_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt')
    jmb_wspec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt')
    jmb_2spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt')
    
    expressing_path = '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt'
    expressing_lines = readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt')
    
    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')
    
    Gelman_data = lines2list('/home/bartolo/web/statium/data/Gelman.txt')
    Gelman_pssm_data = lines2list('/home/bartolo/web/statium/data/Gelman_pssm.txt')
    
    nirs_data = [[], [], [], [], []]
    nir_data = lines2list('/home/bartolo/web/statium/Nir/data.txt')
    for i in range(len(nir_data)):
        for j in range(5): nirs_data[j].append(nir_data[i][j])
    xlib_pred_lines = readlines('/home/bartolo/web/statium/data/xspec_pred_expressing.txt')
    mlib_pred_lines = readlines('/home/bartolo/web/statium/data/mspec_pred_expressing.txt')
    
    nyeastx = lines2list('/home/bartolo/web/statium/Nir/yeastx.txt')
    nyeastm = lines2list('/home/bartolo/web/statium/Nir/yeastm.txt')
    
    xm_lib_idxs = [4, 8, 9, 11, 13, 15]
    
    lib_auc = []
    xlib_auc_labels = ['2d', '3a', '3b', '3d', '3f', '4a']
    ylib_auc_labels = ['Bcl-xL', 'Mcl-1']
    lib_auc.append(library_prediction(jmb_xspec_lines, xlib_pred_lines, expressing_lines, xm_lib_idxs))
    lib_auc.append(library_prediction(jmb_mspec_lines, mlib_pred_lines, expressing_lines, xm_lib_idxs))
    library_prediction_pcoloring(lib_auc, xlib_auc_labels, ylib_auc_labels)
    
    print 'Analysing genome data...'
    genome = []
    for i in range(len(presets)):
        print rvec[i]
        genome.append(statium_evec(presets[i], genome_path, nonlocal))
 
    #import matplotlib
    #matplotlib.use( 'Agg' )
   
    for i in range(len(presets)):
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.rcParams['xtick.labelsize'] = '20'
        pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad']='8'
        pylab.rcParams['ytick.major.pad']='8'
        pylab.hist(pylab.array(genome[i]), normed=False, facecolor='white', edgecolor='black', lw=2)
        pylab.ylim(0, 5000)
        #pylab.yticks([])
        ##pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/genome_statium_' + rvec[i] + '.png')
        pylab.close()
    print 'genome done...'
    
    jmb_xsort = []
    jmb_xspec = [[], [], [], []]
    for line in deep_xaffin_lines:
        seq = line.strip()
        jmb_xspec[0].append(seq)
        jmb_xspec[1].append(statium_energy_calc(evec[0], seq, nonlocal) - statium_energy_calc(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        #
        jmb_xsort.append(statium_energy_calc(evec[0], seq, nonlocal))
        #
        jmb_xspec[2].append(statium_energy_calc(evec[1], seq, nonlocal) - statium_energy_calc(evec[1], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        jmb_xspec[3].append(jmb_xspec[1][-1] - jmb_xspec[2][-1])
    jmb_msort = []
    jmb_mspec = [[], [], [], []]
    for line in deep_maffin_lines:
        seq = line.strip()
        jmb_mspec[0].append(seq)
        jmb_mspec[1].append(statium_energy_calc(evec[0], seq, nonlocal) - statium_energy_calc(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        #
        jmb_msort.append(statium_energy_calc(evec[1], seq, nonlocal))
        #
        jmb_mspec[2].append(statium_energy_calc(evec[1], seq, nonlocal) - statium_energy_calc(evec[1], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        jmb_mspec[3].append(jmb_mspec[1][-1] - jmb_mspec[2][-1])
        
    jmb_xsort.sort()
    jmb_msort.sort()
        
    deep_xspec = [[], [], [], []]
    for line in deep_xspec_lines:
        seq = line.strip()
        deep_xspec[0].append(seq)
        deep_xspec[1].append(statium_energy_calc(evec[0], seq, nonlocal) - statium_energy_calc(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        deep_xspec[2].append(statium_energy_calc(evec[1], seq, nonlocal) - statium_energy_calc(evec[1], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        deep_xspec[3].append(deep_xspec[1][-1] - deep_xspec[2][-1])
    deep_mspec = [[], [], [], []]
    for line in deep_mspec_lines:
        seq = line.strip()
        deep_mspec[0].append(seq)
        deep_mspec[1].append(statium_energy_calc(evec[0], seq, nonlocal) - statium_energy_calc(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        deep_mspec[2].append(statium_energy_calc(evec[1], seq, nonlocal) - statium_energy_calc(evec[1], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        deep_mspec[3].append(deep_mspec[1][-1] - deep_mspec[2][-1])
    deep50_xsort = []
    deep_xspec_50 = [[], [], [], [], []]
    for line in deep_xspec_50_lines:
        seq = line.strip()
        deep_xspec_50[0].append(seq)
        deep_xspec_50[1].append(statium_energy_calc(evec[0], seq, nonlocal))
        deep50_xsort.append(statium_energy_calc(evec[0], seq, nonlocal))
        deep_xspec_50[2].append(statium_energy_calc(evec[1], seq, nonlocal))
        deep_xspec_50[3].append(deep_xspec_50[1][-1] - deep_xspec_50[2][-1])
        deep_xspec_50[4].append(deep_xspec_50[1][-1] - statium_energy_calc(evec[3], seq, nonlocal))
    deep50_msort = []
    deep_mspec_50 = [[], [], [], [], []]
    for line in deep_mspec_50_lines:
        seq = line.strip()
        deep_mspec_50[0].append(seq)
        deep_mspec_50[1].append(statium_energy_calc(evec[0], seq, nonlocal))
        deep50_msort.append(statium_energy_calc(evec[1], seq, nonlocal))
        deep_mspec_50[2].append(statium_energy_calc(evec[1], seq, nonlocal))
        deep_mspec_50[3].append(deep_mspec_50[1][-1] - deep_mspec_50[2][-1])
        deep_mspec_50[4].append(deep_mspec_50[2][-1] - statium_energy_calc(evec[3], seq, nonlocal))
        
    deep50_xsort.sort()
    deep50_msort.sort()
  
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', lw=2, alpha=0.8)
    #pylab.ylim(0, 12)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium/yeast_spec_statium_jmb.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(deep_xspec[3]), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.hist(pylab.array(deep_mspec[3]), normed=False, facecolor='white', edgecolor='red', lw=2, alpha=0.8)
    ##pylab.ylim(0, 12)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium/yeast_spec_statium_deep.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
    
    #####print 'Analysing Mcl-1 and Bcl-xL full yeast libraries...'
    #####yeast_full = []
    #####x_yeast_full = statium_evec(presets[0], yeast_full_path, nonlocal)
    #####m_yeast_full = statium_evec(presets[1], yeast_full_path, nonlocal)
    
    #x_yeast_full = statium_evec(presets[0], expressing_path, nonlocal)
    #m_yeast_full = statium_evec(presets[1], expressing_path, nonlocal)
    #####yeast_full.append(x_yeast_full)
    #####yeast_full.append(m_yeast_full)
    
    ######yeast_full_data = lines2list(expressing_path)
    
    #####x2sort = []
    #####m2sort = []
    #####xm2sort = []
    #####mx2sort = []
    #####for i in range(len(x_yeast_full)):
        #####xm2sort.append([x_yeast_full[i], m_yeast_full[i]])
        #####mx2sort.append([m_yeast_full[i], x_yeast_full[i]])
        #####x2sort.append(x_yeast_full[i])
        #####m2sort.append(m_yeast_full[i])
        
    #####x2sort.sort()
    #####m2sort.sort()
    #####mx2sort.sort()
    #####xm2sort.sort()
    
    #####enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
    #####enrich0 = False
    #####for i in range(len(jmb_xsort)):
        #####if jmb_xsort[i] >= enrich0_e:
        #####print 'enrich1:', float(i) / float(len(jmb_xsort))
        #####enrich0 = True
        #####break
    #####if not enrich0: print 'enrich1:', 1.0
    
    #####enrich0_e = m2sort[int(float(len(m2sort)) * 0.20)]
    #####enrich0 = False
    #####for i in range(len(jmb_msort)):
        #####if jmb_msort[i] >= enrich0_e:
        #####print 'enrich2:', float(i) / float(len(jmb_msort))
        #####enrich0 = True
        #####break
    #####if not enrich0: print 'enrich2:', 1.0
    
    #####enrich_x = [[], []]
    #####enrich0_e = jmb_xsort[0]
    #####c0 = 0.1
    #####while True:
        #####jmbc = 0
        #####for i in range(len(jmb_xsort)):
        #####if jmb_xsort[i] < enrich0_e + c0: jmbc += 1
        #####fullc = 0
        #####for i in range(len(x2sort)):
        #####if x2sort[i] < enrich0_e + c0: fullc += 1
    #####enrich_x[0].append(float(fullc) / float(len(x2sort)))
    #####enrich_x[1].append(float(jmbc) / float(len(jmb_xsort)))
    #####c0 += 0.1
    #####if (float(fullc) / float(len(x2sort))) < 0.22 and (float(fullc) / float(len(x2sort))) > 0.18: print (float(fullc) / float(len(x2sort))), float(jmbc) / float(len(jmb_xsort))
    #####if enrich0_e + c0 > x2sort[-1]: break
    
    #####ofile = open('/home/bartolo/web/statium/X_enrich_statium.txt', 'w')
    #####for i in range(len(enrich_x[0])): ofile.write(str(enrich_x[1][i]) + '\t' + str(enrich_x[0][i]) + '\n')
    #####ofile.close()
    
    #####enrich_m = [[], []]
    #####enrich0_e = jmb_msort[0]
    #####c0 = 0.1
    #####while True:
        #####jmbc = 0
        #####for i in range(len(jmb_msort)):
        #####if jmb_msort[i] < enrich0_e + c0: jmbc += 1
        #####fullc = 0
        #####for i in range(len(m2sort)):
        #####if m2sort[i] < enrich0_e + c0: fullc += 1
    #####enrich_m[0].append(float(fullc) / float(len(m2sort)))
    #####enrich_m[1].append(float(jmbc) / float(len(jmb_msort)))
    #####c0 += 0.1
    #####if (float(fullc) / float(len(m2sort))) < 0.22 and (float(fullc) / float(len(m2sort))) > 0.18: print (float(fullc) / float(len(m2sort))), float(jmbc) / float(len(jmb_msort))
    #####if enrich0_e + c0 > m2sort[-1]: break

    #####ofile = open('/home/bartolo/web/statium/M_enrich_statium.txt', 'w')
    #####for i in range(len(enrich_m[0])): ofile.write(str(enrich_m[1][i]) + '\t' + str(enrich_m[0][i]) + '\n')
    #####ofile.close()

    #####import pylab
    #####pylab.rcParams['xtick.labelsize'] = '14'
    #####pylab.rcParams['ytick.labelsize'] = '14'
    #####pylab.rcParams['savefig.dpi'] = '300'
    #####pylab.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', lw=2)
    #####pylab.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', lw=2)
    #####pylab.ylim(0, 12)
    #####pylab.yticks([])
    #####pylab.savefig('/home/bartolo/web/statium/yeast_spec_statium.png')
    ######pylab.yticks([])
    ######pylab.xticks([])
    #####pylab.close()
  
    #####import pylab
    #####pylab.rcParams['savefig.dpi'] = '300'
    #####pylab.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='blue', lw=2)
    #####pylab.hist(pylab.array(yeast_full[0]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    #####pylab.savefig('/home/bartolo/web/statium/X_hist_statium.png')
    #####pylab.close()
    
    #####import pylab
    #####pylab.rcParams['savefig.dpi'] = '300'
    #####pylab.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', lw=2)
    #####pylab.hist(pylab.array(yeast_full[1]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    #####pylab.savefig('/home/bartolo/web/statium/M_hist_statium.png')
    #####pylab.close()  
    
    #####yeast_spec_pred = [[], []]
    #####for i in range(len(jmb_xspec[3])):
        #####yeast_spec_pred[0].append(0)
        #####yeast_spec_pred[1].append(jmb_xspec[3][i])
    #####for i in range(len(jmb_mspec[3])):
        #####yeast_spec_pred[0].append(1)
        #####yeast_spec_pred[1].append(jmb_mspec[3][i])
    #####v = pyroc(yeast_spec_pred)
    #####print
    #####print 'Yeast sorting specificity...', round(v[1], 2)
    #####print
    
    #####nyeast_spec_pred = [[], []]
    #####nyx = []
    #####nym = []
    #####for i in range(len(nyeastx)):
        #####nyeast_spec_pred[0].append(0)
        #####nyeast_spec_pred[1].append(nyeastx[i][0])
        #####nyx.append(nyeastx[i][0])
    #####for i in range(len(nyeastm)):
        #####nyeast_spec_pred[0].append(1)
        #####nyeast_spec_pred[1].append(nyeastm[i][0])
        #####nym.append(nyeastm[i][0])
    #####v = pyroc(nyeast_spec_pred)
    #####print
    #####print 'Nir yeast sorting specificity...', round(v[1], 2)
    #####print
    
    #####import pylab
    #####pylab.rcParams['savefig.dpi'] = '300'
    #####pylab.hist(pylab.array(nyx), normed=True, facecolor='white', edgecolor='blue', alpha = 0.45, lw=2)
    #####pylab.hist(pylab.array(nym), normed=True, facecolor='white', edgecolor='red', alpha = 0.45, lw=2)
    ######pylab.yticks([])
    ######pylab.xticks([])
    #####pylab.savefig('/home/bartolo/web/statium/Nir/yeast_spec_hist.png')
    #####pylab.close()
    
    ######print 'Analysing Gelman data...'
    #####xcut = [[], []]
    #####mcut = [[], []]
    #####gel_spec = []
    #####gel_xaffin = []
    #####gel_maffin = []
    #####gel_hist = [[], []]
    #####L = len(Gelman_data)
    #####for i in range(L):
        #####seq = Gelman_data[i][0]
        #####xsig = math.log10(Gelman_data[i][1]) - math.log10(110.0)
        #####msig = math.log10(Gelman_data[i][2]) - math.log10(4.0)
        #####gel_hist[0].append(xsig)
        #####gel_hist[1].append(msig)
        #####if seq[12] != 'G': continue
        #####xe = statium_energy_calc(evec[0], seq, nonlocal)
    #####me = statium_energy_calc(evec[1], seq, nonlocal)
        #####xea = statium_energy_calc(evec[0], seq, local)
    #####mea = statium_energy_calc(evec[1], seq, local)
    #####gel_spec.append([xsig - msig, xe - me, seq])
    #####gel_xaffin.append([xsig, xea, seq])
    #####gel_maffin.append([msig, mea, seq])
        #####if Gelman_data[i][1] < 100:
        #####xcut[0].append(0)
        #####xcut[1].append(xea)
        #####if Gelman_data[i][2] < 100:
        #####mcut[0].append(0)
        #####mcut[1].append(mea)
        #####if Gelman_data[i][1] > 1000:
        #####xcut[0].append(1)
        #####xcut[1].append(xea)
        #####if Gelman_data[i][2] > 1000:
        #####mcut[0].append(1)
        #####mcut[1].append(mea)

    #####gellcut_xroc = pyroc(xcut)
    #####gellcut_mroc = pyroc(mcut)
    ######print 'GellCut X', round(gellcut_xroc[1], 2)
    ######print 'GellCut M', round(gellcut_mroc[1], 2)

    
    ######import pylab
    ######pylab.hist(gel_hist[0])
    ######pylab.xlim(-2.0, 4.0)
    ######pylab.savefig('/home/bartolo/web/statium/hist_gelman_x.png')
    
    #####gel_spec.sort()
    #####gel_xaffin.sort()
    #####gel_maffin.sort()
    
    #####gel_spec_pred = [[], []]
    #####gel_xaffin_pred = [[], []]
    #####gel_maffin_pred = [[], []]
    
    #####L = len(gel_xaffin)
    #####for i in range(L):
        #####if float(i) < percut * float(L):
        #####gel_xaffin_pred[0].append(0)
        #####gel_maffin_pred[0].append(0)
        #####gel_spec_pred[0].append(0)
        #####gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #####gel_maffin_pred[1].append(gel_maffin[i][1])
        #####gel_spec_pred[1].append(gel_spec[i][1])
    #####if float(i) > (float(L) - percut * float(L)):
        #####gel_xaffin_pred[0].append(1)
        #####gel_maffin_pred[0].append(1)
        #####gel_spec_pred[0].append(1)
        #####gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #####gel_maffin_pred[1].append(gel_maffin[i][1])
        #####gel_spec_pred[1].append(gel_spec[i][1])
    
    ######print len(gel_xaffin_pred[1])
    #####gel_spec_roc = pyroc(gel_spec_pred)
    #####gel_xaffin_roc = pyroc(gel_xaffin_pred)
    #####gel_maffin_roc = pyroc(gel_maffin_pred)
    
    #print
    #print 'Gellman specificity AUC:', round(gel_spec_roc[1], 2)
    #print 'Gellman Bclxl affinity AUC:', round(gel_xaffin_roc[1], 2)
    #print 'Gellman Mcl-1 affinity AUC:', round(gel_maffin_roc[1], 2)
    #print
        
    print 'Analysing SPOT data...'
    lib_spot_sort_affm = []
    lib_spot_sort_affx = []
    lib_spot_sort_spec = []
    L = len(SPOT360)
    lib_hist = [[], []]
    for i in range(L):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        lib_hist[0].append(xsig)
        lib_hist[1].append(msig)
        
        lib_spot_sort_affm.append([msig, seq, nirs_data[3][i]])
        lib_spot_sort_affx.append([xsig, seq, nirs_data[1][i]])
        lib_spot_sort_spec.append([xsig - msig, seq])
        
    #import pylab
    #pylab.hist(lib_hist[1])
    #pylab.xlim(-0.5, 2.0)
    #pylab.savefig('/home/bartolo/web/statium/hist_lib_m.png')
    
    #Sort Nir's data
    
    
    lib_spot_sort_affm.sort()
    lib_spot_sort_affx.sort()
    lib_spot_sort_spec.sort()
    
    x_lib_spot_pred = [[], []]
    m_lib_spot_pred = [[], []]
    x_lib_spot_corr = [[], []]
    m_lib_spot_corr = [[], []]
    nx_lib_spot_pred = [[], []]
    nm_lib_spot_pred = [[], []]
    nx_lib_spot_corr = [[], []]
    nm_lib_spot_corr = [[], []]
    spec_lib_spot_corr = [[], []]
    spec_lib_spot_pred = [[], []]
    for i in range(L):
        x_lib_spot_corr[0].append(lib_spot_sort_affx[i][0])
        m_lib_spot_corr[0].append(lib_spot_sort_affm[i][0])
    x_lib_spot_corr[1].append(statium_energy_calc(evec[0], lib_spot_sort_affx[i][1], local))
    m_lib_spot_corr[1].append(statium_energy_calc(evec[1], lib_spot_sort_affm[i][1], local))
        if float(i) < percut * float(L):
        x_lib_spot_pred[0].append(0)
        m_lib_spot_pred[0].append(0)
        nx_lib_spot_pred[0].append(0)
        nm_lib_spot_pred[0].append(0)
        spec_lib_spot_pred[0].append(0)
        x_lib_spot_pred[1].append(statium_energy_calc(evec[0], lib_spot_sort_affx[i][1], local))
        m_lib_spot_pred[1].append(statium_energy_calc(evec[1], lib_spot_sort_affm[i][1], local))
        spec_lib_spot_pred[1].append(statium_energy_calc(evec[0], lib_spot_sort_spec[i][1], nonlocal) - statium_energy_calc(evec[1], lib_spot_sort_spec[i][1], nonlocal))
        nx_lib_spot_pred[1].append(lib_spot_sort_affx[i][2])
        nm_lib_spot_pred[1].append(lib_spot_sort_affm[i][2])
    if float(i) > (float(L) - percut * float(L)):
        x_lib_spot_pred[0].append(1)
        m_lib_spot_pred[0].append(1)
        nx_lib_spot_pred[0].append(1)
        nm_lib_spot_pred[0].append(1)
        spec_lib_spot_pred[0].append(1)
        x_lib_spot_pred[1].append(statium_energy_calc(evec[0], lib_spot_sort_affx[i][1], local))
        m_lib_spot_pred[1].append(statium_energy_calc(evec[1], lib_spot_sort_affm[i][1], local))
        spec_lib_spot_pred[1].append(statium_energy_calc(evec[0], lib_spot_sort_spec[i][1], nonlocal) - statium_energy_calc(evec[1], lib_spot_sort_spec[i][1], nonlocal))
        nx_lib_spot_pred[1].append(lib_spot_sort_affx[i][2])
        nm_lib_spot_pred[1].append(lib_spot_sort_affm[i][2])
    
    spec_lib_spot_roc = pyroc(spec_lib_spot_pred)
    x_lib_spot_roc = pyroc(x_lib_spot_pred)
    m_lib_spot_roc = pyroc(m_lib_spot_pred)
    nx_lib_spot_roc = pyroc(nx_lib_spot_pred)
    nm_lib_spot_roc = pyroc(nm_lib_spot_pred)
    roc360 = []
    roc360.append(x_lib_spot_roc)
    roc360.append(m_lib_spot_roc)
    
    #####ofile = open('/home/bartolo/web/statium/X360_affin.txt', 'w')
    #####for i in range(len(x_lib_spot_corr[0])): ofile.write(str(x_lib_spot_corr[0][i]) + '\t' + str(x_lib_spot_corr[1][i]) + '\n')
    #####ofile.close()
    
    xm_360spec = [[], []]
    nir_xm_360spec = [[], []]
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        if xsig < 0.5 or msig < 0.5:
        xm_360spec[0].append(xsig - msig)
        xm_360spec[1].append(statium_energy_calc(evec[0], seq, nonlocal) - statium_energy_calc(evec[1], seq, nonlocal))
        nir_xm_360spec[0].append(xsig - msig)
        nir_xm_360spec[1].append(nirs_data[1][i] - nirs_data[3][i])
    #####ofile = open('/home/bartolo/web/statium/spec360_statium.txt', 'w')
    #####for i in range(len(xm_360spec[0])):
        #####ofile.write(str(xm_360spec[0][i]) + '\t' + str(xm_360spec[1][i]) + '\n')
    #####ofile.close()
    
    #####print 'nirx', nx_lib_spot_roc[1], 'nirm', nm_lib_spot_roc[1], round(pylab.corrcoef(pylab.array(nir_xm_360spec[0]), pylab.array(nir_xm_360spec[1]))[0][1], 2)
    
    import pylab
    print
    print 'Library array specificity AUC:', round(spec_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(xm_360spec[0]), pylab.array(xm_360spec[1]))[0][1], 2), len(xm_360spec[0])
    print 'Library array Bclxl affinity AUC:', round(x_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(x_lib_spot_corr[0]), pylab.array(x_lib_spot_corr[1]))[0][1], 2)
    print 'Library array Mcl-1 affinity AUC:', round(m_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(m_lib_spot_corr[0]), pylab.array(m_lib_spot_corr[1]))[0][1], 2)
    
    print
    
    of = open('/home/bartolo/web/statium/xm_360_spec_statium_bootstrap.txt', 'w')
    Rs = []
    for i in range(2000):
        v = [[], []]
        for j in range(len(xm_360spec[0])):
        rint = random.randint(0, len(xm_360spec[0]) - 1)
        v[0].append(xm_360spec[0][rint])
        v[1].append(xm_360spec[1][rint])
    R = pylab.corrcoef(pylab.array(v[0]), pylab.array(v[1]))[0][1]
    Rs.append(R)
    Rs.sort()
    for i in range(len(Rs)):
    of.write(str(Rs[i]) + '\n')
    of.close()
        
    
    #####import matplotlib
    #####matplotlib.use( 'Agg' )
    #####import pylab
    #####matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #####pylab.savefig('/home/bartolo/web/statium/Nir/nir_lib360spec.png')
    #####pylab.close()
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    
    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == bim:
            wt200_count += 1.0
            wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)
        
    print 'SPOT200 binding...'
    spot200_affin = []
    for i in range(len(idx_vec)):
        spot200_affin.append([])

    full_vec = []
    for i in range(5):
        full_vec.append([])
        for j in range(10): full_vec[i].append([[], []])
    
    pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    sub_hist = []
    for i in range(5):
        sub_hist.append([])
    idx = idx_vec[i]
        for row in SPOT200:
            seq = row[0][0:23]
            pos = 0
            for j in range(len(seq)):
            if seq[j] != bim[j]: pos = pos_vec.index(j)
            dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
            sub_hist[i].append(dsig)
            if seq[12] != 'G': continue
            e = statium_energy_calc(evec[i], seq, local)
            full_vec[i][pos][0].append(dsig)
            full_vec[i][pos][1].append(e)
            spot200_affin[i].append([dsig, e, seq])
        spot200_affin[i].sort()
        #import pylab
        #pylab.hist(pylab.array(sub_hist[i]))
        #pylab.xlim(-0.5, 2.0)
        #pylab.savefig('/home/bartolo/web/statium/hist_sub_' + rvec[i] + '.png')
        #pylab.close()
    L = len(spot200_affin[0])
    
    spot200_affin_pred = []
    for i in range(len(idx_vec)):
        spot200_affin_pred.append([[], []])
        
    spot200_affin_corr = []
    for i in range(len(idx_vec)):
        spot200_affin_corr.append([[], []])
        
    for i in range(5):
        L = len(spot200_affin[i])
        for j in range(L):
        spot200_affin_corr[i][0].append(spot200_affin[i][j][0])
        spot200_affin_corr[i][1].append(spot200_affin[i][j][1])
            if float(j) < percut * float(L):
            print rvec[i], 'bind', spot200_affin[i][j][2], spot200_affin[i][j][0], spot200_affin[i][j][1]
            spot200_affin_pred[i][0].append(0)
            spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
        if float(j) > (float(L) - percut * float(L)):
            print rvec[i], 'nonbind', spot200_affin[i][j][2], spot200_affin[i][j][0], spot200_affin[i][j][1]
            spot200_affin_pred[i][0].append(1)
            spot200_affin_pred[i][1].append(spot200_affin[i][j][1])

    import pylab
    for i in range(5):
        #if i == 0:
        #pylab.scatter(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
        #pylab.savefig('/home/bartolo/web/test2.png')  
        v = pyroc(spot200_affin_pred[i])
        print rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]))[0][1], 2)
    
    #for i in range(len(full_vec)):
        #import pylab
        #pylab.rcParams['savefig.dpi'] = '300'
    
    #barv = []
        #for j in range(10): barv.append(round(pylab.corrcoef(pylab.array(full_vec[i][j][0]), pylab.array(full_vec[i][j][1]))[0][1], 2))
        #pylab.bar(pylab.arange(len(barv)), pylab.array(barv), 0.35, color='r', align='center')
    #pylab.xlim(-1, len(pylab.arange(len(barv))))
    #pylab.ylim(-0.6, 1)
    #pylab.xticks(pylab.arange(len(barv)), ('2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a')) 
    #pylab.savefig('/home/bartolo/web/statium/statium_pos_bar_' + rvec[i] + '.png')
    #pylab.close()
    
    print 'Bad and Noxa SPOT substitution binding...'
    spot200_affin_bn = []
    for i in range(2):
        spot200_affin_bn.append([])

    bad_hist = []
    for i in range(len(bad_data)):
        seq = bad_data[i][0]
        dsig = bad_data[i][1]
        bad_hist.append(dsig)
        if seq == 'AAQRYGRELRRMSDEFVDSFKKG': continue
        if not seq[12] in 'SG': continue
        if not seq[5] in 'G': continue
        e = statium_energy_calc(evec[0], seq, local)
        spot200_affin_bn[0].append([dsig, e, seq])
    spot200_affin_bn[0].sort()
    
    #import pylab
    #pylab.hist(pylab.array(bad_hist))
    #pylab.xlim(-0.5, 2.0)
    #pylab.savefig('/home/bartolo/web/statium/hist_bad.png')
    #pylab.close()
    
    noxa_hist = []
    for i in range(len(noxa_data)):
        seq = noxa_data[i][0]
        dsig = noxa_data[i][1]
        noxa_hist.append(dsig)
        if seq == 'LEVECATQLRRFGDKLNFRQKLL': continue
        if seq[12] != 'G': continue
        e = statium_energy_calc(evec[1], seq, local)
        spot200_affin_bn[1].append([dsig, e, seq])
    spot200_affin_bn[1].sort()

    #import pylab
    #pylab.hist(pylab.array(noxa_hist))
    #pylab.xlim(-0.5, 2.0)
    #pylab.savefig('/home/bartolo/web/statium/hist_noxa.png')
    #pylab.close()

    spot200_affin_pred_bn = []
    for i in range(2):
        spot200_affin_pred_bn.append([[], []])
        
    spot200_affin_corr_bn = []
    for i in range(2):
        spot200_affin_corr_bn.append([[], []])
        
    for i in range(2):
        L = len(spot200_affin_bn[i])
        for j in range(L):
        spot200_affin_corr_bn[i][0].append(spot200_affin_bn[i][j][0])
        spot200_affin_corr_bn[i][1].append(spot200_affin_bn[i][j][1])
            if float(j) < percut * float(L):
            spot200_affin_pred_bn[i][0].append(0)
            spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
        if float(j) > (float(L) - percut * float(L)):
            spot200_affin_pred_bn[i][0].append(1)
            spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
            
        print len(spot200_affin_pred_bn[i][0])
         
    import pylab
    for i in range(2):
        v = pyroc(spot200_affin_pred_bn[i])
        print bn_rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr_bn[i][0]), pylab.array(spot200_affin_corr_bn[i][1]))[0][1], 2)
        
    print
    #####print 'SPOT200 specificity...'
    #####print
    
    #####spot200_spec = []
    #####for i in range(len(idx_vec)):
        #####spot200_spec.append([])
        #####for j in range(len(idx_vec)): spot200_spec[i].append([])
        
    #####spot200_spec_corr = []
    #####for i in range(len(idx_vec)):
        #####spot200_spec_corr.append([])
        #####for j in range(len(idx_vec)): spot200_spec_corr[i].append([[], []])
        
    #####spot200_spec_pred = []
    #####for i in range(len(idx_vec)):
        #####spot200_spec_pred.append([])
        #####for j in range(len(idx_vec)): spot200_spec_pred[i].append([[], []])

    #####for i in range(5):
    #####idxi = idx_vec[i]
    #####for j in range(i + 1, 5):
        #####idxj = idx_vec[j]
            #####for row in SPOT200:
                #####seq = row[0][0:23]
                #####if seq[12] != 'G': continue
                #####dsigi = -1.0 * math.log10(row[idxi] / wt_vec[i])
                #####dsigj = -1.0 * math.log10(row[idxj] / wt_vec[j])
                #####ei = statium_energy_calc(evec[i], seq, nonlocal)
                #####ej = statium_energy_calc(evec[j], seq, nonlocal)
                #####spot200_spec[i][j].append([dsigi - dsigj, ei - ej, seq, dsigi, dsigj])
            #####spot200_spec[i][j].sort()
        
    #####for i in range(5):
        #####for j in range(i + 1, 5):
            #####L = len(spot200_spec[i][j])
        #####for k in range(L):
         ######   if spot200_spec[i][j][k][3] < 0.5 or spot200_spec[i][j][k][4] < 0.5:
        #####spot200_spec_corr[i][j][0].append(spot200_spec[i][j][k][0])
        #####spot200_spec_corr[i][j][1].append(spot200_spec[i][j][k][1])
        #####if float(k) < percut * float(L):
            #####spot200_spec_pred[i][j][0].append(0)
            #####spot200_spec_pred[i][j][1].append(spot200_spec[i][j][k][1])
        #####if float(k) > (float(L) - percut * float(L)):
            #####spot200_spec_pred[i][j][0].append(1)
            #####spot200_spec_pred[i][j][1].append(spot200_spec[i][j][k][1])
        #####pyrocij = pyroc(spot200_spec_pred[i][j])
        #####print rvec[i], rvec[j], round(pyrocij[1], 2), round(pylab.corrcoef(pylab.array(spot200_spec_corr[i][j][0]), pylab.array(spot200_spec_corr[i][j][1]))[0][1], 2), len(spot200_spec_corr[i][j][0])

    #####import matplotlib
    #####matplotlib.use( 'Agg' )
    #####import pylab
    #####matplotlib.pyplot.scatter(pylab.array(m_lib_spot_corr[1]), pylab.array(m_lib_spot_corr[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #####pylab.savefig('/home/bartolo/web/m_lib360scatter.png')
    #####pylab.close()
        
    print
    print
    #####print 'Analysing Bfl-1 full yeast libraries...'
    #####f_yeast_full = statium_evec(presets[3], bfl1_yeast_full_path, nonlocal)
    #####f_yeast_spec = statium_evec(presets[3], bfl1_yeast_spec_path, nonlocal)
    #####fm_yeast_spec = statium_evec(presets[1], bfl1_yeast_spec_path, nonlocal)
    #####fx_yeast_spec = statium_evec(presets[0], bfl1_yeast_spec_path, nonlocal)
    
    #####mf_yeast_spec_diff = []
    #####for i in range(len(f_yeast_spec)): mf_yeast_spec_diff.append(fm_yeast_spec[i] - f_yeast_spec[i])
    #####xf_yeast_spec_diff = []
    #####for i in range(len(f_yeast_spec)): xf_yeast_spec_diff.append(fx_yeast_spec[i] - f_yeast_spec[i])
    
    #####print 'Analysing Bcl-2 and Bcl-w full yeast libraries...'
    #####w_yeast_full = statium_evec(presets[2], w2_yeast_full_path, nonlocal)
    #####w_yeast_spec = statium_evec(presets[2], w_yeast_spec_path, nonlocal)
    #####b_yeast_full = statium_evec(presets[4], w2_yeast_full_path, nonlocal)
    #####b_yeast_spec = statium_evec(presets[4], b_yeast_spec_path, nonlocal)
    
    #####natural = [['PEIWIAQELRRIGDEFNAYYARR', 'WAREIGAQLRRMADDLNAQYERR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'TMGQVGRQLAIIGDDINRRYDSE', 'AAQLTAARLKALGDELHQRTMWR', 'MTQEVGQLLQDMGDDVYQQYRSL', 'EFARIARDLSHIGDAVVISAAKD'], [], [], [], [], []]
    #####natural_names = ['Bim', 'Puma', 'Noxa', 'Bad', 'Bak', 'Hrk', 'Mule', 'PCNA']
    #####for i in range(len(natural[0])):
        #####natural[1].append(statium_energy_calc(evec[0], natural[0][i], nonlocal))
        #####natural[2].append(statium_energy_calc(evec[1], natural[0][i], nonlocal))
        #####natural[3].append(statium_energy_calc(evec[2], natural[0][i], nonlocal))
        #####natural[4].append(statium_energy_calc(evec[3], natural[0][i], nonlocal))
        #####natural[5].append(statium_energy_calc(evec[4], natural[0][i], nonlocal))
        
    #####print 'Analysing JMB Specific yeast sequences...'
    #####bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='black', lw=2)
    #pylab.hist(pylab.array(yeast_full[0]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/X_hist_statium.png')
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='black', lw=2)
    #pylab.hist(pylab.array(yeast_full[1]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/M_hist_statium.png')
    #pylab.close()
    

    
    #import pylab
    #pylab.plot(pylab.array(enrich_x[0]), pylab.array(enrich_x[1]))
    #pylab.savefig('/home/bartolo/web/statium/enrich_x.png')
    #pylab.close()
    
    #####enrich_x = [[], []]
    #####enrich0_e = jmb_xsort[0]
    #####c0 = 0.5
    #####while True:
        #####jmbc = 0
        #####for i in range(len(jmb_xsort)):
        #####if jmb_xsort[i] < enrich0_e + c0: jmbc += 1
        #####fullc = 0
        #####for i in range(len(x2sort)):
        #####if x2sort[i] < enrich0_e + c0: fullc += 1
    #####enrich_x[0].append(enrich0_e + c0)
    #####enrich_x[1].append(float(jmbc) / (float(jmbc) + float(fullc)))
    #####c0 += 0.1
    #####if enrich0_e + c0 > x2sort[-1]: break
    
    #####import pylab
    #####pylab.plot(pylab.array(enrich_x[0]), pylab.array(enrich_x[1]))
    #####pylab.savefig('/home/bartolo/web/statium/enrich_x.png')
    #####pylab.close()
    
    #####enrich_m = [[], []]
    #####enrich0_e = deep50_msort[0]
    #####c0 = 0.5
    #####while True:
        #####deep50c = 0
        #####for i in range(len(deep50_msort)):
        #####if deep50_msort[i] < enrich0_e + c0: deep50c += 1
        #####fullc = 0
        #####for i in range(len(m2sort)):
        #####if m2sort[i] < enrich0_e + c0: fullc += 1
    #####enrich_m[0].append(enrich0_e + c0)
    #####enrich_m[1].append(float(deep50c) / (float(deep50c) + float(fullc)))
    #####c0 += 0.1
    #####if enrich0_e + c0 > m2sort[-1]: break
    

    
    #####import pylab
    #####pylab.plot(pylab.array(enrich_m[0]), pylab.array(enrich_m[1]))
    #####pylab.savefig('/home/bartolo/web/statium/enrich_m_deep50.png')
    #####pylab.close()
    
    #####enrich_x = [[], []]
    #####enrich0_e = deep50_xsort[0]
    #####c0 = 0.5
    #####while True:
        #####deep50c = 0
        #####for i in range(len(deep50_xsort)):
        #####if deep50_xsort[i] < enrich0_e + c0: deep50c += 1
        #####fullc = 0
        #####for i in range(len(x2sort)):
        #####if x2sort[i] < enrich0_e + c0: fullc += 1
    #####enrich_x[0].append(enrich0_e + c0)
    #####enrich_x[1].append(float(deep50c) / (float(deep50c) + float(fullc)))
    #####c0 += 0.1
    #####if enrich0_e + c0 > x2sort[-1]: break
    
    #####import pylab
    #####pylab.plot(pylab.array(enrich_x[0]), pylab.array(enrich_x[1]))
    #####pylab.savefig('/home/bartolo/web/statium/enrich_x_deep50.png')
    #####pylab.close()
    
    #####xspec_pred = []
    #####mspec_pred = []
    #####L = len(x_yeast_full)
    #####for i in range(len(x_yeast_full)):
        #####if i % 10000 == 0: print i
        #####percentile = float(i) / float(L)
        #####if percentile > 0.10: break
        #####mpercentile = float(m2sort.index(xm2sort[i][1])) / float(L)
        #####xpercentile = float(x2sort.index(mx2sort[i][1])) / float(L)
    
        #####if mpercentile > 0.35: xspec_pred.append(xm2sort[i][2])
        #####if xpercentile > 0.35: mspec_pred.append(mx2sort[i][2])
    #####xf = open('/home/bartolo/web/xspec_pred_expressing.txt', 'w')
    #####for i in range(len(xspec_pred)): xf.write(str(xspec_pred[i]) + '\n')
    #####xf.close()
    #####mf = open('/home/bartolo/web/mspec_pred_expressing.txt', 'w')
    #####for i in range(len(mspec_pred)): mf.write(str(mspec_pred[i]) + '\n')
    #####mf.close()
        
    #####print 'Making plots...'
        
    #####import matplotlib
    #####matplotlib.use( 'Agg' )

    #####import pylab
    #####pylab.rcParams['xtick.labelsize'] = '8'
    #####pylab.rcParams['ytick.labelsize'] = '8'

    #####matplotlib.pyplot.subplot(441)
    #####matplotlib.pyplot.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(yeast_full[0]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #####t = ttest(pylab.array(jmb_xspec[1]), pylab.array(yeast_full[0]))
    #####pylab.title('Bcl-xL yeast lib. (t=' + t + ')', fontsize=8)
    #####pylab.yticks([])
    #####pylab.xticks([])

    #####matplotlib.pyplot.subplot(442)
    #####matplotlib.pyplot.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(yeast_full[1]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #####t = ttest(pylab.array(jmb_mspec[2]), pylab.array(yeast_full[1]))
    #####pylab.title('Mcl-1 yeast lib. (t=' + t + ')', fontsize=8)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    #####matplotlib.pyplot.subplot(4, 4, 3)
    #####t1 = ttest(pylab.array(w_yeast_spec), pylab.array(w_yeast_full))
    #####matplotlib.pyplot.title('Bcl-w yeast lib. (t1=' + t1 + ')', fontsize=8)
    #####matplotlib.pyplot.hist(pylab.array(w_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(w_yeast_spec), normed=True, facecolor='white', edgecolor='green', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    #####matplotlib.pyplot.subplot(4, 4, 4)
    #####t1 = ttest(pylab.array(b_yeast_spec), pylab.array(b_yeast_full))
    #####matplotlib.pyplot.title('Bcl-2 yeast lib. (t1=' + t1 + ')', fontsize=8)
    #####matplotlib.pyplot.hist(pylab.array(b_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(b_yeast_spec), normed=True, facecolor='white', edgecolor='cyan', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    #####matplotlib.pyplot.subplot(4, 4, 5)
    #####t1 = ttest(pylab.array(f_yeast_spec), pylab.array(f_yeast_full))
    #####matplotlib.pyplot.title('Bfl-1 yeast lib. (t1=' + t1 + ')', fontsize=8)
    #####matplotlib.pyplot.hist(pylab.array(f_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(f_yeast_spec), normed=True, facecolor='white', edgecolor='black', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    #####for i in range(5):
        #####matplotlib.pyplot.subplot(4, 4, 6 + i)
        #####if i in [0, 1, 2, 3, 4]:
            #####genome_array = pylab.array(genome[i])
        #####matplotlib.pyplot.hist(genome_array, facecolor='white', edgecolor=colors[i], lw=2)
        #####matplotlib.pyplot.xlim(min(genome_array), max(genome_array))
        #####matplotlib.pyplot.ylim(0, 6500)
        #####for j in range(len(natural[0])):
            #####matplotlib.pyplot.annotate(natural_names[j], (natural[1 + i][j], 700 + 700 * j), xycoords='data', xytext=(0.0, 20.0), textcoords='offset points', arrowprops=dict(arrowstyle="->"), fontsize=8, horizontalalignment='right', verticalalignment='top')
        ######matplotlib.pyplot.text(mean(genome_array), 5500, rvec[i], fontsize=10)
    #####else:
        #####matplotlib.pyplot.plot(pylab.array([0, 1, 2, 3, 4, 5]), pylab.array([0, 0, 0, 0, 0, 0]))
        #####matplotlib.pyplot.plot(pylab.array([0, 0, 0, 0, 0, 0]), pylab.array([0, 1, 2, 3, 4, 5]))
    #####pylab.title(rvec[i] + ' genome scan', fontsize=8)
        #####pylab.yticks([])
        #####pylab.xticks([])
        
    #####matplotlib.pyplot.subplot(4, 4, 11)
    #####matplotlib.pyplot.title('Comb. Lib. SPOT specificity', fontsize=8)
    #####xa = pylab.array(xm_360spec[1])
    #####ya = pylab.array(xm_360spec[0])
    #####R = str(pylab.corrcoef(xa, ya)[0][1])
    #####matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R[0:min(4, len(R))], fontsize=10)
    #####matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #####matplotlib.pyplot.yticks([])
    #####matplotlib.pyplot.xticks([])
        
    #####matplotlib.pyplot.subplot(4, 4, 12)
    #####for i in range(len(roc360)):
        #####xsa = pylab.array(roc360[i][0][1])
        #####xea = pylab.array(roc360[i][0][0])
        #####matplotlib.pyplot.figtext(0.77, 0.32 + float(i) * 0.02, rvec[i]+'(AUC='+str(round(roc360[i][1], 2))+')', fontdict=None, fontsize=8, color=colors[i])
        #####matplotlib.pyplot.plot(xea, xsa, c=colors[i], label=rvec[i]+'('+str(round(roc360[i][1], 2))+')')
    #####matplotlib.pyplot.title('SPOT array prediction', fontsize=8)
    #####matplotlib.pyplot.xlim(-0.02, 1.0)
    #####matplotlib.pyplot.ylim(0, 1.02)
    #####matplotlib.pyplot.yticks([])
    #####matplotlib.pyplot.xticks([])
    
    #####matplotlib.pyplot.subplot(4, 4, 13)
    #####matplotlib.pyplot.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #####t = ttest(pylab.array(jmb_xspec[3]), pylab.array(jmb_mspec[3]))
    #####pylab.title('Bcl-xL, Mcl-1 spec. (t=' + t + ')', fontsize=8)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    #####matplotlib.pyplot.subplot(4, 4, 14)
    #####t = ttest(pylab.array(deep_xspec_50[3]), pylab.array(deep_mspec_50[3]))
    #####matplotlib.pyplot.title('Deep spec. (t=' + t + ')', fontsize=8)
    #####matplotlib.pyplot.hist(pylab.array(deep_xspec_50[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #####matplotlib.pyplot.hist(pylab.array(deep_mspec_50[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #####pylab.yticks([])
    #####pylab.xticks([])
    
    ######matplotlib.pyplot.subplot(4, 4, 15)
    ######matplotlib.pyplot.title('Gelman specificity', fontsize=8)
    ######xa = pylab.array(Gelman[5])
    ######ya = pylab.array(Gelman[4])
    ######R = str(pylab.corrcoef(xa, ya)[0][1])
    ######matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R[0:min(4, len(R))], fontsize=10)
    ######matplotlib.pyplot.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    ######matplotlib.pyplot.yticks([])
    ######matplotlib.pyplot.xticks([])
    
    #####matplotlib.pyplot.savefig(opath)
    
def pssm_enrich():

    SPOT_vec = PSSM5()
    SPOT_bad_noxa_vec = PSSM_bad_noxa()
    
    dr = ['x', 'm', 'w', 'f', '2', 'bad', 'noxa']
    
    jmb_xspec_lines = readlines('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_lines = readlines('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')
    deep_xspec_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    deep_mspec_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    
    deep_faffin_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt')
    deep_waffin_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt')
    deep_2affin_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt')
    deep_xaffin_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt')
    deep_maffin_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt')
    yeast_full_lines = readlines('/home/bartolo/web/statium/data/yeast_full_lib.txt')
    bfl1_yeast_full_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt')
    w2_yeast_full_lines = readlines('/home/bartolo/web/statium/deepseq/w2/w2_full.txt')
    
    data_vec = []
    data_vec.append(['JMB_xspec', jmb_xspec_lines, yeast_full_lines])
    data_vec.append(['JMB_mspec', jmb_mspec_lines, yeast_full_lines])
    data_vec.append(['deep_xspec', deep_xspec_lines, yeast_full_lines])
    data_vec.append(['deep_mspec', deep_mspec_lines, yeast_full_lines])
    data_vec.append(['deep_xaffin', deep_xaffin_lines, yeast_full_lines])
    data_vec.append(['deep_maffin', deep_maffin_lines, yeast_full_lines])
    data_vec.append(['deep_faffin', deep_faffin_lines, bfl1_yeast_full_lines])
    data_vec.append(['deep_waffin', deep_waffin_lines, w2_yeast_full_lines])
    data_vec.append(['deep_2affin', deep_2affin_lines, w2_yeast_full_lines])
    
    count = 0
    for i in range(7):
        for j in range(len(data_vec)):
        
        op = '/home/bartolo/web/statium/bootstrap/' + dr[i] + '_' + data_vec[j][0] + '_enrich_pssm_bootstrap.txt'
        #if os.path.exists(op): continue
        use = False
        if i == 3 and j == 6: use = True
        #if i == 5 and j == 4: use = True
        if not use: continue
        print op
        print dr[i], data_vec[j][0],
    
        jmb_xsort = []
        for line in data_vec[j][1]:
        seq = line.strip()
                energy_pssm = pssm_energy10(SPOT_vec, seq)
                bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
                if i >= 0 and i <= 4: e = energy_pssm[i]
                elif i == 5: e = bn_energy_pssm[0]
                elif i == 6: e = bn_energy_pssm[1]
        jmb_xsort.append(e)
    
        x2sort = []
        for line in data_vec[j][2]:
        seq = line.strip()
                energy_pssm = pssm_energy10(SPOT_vec, seq)
                bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
                if i >= 0 and i <= 4: e0 = energy_pssm[i]
                elif i == 5: e0 = bn_energy_pssm[0]
                elif i == 6: e0 = bn_energy_pssm[1]
        x2sort.append(e0)
        
        x2sort.sort()
        jmb_xsort.sort()
        enrich0_e_vec = []
    
        
        enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
        for k in range(len(jmb_xsort)): enrich0_e_vec.append(enrich0_e)
        enrich0 = False
        for k in range(len(jmb_xsort)):
        if jmb_xsort[k] >= enrich0_e:
            enrich_orig = round(float(k) / float(len(jmb_xsort)), 2)
            enrich0 = True
            break
        if not enrich0: enrich_orig = 1.0
        
        print enrich_orig
        
        bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')
        
        #if not os.path.exists(op): bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')
            #elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')


def pssm_affinity_pred():

    percut = 0.3
    SPOT_vec = PSSM5()
    SPOT_bad_noxa_vec = PSSM_bad_noxa()

    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    
    dr = ['X', 'M', 'W', 'F', '2', 'Xbad', 'Mnoxa']

    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-Bad', 'Mcl-1-Noxa']

    lib_spot_sort_affm = []
    lib_spot_sort_affx = []
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]

        lib_spot_sort_affm.append([msig, seq])
        lib_spot_sort_affx.append([xsig, seq])

    lib_spot_sort_affm.sort()
    lib_spot_sort_affx.sort()


    for eidx in range(7):
        print rvec[eidx]
        print

        x_lib_spot_pred = [[], []]
        m_lib_spot_pred = [[], []]
        for i in range(len(SPOT360)):
            xseq = lib_spot_sort_affx[i][1]
        mseq = lib_spot_sort_affm[i][1]
            energy_pssm_x = pssm_energy10(SPOT_vec, xseq)
            bn_energy_pssm_x = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, xseq)
            energy_pssm_m = pssm_energy10(SPOT_vec, mseq)
            bn_energy_pssm_m = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, mseq)
            if eidx >= 0 and eidx <= 4:
        ex = energy_pssm_x[eidx]
        em = energy_pssm_m[eidx]
            elif eidx == 5:
        ex = bn_energy_pssm_x[0]
                em = bn_energy_pssm_m[0]
            elif eidx == 6:
        ex = bn_energy_pssm_x[1]
        em = bn_energy_pssm_m[1]
            if float(i) < percut * float(len(SPOT360)):
                x_lib_spot_pred[0].append(0)
                m_lib_spot_pred[0].append(0)
                x_lib_spot_pred[1].append(ex)
                m_lib_spot_pred[1].append(em)
            if float(i) > (float(len(SPOT360)) - percut * float(len(SPOT360))):
                x_lib_spot_pred[0].append(1)
                m_lib_spot_pred[0].append(1)
                x_lib_spot_pred[1].append(ex)
                m_lib_spot_pred[1].append(em)

        x_lib_spot_roc = pyroc(x_lib_spot_pred)
        m_lib_spot_roc = pyroc(m_lib_spot_pred)
        print 'libX', round(x_lib_spot_roc[1], 2), len(x_lib_spot_pred[0])
        print 'libM', round(m_lib_spot_roc[1], 2), len(m_lib_spot_pred[0])
    print
    print

        op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Xpred_pssm_bootstrap.txt'
        if not os.path.exists(op): bootstrap_coyote(op, 2000, x_lib_spot_pred, x_lib_spot_roc[1], 'auc')
        elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, x_lib_spot_pred, x_lib_spot_roc[1], 'auc')

        op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Mpred_pssm_bootstrap.txt'
        if not os.path.exists(op): bootstrap_coyote(op, 2000, m_lib_spot_pred, m_lib_spot_roc[1], 'auc')
        elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, m_lib_spot_pred, m_lib_spot_roc[1], 'auc') 


def pssm_bench(opath):
  
    import pylab
    
    #print pylab.cm.datad['RdBu_r']
    
    SPOT_vec = PSSM5()
    SPOT_bad_noxa_vec = PSSM_bad_noxa()
    
    idx_vec = [2, 3, 4, 5, 6]
    colors = ['b', 'r', 'g', 'k', 'c']
    colorsf = ['blue', 'red', 'green', 'black', 'cyan']
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2']
    bn_rvec = ['Bcl-xL-Bad', 'Mcl-1-Noxa']
    
    jmb_xspec_lines = readlines('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_lines = readlines('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')
    deep_xspec_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    deep_mspec_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    deep_xaffin_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt')
    deep_maffin_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt')
    deep_xspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro_25.txt')
    deep_mspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro_25.txt')
    yeast_full_lines = readlines('/home/bartolo/web/statium/data/yeast_full_lib.txt')
    genome_lines = readlines('/home/bartolo/web/statium/BH3_test_seq.txt')
    bfl1_yeast_full_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt')
    bfl1_yeast_spec_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr_10.txt')
    w2_yeast_full_lines = readlines('/home/bartolo/web/statium/deepseq/w2/w2_full.txt')
    w_yeast_spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort_25.txt')
    b_yeast_spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort_25.txt')
    
    jmb_fspec_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt')
    jmb_wspec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt')
    jmb_2spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt')
    
    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')
    
    Gelman_data = lines2list('/home/bartolo/web/statium/data/Gelman.txt')
    
    print 'Analysing genome data...'
    genome = [[], [], [], [], []]
    for i in range(5):
        print rvec[i]
        for j in range(len(genome_lines)):
        seq = genome_lines[j].strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
            genome[i].append(energy_pssm[i])
 
    #import matplotlib
    #matplotlib.use( 'Agg' )
   
    for i in range(5):
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.rcParams['xtick.labelsize'] = '20'
        pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad']='8'
        pylab.rcParams['ytick.major.pad']='8'
        pylab.hist(pylab.array(genome[i]), normed=False, facecolor='white', edgecolor='black', lw=2)
        pylab.ylim(0, 5000)
        if i != 1 and i != 2: pylab.yticks([])
        ##pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/genome_pssm_' + rvec[i] + '.png')
        pylab.close()
    print 'genome done...'
    
    #print 'Analysing Specific yeast sequences...'
    
    #jmb_xsort = []
    #jmb_xspec = [[], [], [], []]
    #for line in jmb_xspec_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
        #jmb_xspec[0].append(seq)
        #jmb_xspec[1].append(energy_pssm[0])
        ##
        #jmb_xsort.append(energy_pssm[0])
        ##
        #jmb_xspec[2].append(energy_pssm[1])
        #jmb_xspec[3].append(jmb_xspec[1][-1] - jmb_xspec[2][-1])
    #jmb_msort = []
    #jmb_mspec = [[], [], [], []]
    #for line in jmb_mspec_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
        #jmb_mspec[0].append(seq)
        #jmb_mspec[1].append(energy_pssm[0])
        ##
        #jmb_msort.append(energy_pssm[1])
        ##
        #jmb_mspec[2].append(energy_pssm[1])
        #jmb_mspec[3].append(jmb_mspec[1][-1] - jmb_mspec[2][-1])
        
    #jmb_xsort.sort()
    #jmb_msort.sort()
        
    #deep_xspec = [[], [], [], []]
    #for line in deep_xspec_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #deep_xspec[0].append(seq)
        #deep_xspec[1].append(energy_pssm[0])
        #deep_xspec[2].append(energy_pssm[1])
        #deep_xspec[3].append(deep_xspec[1][-1] - deep_xspec[2][-1])
    #deep_mspec = [[], [], [], []]
    #for line in deep_mspec_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #deep_mspec[0].append(seq)
        #deep_mspec[1].append(energy_pssm[0])
        #deep_mspec[2].append(energy_pssm[1])
        #deep_mspec[3].append(deep_mspec[1][-1] - deep_mspec[2][-1])
    #deep_xspec_50 = [[], [], [], []]
    #for line in deep_xspec_50_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #deep_xspec_50[0].append(seq)
        #deep_xspec_50[1].append(energy_pssm[0])
        #deep_xspec_50[2].append(energy_pssm[1])
        #deep_xspec_50[3].append(deep_xspec_50[1][-1] - deep_xspec_50[2][-1])
    #deep_mspec_50 = [[], [], [], []]
    #for line in deep_mspec_50_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #deep_mspec_50[0].append(seq)
        #deep_mspec_50[1].append(energy_pssm[0])
        #deep_mspec_50[2].append(energy_pssm[1])
        #deep_mspec_50[3].append(deep_mspec_50[1][-1] - deep_mspec_50[2][-1])
        
    #print
    #print 'Analysing Mcl-1 and Bcl-xL full yeast libraries...'
    #yeast_full = [[], []]
    #for line in yeast_full_lines:
        #seq = line.strip()
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
        #yeast_full[0].append(energy_pssm[0])
        #yeast_full[1].append(energy_pssm[1])
        
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', lw=2, alpha=0.8)
    #pylab.ylim(0, 12)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium/yeast_spec_pssm_jmb.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
        
    #x_yeast_full = []
    #m_yeast_full = []
    #for i in range(len(yeast_full[0])):
        #x_yeast_full.append(yeast_full[0][i])
        #m_yeast_full.append(yeast_full[1][i])
        
    #x2sort = []
    #m2sort = []
    #for i in range(len(x_yeast_full)):
        #x2sort.append(x_yeast_full[i])
        #m2sort.append(m_yeast_full[i])
        
    #x2sort.sort()
    #m2sort.sort()
    
    #enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
    #enrich0 = False
    #for i in range(len(jmb_xsort)):
        #if jmb_xsort[i] >= enrich0_e:
        #print 'enrich1:', float(i) / float(len(jmb_xsort))
        #enrich0 = True
        #break
    #if not enrich0: print 'enrich1:', 1.0
    
    #enrich0_e = m2sort[int(float(len(m2sort)) * 0.20)]
    #enrich0 = False
    #for i in range(len(jmb_msort)):
        #if jmb_msort[i] >= enrich0_e:
        #print 'enrich2:', float(i) / float(len(jmb_msort))
        #enrich0 = True
        #break
    #if not enrich0: print 'enrich2:', 1.0
    #return
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xsort), normed=True, facecolor='white', edgecolor='black', lw=2)
    #pylab.hist(pylab.array(yeast_full[0]), normed=True, facecolor='gray', edgecolor='gray', alpha=0.45, lw=2)
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/M_hist_pssm.png')
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', lw=2)
    #pylab.hist(pylab.array(yeast_full[1]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/M_hist_pssm.png')
    #pylab.close()
    

    #enrich_x = [[], []]
    #enrich0_e = min(jmb_xsort[0], x2sort[0])
    #c0 = 0.1
    #while True:
        #jmbc = 0
        #for i in range(len(jmb_xsort)):
        #if jmb_xsort[i] < enrich0_e + c0: jmbc += 1
        #fullc = 0
        #for i in range(len(x2sort)):
        #if x2sort[i] < enrich0_e + c0: fullc += 1
    #enrich_x[0].append(float(fullc) / float(len(x2sort)))
    #enrich_x[1].append(float(jmbc) / float(len(jmb_xsort)))
    #c0 += 0.1
    #print (float(fullc) / float(len(x2sort))), float(jmbc) / float(len(jmb_xsort))
    #if enrich0_e + c0 > x2sort[-1]: break
    
    #ofile = open('/home/bartolo/web/statium/X_enrich_pssm.txt', 'w')
    #for i in range(len(enrich_x[0])): ofile.write(str(enrich_x[1][i]) + '\t' + str(enrich_x[0][i]) + '\n')
    #ofile.close()
    
    ########print
    #enrich_m = [[], []]
    #enrich0_e = min(jmb_msort[0], m2sort[0])
    #c0 = 0.1
    #while True:
        #jmbc = 0
        #for i in range(len(jmb_msort)):
        #if jmb_msort[i] < enrich0_e + c0: jmbc += 1
        #fullc = 0
        #for i in range(len(m2sort)):
        #if m2sort[i] < enrich0_e + c0: fullc += 1
    #enrich_m[0].append(float(fullc) / float(len(m2sort)))
    #enrich_m[1].append(float(jmbc) / float(len(jmb_msort)))
    #c0 += 0.1
    #print (float(fullc) / float(len(m2sort))), float(jmbc) / float(len(jmb_msort))
    #if enrich0_e + c0 > m2sort[-1]: break
    
    #ofile = open('/home/bartolo/web/statium/M_enrich_pssm.txt', 'w')
    #for i in range(len(enrich_m[0])): ofile.write(str(enrich_m[1][i]) + '\t' + str(enrich_m[0][i]) + '\n')
    #ofile.close()
    
    percut = 0.3
    
    #import pylab
    #print 'Analysing Gelman data...'

    #gel_spec = []
    #gel_xaffin = []
    #gel_maffin = []
    #L = len(Gelman_data)
    #Gelman = [[[], []], [[], []], [[], []]]
    #for i in range(L):
        #seq = Gelman_data[i][0]
        #wt_pssm = pssm_energy10(SPOT_vec, 'PEIWIAQELRRIGDEFNAYYARR')
        #xwte = wt_pssm[0]
        #mwte = wt_pssm[1]
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #xsig = math.log10(Gelman_data[i][1]) - math.log10(110.0)
        #msig = math.log10(Gelman_data[i][2]) - math.log10(4.0)
        #xe = energy_pssm[0]
    #me = energy_pssm[1]
        #if me != 0.0:
        #if xwte != xe:
            ##print seq, xsig, msig, xe, me
            #gel_spec.append([xsig - msig, xe - me, seq])
        #gel_xaffin.append([xsig, xe, seq])
        #gel_maffin.append([msig, me, seq])
        
        #Gelman[0][0].append(xsig - msig)
        #Gelman[0][1].append(xe - me)
        
        #Gelman[1][0].append(xsig)
        #Gelman[1][1].append(xe)
        
        #Gelman[2][0].append(msig)
        #Gelman[2][1].append(me)
    
    ##print len(gel_spec)
    #gel_spec.sort()
    #gel_xaffin.sort()
    #gel_maffin.sort()
    
    #gel_spec_pred = [[], []]
    #gel_xaffin_pred = [[], []]
    #gel_maffin_pred = [[], []]
    
    #L = len(gel_xaffin)
    #for i in range(L):
        #if float(i) < percut * float(L):
        #gel_xaffin_pred[0].append(0)
        #gel_maffin_pred[0].append(0)
        #gel_spec_pred[0].append(0)
        #gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #gel_maffin_pred[1].append(gel_maffin[i][1])
        #gel_spec_pred[1].append(gel_spec[i][1])
    #if float(i) > (float(L) - percut * float(L)):
        #gel_xaffin_pred[0].append(1)
        #gel_maffin_pred[0].append(1)
        #gel_spec_pred[0].append(1)
        #gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #gel_maffin_pred[1].append(gel_maffin[i][1])
        #gel_spec_pred[1].append(gel_spec[i][1])
    #print len(gel_spec_pred[1])
    
    #gel_spec_roc = pyroc(gel_spec_pred)
    #gel_xaffin_roc = pyroc(gel_xaffin_pred)
    #gel_maffin_roc = pyroc(gel_maffin_pred)
    
    #print
    #print 'Gellman specificity AUC:', round(gel_spec_roc[1], 2)
    #print 'Gellman Bclxl affinity AUC:', round(gel_xaffin_roc[1], 2)
    #print 'Gellman Mcl-1 affinity AUC:', round(gel_maffin_roc[1], 2)
    #print

    #pylab.close()
    #import matplotlib
    #matplotlib.use( 'Agg' )    
    #import pylab
    #xa = pylab.array(Gelman[2][1])
    #ya = pylab.array(Gelman[2][0])
    #R = str(pylab.corrcoef(xa, ya)[0][1])
    #print 'Gelman R', R
    ##pylab.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.95 + min(ya), 'R=' + R[0:min(4, len(R))], fontsize=20)
    #pylab.scatter(xa, ya, c='k', marker='o', s=50, facecolor='none', edgecolors='k')
    ##matplotlib.pyplot.yticks([])
    ##matplotlib.pyplot.xticks([])
    #pylab.savefig('/home/bartolo/web/statium_noref/gelman_maffin.png')
        
        
    print 'Analysing library SPOT data...'
    lib_spot_sort_affm = []
    lib_spot_sort_affx = []
    lib_spot_sort_spec = []
    lib_corrx = [[], []]
    lib_corrm = [[], []]
    L = len(SPOT360)
    for i in range(L):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        ev = pssm_energy10(SPOT_vec, seq)
        
        lib_spot_sort_affm.append([msig, ev[1], seq])
        lib_spot_sort_affx.append([xsig, ev[0], seq])
        lib_spot_sort_spec.append([xsig - msig, ev[0] - ev[1], seq])
        
        lib_corrx[0].append(xsig)
        lib_corrx[1].append(ev[0])
        lib_corrm[0].append(msig)
        lib_corrm[1].append(ev[1])
        
    print 'xaffin corr', round(pylab.corrcoef(pylab.array(lib_corrx[0]), pylab.array(lib_corrx[1]))[0][1], 2)
    print 'maffin corr', round(pylab.corrcoef(pylab.array(lib_corrm[0]), pylab.array(lib_corrm[1]))[0][1], 2)
    
    lib_spot_sort_affm.sort()
    lib_spot_sort_affx.sort()
    lib_spot_sort_spec.sort()
    
    x_lib_spot_pred = [[], []]
    m_lib_spot_pred = [[], []]
    spec_lib_spot_pred = [[], []]
    for i in range(L):
        if float(i) < percut * float(L):
        x_lib_spot_pred[0].append(0)
        m_lib_spot_pred[0].append(0)
        spec_lib_spot_pred[0].append(0)
        x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
        m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])
        spec_lib_spot_pred[1].append(lib_spot_sort_spec[i][1])
    if float(i) > (float(L) - percut * float(L)):
        x_lib_spot_pred[0].append(1)
        m_lib_spot_pred[0].append(1)
        spec_lib_spot_pred[0].append(1)
        x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
        m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])
        spec_lib_spot_pred[1].append(lib_spot_sort_spec[i][1])
    
    print len(x_lib_spot_pred[1])
    x_lib_spot_roc = pyroc(x_lib_spot_pred)
    m_lib_spot_roc = pyroc(m_lib_spot_pred)
    spec_lib_spot_roc = pyroc(spec_lib_spot_pred)
    roc360 = []
    roc360.append(x_lib_spot_roc)
    roc360.append(m_lib_spot_roc)
    
    print 'Library array specificity AUC:', round(spec_lib_spot_roc[1], 2)
    print 'Library array Bclxl affinity AUC:', round(x_lib_spot_roc[1], 2)
    print 'Library array Mcl-1 affinity AUC:', round(m_lib_spot_roc[1], 2)
    print
    
    xm_360spec = [[], []]
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        ev = pssm_energy10(SPOT_vec, seq)
        if xsig < 0.5 or msig < 0.5:
        ediff = ev[0] - ev[1]
        xm_360spec[0].append(xsig - msig)
        xm_360spec[1].append(ediff)
    print
    import pylab
    print 'lib SPOT R', round(pylab.corrcoef(pylab.array(xm_360spec[0]), pylab.array(xm_360spec[1]))[0][1], 2)
    pylab.close()
    
    of = open('/home/bartolo/web/statium/xm_360_spec_pssm_bootstrap.txt', 'w')
    Rs = []
    for i in range(2000):
        v = [[], []]
        for j in range(len(xm_360spec[0])):
        rint = random.randint(0, len(xm_360spec[0]) - 1)
        v[0].append(xm_360spec[0][rint])
        v[1].append(xm_360spec[1][rint])
    R = pylab.corrcoef(pylab.array(v[0]), pylab.array(v[1]))[0][1]
    Rs.append(R)
    Rs.sort()
    for i in range(len(Rs)):
    of.write(str(Rs[i]) + '\n')
    of.close()
    
    ofile = open('/home/bartolo/web/statium/spec360_pssm.txt', 'w')
    for i in range(len(xm_360spec[0])):
        ofile.write(str(xm_360spec[0][i]) + '\t' + str(xm_360spec[1][i]) + '\n')
    ofile.close()
    
    natural = [['PEIWIAQELRRIGDEFNAYYARR', 'WAREIGAQLRRMADDLNAQYERR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'TMGQVGRQLAIIGDDINRRYDSE', 'AAQLTAARLKALGDELHQRTMWR', 'MTQEVGQLLQDMGDDVYQQYRSL'], [], [], [], [], []]
    natural_names = ['Bim', 'Puma', 'Noxa', 'Bad', 'Bak', 'Hrk', 'Mule']
    for i in range(len(natural[0])): 
        #print natural_names[i], statium_energy_calc(evec[0], natural[0][i], 1.0)
        energy_pssm = pssm_energy10(SPOT_vec, natural[0][i])
        natural[1].append(energy_pssm[0])
        natural[2].append(energy_pssm[1])
        natural[3].append(energy_pssm[2])
        natural[4].append(energy_pssm[3])
        natural[5].append(energy_pssm[4])
        
    natural_rank = [[], [], [], [], []]
    natural2 = [['PEIWIAQELRRIGDEFNAYYARR', 'WAREIGAQLRRMADDLNAQYERR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'AAQLTAARLKALGDELHQRTMWR', 'IIRNIARHLAQVGDSMDRSIPPG', 'GSDALALRLACIGDEMDVSLRAP', 'AEVQIARKLQCIADQFHRLHVQQ', 'MTQEVGQLLQDMGDDVYQQYRSL', 'RLAEVCAVLLRLGDELEMIRPSV'], [], [], [], [], []]
    natural_names2 = ['Bim', 'Puma', 'Noxa', 'Bad', 'Hrk', 'Bid', 'Bik', 'Bmf', 'Mule', 'Bok']
    
    energy_pssm_puma = pssm_energy10(SPOT_vec, 'WAREIGAQLRRMADDLNAQYERR')
    energy_pssm_bak = pssm_energy10(SPOT_vec, 'TMGQVGRQLAIIGDDINRRYDSE')
    energy_pssm_hrk = pssm_energy10(SPOT_vec, 'AAQLTAARLKALGDELHQRTMWR')
    
    for i in range(len(natural2[0])):
        energy_pssm = pssm_energy10(SPOT_vec, natural2[0][i])
        for j in range(5):
        ave = energy_pssm_puma[j]
            natural_rank[j].append(energy_pssm[j])
        
    for i in range(5):
        print rvec[i]
        for j in range(len(natural_names2)):
        print natural_names2[j], natural_rank[i][j]
    print
    print
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    
    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == bim:
            wt200_count += 1.0
            wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    print
    print 'SPOT200 binding...'
    spot200_affin = []
    for i in range(len(idx_vec)):
        spot200_affin.append([])

    for i in range(5):
    idx = idx_vec[i]
        for row in SPOT200:
            seq = row[0][0:23]
            energy_pssm = pssm_energy10(SPOT_vec, seq)
            energy_pssm_wt = pssm_energy10(SPOT_vec, 'PEIWIAQELRRIGDEFNAYYARR')
            dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
            e = energy_pssm[i]
            ewt = energy_pssm_wt[i]
            
            if e != ewt: spot200_affin[i].append([dsig, e, seq])
        spot200_affin[i].sort()
    L = len(spot200_affin[0])
    
    spot200_affin_pred = []
    for i in range(len(idx_vec)):
        spot200_affin_pred.append([[], []])
    spot200_affin_corr = []
    for i in range(len(idx_vec)):
        spot200_affin_corr.append([[], []])
        
    for i in range(5):
        L = len(spot200_affin[i])
        for j in range(L):
        spot200_affin_corr[i][0].append(spot200_affin[i][j][0])
        spot200_affin_corr[i][1].append(spot200_affin[i][j][1])
            if float(j) < percut * float(L):
            spot200_affin_pred[i][0].append(0)
            spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
        if float(j) > (float(L) - percut * float(L)):
            spot200_affin_pred[i][0].append(1)
            spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
    print len(spot200_affin_pred[i][0])
            
    import pylab
    for i in range(5):
        #if i == 0:
        #pylab.scatter(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
        #pylab.savefig('/home/bartolo/web/test2.png')  
        v = pyroc(spot200_affin_pred[i])
        print rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]))[0][1], 2)
        
    print 'Bad and Noxa SPOT substitution binding...'
    spot200_affin_bn = []
    for i in range(2):
        spot200_affin_bn.append([])

    for i in range(len(bad_data)):
        seq = bad_data[i][0]
        dsig = bad_data[i][1]
        if seq == 'AAQRYGRELRRMSDEFVDSFKKG': continue
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        e = energy_pssm[0]
        if e == 0.0: continue
        spot200_affin_bn[0].append([dsig, e, seq])
    spot200_affin_bn[0].sort()
    
    noxa_hist = []
    for i in range(len(noxa_data)):
        seq = noxa_data[i][0]
        dsig = noxa_data[i][1]
        noxa_hist.append(dsig)
        if seq == 'LEVECATQLRRFGDKLNFRQKLL': continue
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        e = energy_pssm[1]
        if e == 0.0: continue
        spot200_affin_bn[1].append([dsig, e, seq])
    spot200_affin_bn[1].sort()
    
    spot200_affin_pred_bn = []
    for i in range(2):
        spot200_affin_pred_bn.append([[], []])
        
    spot200_affin_corr_bn = []
    for i in range(2):
        spot200_affin_corr_bn.append([[], []])
        
    for i in range(2):
        L = len(spot200_affin_bn[i])
        for j in range(L):
        spot200_affin_corr_bn[i][0].append(spot200_affin_bn[i][j][0])
        spot200_affin_corr_bn[i][1].append(spot200_affin_bn[i][j][1])
            if float(j) < percut * float(L):
            spot200_affin_pred_bn[i][0].append(0)
            spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
        if float(j) > (float(L) - percut * float(L)):
            spot200_affin_pred_bn[i][0].append(1)
            spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
    print len(spot200_affin_pred_bn[i][1])
         
    import pylab
    for i in range(2):
        v = pyroc(spot200_affin_pred_bn[i])
        print bn_rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr_bn[i][0]), pylab.array(spot200_affin_corr_bn[i][1]))[0][1], 2)
        if i == 0:
        pylab.scatter(pylab.array(spot200_affin_corr_bn[i][0]), pylab.array(spot200_affin_corr_bn[i][1]))
            pylab.savefig('/home/bartolo/web/noxa_test.png')
    pylab.close()
    
    #print
        
    #M_lib_pred_file = open('/home/bartolo/web/statium/M_lib_pred_pssm.txt', 'w')
    #for i in range(len(jmb_mspec[0])):
    #M_lib_pred_file.write('0\t')
    #M_lib_pred_file.write(str(jmb_mspec[2][i]) + '\n')
    #for i in range(len(yeast_full[0])):
    #M_lib_pred_file.write('1\t')
    #M_lib_pred_file.write(str(yeast_full[1][i]) + '\n')
    #M_lib_pred_file.close()
    #return
    
    print 'Analysing Bfl-1 full yeast libraries...'
    f_yeast_full = []
    f_yeast_spec = []
    fm_yeast_spec = []
    count = 0
    for line in bfl1_yeast_full_lines:
        count += 1
        if count % 1000000 == 0: print count
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        f_yeast_full.append(energy_pssm[3])
        
    for line in bfl1_yeast_spec_lines:
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        f_yeast_spec.append(energy_pssm[3])
        #fm_yeast_spec.append(energy_pssm[1])
        
    print 'Analysing Bcl-2 and Bcl-w full yeast libraries...'
    w_yeast_full = []
    w_yeast_spec = []
    b_yeast_full = []
    b_yeast_spec = []
    count = 0
    for line in w2_yeast_full_lines:
        count += 1
        if count % 1000000 == 0: print count
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        w_yeast_full.append(energy_pssm[2])
        b_yeast_full.append(energy_pssm[4])
    for line in w_yeast_spec_lines:
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        w_yeast_spec.append(energy_pssm[2])
    for line in b_yeast_spec_lines:
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        b_yeast_spec.append(energy_pssm[4])
    
    print 'Analysing genome data...'
    genome = [[], [], [], [], []]
    for line in genome_lines:
        seq = line.strip()
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        for i in range(5): genome[i].append(energy_pssm[i])
        
    print 'Making plots...'
        
    import matplotlib
    matplotlib.use( 'Agg' )

    import pylab
    pylab.rcParams['xtick.labelsize'] = '8'
    pylab.rcParams['ytick.labelsize'] = '8'

    #for i in range(len(full_vec)):
        #for j in range(len(pos_vec)):
            #full_vec[i][5].append(stats.spearmanr(pylab.array(full_vec[i][3][j]), pylab.array(full_vec[i][4][j]))[0])
    
    #for i in range(len(full_vec)):

        #matplotlib.pyplot.subplot(441 + i)
    #pylab.text(6.0, -0.4, rvec[i], fontsize=10)
    #matplotlib.pyplot.bar(pylab.arange(len(spots)), pylab.array(full_vec[i][5]), 0.35, color='r', align='center')
        #pylab.yticks([])
        #pylab.xticks([])
    ##matplotlib.pyplot.xticks(pylab.arange(len(spots)), spots) ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    #matplotlib.pyplot.xlim(-1, len(pylab.arange(len(spots))))
    #matplotlib.pyplot.ylim(-0.6, 1)
        #pylab.yticks([])
        #pylab.xticks([])
    

    
    #matplotlib.pyplot.subplot(332)
    #matplotlib.pyplot.hist(pylab.array(deep_xspec[3]), normed=True, facecolor='blue', alpha=0.45)
    #matplotlib.pyplot.hist(pylab.array(deep_mspec[3]), normed=True, facecolor='red', alpha=0.45)
    #pylab.yticks([])
    #pylab.xticks([])

    matplotlib.pyplot.subplot(441)
    matplotlib.pyplot.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(yeast_full[0]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    t = ttest(pylab.array(jmb_xspec[1]), pylab.array(yeast_full[0]))
    pylab.title('Bcl-xL yeast lib. (t=' + t + ')', fontsize=8)
    pylab.yticks([])
    pylab.xticks([])

    matplotlib.pyplot.subplot(442)
    matplotlib.pyplot.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(yeast_full[1]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    t = ttest(pylab.array(jmb_mspec[2]), pylab.array(yeast_full[1]))
    pylab.title('Mcl-1 yeast lib. (t=' + t + ')', fontsize=8)
    pylab.yticks([])
    pylab.xticks([])
    
    matplotlib.pyplot.subplot(4, 4, 3)
    t1 = ttest(pylab.array(w_yeast_spec), pylab.array(w_yeast_full))
    matplotlib.pyplot.title('Bcl-w yeast lib. (t1=' + t1 + ')', fontsize=8)
    matplotlib.pyplot.hist(pylab.array(w_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(w_yeast_spec), normed=True, facecolor='white', edgecolor='green', alpha=0.45, lw=2)
    pylab.yticks([])
    pylab.xticks([])
    
    matplotlib.pyplot.subplot(4, 4, 4)
    t1 = ttest(pylab.array(b_yeast_spec), pylab.array(b_yeast_full))
    matplotlib.pyplot.title('Bcl-2 yeast lib. (t1=' + t1 + ')', fontsize=8)
    matplotlib.pyplot.hist(pylab.array(b_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(b_yeast_spec), normed=True, facecolor='white', edgecolor='cyan', alpha=0.45, lw=2)
    pylab.yticks([])
    pylab.xticks([])
    
    matplotlib.pyplot.subplot(4, 4, 5)
    t1 = ttest(pylab.array(f_yeast_spec), pylab.array(f_yeast_full))
    matplotlib.pyplot.title('Bfl-1 yeast lib. (t1=' + t1 + ')', fontsize=8)
    matplotlib.pyplot.hist(pylab.array(f_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(f_yeast_spec), normed=True, facecolor='white', edgecolor='black', alpha=0.45, lw=2)
    pylab.yticks([])
    pylab.xticks([])
    
    for i in range(5):
        matplotlib.pyplot.subplot(4, 4, 6 + i)
        if i in [0, 1, 2, 3, 4]:
            genome_array = pylab.array(genome[i])
        matplotlib.pyplot.hist(genome_array, facecolor='white', edgecolor=colors[i], lw=2)
        matplotlib.pyplot.xlim(min(genome_array), max(genome_array))
        matplotlib.pyplot.ylim(0, 6500)
        for j in range(len(natural[0])):
            matplotlib.pyplot.annotate(natural_names[j], (natural[1 + i][j], 700 + 700 * j), xycoords='data', xytext=(0.0, 20.0), textcoords='offset points', arrowprops=dict(arrowstyle="->"), fontsize=8, horizontalalignment='right', verticalalignment='top')
        #matplotlib.pyplot.text(mean(genome_array), 5500, rvec[i], fontsize=10)
    else:
        matplotlib.pyplot.plot(pylab.array([0, 1, 2, 3, 4, 5]), pylab.array([0, 0, 0, 0, 0, 0]))
        matplotlib.pyplot.plot(pylab.array([0, 0, 0, 0, 0, 0]), pylab.array([0, 1, 2, 3, 4, 5]))
    pylab.title(rvec[i] + ' genome scan', fontsize=8)
        pylab.yticks([])
        pylab.xticks([])
        
    matplotlib.pyplot.subplot(4, 4, 11)
    matplotlib.pyplot.title('Comb. Lib. SPOT specificity', fontsize=8)
    xa = pylab.array(xm_360spec[1])
    ya = pylab.array(xm_360spec[0])
    R = str(pylab.corrcoef(xa, ya)[0][1])
    matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R[0:min(4, len(R))], fontsize=10)
    matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    matplotlib.pyplot.yticks([])
    matplotlib.pyplot.xticks([])
        
    matplotlib.pyplot.subplot(4, 4, 12)
    for i in range(len(roc360)):
        xsa = pylab.array(roc360[i][0][1])
        xea = pylab.array(roc360[i][0][0])
        matplotlib.pyplot.figtext(0.77, 0.32 + float(i) * 0.02, rvec[i]+'(AUC='+str(round(roc360[i][1], 2))+')', fontdict=None, fontsize=8, color=colors[i])
        matplotlib.pyplot.plot(xea, xsa, c=colors[i], label=rvec[i]+'('+str(round(roc360[i][1], 2))+')')
    matplotlib.pyplot.title('SPOT array prediction', fontsize=8)
    matplotlib.pyplot.xlim(-0.02, 1.0)
    matplotlib.pyplot.ylim(0, 1.02)
    matplotlib.pyplot.yticks([])
    matplotlib.pyplot.xticks([])
    
    matplotlib.pyplot.subplot(4, 4, 13)
    matplotlib.pyplot.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    t = ttest(pylab.array(jmb_xspec[3]), pylab.array(jmb_mspec[3]))
    pylab.title('Bcl-xL, Mcl-1 spec. (t=' + t + ')', fontsize=8)
    pylab.yticks([])
    pylab.xticks([])
    
    matplotlib.pyplot.subplot(4, 4, 14)
    t = ttest(pylab.array(deep_xspec_50[3]), pylab.array(deep_mspec_50[3]))
    matplotlib.pyplot.title('Deep spec. (t=' + t + ')', fontsize=8)
    matplotlib.pyplot.hist(pylab.array(deep_xspec_50[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    matplotlib.pyplot.hist(pylab.array(deep_mspec_50[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    pylab.yticks([])
    pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 15)
    #matplotlib.pyplot.title('Gelman specificity', fontsize=8)
    #xa = pylab.array(Gelman[5])
    #ya = pylab.array(Gelman[4])
    #R = str(pylab.corrcoef(xa, ya)[0][1])
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R[0:min(4, len(R))], fontsize=10)
    #matplotlib.pyplot.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
    matplotlib.pyplot.savefig(opath)
    
def library_predict():
  
    fv = ['/home/bartolo/web/statium/M_enrich_pssm.txt', '/home/bartolo/web/statium/M_enrich_deep.txt', '/home/bartolo/web/statium/M_enrich_statium.txt']
    
    data = []
    for i in range(len(fv)):
        data.append([[0.0], [0.0]])
        dl = lines2list(fv[i])
        for j in range(len(dl)):
        data[i][0].append(dl[j][0])
        data[i][1].append(dl[j][1])
        
    marks = ['-', '-.', '--']
    colors = ['k', 'g', 'm']
    labels = [r'$PSSM_{SPOT}$', r'$PSSM_{DEEP}$', r'$STATIUM$']
        
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['savefig.dpi'] = '300'
    #pylab.rcParams['text.usetex'] = True
    for i in range(len(fv)):
        y = pylab.array(data[i][0])
        x = pylab.array(data[i][1])
        pylab.plot(x, y, colors[i], label=labels[i], lw=2)
    pylab.xlim(-0.02, 1.0)
    pylab.ylim(0, 1.02)
    #pylab.legend(loc='lower right')
    #pylab.title('Mcl-1 yeast sorting prediction')
    #leg.draw_frame(False)
    #pylab.ylabel('Fraction of verified binders', fontsize=)
    #pylab.xlabel('Fraction of full library')
    pylab.savefig('/home/bartolo/web/statium/M_lib_enrich.png')
    
def spec360_4plot():
  
    fv = ['/home/bartolo/web/statium/spec360_deep.txt', '/home/bartolo/web/statium/spec360_deepa.txt', '/home/bartolo/web/statium/spec360_pssm.txt', '/home/bartolo/web/statium/spec360_statium.txt']
    
    data = []
    for i in range(len(fv)):
        data.append([[], []])
        dl = lines2list(fv[i])
        for j in range(len(dl)):
        data[i][0].append(dl[j][0])
        data[i][1].append(dl[j][1])
        
    import pylab
    pylab.rcParams['xtick.labelsize'] = '10'
    pylab.rcParams['ytick.labelsize'] = '10'
    pylab.rcParams['savefig.dpi'] = '300'
    for i in range(len(fv)):
        pylab.subplot(2, 2, i + 1)
        ya = pylab.array(data[i][0])
        xa = pylab.array(data[i][1])
        pylab.ylim(-1.5, 2.0)
        #if i in [1, 3]: pylab.yticks([])
        pylab.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #pylab.xlim(-0.02, 1.0)
    
    #pylab.legend(loc='lower right')
    #pylab.title('Mcl-1 yeast sorting prediction')
    #leg.draw_frame(False)
    #pylab.ylabel('Fraction of verified binders', fontsize=)
    #pylab.xlabel('Fraction of full library')
    pylab.savefig('/home/bartolo/web/statium/spec360.png')
    
    #matplotlib.pyplot.subplot(4, 4, 11)
    #xa = pylab.array(xm_360spec[1])
    #ya = pylab.array(xm_360spec[0])
    #R = str(round(pylab.corrcoef(xa, ya)[0][1], 2))
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R, fontsize=10)
    #matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
def XM360_4plot():
  
    fv = ['/home/bartolo/web/statium/X360_affin.txt', '/home/bartolo/web/statium/M360_affin.txt']
    
    data = []
    for i in range(len(fv)):
        data.append([[], []])
        dl = lines2list(fv[i])
        for j in range(len(dl)):
        data[i][0].append(dl[j][0])
        data[i][1].append(dl[j][1])
        
    import pylab
    pylab.rcParams['xtick.labelsize'] = '10'
    pylab.rcParams['ytick.labelsize'] = '10'
    pylab.rcParams['savefig.dpi'] = '300'
    for i in range(len(fv)):
        pylab.subplot(2, 2, i + 1)
        ya = pylab.array(data[i][0])
        xa = pylab.array(data[i][1])
        pylab.ylim(-0.5, 2.0)
        #if i in [1, 3]: pylab.yticks([])
        pylab.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #pylab.xlim(-0.02, 1.0)
    
    #pylab.legend(loc='lower right')
    #pylab.title('Mcl-1 yeast sorting prediction')
    #leg.draw_frame(False)
    #pylab.ylabel('Fraction of verified binders', fontsize=)
    #pylab.xlabel('Fraction of full library')
    pylab.savefig('/home/bartolo/web/statium/XM360.png')
    
    #matplotlib.pyplot.subplot(4, 4, 11)
    #xa = pylab.array(xm_360spec[1])
    #ya = pylab.array(xm_360spec[0])
    #R = str(round(pylab.corrcoef(xa, ya)[0][1], 2))
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R, fontsize=10)
    #matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
def deep_enrich():

    x = 1.0
    xc = 0.0
    
    dr = ['xa', 'ma', 'wa', 'fa', '2a', 'x', 'm']
    
    evec = []
    for i in range(len(dr)): evec.append([deepe_matrix_coupling(dr[i]), dr[i]])
    
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-spec', 'Mcl-1-spec']
    
    jmb_xspec_lines = readlines('/home/bartolo/web/statium/data/jmb_bclxl_spec_noinvitro.txt')
    jmb_mspec_lines = readlines('/home/bartolo/web/statium/data/jmb_mcl1_spec_noinvitro.txt')
    deep_xspec_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    deep_mspec_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    
    deep_faffin_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt')
    deep_waffin_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt')
    deep_2affin_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt')
    deep_xaffin_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt')
    deep_maffin_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt')
    yeast_full_lines = readlines('/home/bartolo/web/statium/data/yeast_full_lib.txt')
    bfl1_yeast_full_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt')
    w2_yeast_full_lines = readlines('/home/bartolo/web/statium/deepseq/w2/w2_full.txt')
    
    data_vec = []
    data_vec.append(['JMB_xspec', jmb_xspec_lines, yeast_full_lines])
    data_vec.append(['JMB_mspec', jmb_mspec_lines, yeast_full_lines])
    data_vec.append(['deep_xspec', deep_xspec_lines, yeast_full_lines])
    data_vec.append(['deep_mspec', deep_mspec_lines, yeast_full_lines])
    data_vec.append(['deep_xaffin', deep_xaffin_lines, yeast_full_lines])
    data_vec.append(['deep_maffin', deep_maffin_lines, yeast_full_lines])
    data_vec.append(['deep_faffin', deep_faffin_lines, bfl1_yeast_full_lines])
    data_vec.append(['deep_waffin', deep_waffin_lines, w2_yeast_full_lines])
    data_vec.append(['deep_2affin', deep_2affin_lines, w2_yeast_full_lines])
    
    for i in range(len(evec)):
        for j in range(len(data_vec)):
        print dr[i], data_vec[j][0],
    
        ewt = deepe_calc_coupling(evec[i], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
        jmb_xsort = []
        for line in data_vec[j][1]:
        seq = line.strip()
        e = deepe_calc_coupling(evec[i], seq, x, xc)
        if e != ewt and e != -999.0: jmb_xsort.append(e)
    
        x2sort = []
        for line in data_vec[j][2]:
        seq = line.strip()
        e0 = deepe_calc_coupling(evec[i], seq, x, xc)
        if e0 != ewt and e0 != -999.0: x2sort.append(e0)
        
        x2sort.sort()
        jmb_xsort.sort()
        enrich0_e_vec = []
    
        
        enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
        for k in range(len(jmb_xsort)): enrich0_e_vec.append(enrich0_e)
        enrich0 = False
        for k in range(len(jmb_xsort)):
        if jmb_xsort[k] >= enrich0_e:
            enrich_orig = round(float(k) / float(len(jmb_xsort)), 2)
            enrich0 = True
            break
        if not enrich0: enrich_orig = 1.0
        print enrich_orig
        
        op = '/home/bartolo/web/statium/bootstrap/' + dr[i] + '_' + data_vec[j][0] + '_enrich_deep_bootstrap.txt'
        if not os.path.exists(op): bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')
            elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, [enrich0_e_vec, jmb_xsort], enrich_orig, 'enrich')


def deep_affinity_pred():

    percut = 0.3
    x = 1.0
    xc = 0.0

    dr = ['xa', 'ma', 'wa', 'fa', '2a', 'x', 'm']

    evec = []
    for i in range(len(dr)): evec.append([deepe_matrix_coupling(dr[i]), dr[i]])

    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-spec', 'Mcl-1-spec']

    idx_vec = [2, 3, 4, 5, 6, 7, 8]

    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')

    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-Bad', 'Mcl-1-Noxa']
    bn_rvec = ['Bcl-xL-Bad', 'Mcl-1-Noxa']

    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')


    lib_spot_sort_affm = []
    lib_spot_sort_affx = []
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]

        lib_spot_sort_affm.append([msig, seq])
        lib_spot_sort_affx.append([xsig, seq])

    lib_spot_sort_affm.sort()
    lib_spot_sort_affx.sort()


    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)

    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == bim:
                wt200_count += 1.0
                wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    for eidx in range(len(evec)):
        print dr[eidx]
        print
        
        if not dr[eidx] in ['ma', 'm']: continue 

        #lib_spot_sort_affm = []
        #lib_spot_sort_affx = []
        #N = len(SPOT360)
        #for i in range(N):
            #seq = SPOT360[i][0]
            #xsig = SPOT360[i][2]
            #msig = SPOT360[i][3]
            #e = deepe_calc_coupling(evec[eidx], seq, x, xc)
            #ewt = deepe_calc_coupling(evec[eidx], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
        #if e == ewt or e == -999.0: continue
            #lib_spot_sort_affm.append([msig, e, seq])
            #lib_spot_sort_affx.append([xsig, e, seq])

        #lib_spot_sort_affm.sort()
    #lib_spot_sort_affx.sort()

        #x_lib_spot_pred = [[], []]
        #m_lib_spot_pred = [[], []]
        #N = len(lib_spot_sort_affm)
        #for i in range(N):
            #if float(i) < percut * float(N):
                #x_lib_spot_pred[0].append(0)
                #m_lib_spot_pred[0].append(0)
                #x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
                #m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])
            #if float(i) > (float(N) - percut * float(N)):
                #x_lib_spot_pred[0].append(1)
                #m_lib_spot_pred[0].append(1)
                #x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
                #m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])

        #x_lib_spot_roc = pyroc(x_lib_spot_pred)
        #m_lib_spot_roc = pyroc(m_lib_spot_pred)
        #print 'libX', round(x_lib_spot_roc[1], 2), len(x_lib_spot_pred[0])
        #print 'libM', round(m_lib_spot_roc[1], 2), len(m_lib_spot_pred[0])
        
        ##op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Xpred_deep_bootstrap.txt'
        ##if not os.path.exists(op): bootstrap_coyote(op, 2000, x_lib_spot_pred, x_lib_spot_roc[1], 'auc')
        ##elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, x_lib_spot_pred, x_lib_spot_roc[1], 'auc')

        ##op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_360_Mpred_deep_bootstrap.txt'
        ##if not os.path.exists(op): bootstrap_coyote(op, 2000, m_lib_spot_pred, m_lib_spot_roc[1], 'auc')
        ##elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, m_lib_spot_pred, m_lib_spot_roc[1], 'auc') 

        #spot200_affin = []
        #for i in range(len(idx_vec)): spot200_affin.append([])

        #for i in range(5):
            #idx = idx_vec[i]
            #for row in SPOT200:
                #seq = row[0][0:23]
                #dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
                #e = deepe_calc_coupling(evec[eidx], seq, x, xc)
                #ewt = deepe_calc_coupling(evec[eidx], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
                #if e != ewt and e != -999.0: spot200_affin[i].append([dsig, e, seq])
            #spot200_affin[i].sort()

        #spot200_affin_pred = []
        #for i in range(len(idx_vec)): spot200_affin_pred.append([[], []])

        #for i in range(5):
            #N = len(spot200_affin[i])
            #for j in range(N):
                #if float(j) < percut * float(N):
                    #spot200_affin_pred[i][0].append(0)
                    #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
                #if float(j) > (float(N) - percut * float(N)):
                    #spot200_affin_pred[i][0].append(1)
                    #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])

        #for i in range(5):
            #v = pyroc(spot200_affin_pred[i])
            #auc0 = v[1]
            #print rvec[i], round(v[1], 2), len(spot200_affin_pred[i][0])
            
            ##op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_' + rvec[i] + '200_pred_deep_bootstrap.txt'
            ##if not os.path.exists(op): bootstrap_coyote(op, 2000, spot200_affin_pred[i], auc0, 'auc')
            ##elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, spot200_affin_pred[i], auc0, 'auc')


        spot200_affin_bn = [[], []]

        for i in range(len(bad_data)):
            seq = bad_data[i][0]
            dsig = bad_data[i][1]
            if seq == 'AAQRYGRELRRMSDEFVDSFKKG': continue
            e = deepe_calc_coupling(evec[eidx], seq, x, xc)
            en = deepe_calc_coupling(evec[eidx], 'AAQRYGRELRRMSDEFVDSFKKG', x, xc)
            if e == en or e == -999.0: continue
            spot200_affin_bn[0].append([dsig, e, seq])
        spot200_affin_bn[0].sort()

        for i in range(len(noxa_data)):
            seq = noxa_data[i][0]
            dsig = noxa_data[i][1]
            if seq == 'LEVECATQLRRFGDKLNFRQKLL': continue
            e = deepe_calc_coupling(evec[eidx], seq, x, xc)
            en = deepe_calc_coupling(evec[eidx], 'LEVECATQLRRFGDKLNFRQKLL', x, xc)
        if e == en or e == -999.0: continue
            spot200_affin_bn[1].append([dsig, e, seq])
        spot200_affin_bn[1].sort()

        spot200_affin_pred_bn = []
        for i in range(2): spot200_affin_pred_bn.append([[], []])

        for i in range(2):
            N = len(spot200_affin_bn[i])
            for j in range(N):
                if float(j) < percut * float(N):
                    spot200_affin_pred_bn[i][0].append(0)
                    spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
                if float(j) > (float(N) - percut * float(N)):
                    spot200_affin_pred_bn[i][0].append(1)
                    spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
        for i in range(1, 2):
            v = pyroc(spot200_affin_pred_bn[i])
            auc0 = v[1]
            print bn_rvec[i], round(v[1], 2), len(spot200_affin_pred_bn[i][0])
            
            op = '/home/bartolo/web/statium/bootstrap/' + dr[eidx] + '_' + rvec[i] + '_BN_pred_deep_bootstrap.txt'
            if not os.path.exists(op): bootstrap_coyote(op, 2000, spot200_affin_pred_bn[i], auc0, 'auc')
            elif len(lines2list(op)) == 0: bootstrap_coyote(op, 2000, spot200_affin_pred_bn[i], auc0, 'auc')


def deep_bench_coupling(opath):
  
    import pylab
    x = 1.0
    xc = 0.0
    percut = 0.3
    
    dr = ['xa', 'ma', 'wa', 'fa', '2a']
    sdr = ['x', 'm']
    
    evec = []
    for i in range(len(dr)): evec.append([deepe_matrix_coupling(dr[i]), dr[i]])
    
    esvec = []
    for i in range(len(sdr)): esvec.append([deepe_matrix_coupling(sdr[i]), sdr[i]])
    
    idx_vec = [2, 3, 4, 5, 6]
    colors = ['b', 'r', 'g', 'k', 'c']
    colorsf = ['blue', 'red', 'green', 'black', 'cyan']
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2']
    bn_rvec = ['Bcl-xL-Bad', 'Mcl-1-Noxa']
    
    jmb_xspec_lines = readlines('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_lines = readlines('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')
    deep_xspec_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    deep_mspec_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    deep_xaffin_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt')
    deep_maffin_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt')
    deep_xspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro_25.txt')
    deep_mspec_50_lines = readlines('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro_25.txt')
    yeast_full_lines = readlines('/home/bartolo/web/statium/data/yeast_full_lib.txt')
    genome_lines = readlines('/home/bartolo/web/statium/BH3_test_seq.txt')
    bfl1_yeast_full_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt')
    bfl1_yeast_spec_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr_10.txt')
    w2_yeast_full_lines = readlines('/home/bartolo/web/statium/deepseq/w2/w2_full.txt')
    w_yeast_spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort_25.txt')
    b_yeast_spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort_25.txt')
    
    jmb_fspec_lines = readlines('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt')
    jmb_wspec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt')
    jmb_2spec_lines = readlines('/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt')
    
    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')
    
    Gelman_data = lines2list('/home/bartolo/web/statium/data/Gelman.txt')
    Gelman_pssm_data = lines2list('/home/bartolo/web/statium/data/Gelman_pssm.txt')
    
    print 'Analysing genome data...'
    genome = [[], [], [], [], []]
    for i in range(5):
        print rvec[i]
        for j in range(len(genome_lines)):
        seq = genome_lines[j].strip()
        e = deepe_calc_coupling(evec[i], seq, x, xc)
        if e != -999.0: genome[i].append(e)
 
    #import matplotlib
    #matplotlib.use( 'Agg' )
   
    for i in range(5):
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.rcParams['xtick.labelsize'] = '20'
        pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad']='8'
        pylab.rcParams['ytick.major.pad']='8'
        pylab.hist(pylab.array(genome[i]), normed=False, facecolor='white', edgecolor='black', lw=2)
        if i == 3: pylab.xlim(5, 50)
        #if i != 1 and i != 2: pylab.yticks([])
        ##pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/genome_deep_' + rvec[i] + '.png')
        pylab.close()
    print 'genome done...'
    
    #print 'Analysing Specific yeast sequences...'
    
    #jmb_xsort = []
    #jmb_xspec = [[], [], [], []]
    #for line in jmb_xspec_lines:
        #seq = line.strip()
        #jmb_xspec[0].append(seq)
        #jmb_xspec[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        ###
        #e = deepe_calc_coupling(esvec[0], seq, x, xc)
        #jmb_xsort.append(e)
        #jmb_xspec[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #jmb_xspec[3].append(jmb_xspec[1][-1] - jmb_xspec[2][-1])
    #jmb_msort = []
    #jmb_mspec = [[], [], [], []]
    #for line in jmb_mspec_lines:
        #seq = line.strip()
        #jmb_mspec[0].append(seq)
        #jmb_mspec[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        ###
        #e = deepe_calc_coupling(esvec[1], seq, x, xc)
        #jmb_msort.append(e)
        #jmb_mspec[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #jmb_mspec[3].append(jmb_mspec[1][-1] - jmb_mspec[2][-1])
        
    #deep_xspec = [[], [], [], []]
    #for line in deep_xspec_lines:
        #seq = line.strip()
        #deep_xspec[0].append(seq)
        #deep_xspec[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        #deep_xspec[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #deep_xspec[3].append(deep_xspec[1][-1] - deep_xspec[2][-1])
    #deep_mspec = [[], [], [], []]
    #for line in deep_mspec_lines:
        #seq = line.strip()
        #deep_mspec[0].append(seq)
        #deep_mspec[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        #deep_mspec[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #deep_mspec[3].append(deep_mspec[1][-1] - deep_mspec[2][-1])
    #deep_xspec_50 = [[], [], [], []]
    #for line in deep_xspec_50_lines:
        #seq = line.strip()
        #deep_xspec_50[0].append(seq)
        #deep_xspec_50[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        #deep_xspec_50[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #deep_xspec_50[3].append(deep_xspec_50[1][-1] - deep_xspec_50[2][-1])
    #deep_mspec_50 = [[], [], [], []]
    #for line in deep_mspec_50_lines:
        #seq = line.strip()
        #deep_mspec_50[0].append(seq)
        #deep_mspec_50[1].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        #deep_mspec_50[2].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #deep_mspec_50[3].append(deep_mspec_50[1][-1] - deep_mspec_50[2][-1])
        
        
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '20'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', lw=2, alpha=0.8)
    #pylab.ylim(0, 12)
    #pylab.savefig('/home/bartolo/web/statium/yeast_spec_deep_jmb.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
    
    #print 'Analysing Mcl-1 and Bcl-xL full yeast libraries...'
    #yeast_full = [[], []]
    #count = 0
    #for line in yeast_full_lines:
        #count += 1
        #seq = line.strip()
        #e0 = deepe_calc_coupling(esvec[0], seq, x, xc)
        #e1 = deepe_calc_coupling(esvec[1], seq, x, xc)
        #yeast_full[0].append(e0)
        #yeast_full[1].append(e1)
        
    #x_yeast_full = []
    #m_yeast_full = []
    #for i in range(len(yeast_full[0])):
        #if e != 0.0: x_yeast_full.append(yeast_full[0][i])
        #if e != 0.0: m_yeast_full.append(yeast_full[1][i])
        
    #x2sort = []
    #m2sort = []
    #for i in range(len(x_yeast_full)):
        #x2sort.append(x_yeast_full[i])
        #m2sort.append(m_yeast_full[i])
        
    #x2sort.sort()
    #m2sort.sort()
    #jmb_msort.sort()
    #jmb_xsort.sort()
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='blue', lw=2)
    #pylab.hist(pylab.array(yeast_full[0]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/test_hist_deep.png')
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', lw=2)
    #pylab.hist(pylab.array(yeast_full[1]), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    #pylab.savefig('/home/bartolo/web/statium/M_hist_deep.png')
    #pylab.close()
    
    #enrich0_e = x2sort[int(float(len(x2sort)) * 0.20)]
    #enrich0 = False
    #for i in range(len(jmb_xsort)):
        #if jmb_xsort[i] >= enrich0_e:
        #print 'enrich1:', float(i) / float(len(jmb_xsort))
        #enrich0 = True
        #break
    #if not enrich0: print 'enrich1:', 1.0
    
    #enrich0_e = m2sort[int(float(len(m2sort)) * 0.20)]
    #enrich0 = False
    #for i in range(len(jmb_msort)):
        #if jmb_msort[i] >= enrich0_e:
        #print 'enrich2:', float(i) / float(len(jmb_msort))
        #enrich0 = True
        #break
    #if not enrich0: print 'enrich2:', 1.0

    #enrich_x = [[], []]
    #enrich0_e = min(jmb_xsort[0], x2sort[0])
    #c0 = 0.1
    #while True:
        #jmbc = 0
        #for i in range(len(jmb_xsort)):
        #if jmb_xsort[i] < enrich0_e + c0: jmbc += 1
        #fullc = 0
        #for i in range(len(x2sort)):
        #if x2sort[i] < enrich0_e + c0: fullc += 1
    #enrich_x[0].append(float(fullc) / float(len(x2sort)))
    #enrich_x[1].append(float(jmbc) / float(len(jmb_xsort)))
    #c0 += 0.1
    #print (float(fullc) / float(len(x2sort))), float(jmbc) / float(len(jmb_xsort))
    #if enrich0_e + c0 > x2sort[-1]: break
    
    #ofile = open('/home/bartolo/web/statium/X_enrich_deep.txt', 'w')
    #for i in range(len(enrich_x[0])): ofile.write(str(enrich_x[1][i]) + '\t' + str(enrich_x[0][i]) + '\n')
    #ofile.close()
    
    #print
    #enrich_m = [[], []]
    #enrich0_e = min(jmb_msort[0], m2sort[0])
    #c0 = 0.1
    #while True:
        #jmbc = 0
        #for i in range(len(jmb_msort)):
        #if jmb_msort[i] < enrich0_e + c0: jmbc += 1
        #fullc = 0
        #for i in range(len(m2sort)):
        #if m2sort[i] < enrich0_e + c0: fullc += 1
    #enrich_m[0].append(float(fullc) / float(len(m2sort)))
    #enrich_m[1].append(float(jmbc) / float(len(jmb_msort)))
    #c0 += 0.1
    #print (float(fullc) / float(len(m2sort))), float(jmbc) / float(len(jmb_msort))
    #if enrich0_e + c0 > m2sort[-1]: break
    
    #ofile = open('/home/bartolo/web/statium/M_enrich_deep.txt', 'w')
    #for i in range(len(enrich_m[0])): ofile.write(str(enrich_m[1][i]) + '\t' + str(enrich_m[0][i]) + '\n')
    #ofile.close()
    
    #return
        
    #M_lib_pred_file = open('/home/bartolo/web/statium/M_lib_pred_deep.txt', 'w')
    #for i in range(len(jmb_mspec[0])):
    #M_lib_pred_file.write('0\t')
    #M_lib_pred_file.write(str(jmb_mspec[2][i]) + '\n')
    #for i in range(len(yeast_full[0])):
    #M_lib_pred_file.write('1\t')
    #M_lib_pred_file.write(str(yeast_full[1][i]) + '\n')
    #M_lib_pred_file.close()
    
    #print 'Analysing Gelman data...'

    #gel_spec = []
    #gel_xaffin = []
    #gel_maffin = []
    #L = len(Gelman_data)
    #for i in range(L):
        #seq = Gelman_data[i][0]
        #xsig = math.log10(Gelman_data[i][1]) - math.log10(110.0)
        #msig = math.log10(Gelman_data[i][2]) - math.log10(4.0)
        #xe = deepe_calc_coupling(evec[0], seq, x, xc)
        #me = deepe_calc_coupling(evec[1], seq, x, xc)
        #xeb = deepe_calc_coupling(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
        #if xe == xeb: continue
    #gel_spec.append([xsig - msig, xe - me, seq])
    #gel_xaffin.append([xsig, xe, seq])
    #gel_maffin.append([msig, me, seq])
    
    #print len(gel_xaffin)
    
    #gel_spec.sort()
    #gel_xaffin.sort()
    #gel_maffin.sort()
    
    #gel_spec_pred = [[], []]
    #gel_xaffin_pred = [[], []]
    #gel_maffin_pred = [[], []]
    #gel_spec_corr = [[], []]
    #gel_xaffin_corr = [[], []]
    #gel_maffin_corr = [[], []]
    
    #L = len(gel_xaffin)
    #for i in range(L):
        #gel_spec_corr[0].append(gel_spec[i][0])
        #gel_spec_corr[1].append(gel_spec[i][1])
        #gel_xaffin_corr[0].append(gel_xaffin[i][0])
        #gel_xaffin_corr[1].append(gel_xaffin[i][1])
        #gel_maffin_corr[0].append(gel_maffin[i][0])
        #gel_maffin_corr[1].append(gel_maffin[i][1])
        
        #if float(i) < percut * float(L):
        #gel_xaffin_pred[0].append(0)
        #gel_maffin_pred[0].append(0)
        #gel_spec_pred[0].append(0)
        #gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #gel_maffin_pred[1].append(gel_maffin[i][1])
        #gel_spec_pred[1].append(gel_spec[i][1])
    #if float(i) > (float(L) - percut * float(L)):
        #gel_xaffin_pred[0].append(1)
        #gel_maffin_pred[0].append(1)
        #gel_spec_pred[0].append(1)
        #gel_xaffin_pred[1].append(gel_xaffin[i][1])
        #gel_maffin_pred[1].append(gel_maffin[i][1])
        #gel_spec_pred[1].append(gel_spec[i][1])
    
    #gel_spec_roc = pyroc(gel_spec_pred)
    #gel_xaffin_roc = pyroc(gel_xaffin_pred)
    #gel_maffin_roc = pyroc(gel_maffin_pred)
    

    #print
    #print 'Gellman specificity AUC:', round(gel_spec_roc[1], 2), round(pylab.corrcoef(pylab.array(gel_spec_corr[0]), pylab.array(gel_spec_corr[1]))[0][1], 2)
    #print 'Gellman Bclxl affinity AUC:', round(gel_xaffin_roc[1]), round(pylab.corrcoef(pylab.array(gel_xaffin_corr[0]), pylab.array(gel_xaffin_corr[1]))[0][1], 2)
    #print 'Gellman Mcl-1 affinity AUC:', round(gel_maffin_roc[1]), round(pylab.corrcoef(pylab.array(gel_maffin_corr[0]), pylab.array(gel_maffin_corr[1]))[0][1], 2)
    print
    
    #print 'Analysing genome data...'
    #genome = [[], [], [], [], []]
    #for line in genome_lines:
        #seq = line.strip()
        #genome[0].append(deepe_calc_coupling(esvec[0], seq, x, xc))
        #genome[1].append(deepe_calc_coupling(esvec[1], seq, x, xc))
        #genome[2].append(deepe_calc_coupling(evec[2], seq, x, xc))
        #genome[3].append(deepe_calc_coupling(evec[3], seq, x, xc))
        #genome[4].append(deepe_calc_coupling(evec[4], seq, x, xc))
        
    #print 'Analysing library SPOT data...'
    #lib_spot_sort_affm = []
    #lib_spot_sort_affx = []
    #lib_spot_sort_spec = []
    #L = len(SPOT360)
    #for i in range(L):
        #seq = SPOT360[i][0]
        #xsig = SPOT360[i][2]
        #msig = SPOT360[i][3]     
        #xe = deepe_calc_coupling(evec[0], seq, x, xc)
        #me = deepe_calc_coupling(evec[1], seq, x, xc)
        #xse = deepe_calc_coupling(esvec[0], seq, x, xc)
        #mse = deepe_calc_coupling(esvec[1], seq, x, xc)
        #xewt = deepe_calc_coupling(evec[0], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
        #if xe == xewt: continue
        
        #lib_spot_sort_affm.append([msig, me, seq])
        #lib_spot_sort_affx.append([xsig, xe, seq])
        #lib_spot_sort_spec.append([xsig - msig, xse - mse, seq])
    
    #lib_spot_sort_affm.sort()
    #lib_spot_sort_affx.sort()
    #lib_spot_sort_spec.sort()
    
    #x_lib_spot_pred = [[], []]
    #m_lib_spot_pred = [[], []]
    #x_lib_spot_corr = [[], []]
    #m_lib_spot_corr = [[], []]
    #spec_lib_spot_pred = [[], []]
    #L =  len(lib_spot_sort_affm)
    #for i in range(L):
        #x_lib_spot_corr[0].append(lib_spot_sort_affx[i][0])
        #m_lib_spot_corr[0].append(lib_spot_sort_affm[i][0])
        #x_lib_spot_corr[1].append(lib_spot_sort_affx[i][1])
        #m_lib_spot_corr[1].append(lib_spot_sort_affm[i][1])
        #if float(i) < percut * float(L):
        #x_lib_spot_pred[0].append(0)
        #m_lib_spot_pred[0].append(0)
        #spec_lib_spot_pred[0].append(0)
        #x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
        #m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])
        #spec_lib_spot_pred[1].append(lib_spot_sort_spec[i][1])
    #if float(i) > (float(L) - percut * float(L)):
        #x_lib_spot_pred[0].append(1)
        #m_lib_spot_pred[0].append(1)
        #spec_lib_spot_pred[0].append(1)
        #x_lib_spot_pred[1].append(lib_spot_sort_affx[i][1])
        #m_lib_spot_pred[1].append(lib_spot_sort_affm[i][1])
        #spec_lib_spot_pred[1].append(lib_spot_sort_spec[i][1])
    
    #print len(m_lib_spot_pred[0])
    #spec_lib_spot_roc = pyroc(spec_lib_spot_pred)
    #x_lib_spot_roc = pyroc(x_lib_spot_pred)
    #m_lib_spot_roc = pyroc(m_lib_spot_pred)
    #roc360 = []
    #roc360.append(x_lib_spot_roc)
    #roc360.append(m_lib_spot_roc)

    xm_360spec = [[], []]
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        #print seq, deepe_calc_coupling(evec[0], seq, x, xc) - deepe_calc_coupling(evec[1], seq, x, xc)
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        if xsig < 0.5 or msig < 0.5:
        xm_360spec[0].append(xsig - msig)
        xm_360spec[1].append(deepe_calc_coupling(esvec[0], seq, x, xc) - deepe_calc_coupling(esvec[1], seq, x, xc))
        
    print
    #print 'Library array specificity AUC:', round(spec_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(xm_360spec[0]), pylab.array(xm_360spec[1]))[0][1], 2)
    #print 'Library array Bclxl affinity AUC:', round(x_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(x_lib_spot_corr[0]), pylab.array(x_lib_spot_corr[1]))[0][1], 2), stats.spearmanr(pylab.array(x_lib_spot_corr[0]), pylab.array(x_lib_spot_corr[1]))[0]
    #print 'Library array Mcl-1 affinity AUC:', round(m_lib_spot_roc[1], 2), round(pylab.corrcoef(pylab.array(m_lib_spot_corr[0]), pylab.array(m_lib_spot_corr[1]))[0][1], 2), stats.spearmanr(pylab.array(m_lib_spot_corr[0]), pylab.array(m_lib_spot_corr[1]))[0]
    print
    print
    
    of = open('/home/bartolo/web/statium/xm_360_spec_deepS_bootstrap.txt', 'w')
    Rs = []
    for i in range(2000):
        v = [[], []]
        for j in range(len(xm_360spec[0])):
        rint = random.randint(0, len(xm_360spec[0]) - 1)
        v[0].append(xm_360spec[0][rint])
        v[1].append(xm_360spec[1][rint])
    R = pylab.corrcoef(pylab.array(v[0]), pylab.array(v[1]))[0][1]
    Rs.append(R)
    Rs.sort()
    for i in range(len(Rs)):
    of.write(str(Rs[i]) + '\n')
    of.close()
    
    #ofile = open('/home/bartolo/web/statium/spec360_deepa.txt', 'w')
    #for i in range(len(xm_360spec[0])):
        #ofile.write(str(xm_360spec[0][i]) + '\t' + str(xm_360spec[1][i]) + '\n')
    #ofile.close()
    
    #import pylab
    #pylab.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #pylab.savefig('/home/bartolo/web/spec360_deep_single.png')
    
    natural_rank = [[], [], [], [], []]
    
    natural = [['PEIWIAQELRRIGDEFNAYYARR', 'WAREIGAQLRRMADDLNAQYERR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'TMGQVGRQLAIIGDDINRRYDSE', 'AAQLTAARLKALGDELHQRTMWR', 'MTQEVGQLLQDMGDDVYQQYRSL', 'PEEWIEQELRRIGDEENAYYARR', 'PEIWIAQELRRAGDEFNAYKARR', 'RLAEVCAVLLRLGDELEMIRPSV'], [], [], [], [], []]
    natural_names = ['Bim', 'Puma', 'Noxa', 'Bad', 'Bak', 'Hrk', 'Mule', 'des1', 'des2', 'Bok']
    
    print
    print
    for i in range(len(natural[0])):
        print natural_names[i]
        for j in range(5): print rvec[j], deepe_calc_coupling(evec[j], natural[0][i], x, xc)
        print
        print
        ##print natural_names[i], statium_energy_calc(evec[0], natural[0][i], 1.0)
        #natural[1].append(deepe_calc_coupling(evec[0], natural[0][i], x, xc))
        #natural[2].append(deepe_calc_coupling(evec[1], natural[0][i], x, xc))
        #natural[3].append(deepe_calc_coupling_w2(evec[2], natural[0][i], x, xc))
        #natural[4].append(deepe_calc_coupling_f(evec[3], natural[0][i], x, xc))
        #natural[5].append(deepe_calc_coupling_w2(evec[4], natural[0][i], x, xc))

    natural2 = [['PEIWIAQELRRIGDEFNAYYARR', 'WAREIGAQLRRMADDLNAQYERR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'AAQLTAARLKALGDELHQRTMWR', 'IIRNIARHLAQVGDSMDRSIPPG', 'GSDALALRLACIGDEMDVSLRAP', 'AEVQIARKLQCIADQFHRLHVQQ', 'MTQEVGQLLQDMGDDVYQQYRSL', 'RLAEVCAVLLRLGDELEMIRPSV'], [], [], [], [], []]
    natural_names2 = ['Bim', 'Puma', 'Noxa', 'Bad', 'Hrk', 'Bid', 'Bik', 'Bmf', 'Mule', 'Bok']
    print "Genome ranking..."
    for i in range(len(natural2[0])):
        
        natural_rank[0].append(deepe_calc_coupling(evec[0], natural2[0][i], x, xc))
        natural_rank[1].append(deepe_calc_coupling(evec[1], natural2[0][i], x, xc))
        natural_rank[2].append(deepe_calc_coupling(evec[2], natural2[0][i], x, xc))
        natural_rank[3].append(deepe_calc_coupling(evec[3], natural2[0][i], x, xc))
        natural_rank[4].append(deepe_calc_coupling(evec[4], natural2[0][i], x, xc))
        
    for i in range(5):
        print rvec[i]
        for j in range(len(natural_names2)):
        print natural_names2[j], natural_rank[i][j]
    print
    print
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    
    #wt_vec = []
    #for idx in idx_vec:
        #wt200_count = 0.0
        #wt200 = 0.0
        #for row in SPOT200:
            #seq = row[0][0:23]
            #if seq == bim:
            #wt200_count += 1.0
            #wt200 += row[idx]
        #wt200 = wt200 / wt200_count
        #wt_vec.append(wt200)
        
    #print 'Bad and Noxa SPOT substitution binding...'
    #spot200_affin_bn = []
    #for i in range(2):
        #spot200_affin_bn.append([])

    #for i in range(len(bad_data)):
        #seq = bad_data[i][0]
        #dsig = bad_data[i][1]
        #if seq == 'AAQRYGRELRRMSDEFVDSFKKG': continue
        #e = deepe_calc_coupling(evec[0], seq, x, xc)
        #en = deepe_calc_coupling(evec[0], 'AAQRYGRELRRMSDEFVDSFKKG', x, xc)
        #if e == en: continue
        #spot200_affin_bn[0].append([dsig, e, seq])
    #spot200_affin_bn[0].sort()
    
    #print
    #print
    #noxa_hist = []
    #for i in range(len(noxa_data)):
        #seq = noxa_data[i][0]
        #dsig = noxa_data[i][1]
        #noxa_hist.append(dsig)
        #if seq == 'LEVECATQLRRFGDKLNFRQKLL': continue
        #e = deepe_calc_coupling(evec[1], seq, x, xc)
        #en = deepe_calc_coupling(evec[1], 'LEVECATQLRRFGDKLNFRQKLL', x, xc)
        #if e == en: continue
        #spot200_affin_bn[1].append([dsig, e, seq])
    #spot200_affin_bn[1].sort()
    
    #spot200_affin_pred_bn = []
    #for i in range(2):
        #spot200_affin_pred_bn.append([[], []])
        
    #spot200_affin_corr_bn = []
    #for i in range(2):
        #spot200_affin_corr_bn.append([[], []])
        
    #for i in range(2):
        #L = len(spot200_affin_bn[i])
        #for j in range(L):
        #spot200_affin_corr_bn[i][0].append(spot200_affin_bn[i][j][0])
        #spot200_affin_corr_bn[i][1].append(spot200_affin_bn[i][j][1])
            #if float(j) < percut * float(L):
            #spot200_affin_pred_bn[i][0].append(0)
            #spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
        #if float(j) > (float(L) - percut * float(L)):
            #spot200_affin_pred_bn[i][0].append(1)
            #spot200_affin_pred_bn[i][1].append(spot200_affin_bn[i][j][1])
    #print len(spot200_affin_pred_bn[0][0]), len(spot200_affin_pred_bn[1][0])
    #import pylab
    #for i in range(2):
        #v = pyroc(spot200_affin_pred_bn[i])
        #print bn_rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr_bn[i][0]), pylab.array(spot200_affin_corr_bn[i][1]))[0][1], 2)
        
    #print 'SPOT200 binding...'
    #spot200_affin = []
    #for i in range(len(idx_vec)):
        #spot200_affin.append([])

    #for i in range(5):
    #idx = idx_vec[i]
        #for row in SPOT200:
            #seq = row[0][0:23]
            #dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
        #e = deepe_calc_coupling(evec[i], seq, x, xc)
        #ewt = deepe_calc_coupling(evec[i], 'PEIWIAQELRRIGDEFNAYYARR', x, xc)
            #if e != ewt and e != -999.0: spot200_affin[i].append([dsig, e, seq])
           ## else:
        ##    if i == 0: print seq, e, ewt
        #spot200_affin[i].sort()
    
    #spot200_affin_pred = []
    #for i in range(len(idx_vec)):
        #spot200_affin_pred.append([[], []])
    #spot200_affin_corr = []
    #for i in range(len(idx_vec)):
        #spot200_affin_corr.append([[], []])
        
    #for i in range(5):
        #L = len(spot200_affin[i])
        #for j in range(L):
        #spot200_affin_corr[i][0].append(spot200_affin[i][j][0])
        #spot200_affin_corr[i][1].append(spot200_affin[i][j][1])
            #if float(j) < percut * float(L):
            #spot200_affin_pred[i][0].append(0)
            #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
        #if float(j) > (float(L) - percut * float(L)):
            #spot200_affin_pred[i][0].append(1)
            #spot200_affin_pred[i][1].append(spot200_affin[i][j][1])
            
    #print len(spot200_affin_pred[i][0])
            
    #import pylab
    #for i in range(5):
        ##if i == 0:
        ##pylab.scatter(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
        ##pylab.savefig('/home/bartolo/web/test2.png')  
        #v = pyroc(spot200_affin_pred[i])
        #print rvec[i], round(v[1], 2), round(pylab.corrcoef(pylab.array(spot200_affin_corr[i][0]), pylab.array(spot200_affin_corr[i][1]))[0][1], 2)
        
    #print 'SPOT200 specificity...'
    
    #spot200_spec = []
    #for i in range(len(idx_vec)):
        #spot200_spec.append([])
        #for j in range(len(idx_vec)): spot200_spec[i].append([])
        
    #spot200_spec_corr = []
    #for i in range(len(idx_vec)):
        #spot200_spec_corr.append([])
        #for j in range(len(idx_vec)): spot200_spec_corr[i].append([[], []])
        
    #spot200_spec_pred = []
    #for i in range(len(idx_vec)):
        #spot200_spec_pred.append([])
        #for j in range(len(idx_vec)): spot200_spec_pred[i].append([[], []])
        
    #bim = 'PEIWIAQELRRIGDEFNAYYARR'
    #for i in range(5):
    #idxi = idx_vec[i]
    #for j in range(i + 1, 5):
        #idxj = idx_vec[j]
            #for row in SPOT200:
                #seq = row[0][0:23]
                #dsigi = -1.0 * math.log10(row[idxi] / wt_vec[i])
                #dsigj = -1.0 * math.log10(row[idxj] / wt_vec[j])
                #if i in [0, 1]:
            #ei = deepe_calc_coupling(evec[i], seq, x, xc)
            #eib = deepe_calc_coupling(evec[i], bim, x, xc)
                #if j in [0, 1]:
            #ej = deepe_calc_coupling(evec[j], seq, x, xc)
            #ejb = deepe_calc_coupling(evec[j], bim, x, xc)
                #if i == 3:
            #ei = deepe_calc_coupling_f(evec[i], seq, x, xc)
            #eib = deepe_calc_coupling_f(evec[i], bim, x, xc)
                #if j == 3:
            #ej = deepe_calc_coupling_f(evec[j], seq, x, xc)
            #ejb = deepe_calc_coupling_f(evec[j], bim, x, xc)
                #if i in [2, 4]:
            #ei = deepe_calc_coupling_w2(evec[i], seq, x, xc)
            #eib = deepe_calc_coupling_w2(evec[i], bim, x, xc)
                #if j in [2, 4]:
            #ej = deepe_calc_coupling_w2(evec[j], seq, x, xc)
            #ejb = deepe_calc_coupling_w2(evec[j], bim, x, xc)
                #if ei == eib: continue
                #spot200_spec[i][j].append([dsigi - dsigj, ei - ej, seq])
            #spot200_spec[i][j].sort()
        
    #for i in range(5):
        #for j in range(i + 1, 5):
            #L = len(spot200_spec[i][j])
        #for k in range(L):
        #spot200_spec_corr[i][j][0].append(spot200_spec[i][j][k][0])
        #spot200_spec_corr[i][j][1].append(spot200_spec[i][j][k][1])
        #if float(k) < percut * float(L):
            #spot200_spec_pred[i][j][0].append(0)
            #spot200_spec_pred[i][j][1].append(spot200_spec[i][j][k][1])
        #if float(k) > (float(L) - percut * float(L)):
            #spot200_spec_pred[i][j][0].append(1)
            #spot200_spec_pred[i][j][1].append(spot200_spec[i][j][k][1])
        #pyrocij = pyroc(spot200_spec_pred[i][j])
        ##print rvec[i], rvec[j], round(pyrocij[1], 2)

    #corr_matrix = []
    #for i in range(len(idx_vec)):
        #corr_matrix.append([])
        #for j in range(len(idx_vec)): corr_matrix[i].append([[], []])
    #print 'SPOT200 specificity correlations:'
    #bim = 'PEIWIAQELRRIGDEFNAYYARR'
    #for i in range(5):
        #for j in range(i + 1, 5):
        #if i == j: continue
            #idxi = idx_vec[i]
            #idxj = idx_vec[j]
            #count = -1
            #for row in SPOT200:
            #count += 1
                #seqi = row[0][0:23]
                #seqj = row[0][0:23]
                #dsigi = -1.0 * math.log10(row[idxi] / wt_vec[i])
                #dsigj = -1.0 * math.log10(row[idxj] / wt_vec[j])
                
                #if dsigi < 0.5 or dsigj < 0.5:
                    
                    #if i in [0, 1]:
                #ei = deepe_calc_coupling(evec[i], seqi, x, xc)
                #eib = deepe_calc_coupling(evec[i], bim, x, xc)
                    #if j in [0, 1]:
                #ej = deepe_calc_coupling(evec[j], seqj, x, xc)
                #ejb = deepe_calc_coupling(evec[j], bim, x, xc)
                    #if i == 3:
                #ei = deepe_calc_coupling_f(evec[i], seqi, x, xc)
                #eib = deepe_calc_coupling_f(evec[i], bim, x, xc)
                    #if j == 3:
                #ej = deepe_calc_coupling_f(evec[j], seqj, x, xc)
                #ejb = deepe_calc_coupling_f(evec[j], bim, x, xc)
                    #if i in [2, 4]:
                #ei = deepe_calc_coupling(evec[i], seqi, x, xc)
                #eib = deepe_calc_coupling(evec[i], bim, x, xc)
                    #if j in [2, 4]:
                #ej = deepe_calc_coupling(evec[j], seqj, x, xc)
                #ejb = deepe_calc_coupling(evec[j], bim, x, xc)
                
            #if ei == eib or ej == ejb: continue
            
            #corr_matrix[i][j][0].append(dsigi - dsigj)
            #corr_matrix[i][j][1].append(ei - ej)
        
            #if i == 1 and j == 2:
            #pylab.close()
            #import pylab
            #pylab.scatter(pylab.array(corr_matrix[i][j][0]), pylab.array(corr_matrix[i][j][1]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
            #pylab.savefig('/home/bartolo/web/test.png')                    
            #print rvec[i], rvec[j], round(pylab.corrcoef(pylab.array(corr_matrix[i][j][0]), pylab.array(corr_matrix[i][j][1]))[0][1], 2)

    #print
    #print
    #print 'Analysing Bcl-2 and Bcl-w full yeast libraries...'
    #w_yeast_full = []
    #w_yeast_spec = []
    #b_yeast_full = []
    #b_yeast_spec = []
    #count = 0
    #for line in w2_yeast_full_lines:
        #count += 1
        #if count % 10000 == 0: break
        #seq = line.strip()
        #w_yeast_full.append(deepe_calc_coupling(evec[2], seq, x, xc))
        #b_yeast_full.append(deepe_calc_coupling(evec[4], seq, x, xc))
    #for line in w_yeast_spec_lines:
        #seq = line.strip()
        #w_yeast_spec.append(deepe_calc_coupling(evec[2], seq, x, xc))
    #for line in b_yeast_spec_lines:
        #seq = line.strip()
        #b_yeast_spec.append(deepe_calc_coupling(evec[4], seq, x, xc))
       

    #print 'Analysing Bfl-1 full yeast libraries...'
    #f_yeast_full = []
    #f_yeast_spec = []
    #fm_yeast_spec = []
    #count = 0
    #for line in bfl1_yeast_full_lines:
        #count += 1
        #if count % 10000 == 0: break
        #seq = line.strip()
        #f_yeast_full.append(deepe_calc_coupling(evec[3], seq, x, xc))
        
    #for line in bfl1_yeast_spec_lines:
        #seq = line.strip()
        #f_yeast_spec.append(deepe_calc_coupling(evec[3], seq, x, xc))
        #fm_yeast_spec.append(deepe_calc_singlef(deepm, seq))
        
    #print 'Making plots...'
        
    #import matplotlib
    #matplotlib.use( 'Agg' )

    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '8'
    #pylab.rcParams['ytick.labelsize'] = '8'
    
    #for i in range(len(idx_vec)):
        #for j in range(len(idx_vec)):
        #print rvec[i], rvec[j], pylab.corrcoef(pylab.array(sub_matrix[i][j][1]), pylab.array(sub_matrix[i][j][2]))[0][1]

    #for i in range(len(full_vec)):
        #for j in range(len(pos_vec)):
            #full_vec[i][5].append(stats.spearmanr(pylab.array(full_vec[i][3][j]), pylab.array(full_vec[i][4][j]))[0])
    
    #for i in range(len(full_vec)):

        #matplotlib.pyplot.subplot(441 + i)
    #pylab.text(6.0, -0.4, rvec[i], fontsize=10)
    #matplotlib.pyplot.bar(pylab.arange(len(spots)), pylab.array(full_vec[i][5]), 0.35, color='r', align='center')
        #pylab.yticks([])
        #pylab.xticks([])
    ##matplotlib.pyplot.xticks(pylab.arange(len(spots)), spots)
    #matplotlib.pyplot.xlim(-1, len(pylab.arange(len(spots))))
    #matplotlib.pyplot.ylim(-0.6, 1)
        #pylab.yticks([])
        #pylab.xticks([])
    

    
    #matplotlib.pyplot.subplot(332)
    #matplotlib.pyplot.hist(pylab.array(deep_xspec[3]), normed=True, facecolor='blue', alpha=0.45)
    #matplotlib.pyplot.hist(pylab.array(deep_mspec[3]), normed=True, facecolor='red', alpha=0.45)
    #pylab.yticks([])
    #pylab.xticks([])

    #matplotlib.pyplot.subplot(441)
    #matplotlib.pyplot.hist(pylab.array(jmb_xspec[1]), normed=True, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(yeast_full[0]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #t = ttest(pylab.array(jmb_xspec[1]), pylab.array(yeast_full[0]))
    #pylab.title('Bcl-xL yeast lib. (t=' + t + ')', fontsize=8)
    #pylab.yticks([])
    #pylab.xticks([])

    #matplotlib.pyplot.subplot(442)
    #matplotlib.pyplot.hist(pylab.array(jmb_mspec[2]), normed=True, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(yeast_full[1]), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #t = ttest(pylab.array(jmb_mspec[2]), pylab.array(yeast_full[1]))
    #pylab.title('Mcl-1 yeast lib. (t=' + t + ')', fontsize=8)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 3)
    #t1 = ttest(pylab.array(w_yeast_spec), pylab.array(w_yeast_full))
    #matplotlib.pyplot.title('Bcl-w yeast lib. (t1=' + t1 + ')', fontsize=8)
    #matplotlib.pyplot.hist(pylab.array(w_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(w_yeast_spec), normed=True, facecolor='white', edgecolor='green', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 4)
    #t1 = ttest(pylab.array(b_yeast_spec), pylab.array(b_yeast_full))
    #matplotlib.pyplot.title('Bcl-2 yeast lib. (t1=' + t1 + ')', fontsize=8)
    #matplotlib.pyplot.hist(pylab.array(b_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(b_yeast_spec), normed=True, facecolor='white', edgecolor='cyan', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 5)
    #t1 = ttest(pylab.array(f_yeast_spec), pylab.array(f_yeast_full))
    #matplotlib.pyplot.title('Bfl-1 yeast lib. (t1=' + t1 + ')', fontsize=8)
    #matplotlib.pyplot.hist(pylab.array(f_yeast_full), normed=True, facecolor='white', edgecolor='gray', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(f_yeast_spec), normed=True, facecolor='white', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #for i in range(5):
        #matplotlib.pyplot.subplot(4, 4, 6 + i)
        #if i in [0, 1, 2, 3, 4]:
            #genome_array = pylab.array(genome[i])
        #matplotlib.pyplot.hist(genome_array, facecolor='white', edgecolor=colors[i], lw=2)
        #matplotlib.pyplot.xlim(min(genome_array), max(genome_array))
        #matplotlib.pyplot.ylim(0, 6500)
        #for j in range(len(natural[0])):
            #matplotlib.pyplot.annotate(natural_names[j], (natural[1 + i][j], 700 + 700 * j), xycoords='data', xytext=(0.0, 20.0), textcoords='offset points', arrowprops=dict(arrowstyle="->"), fontsize=8, horizontalalignment='right', verticalalignment='top')
        ##matplotlib.pyplot.text(mean(genome_array), 5500, rvec[i], fontsize=10)
    #else:
        #matplotlib.pyplot.plot(pylab.array([0, 1, 2, 3, 4, 5]), pylab.array([0, 0, 0, 0, 0, 0]))
        #matplotlib.pyplot.plot(pylab.array([0, 0, 0, 0, 0, 0]), pylab.array([0, 1, 2, 3, 4, 5]))
    #pylab.title(rvec[i] + ' genome scan', fontsize=8)
        #pylab.yticks([])
        #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 11)
    #matplotlib.pyplot.title('Comb. Lib. SPOT specificity', fontsize=8)
    #xa = pylab.array(xm_360spec[1])
    #ya = pylab.array(xm_360spec[0])
    #R = str(round(pylab.corrcoef(xa, ya)[0][1], 2))
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R, fontsize=10)
    #matplotlib.pyplot.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
        
    #matplotlib.pyplot.subplot(4, 4, 12)
    #for i in range(len(roc360)):
        #xsa = pylab.array(roc360[i][0][1])
        #xea = pylab.array(roc360[i][0][0])
        #matplotlib.pyplot.figtext(0.77, 0.32 + float(i) * 0.02, rvec[i]+'(AUC='+str(round(roc360[i][1], 2))[0:4]+')', fontdict=None, fontsize=8, color=colors[i])
        #matplotlib.pyplot.plot(xea, xsa, c=colors[i], label=rvec[i]+'('+str(round(roc360[i][1], 2))+')')
    #matplotlib.pyplot.title('SPOT array prediction', fontsize=8)
    #matplotlib.pyplot.xlim(-0.02, 1.0)
    #matplotlib.pyplot.ylim(0, 1.02)
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 13)
    #matplotlib.pyplot.hist(pylab.array(jmb_xspec[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(jmb_mspec[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #t = ttest(pylab.array(jmb_xspec[3]), pylab.array(jmb_mspec[3]))
    #pylab.title('Bcl-xL, Mcl-1 spec. (t=' + t + ')', fontsize=8)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 14)
    #t = ttest(pylab.array(deep_xspec_50[3]), pylab.array(deep_mspec_50[3]))
    #matplotlib.pyplot.title('Deep spec. (t=' + t + ')', fontsize=8)
    #matplotlib.pyplot.hist(pylab.array(deep_xspec_50[3]), normed=False, facecolor='white', edgecolor='blue', alpha=0.45, lw=2)
    #matplotlib.pyplot.hist(pylab.array(deep_mspec_50[3]), normed=False, facecolor='white', edgecolor='red', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 15)
    #matplotlib.pyplot.title('Bcl-xL vs. Mcl-1 spec.', fontsize=8)
    #xa = pylab.array(corr_matrix[0][1][0])
    #ya = pylab.array(corr_matrix[0][1][1])
    #R = str(round(pylab.corrcoef(xa, ya)[0][1], 2))
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R, fontsize=10)
    #matplotlib.pyplot.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
    #matplotlib.pyplot.subplot(4, 4, 16)
    #matplotlib.pyplot.title('Mcl-1 vs. Bcl-2 spec.', fontsize=8)
    #xa = pylab.array(corr_matrix[1][4][0])
    #ya = pylab.array(corr_matrix[1][4][1])
    #R = str(round(pylab.corrcoef(xa, ya)[0][1], 2))
    #matplotlib.pyplot.text(min(xa) - 0.05 * (max(xa) - min(xa)), (max(ya) - min(ya)) * 0.85 + min(ya), 'R=' + R, fontsize=10)
    #matplotlib.pyplot.scatter(xa, ya, c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #matplotlib.pyplot.yticks([])
    #matplotlib.pyplot.xticks([])
    
    #matplotlib.pyplot.savefig(opath)
    
def PSSM_DEEP_refine():
  
    #seq_path = '/home/bartolo/web/statium/deepseq/w2/bcl2_sort.txt'
    seq_path = '/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt'
    #seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro.txt'
    #seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro.txt'
    #seq_path = '/home/bartolo/web/statium/data/deep_mcl1_affinity_noinvitro_exclusive.txt'
    #seq_path = '/home/bartolo/web/statium/data/deep_bclxl_affinity_noinvitro_exclusive.txt'
    
    deep = deepe_matrix_coupling('x')
    #deepxs = deepe_matrix_single('x')
    
    seqs = lines2list(seq_path)
    
    ranks = []
    for i in range(len(seqs)):
        seq = seqs[i][0]
        
        e = deepe_calc_coupling(deep, seq)
        
        ranks.append([e, seq])
    ranks.sort()
    
    of = open('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro_cpl25.txt', 'w')
    nseq = int(float(len(ranks)) * 0.25)
    for i in range(nseq):
        of.write(ranks[i][1] + '\n')
    of.close()
    
    
def SPOT360_comparison(pdir1, pdir2, data_path, r1, r2):
  
    SPOT_vec = PSSM5()
  
    receptor_vec = ['bclxl', 'mcl1', 'bclw', 'bfl1', 'bcl2']
    r1idx = receptor_vec.index(r1) + 2
    r2idx = receptor_vec.index(r2) + 2
    
    deepm = deepe_matrix('m')
    deepx = deepe_matrix('x')
  
    e1 = load_design_energy(pdir1)
    e2 = load_design_energy(pdir2)
    
    SPOT200 = lines2list(data_path)
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    L = len(bim)

    bim_e1 = xenergy(e1, bim, 10.0, False)
    bim_e2 = xenergy(e2, bim, 10.0, False)
    
    wt200_count1 = 0.0
    wt2001 = 0.0
    for row in SPOT200:
        seq = row[0][0:23]
        if seq == bim:
        wt200_count1 += 1.0
        wt2001 += row[r1idx]
    wt2001 = wt2001 / wt200_count1
    
    wt200_count2 = 0.0
    wt2002 = 0.0
    for row in SPOT200:
        seq = row[0][0:23]
        if seq == bim:
        wt200_count2 += 1.0
        wt2002 += row[r2idx]
    wt2002 = wt2002 / wt200_count2
    
    #of = open('/home/bartolo/web/statium/data/ROC/spec/deepe_affinity_exclusive.txt', 'w')
    
    sv1 = []
    sv2 = []
    ev1 = []
    ev2 = []
    for row in SPOT200:
        seq = row[0][0:23]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        pssmx = energy_pssm[0]
        pssmm = energy_pssm[1]
        dsig1 = -1.0 * math.log10(row[r1idx] / wt2001)
        dsig2 = -1.0 * math.log10(row[r2idx] / wt2002)
        if dsig1 < 0.5 or dsig2 < 0.5: sv1.append(dsig1 - dsig2)
        sv2.append(dsig2)
        row.append(dsig1)
        row.append(dsig2)
        seq_e1 = xenergy(e1, seq, 10.0, False)
        seq_e2 = xenergy(e2, seq, 10.0, False)
        ddg1 = seq_e1 - bim_e1
        ddg2 = seq_e2 - bim_e2
        deepxe = deepe_calc(deepx, seq)
        deepme = deepe_calc(deepm, seq)
        deepxes = deepe_calc_single(deepxs, seq)
        deepmes = deepe_calc_single(deepms, seq)
        if dsig1 < 0.5 or dsig2 < 0.5: ev1.append(pssmx - pssmm)
        ev2.append(seq_e2)
        row.append(ddg1)
        row.append(ddg2)
        
        #bin = '0'
        #if dsig1 - dsig2 < 0.0: bin = '1'
        #of.write(bin + '\t' + str((deepxes - deepmes) * -1.0) + '\n')
    #of.close()
        
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    

    pylab.scatter(pylab.array(ev1), pylab.array(sv1))
    r = stats.spearmanr(pylab.array(ev2), pylab.array(sv2))[0]
    n = len(ev1)
    p = stats.spearmanr(pylab.array(ev2), pylab.array(sv2))[1]
    print n, r, p
    print 'Pearson:', str(pylab.corrcoef(pylab.array(ev2), pylab.array(sv2))[0][1])
    #pylab.yticks([])

    pylab.savefig('/home/bartolo/web/statium/data/plots/SPOT360_spec_scatter_pssm.png')
    pylab.close()
    
    #print rate, ratep
   # import pylab
    #pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
        
    #for pos in pos_vec:
     #   spec2001 = [[], []]
      #  spec2002 = [[], []]
       # for row in SPOT200:
        #    seq = row[0][0:23]
         #   mut = 0
          #  for i in range(L):
       #     if seq[i] != bim[i]:
        #        mut = i
         #       break
        #if not mut == pos: continue
            #spec2001[0].append(row[7])
            #spec2001[1].append(row[9])
            #spec2002[0].append(row[8])
            #spec2002[1].append(row[10])
            
            
            
        #print  str(pylab.corrcoef(pylab.array(spec2001[1]), pylab.array(spec2001[0]))[0][1]), str(pylab.corrcoef(pylab.array(spec2002[1]), pylab.array(spec2002[0]))[0][1])
    
   # spec2001 = [[], []]
    #spec2002 = [[], []]
    #for row in SPOT200:
     #   seq = row[0][0:23]
      #  mut = 0
       # for i in range(L):
    #    if seq[i] != bim[i]:
     #       mut = i
      #      break
            
    #if not mut in [14]: continue
        
        #ediff = row[9] - row[10]
    #if ((row[7] < 0.0 and row[8] > 0.0) or (row[7] > 0.0 and row[8] < 0.0)) and ((row[9] < -10.0 and row[10] > 10.0) or (row[9] > 10.0 and row[10] < -10.0)):
    #if ((row[7] < 0.0 and row[8] > 0.0) or (row[7] > 0.0 and row[8] < 0.0)) and (ediff > 25.0 or ediff < -25.0):
            #print row[1], row[7]- row[8], row[9] - row[10]
            
         #   spec2001[0].append(row[7] - row[8])
          #  spec2001[1].append(row[9] - row[10])
           # spec2002[0].append(row[8])
            #spec2002[1].append(row[10])

    #print
    #print  str(pylab.corrcoef(pylab.array(spec2001[1]), pylab.array(spec2001[0]))[0][1])

    #pylab.rcParams['xtick.labelsize'] = '15'
    #pylab.rcParams['ytick.labelsize'] = '15'
    #pylab.rcParams['ytick.direction'] = 'out'
    #pylab.rcParams['xtick.direction'] = 'out'
    
    #pylab.scatter(pylab.array(spec2001[0]), pylab.array(spec2001[1]))

    #pylab.savefig('/home/bartolo/web/tst.png')
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '15'
    #pylab.rcParams['ytick.labelsize'] = '15'
    #pylab.rcParams['ytick.direction'] = 'out'
    #pylab.rcParams['xtick.direction'] = 'out'
    
    #pylab.scatter(pylab.array(spec2002[0]), pylab.array(spec2002[1]))

    #pylab.savefig('/home/bartolo/web/full_house_bclw_F15_evs.png')
    #pylab.close()
    
def SPOT_log(p1, r, stat_dir, names, op):
  
    SPOT_vec = PSSM5()
    
    nl = readlines(names)
    
    use_deep = False
    if r in 'mx':
        deepe = deepe_matrix_single(r)
        use_deep = True
  
    e1 = load_design_energy(stat_dir)
  
    data = lines2list(p1)
    
    if r == 'x': wt = [41585689.96, 35066023.81, 32635294.94, 36724240.95, 37208143.94, 36043775.76, 32078793.54, 41796802.73, 33976329.69, 32265382.09, 28442571.81]
    if r == 'x': wtn = [5128058.38, 4197284.61, 1109642.39, 4873309.11, 4630097.69, 4317967.51, 4636250.98]
    if r == 'm': wt = [53818742.55, 54190548.38, 58627198.08, 47644330.93, 50041419.46, 49323330.54, 47728219.68, 66718281.73, 73628389.6, 71914385.28, 66567470.98]
    if r == 'm': wtn = [7335097.52, 8453732.98, 9912338.32, 9991237.29, 9185279.11, 8746450.1, 7680375.6]
    if r == 'w': wt = [62138130.47, 80516683.46, 56676066.36]
    if r == 'w': wtn = [3936382.37, 4254127.89, 5216704.48]
    if r == 'f': wt = [73377544.71, 53826297.05, 90676469.72]
    if r == 'f': wtn = [8796196.62, 7027987.51, 7200137.5]
    if r == 'b': wt = [30565057.44, 40414453.00, 37254842.99]
    if r == 'b': wtn = [1662866.61, 1947019.19, 2398964.26]
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    bim_e1 = xenergy(e1, bim, 10.0, False)
    L = len(bim)
    
    tot_sig_wt = 0.0
    for i in range(len(wt)): tot_sig_wt += wt[i]
    sig_wt = tot_sig_wt / float(len(wt))
    
    tot_sig_wtn = 0.0
    for i in range(len(wtn)): tot_sig_wtn += wtn[i]
    sig_wtn = tot_sig_wtn / float(len(wtn))
    
    of = open(op, 'w')
    
    for i in range(len(data)):
        seq = data[i][0]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        if r == 'x': pssm = energy_pssm[0]
        elif r == 'm': pssm = energy_pssm[1]
        elif r == 'w': pssm = energy_pssm[2]
        elif r == 'f': pssm = energy_pssm[3]
        elif r == 'b': pssm = energy_pssm[4]
        
        #dsig = -1.0 * math.log10(data[i][1] / sig_wt)
        dsig = -1.0 * math.log10(data[i][1] / sig_wt)
        print data[i][1] / sig_wt
        seq_e1 = xenergy(e1, seq, 10.0, False)
        ddg1 = seq_e1 - bim_e1
        if use_deep: deepes = deepe_calc_single(deepe, seq)
        else: deepes = 9999.0
        
        of.write(seq + '\t' + str(dsig) + '\t' + str(ddg1) + '\t' + str(pssm) + '\t' + str(deepes) + '\t' + nl[i].strip() + '\n')
        #of.write(seq + '\t' + str(dsig) + '\t' + nl[i].strip() + '\n')
    of.close()
    
    print sig_wtn / sig_wt
    
def SPOT_ratio(p1, r):
  
    data = lines2list(p1)
    
    if r == 'x': wt = [41585689.96, 35066023.81, 32635294.94, 36724240.95, 37208143.94, 36043775.76, 32078793.54, 41796802.73, 33976329.69, 32265382.09, 28442571.81]
    if r == 'x': wtn = [5128058.38, 4197284.61, 1109642.39, 4873309.11, 4630097.69, 4317967.51, 4636250.98]
    if r == 'm': wt = [53818742.55, 54190548.38, 58627198.08, 47644330.93, 50041419.46, 49323330.54, 47728219.68, 66718281.73, 73628389.6, 71914385.28, 66567470.98]
    if r == 'm': wtn = [7335097.52, 8453732.98, 9912338.32, 9991237.29, 9185279.11, 8746450.1, 7680375.6]
    if r == 'w': wt = [62138130.47, 80516683.46, 56676066.36]
    if r == 'w': wtn = [3936382.37, 4254127.89, 5216704.48]
    if r == 'f': wt = [73377544.71, 53826297.05, 90676469.72]
    if r == 'f': wtn = [8796196.62, 7027987.51, 7200137.5]
    if r == 'b': wt = [30565057.44, 40414453.00, 37254842.99]
    if r == 'b': wtn = [1662866.61, 1947019.19, 2398964.26]
    
    tot_sig_wt = 0.0
    for i in range(len(wt)): tot_sig_wt += wt[i]
    sig_wt = tot_sig_wt / float(len(wt))
    
    tot_sig_wtn = 0.0
    for i in range(len(wtn)): tot_sig_wtn += wtn[i]
    sig_wtn = tot_sig_wtn / float(len(wtn))
    
    for i in range(len(data)):
        print data[i][0] / sig_wt
    
def SPOT_log_plot(p1):
  
    l1 = readlines(p1)
    s = []
    n = []
    for i in range(len(l1)):
        items = l1[i].strip().split()
        s.append(float(items[0]))
        name = ''
        for j in range(len(items) - 1): name += items[j + 1] + ' '
        n.append(name)
        
    import matplotlib
    matplotlib.use( 'Agg' )
        
    import pylab
    
    a1 = pylab.array(s)
    

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (35, 20)
    pylab.bar(pylab.arange(len(n)), a1, color='w', edgecolor='b', linewidth=2, width=1.0, alpha=0.4)
    #facecolor='white', edgecolor='black', lw=2
    #pylab.ylim(0.0, 12.0)
    pylab.xlim(-1, len(s) + 1)
    pylab.xticks(pylab.arange(len(s)) + 0.5, n, rotation= 90.0)
    #pylab.xticks(pylab.arange(len(s)), n)
    #pylab.xlabel('position in sequence', fontsize=20)
    #pylab.ylabel('change in TSP3', fontsize=20)
    #pylab.title('Change in TSP3 by position', fontsize=20)
    pylab.savefig('/home/bartolo/web/statium/data/plots/bclxl_genome_hits.png')
    pylab.close()
        
def bcl2_char_data(preset_dir):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]

    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
        
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
        
    charge = []
    polar = []
    phob = []
    poss = []
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        

        aaf = AAChar_fasta(pdbinfo_vec[pos0][1])
        if not pos0 in res_vec and not pos0 in poss and aaf in ['E', 'D', 'R', 'K']:
        charge.append([pos0, aaf])
        poss.append(pos0)
        if not pos0 in res_vec and not pos0 in poss and aaf in ['H', 'N', 'Q', 'S', 'T']:
        polar.append([pos0, aaf])
        poss.append(pos0)
        if not pos0 in res_vec and not pos0 in poss and aaf in ['A', 'C', 'F', 'I', 'L', 'M', 'P', 'V', 'W', 'Y']:
        phob.append([pos0, aaf])
        poss.append(pos0)
    
    return [len(phob), len(polar), len(charge)]
    
def bcl2_character(preset_list):
  
    import pylab
    
    dirs = preset_list.split(',')
    va = []
    vp = []
    vc = []
    
    for diro in dirs:
        rv = bcl2_char_data(diro)
        va.append(rv[0])
        vp.append(rv[1])
        vc.append(rv[2])
        
    aa = pylab.array(va)
    ap = pylab.array(vp)
    ac = pylab.array(vc)
    xs = pylab.arange(len(dirs))
  
    pylab.bar(xs, aa, 0.35, color='k')
    pylab.bar(xs, ap, 0.35, bottom=aa, color='r')
    pylab.bar(xs, vc, 0.35, bottom=aa+ap, color='b')
    
    pylab.savefig('/home/bartolo/web/here.png')
    pylab.close()
    
def SPOT_exluded_residues():

    b2e = ''
    b3a = ''
    b3e = ''
    lines = readlines('/home/bartolo/web/orgWASP/3IO8_bclxl_2PQK_mcl1_SPOT200_analysis.txt')
    for line in lines:
        items = line.split()
        if len(items[1]) == 4:
        if items[1][1:3] == '2e' and float(items[4]) > 1.0 and float(items[5]) > 1.0 and not items[1][-1] in b2e:
            b2e += items[1][-1]
        if items[1][1:3] == '3a' and float(items[4]) > 1.0 and float(items[5]) > 1.0 and not items[1][-1] in b3a:
            b3a += items[1][-1]
        if items[1][1:3] == '3e' and float(items[4]) > 1.0 and float(items[5]) > 1.0 and not items[1][-1] in b3e:
            b3e += items[1][-1]

    print b2e
    print b3a
    print b3e

def load_design_preset(preset_dir):
  
    preset_list = os.listdir(preset_dir)
    
    pair_list = []
    pair_list.append([])
    pair_list.append([])
    
    for file in preset_list:
    file_path = os.path.join(preset_dir, file)
    if file[-10] + file[-9] == '_p':
        lines = readlines(file_path)
        pair_pos = []
        for i in range(1, len(lines)):
        line = lines[i].split()
        pair = []
        for j in range(1, len(line)): pair.append(float(line[j]))
        pair_pos.append(pair)
        pair_list[0].append(pair_pos)
        pair_list[1].append([int(file.split('_')[-3]) - 1, int(file.split('_')[-2]) - 1])
            
    return pair_list
    
def load_design_preset_sidechain(preset_dir):
  
    preset_list = os.listdir(preset_dir)
    
    pair_list = [[], []]
    
    for file in preset_list:
    file_path = os.path.join(preset_dir, file)
    if len(file.split('_')) == 3:
        if file[-10] + file[-9] == '_p':
            data = lines2list(file_path)
        pair_pos = []
        for i in range(20): pair_pos.append(data[i][1])
        pair_list[0].append(pair_pos)
        pair_list[1].append([int(file.split('_')[0]) - 1, int(file.split('_')[1]) - 1])
            
    return pair_list
    
def load_design_presett(preset_dir):
  
    preset_list = os.listdir(preset_dir)
    
    pair_list = []
    pair_list.append([])
    pair_list.append([])
    
    for file in preset_list:
    file_path = os.path.join(preset_dir, file)
    if len(file.split('_')) == 3:
        if file[-10] + file[-9] == '_p':
            lines = readlines(file_path)
        pair_pos = []
        for i in range(1, len(lines)):
            line = lines[i].split()
            pair = []
            for j in range(1, len(line)): pair.append(float(line[j]))
            pair_pos.append(pair)
        pair_list[0].append(pair_pos)
        pair_list[1].append([int(file.split('_')[0]) - 1, int(file.split('_')[1]) - 1])
            
    return pair_list
    
def sequence_library_energy_search(preset_dir, seq_path):
  
    #import numpy
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    exclude_path = os.path.join(file_dir, file_base + '.exclude')
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    exclude = [[], []]
    elines = readlines(exclude_path)
    for line in elines:
        items = line.split()
        exclude[0].append(int(items[0]))
        exclude[1].append(items[1])

    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    L = len(bim)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    sout_path = '/home/bartolo/web/seq.txt'
    nout_path = '/home/bartolo/web/names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    evec = []
    low_count = 0
    for i in range(len(seqs)):
      
          
        prot_seq = seqs[i][0]

        
        if i % 1000 == 0 and i > 0: print float(i) / float(len(seqs)), 'finished'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        nnaa = 0
        Ncharge = 0
        nPhob = 0
        cancel = False
        for k in range(L):
            aa = prot_seq[j + k]
            if k in exclude[0]:
            if aa in exclude[1][exclude[0].index(k)]:
                cancel = True
            seq += aa
            if aa in 'RKED': Ncharge += 1
            if aa in 'ACFGILMPVYW': nPhob += 1
            if AAChar_int(aa) >= 20: nnaa += 1
            
            if nnaa > 0 or Ncharge < 5 or nPhob > 15: continue
            if cancel: continue
            
            if not seq in seq_vec: seq_vec.append(seq)
            else: continue
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def BH3_mode():
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    L = len(bim)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/lib_statium/BH3mode_seq.txt'
    nout_path = '/home/bartolo/web/lib_statium/BH3mode_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    for i in range(len(seqs)):
          
        prot_seq = seqs[i][0]
        
        if i % 1000 == 0 and i > 0: print float(i) / float(len(seqs)), 'finished'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            if not seq[4] in 'ACFILMVWY' or not seq[5] in 'ACSGHIPTV' or not seq[8] in 'ILM' or not seq[9] in 'DEACFHIKLMNQRSTWVY' or not seq[10] in 'DEACFHIKLMNQRSTWVY' or not seq[11] in 'ACFILMVWY' or not seq[12] in 'AGS' or not seq[13] in 'DEQ' or not seq[14] in 'DEQ' or not seq[15] in 'ACFILMVWY': continue
            
            if not seq in seq_vec: seq_vec.append(seq)
            else: continue
            
            print seq, seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def BH3_genome_all():
  
    nonlocal = 0.0
  
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    evec = []
    for i in range(len(presets)): evec.append(load_design_energy(presets[i]))
    
    SPOT_vec = PSSM5()
    SPOT_bad_noxa_vec = PSSM_bad_noxa()
    
    dr = ['x', 'm', 'w', 'f' '2', 'bad', 'noxa']
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2']
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    L = len(bim)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/BH3_test_seq_loose.txt'
    nout_path = '/home/bartolo/web/statium/BH3_test_names_loose.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    print len(seqs)
    for i in range(len(seqs)):
          
        prot_seq = seqs[i][0]
        
        if i % 100 == 0 and i > 0: print float(i) / float(len(seqs)), 'finished'
        #print float(i) / float(len(seqs)), 'finished'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
           
        nnaa = 0
        Ncharge = 0
        nPhob = 0
        nMC = 0
        for k in range(len(seq)):
            aa = seq[k]
            if aa in 'RKED': Ncharge += 1
            if aa in 'ACFGILMPVYW': nPhob += 1
            if AAChar_int(aa) >= 20: nnaa += 1
        if seq[4] in 'MC': nMC += 1
        if seq[5] in 'MC': nMC += 1
        if seq[7] in 'MC': nMC += 1
        if seq[8] in 'MC': nMC += 1
        if seq[9] in 'MC': nMC += 1
        if seq[11] in 'MC': nMC += 1
        if seq[12] in 'MC': nMC += 1
        if seq[13] in 'MC': nMC += 1
        if seq[14] in 'MC': nMC += 1
        if seq[15] in 'MC': nMC += 1
        
        if seq == 'AAQRYGRELRRMSDEFVDSFKKG': print nnaa, Ncharge, nPhob, nMC
        
        if not seq[5] in 'ACSGHIPTV' or not seq[8] in 'ACFILMVWY' or not seq[12] in 'AGS' or not seq[13] in 'ACDEFGHIKLMNQRSTVWY': continue
            
            if nnaa > 0 or Ncharge < 4 or nPhob > 15 or nMC > 3: continue
            if seq == 'AAQRYGRELRRMSDEFVDSFKKG': print 'adding...'
            #if not seq[4] in 'ACFILMVWY' or not seq[5] in 'ACSGHIPTV' or not seq[8] in 'ILM' or not seq[9] in 'DEACFHIKLMNQRSTWVY' or not seq[10] in 'DEACFHIKLMNQRSTWVY' or not seq[11] in 'ACFILMVWY' or not seq[12] in 'AGS' or not seq[13] in 'DEQ' or not seq[14] in 'DEQ' or not seq[15] in 'ACFILMVWY': continue
            
            if not seq in seq_vec: seq_vec.append(seq)
            else: continue
            
            ##seq = 'WAREIGAQLRRMADDLNAQYERR'
            #e = []
            #energy_pssm = pssm_energy10(SPOT_vec, seq)
            #for k in range(5): e.append(energy_pssm[k])
            ##bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
            ##for k in range(2): e.append(bn_energy_pssm[k])
            
            #for k in range(5): e.append(statium_energy_calc(evec[k], seq, nonlocal) - statium_energy_calc(evec[k], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
            
            #found = False
            #found2 = False
            #for k in range(len(e)):
                #if k <= 4 and e[k] < 0.0: found = True
                #if k > 4 and e[k] < 0.0: found2 = True
                
            #if found and found2:
            #print
            #print seq_lines[seqs[i][1] - 2].strip()
            #print seq
            #for k in range(len(e)): print round(e[k], 2),
            #print
            #print
            #print seq, seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def BH3_genome_all_energy():
  
    nonlocal = 0.0
    #matrix = uniprot_bcl2_matrix()
  
    presets = ['/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8', '/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1', '/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3', '/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp', '/home/bartolo/web/statium_noref/bcl22/bcl2']
    evec = []
    for i in range(len(presets)): evec.append(load_design_energy(presets[i]))
    
    SPOT_vec = PSSM5()
    SPOT_bad_noxa_vec = PSSM_bad_noxa()
    
    dr = ['x', 'm', 'w', 'f' '2', 'bad', 'noxa']
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2']
    
    seq_data = lines2list('/home/bartolo/web/statium/BH3_heuristicKRHNQST_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/BH3_heuristicKRHNQST_names.txt')
    of = open('/home/bartolo/web/statium/BH3_test_heuristicKRHNQST.txt', 'w')
    names = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)
        
    for i in range(len(seq_data)):
        if i % 1000 == 0 and i > 0: print float(i) / float(len(seq_data)), 'finished'

        seq = seq_data[i][0]
    if not check_BH3(seq): continue
        e = []
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        for k in range(5): e.append(energy_pssm[k])
            ##bn_energy_pssm = pssm_energy10_bad_noxa(SPOT_bad_noxa_vec, seq)
            ##for k in range(2): e.append(bn_energy_pssm[k])
        
    for k in range(5): e.append(statium_energy_calc(evec[k], seq, nonlocal) - statium_energy_calc(evec[k], 'PEIWIAQELRRIGDEFNAYYARR', nonlocal))
        #e.append(bcl2_uniprot_score(matrix, seq))
        of.write(seq + '\t')
        for k in range(len(e)): of.write(str(round(e[k], 2)) + '\t')
        of.write(names[i] + '\n')
    of.close()
    
def combine_columns(f1, f2, opath):
  
    f1_lines = readlines(f1)
    f2_lines = readlines(f2)
    
    ofile = open(opath, 'w')
    for i in range(len(f1_lines)):
        ofile.write(f1_lines[i].strip() + '\t' + f2_lines[i].strip() + '\n')
        
    ofile.close()
    
def design_list_calc(preset_dir, seq_path, opath):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    stats_path = os.path.join(file_dir, file_base + '.stats')
    
    stats = False
    if os.path.exists(stats_path):
        stats = True
        line = readline(stats_path, 1)
        items = line.strip().split('=')
        stats_vec = [float(items[0]), float(items[1])]
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    seqs = lines2list(seq_path)
    
    #seqs = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'TMGQVGRQLAIIGDDINRRYDSE', 'STKKLSECLKRIGDELDSNMELQ', 'LPPEFAAQLRKIGDKVYCTWSAP', 'EGEKEVEALKKSADWVSDWSSRP', 'AAQLTAARLKALGDELHQRTMWR', 'AEVQIARKLQCIADQFHRLHVQQ', 'GSDALALRLACIGDEMDVSLRAP', 'IIRNIARHLAQVGDSMDRSIPPG', 'VIDDHERGLIRNGRDFLLALERQ', 'HKKKTVKMLEYLGKDVLHGVFNY', 'EANLFEEALEKYGKDFTDIQQDF', 'TAEEVVLWLEQLGPWASLYRERF', 'KAETGGKLLEIKAHEDEVLCCAF', 'PEIWEAQEERREGDEENAYYARR', 'ATSYRGDHIKLQADSFGLHIVPV']
    #names = ['puma', 'bim', 'Noxa', 'bad', 'Bak', 'Bax', 'MNoxaA', 'BNIP3', 'Hrk/DP5', 'bmf', 'bik', 'bid', 'DDE', 'Casp5Card', 'MTA1', 'bar_sam', 'apaf', 'neg', 'scott']

    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        energy = sequence_energy(pair_list, seq, seq_ref, res_vec, pdbinfo_vec, 10.0)
    #print name + '\t' + str(energy), seq,
    if stats: seqs[i].append(str((energy - stats_vec[0]) / stats_vec[1])[0:5])
    else: seqs[i].append(str(energy)[0:5])
    
    ofile = open(opath, 'w')
    for i in range(len(seqs)):
        for j in range(len(seqs[i])): ofile.write(str(seqs[i][j]) + '\t')
        ofile.write('\n')
    ofile.close()
    
def general_design_list_calc(preset_dir, seq_path, opath):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    stats_path = os.path.join(file_dir, file_base + '.stats')
    
    stats = False
    if os.path.exists(stats_path):
        stats = True
        line = readline(stats_path, 1)
        items = line.strip().split('=')
        stats_vec = [float(items[0]), float(items[1])]
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    seqs = lines2list(seq_path)
    
    #seqs = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'LEVECATQLRRFGDKLNFRQKLL', 'AAQRYGRELRRMSDEFVDSFKKG', 'TMGQVGRQLAIIGDDINRRYDSE', 'STKKLSECLKRIGDELDSNMELQ', 'LPPEFAAQLRKIGDKVYCTWSAP', 'EGEKEVEALKKSADWVSDWSSRP', 'AAQLTAARLKALGDELHQRTMWR', 'AEVQIARKLQCIADQFHRLHVQQ', 'GSDALALRLACIGDEMDVSLRAP', 'IIRNIARHLAQVGDSMDRSIPPG', 'VIDDHERGLIRNGRDFLLALERQ', 'HKKKTVKMLEYLGKDVLHGVFNY', 'EANLFEEALEKYGKDFTDIQQDF', 'TAEEVVLWLEQLGPWASLYRERF', 'KAETGGKLLEIKAHEDEVLCCAF', 'PEIWEAQEERREGDEENAYYARR', 'ATSYRGDHIKLQADSFGLHIVPV']
    #names = ['puma', 'bim', 'Noxa', 'bad', 'Bak', 'Bax', 'MNoxaA', 'BNIP3', 'Hrk/DP5', 'bmf', 'bik', 'bid', 'DDE', 'Casp5Card', 'MTA1', 'bar_sam', 'apaf', 'neg', 'scott']

    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        energy = sequence_energy(pair_list, seq, seq_ref, res_vec, pdbinfo_vec, 10.0)
    #print name + '\t' + str(energy), seq,
    if stats: seqs[i].append((energy - stats_vec[0]) / stats_vec[1])
    else: seqs[i].append(energy)
    
    ofile = open(opath, 'w')
    for i in range(len(seqs)):
        for j in range(len(seqs[i])): ofile.write(str(seqs[i][j]) + '\t')
        ofile.write('\n')
    ofile.close()
    

    
def natural_pssm():
    
    SPOT_vec = PSSM5()
            
    seqs = []
    names = []
    natural = lines2list('/home/bartolo/web/statium/BH3_natural.txt')
    for i in range(len(natural)):
        if len(natural[i]) > 1:
            seqs.append(natural[i][0])
            names.append(natural[i][1])
        else:
            seqs.append(natural[i][0])
            names.append('seq')
    
    print 'BH3' + '\t\t' + 'sequence              ' + '\tbclxl\tmcl1\tbcl2\tbclw\tbfl1'
    for i in range(len(seqs)):
        seq = seqs[i]
        name = names[i]
      
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        pssm_bclxl = energy_pssm[0]
        pssm_mcl1 = energy_pssm[1]
        pssm_bclw = energy_pssm[2]
        pssm_bfl1 = energy_pssm[3]
        pssm_bcl2 = energy_pssm[4]
        
        print name + '\t\t' + seq + '\t' + str(pssm_bclxl) + '\t' + str(pssm_mcl1) + '\t' + str(pssm_bcl2) + '\t' + str(pssm_bclw) + '\t' + str(pssm_bfl1)
    
def design_energy_calc():
  
    design_energy_bclxl = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    design_energy_bclw = load_design_energy('/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp')
    
    seqs = []
    names = []
    natural = lines2list('/home/bartolo/web/statium/BH3_natural.txt')
    for i in range(len(natural)):
        if len(natural[i]) > 1:
            seqs.append(natural[i][0])
            names.append(natural[i][1])
        else:
            seqs.append(natural[i][0])
            names.append('seq')
    
    print 'BH3' + '\t\t' + 'sequence              ' + '\tbclxl\tmcl1\tbcl2\tbclw\tbfl1'
    for i in range(len(seqs)):
        seq = seqs[i]
        name = names[i]
        
        stats = False
        bclxl_energy = statium_energy_calc(design_energy_bclxl, seq, 0.0)
        mcl1_energy = statium_energy_calc(design_energy_mcl1, seq, 0.0)
        bclw_energy = statium_energy_calc(design_energy_bclw, seq, 0.0)
        bcl2_energy = statium_energy_calc(design_energy_bcl2, seq, 0.0)
        bfl1_energy = statium_energy_calc(design_energy_bfl1, seq, 0.0)
    print name + '\t\t' + seq + '\t' + str(round(bclxl_energy, 2)) + '\t' + str(round(mcl1_energy, 2)) + '\t' + str(round(bcl2_energy, 2)) + '\t' + str(round(bclw_energy, 2)) + '\t' + str(round(bfl1_energy, 2))
    
def dup_seq(ip):
  
    v = []
    l = readlines(ip)
    for line in l:
        items = line.split()
        if len(items) > 0:
        if len(items[0]) == 27:
            print items[0]
            seq = []
            for i in range(27):
            if i == 10: seq.append('D')
            else: seq.append(items[0][i])
        print string.join(seq, '')
            seq = []
            for i in range(27):
            if i == 10: seq.append('K')
            else: seq.append(items[0][i])
        print string.join(seq, '')
            seq = []
            for i in range(27):
            if i == 14: seq.append('L')
            else: seq.append(items[0][i])
        print string.join(seq, '')
        else: print items[0]
    else: print
    print len(v)

def xenergy(energy_vec, seq, chargeX, stats):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    count = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        if (pos0 in res_vec and pos1 in res_vec): e = e * 0.0
        #if (not pos0 in res_vec or not pos1 in res_vec): e = e * chargeX
        #if charge_pair(aa0, aa1): e += 30.0
        #if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)) and pos1 - pos0: e = e * 3.0        
#print pos0 + 1, pos1 + 1, AAChar_fasta(aa0), AAChar_fasta(aa1), e
    #print str(pos0 + 1) + '\t' + str(pos1 + 1) + '\t' + AAChar_fasta(aa0) + '\t' + AAChar_fasta(aa1) + '\t' + str(e)

        energy += e
        count += 1.0
            
    if stats: return round(Energy2Prob(energy, energy_vec[-1]), 5)
    else: return energy
    
def statium_energy_calc(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
    weights_vec = energy_vec[5]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        if [pos0 + 1, pos1 + 1] in mask_vec: continue
        
        if pos0 in res_vec or pdbinfo_vec[pos0][1] < 0: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec or pdbinfo_vec[pos1][1] < 0: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]   
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa0][aa1]
        if (pos0 in res_vec and pos1 in res_vec):
            e = e * localX
    energy += e
            
    return energy

def statium_energy_calc_intralocal(energy_vec, seq, localX, flag):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
    weights_vec = energy_vec[5]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])

    labels = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']
  
    energy = 0.0
    benergy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]]) 
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa0][aa1]
        energy += e
            
    return energy
  
def statium_energy_calc_fullsequence(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        if [pos0 + 1, pos1 + 1] in mask_vec: continue
        
        aa0 = AAChar_int(seq[pos0])
        aa1 = AAChar_int(seq[pos1])  
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        #if e == 4.6: continue
        
        if (pos0 in res_vec and pos1 in res_vec):
        e = e * localX
        if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)): e = e * 1.0
    #if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)): e = e * 10.0
    energy += e
            
    return energy
    
def statium_energy_calc_sidechain(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
    weights_vec = energy_vec[5]
  
    energy = 0.0
    L = len(res_vec)
    for j in range(len(pair_list[0])):
        pos1 = pair_list[1][j][1]
        pos0 = pair_list[1][j][0]
        try:
            if seq[pos1 - seq_ref[0] + seq_ref[1]] == 'X': continue
            if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        except: continue
    
        if AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa1]
        energy += e
            
    return energy

def statium_pair_terms(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]

    pair_terms = []
  
    energy = 0.0
    L = len(res_vec)
    for j in range(len(pair_list[0])):
        pos1 = pair_list[1][j][1]
        pos0 = pair_list[1][j][0]
        try:
            if seq[pos1 - seq_ref[0] + seq_ref[1]] == 'X': continue
            if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        except: continue
      
    if AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa1]
        pair_terms.append(e)
            
    return pair_terms

def statium_pair_terms_orig(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    pair_terms = []
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        if [pos0 + 1, pos1 + 1] in mask_vec: continue
        
        aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: continue
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa0][aa1]
    pair_terms.append(e)
            
    return pair_terms

def statium_labels(energy_vec, seq, localX):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]

    labels = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']

    linfo = []
  
    energy = 0.0
    L = len(res_vec)
    for j in range(len(pair_list[0])):
        pos1 = pair_list[1][j][1]
        pos0 = pair_list[1][j][0]
        try:
            if seq[pos1 - seq_ref[0] + seq_ref[1]] == 'X': continue
            if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        except: continue
      
    linfo.append([pos0 + 1, AAChar_fasta(pdbinfo_vec[pos0][1]), labels[pos1 - seq_ref[0] + seq_ref[1]]])
            
    return linfo

def bcl2_svm():

    data = lines2list('/home/bartolo/web/statium/all_array_analysis/svm/genome/x_binders.txt')
    genome_data = lines2list('/home/bartolo/web/statium/all_array_analysis/svm/random_genome_seq_hits.txt')
    bind = []
    for i in range(len(data)):
        seq = data[i][0]
    bind.append(seq)
    nobind = []
    for i in range(len(genome_data)):
        seq = genome_data[i][0]
    if not seq in bind: nobind.append(seq)

    features = []
    states = []
    for seq in bind:
        fvec = []
    for j in range(len(seq)):
        aa = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        aa[AAChar_int(seq[j])] = 1
        for k in range(20): fvec.append(aa[k])
    features.append(fvec)
    states.append(0)
    count = 0
    count2 = 0
    for seq in nobind:
    count += 1
    if not count % 10 == 0: continue
        fvec = []
    for j in range(len(seq)):
        aa = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        aa[AAChar_int(seq[j])] = 1
        for k in range(20): fvec.append(aa[k])
    count2 += 1
    #print count2
    features.append(fvec)
    states.append(1)

    X = array(features)
    y = array(states)

    print 'training...'

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    for seq in nobind:
#        test = statium_pair_terms(xmode, seq, 0.0)
#    print seq, clf.predict(array([test]))
        
    fvec = []
    for j in range(len(seq)):
        aa = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        aa[AAChar_int(seq[j])] = 1
        for k in range(20): fvec.append(aa[k])
    print seq, clf.predict(array(fvec))
        
            
    weights = clf.coef_
    count = 0
    wvec = []
    pos = []
    for i in range(len(weights[0])):
    aa = AAChar_fasta(count)
    pos.append(weights[0][i])
    if count == 19:
        count = 0
        wvec.append(pos)
        pos = []
    else: count += 1

    #import pylab
    #pylab.rcParams['savefig.dpi'] = '800'
    #fig = pylab.figure()
    #ax = fig.gca()
    #ax.pcolor(array(wvec), cmap=pylab.get_cmap('Greys'))
    #pylab.ylim(0, 23)
    #pylab.xticks([])
    #pylab.yticks([])
    #fig.set_aspect('equal')
    #pylab.savefig('/home/bartolo/web/here.png')

    return clf

def statium_svm():

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    data = lines2list('/home/bartolo/web/statium/all_array_analysis/prediction/x_binders.txt')
    genome_data = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq_removeU.txt')
    bind = []
    for i in range(len(data)):
        seq = data[i][0]
    bind.append(seq)
    nobind = []
    for i in range(len(genome_data)):
        seq = genome_data[i][0]
    if not seq in bind: nobind.append(seq)

    linfo = statium_labels(xmode, 'PEIWIAQELRRIGDEFNAYYARR', 0.0)

    features = []
    states = []
    for seq in bind:
        fvec = statium_pair_terms(xmode, seq, 0.0)
    features.append(fvec)
    states.append(0)
    count = 0
    for seq in nobind:
    count += 1
    if count % 10 != 0: continue
        fvec = statium_pair_terms(xmode, seq, 0.0)
    features.append(fvec)
    states.append(1)

    X = array(features)
    y = array(states)

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    for seq in nobind:
        test = statium_pair_terms(xmode, seq, 0.0)
    print seq, clf.predict(array([test]))
            
    weights = clf.coef_
    for i in range(len(weights[0])):
        print linfo[i], weights[0][i]

def statium_spec_svm():

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')

    xdata = lines2list('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    mdata = lines2list('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')

    x = []
    for i in range(len(xdata)):
        seq = xdata[i][0]
    x.append(seq)
    m = []
    for i in range(len(mdata)):
        seq = mdata[i][0]
    m.append(seq)

    features = []
    states = []
    for seq in m:
        xvec = statium_pair_terms(xmode, seq, 0.0)
    mvec = statium_pair_terms(mmode, seq, 0.0)
    fvec = []
    for i in range(len(mvec)): fvec.append(mvec[i])
    features.append(fvec)
    states.append(2)
    for seq in x:
        xvec = statium_pair_terms(xmode, seq, 0.0)
    mvec = statium_pair_terms(mmode, seq, 0.0)
    fvec = []
    for i in range(len(mvec)): fvec.append(mvec[i])
    features.append(fvec)
    states.append(1)


    X = array(features)
    y = array(states)

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    #for seq in nobind:
     #   test = statium_pair_terms(xmode, seq, 0.0)
    #print seq, clf.predict(array([test]))
            
    weights = clf.coef_
    for i in range(len(weights[0])):
    if weights[0][i] < 0.00001: w = 0.0
    else: w = weights[0][i]
        print w

def statium_spec_svm_orig():

    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')

    xdata = lines2list('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    mdata = lines2list('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')

    x = []
    for i in range(len(xdata)):
        seq = xdata[i][0]
    x.append(seq)
    m = []
    for i in range(len(mdata)):
        seq = mdata[i][0]
    m.append(seq)

    features = []
    states = []
    for seq in m:
        xvec = statium_pair_terms_orig(xorig, seq, 0.0)
    mvec = statium_pair_terms_orig(morig, seq, 0.0)
    fvec = []
    for i in range(len(mvec)): fvec.append(mvec[i])
    features.append(fvec)
    states.append(2)
    for seq in x:
        xvec = statium_pair_terms_orig(xorig, seq, 0.0)
    mvec = statium_pair_terms_orig(morig, seq, 0.0)
    fvec = []
    for i in range(len(mvec)): fvec.append(mvec[i])
    features.append(fvec)
    states.append(1)


    X = array(features)
    y = array(states)

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    #for seq in nobind:
     #   test = statium_pair_terms(xmode, seq, 0.0)
    #print seq, clf.predict(array([test]))
            
    weights = clf.coef_
    for i in range(len(weights[0])):
    if weights[0][i] < 0.00001: w = 0.0
    else: w = weights[0][i]
        print w

def statium_spec_vmodel(r):

    xdata = lines2list('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    mdata = lines2list('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')

    deepxs = deepe_matrix_single('x')
    deepms = deepe_matrix_single('m')

    idx_vec = [4, 8, 9, 11, 13, 15]
    labels = ['2d', '3a', '3b', '3d', '3f', '4a']

    lib = [['F', 'V', 'T', 'I', 'N', 'Y', 'D', 'A', 'S'], ['F', 'I', 'L', 'V', 'A', 'T', 'P', 'S'], ['R', 'D', 'G', 'S', 'K', 'N', 'E', 'Q', 'H'], ['I', 'V', 'F', 'Y', 'A', 'N', 'T', 'D', 'S'], ['D', 'N', 'E', 'G', 'S', 'R', 'Q', 'K', 'H'], ['T', 'I', 'V', 'A', 'F', 'D', 'N', 'S', 'Y']]

    flat_lib = []
    for i in range(len(lib)):
    for j in range(len(lib[i])):
        flat_lib.append(labels[i] + ' ' + lib[i][j])

    x = []
    for i in range(len(xdata)):
        seq = xdata[i][0]
    x.append(seq)
    m = []
    for i in range(len(mdata)):
        seq = mdata[i][0]
    m.append(seq)

    if r == 'm': bindm = 1
    else: bindm = 2
    if r == 'x': bindx = 1
    else: bindx = 2

    features = []
    states = []
    for seq in m:
    fvec = []
    for j in range(len(idx_vec)):
        idx = idx_vec[j]
            fvec.append(deepms[j][AAChar_int(seq[idx])])
    features.append(fvec)
    states.append(bindm)

    for seq in x:
    fvec = []
    for j in range(len(idx_vec)):
        idx = idx_vec[j]
            fvec.append(deepxs[j][AAChar_int(seq[idx])])
    features.append(fvec)
    states.append(bindx)

    X = array(features)
    y = array(states)

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    #for seq in nobind:
     #   test = statium_pair_terms(xmode, seq, 0.0)
    #print seq, clf.predict(array([test]))
            
    weights = clf.coef_
    wvec = []
    for i in range(len(weights[0])):
    if weights[0][i] < 0.00001: w = 0.0
    else: w = weights[0][i]
        wvec.append(w)
    print w

    return wvec

def score_vmodel(seq, wvec, deep):

    idx_vec = [4, 8, 9, 11, 13, 15]
    labels = ['2d', '3a', '3b', '3d', '3f', '4a']

    lib = [['F', 'V', 'T', 'I', 'N', 'Y', 'D', 'A', 'S'], ['F', 'I', 'L', 'V', 'A', 'T', 'P', 'S'], ['R', 'D', 'G', 'S', 'K', 'N', 'E', 'Q', 'H'], ['I', 'V', 'F', 'Y', 'A', 'N', 'T', 'D', 'S'], ['D', 'N', 'E', 'G', 'S', 'R', 'Q', 'K', 'H'], ['T', 'I', 'V', 'A', 'F', 'D', 'N', 'S', 'Y']]


    score = 0.0
    for i in range(len(idx_vec)):
    idx = idx_vec[i]
    score += wvec[i] * deep[i][AAChar_int(seq[idx])]

    return score

def statium_spec_vmodel_pair(r):

    xdata = lines2list('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    mdata = lines2list('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')

    idx_vec = [4, 8, 9, 11, 13, 15]
    labels = ['2d', '3a', '3b', '3d', '3f', '4a']

    lib = [['F', 'V', 'T', 'I', 'N', 'Y', 'D', 'A', 'S'], ['F', 'I', 'L', 'V', 'A', 'T', 'P', 'S'], ['R', 'D', 'G', 'S', 'K', 'N', 'E', 'Q', 'H'], ['I', 'V', 'F', 'Y', 'A', 'N', 'T', 'D', 'S'], ['D', 'N', 'E', 'G', 'S', 'R', 'Q', 'K', 'H'], ['T', 'I', 'V', 'A', 'F', 'D', 'N', 'S', 'Y']]

    x = []
    for i in range(len(xdata)):
        seq = xdata[i][0]
    x.append(seq)
    m = []
    for i in range(len(mdata)):
        seq = mdata[i][0]
    m.append(seq)

    if r == 'm': bindm = 2
    else: bindm = 1
    if r == 'x': bindx = 2
    else: bindx = 1

    features = []
    states = []
    for seq in m:
    fvec = []
    for j in range(len(idx_vec)):
        for k in range(j + 1, len(idx_vec)):
            idxj = idx_vec[j]
        idxk = idx_vec[k]
            for l in range(len(lib[j])):
            for p in range(len(lib[k])):
            if seq[idxj] == lib[j][l] and seq[idxk] == lib[k][p]: fvec.append(1.0)
                else: fvec.append(0.0)
    features.append(fvec)
    states.append(bindm)

    for seq in x:
    fvec = []
    for j in range(len(idx_vec)):
        for k in range(j + 1, len(idx_vec)):
            idxj = idx_vec[j]
        idxk = idx_vec[k]
            for l in range(len(lib[j])):
            for p in range(len(lib[k])):
            if seq[idxj] == lib[j][l] and seq[idxk] == lib[k][p]: fvec.append(1.0)
                else: fvec.append(0.0)
    features.append(fvec)
    states.append(bindx)

    X = array(features)
    y = array(states)

    from sklearn.svm import SVC
    
    clf = SVC(kernel='linear')
    clf.fit(X, y)
    
    #for seq in nobind:
     #   test = statium_pair_terms(xmode, seq, 0.0)
    #print seq, clf.predict(array([test]))
            
    weights = clf.coef_
    wvec = []
    for i in range(len(weights[0])):
    if weights[0][i] < 0.00001: w = 0.0
    else: w = weights[0][i]
        wvec.append(w)

    rwvec = []
    for j in range(len(idx_vec)):
        rwvec.append([])
    for k in range(len(idx_vec)): rwvec[j].append([[], []])

    count = 0
    for j in range(len(idx_vec)):
        for k in range(j + 1, len(idx_vec)):
            idxj = idx_vec[j]
               idxk = idx_vec[k]
        for l in range(len(lib[j])):
        for p in range(len(lib[k])):
            pair = lib[j][l] + lib[k][p]
            rwvec[j][k][0].append(pair)    
            rwvec[j][k][1].append(wvec[count])
            count += 1

    return rwvec

def score_vmodel_pair(seq, wvec):

    idx_vec = [4, 8, 9, 11, 13, 15]
    labels = ['2d', '3a', '3b', '3d', '3f', '4a']

    lib = [['F', 'V', 'T', 'I', 'N', 'Y', 'D', 'A', 'S'], ['F', 'I', 'L', 'V', 'A', 'T', 'P', 'S'], ['R', 'D', 'G', 'S', 'K', 'N', 'E', 'Q', 'H'], ['I', 'V', 'F', 'Y', 'A', 'N', 'T', 'D', 'S'], ['D', 'N', 'E', 'G', 'S', 'R', 'Q', 'K', 'H'], ['T', 'I', 'V', 'A', 'F', 'D', 'N', 'S', 'Y']]

    score = 0.0
    for i in range(len(idx_vec)):
        for j in range(i + 1, len(idx_vec)):
        idxi = idx_vec[i]
        idxj = idx_vec[j]
        pair = seq[idxi] + seq[idxj]
        score += wvec[i][j][1][wvec[i][j][0].index(pair)]

    return score
   
def statium_pos_sidechain(energy_vec):
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
    
    esum = []
    for i in range(len(res_vec)):
        esumi = []
        for j in range(20): esumi.append(0.0)
        esum.append(esumi)
  
    energy = 0.0
    for j in range(len(pair_list[0])):
        pos1 = pair_list[1][j][1]
        
        idx = res_vec.index(pos1)
        for k in range(20): esum[idx][k] += pair_list[0][j][k]
    
    print 'AA\t',
    for i in range(20): print AAChar_fasta(i) + '\t',
    print
    for i in range(len(esum)):
        print AAChar_fasta(pdbinfo_vec[res_vec[i]][1]) + '\t',
        for j in range(20): print str(round(esum[i][j], 2)) + '\t',
        print
    
def mask_pairs(epath, ecut):
  
    mask_file = open(epath + '.mask', 'w')
  
    energy_vec = load_design_energy(epath)
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    mask_vec = energy_vec[4]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        aa0 = pdbinfo_vec[pos0][1]
        aa1 = pdbinfo_vec[pos1][1]   
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        #if e == 4.6: continue
        
        if (pos0 in res_vec and pos1 in res_vec):
        e = e * localX
        if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)): e = e * 1.0
    else:
        if e > ecut: mask_file.write(str(pos0 + 1) + '\t' + str(pos1 + 1) + '\n')
    energy += e
    
    mask_file.close()
    return energy
    
def statium_general_calc(energy_vec, dvec):
  
    pair_list = energy_vec[0]
    pdbinfo_vec = energy_vec[1]
    
    seq = []
    for i in range(len(pdbinfo_vec)): seq.append(pdbinfo_vec[i][1])
    
    for i in range(len(dvec)): seq[dvec[i][0]] = dvec[i][1]
  
    energy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        aa0 = seq[pos0]
        aa1 = seq[pos1]
        e = pair_list[0][j][aa0][aa1]
        if (salt_bridge(aa0, aa1)): e = e * 1.0
        energy += e
            
    return energy
    
def E9_ILP():

    data = lines2list('/home/bartolo/web/E9_IM9/mutations.txt')

    loaded_statium = load_statium('/home/bartolo/web/E9_IM9_ip/E9_IM9_1bxi')
    
    wte = statium_general_calc(loaded_statium, [])
    
    pred_vec = [[], []]
    for i in range(len(data)):
        ddg = data[i][2]
        dvec = [[int(data[i][0]) - 1, AAChar_int(data[i][1])]]
        e = statium_general_calc(loaded_statium, dvec)
        
        if e - wte != 0.0:
            if ddg > 1.0:
                pred_vec[0].append(1)
                pred_vec[1].append(e - wte)
            else:
                pred_vec[0].append(0)
                pred_vec[1].append(e - wte)
        
    print data[i][0], ddg, e - wte
   
    pred = pyroc(pred_vec)
    print pred[0][0]
    print pred[0][1]
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['savefig.dpi'] = '300'
    
    pylab.plot(pylab.array(pred[0][0]), pylab.array(pred[0][1]), 'k', lw=4)
    pylab.xlim(-0.05, 1.0)
    pylab.ylim(0.0, 1.05)
    pylab.savefig('/home/bartolo/web/E9_IM9/mutations_roc.png')
    pylab.close()
    
    print pred[1]
    
def statium_config(preset):
  
    seqint = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.seqint'), 'w')
    ref = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.ref'), 'w')
    posint = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.posint'), 'w')
    paths = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.paths'), 'w')
  
    energy_vec = load_design_energy(preset)
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    
    ref.write(str(seq_ref[0]) + '\t' + str(seq_ref[1]))
    ref.close()
    
    print len(pdbinfo_vec)
    
    for i in range(len(pdbinfo_vec)): seqint.write(str(pdbinfo_vec[i][1]) + '\n')
    seqint.close()
    
    seq = ''
    for i in range(len(pdbinfo_vec)): seq += AAChar_fasta(pdbinfo_vec[i][1])
    print seq
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    count = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
    posint.write(str(pos0) + '\t' + str(pos1) + '\n')
    #if AAChar_fasta(aa1) != 'G': print AAChar_fasta(aa0), AAChar_fasta(aa1), pos0, pos1, e
        paths.write(os.path.join(preset, str(pos0 + 1) + '_' + str(pos1 + 1) + '_probs.txt') + '\n')
    posint.close()
    paths.close()
    
def statium_config_sidechain(preset):
  
    seqint = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.seqint'), 'w')
    #ref = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.ref'), 'w')
    #posint = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.posint'), 'w')
    #paths = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.paths'), 'w')
  
    energy_vec = load_design_energy_sidechain(preset)
  
    #pair_list = energy_vec[0]
    #seq_ref = energy_vec[3]
    #res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    
    #ref.write(str(seq_ref[0]) + '\t' + str(seq_ref[1]))
    #ref.close()
    
    #print len(pdbinfo_vec)
    
    for i in range(len(pdbinfo_vec)): seqint.write(str(pdbinfo_vec[i][1]) + '\n')
    seqint.close()
    
    #seq = ''
    #for i in range(len(pdbinfo_vec)): seq += AAChar_fasta(pdbinfo_vec[i][1])
    #print seq
  
    #pos_list = []
    #pos_list.append([])
    #pos_list.append([])
  
    #energy = 0.0
    #benergy = 0.0
    #count = 0.0
    #for j in range(len(pair_list[0])):
        #pos0 = pair_list[1][j][0]
        #pos1 = pair_list[1][j][1]
    #posint.write(str(pos0) + '\t' + str(pos1) + '\n')
    ##if AAChar_fasta(aa1) != 'G': print AAChar_fasta(aa0), AAChar_fasta(aa1), pos0, pos1, e
        #paths.write(os.path.join(preset, str(pos0 + 1) + '_' + str(pos1 + 1) + '_probs.txt') + '\n')
    #posint.close()
    #paths.close()
    
def statium_general_config(preset):
  
    seqint = open(os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.seqint'), 'w')

    pdb_path = os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.pdb')
    seqdata_path = os.path.join(os.path.split(preset)[0], os.path.split(preset)[1] + '.seq')
    pdbinfo_vec = structure_info(pdb_path, seqdata_path)
    
    seq = ''
    for i in range(len(pdbinfo_vec)):
    seq += AAChar_fasta(pdbinfo_vec[i][1])
        seqint.write(str(pdbinfo_vec[i][1]) + '\n')
    seqint.close()
    print seq
    
def cut_float(number, size):
    
    return str(number)[0:min(size, len(str(number)))]
    
def statium_position_energy(preset):
  
    seq = 'PEIWIAQELRRIADEFNAYYARR'
    energy_vec = load_design_energy(preset)
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    for i in range(len(res_vec)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)
  
    energy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if not pos1 in res_vec: continue
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        if (not pos0 in res_vec and pos1 in res_vec):
        for k in range(20):
            pos_list[res_vec.index(pos1)][k] += pair_list[0][j][aa0][k]

        energy += e

    #prnt_str = ''
    prnt_str = 'AA\t'
    for i in range(20): prnt_str += AAChar_fasta(i) + '\t'
    prnt_str += '\n'
    for i in range(len(pos_list)):
        prnt_str += seq[res_vec[i] - seq_ref[0] + seq_ref[1]] + '\t'
        for j in range(20): prnt_str += cut_float(pos_list[i][j], 5) + '\t'
        if i < len(pos_list) - 1: prnt_str += '\n'
        
    print prnt_str
    
def statium_classy_config0(preset):
  
    seq = 'PEIWIAQELRRIADEFNAYYARR'
    labels = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']
    energy_vec = load_design_energy(preset)
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    for i in range(len(labels)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)
        
    posmin = res_vec[0] - seq_ref[0] + seq_ref[1]
    posmax = res_vec[-1] - seq_ref[0] + seq_ref[1]
  
    energy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if not pos1 in res_vec: continue
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        if (not pos0 in res_vec and pos1 in res_vec):
        for k in range(20):
            pos_list[pos1 - seq_ref[0] + seq_ref[1]][k] += pair_list[0][j][aa0][k]

        energy += e
        
    clstr = ''
    for i in range(len(labels)):
        for j in range(20):
        if i < posmin or i > posmax or j == 5: estr = '0.0'
        else: estr = str(pos_list[i][j])
            clstr += 'design ' + labels[i] + ' ' + AAChar_fasta(j) + ' ' + str(estr) + '\n'
        
    return clstr.strip()
    
def statium_classy_config(energy_vec, lib_path):
   
    libf = readlines(lib_path)
    lib = []
    CH = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        for res in range(len(seq)):
        lib[-1].append(AAChar_int(seq[res]))
        if seq[res] in 'DEKR': CH.append(1.0)
        else: CH.append(0.0)
        
    nums = []
    count = 0
    for i in range(len(lib)):
        nums.append([])
        for j in range(len(lib[i])):
        count += 1
        nums[-1].append(count)
        

    seq = 'WAREIGAQLRRMADDLNAQYERR'
    labels = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    
    ppos = []
  
    pos_list = []
    for i in range(len(labels)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)
        
    posmin = res_vec[0] - seq_ref[0] + seq_ref[1]
    posmax = res_vec[-1] - seq_ref[0] + seq_ref[1]
  
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if not pos1 in res_vec: continue
           
        if (not pos0 in res_vec):
        aa0 = pdbinfo_vec[pos0][1]
        for k in range(20):
            if AAChar_fasta(k) != 'G':
                pos_list[pos1 - seq_ref[0] + seq_ref[1]][k] += pair_list[0][j][aa0][k]

        if (pos0 in res_vec):
        idx0 = pos0 - seq_ref[0] + seq_ref[1]
        idx1 = pos1 - seq_ref[0] + seq_ref[1]
        for k in range(len(lib[idx0])):
            for l in range(len(lib[idx1])):
            if AAChar_fasta(lib[idx0][k]) == 'G' or AAChar_fasta(lib[idx1][l]) == 'G': e = 0.0
            else: e = pair_list[0][j][lib[idx0][k]][lib[idx1][l]] * 0.10
            ppos.append([nums[idx0][k], nums[idx1][l], e])
     
    spos = []
    for i in range(len(labels)):
        for j in range(len(lib[i])): spos.append(pos_list[i][lib[i][j]])
        
    ppos.sort()
        
    return [spos, ppos, CH]
    
def statium_classy_config_sidechain(energy_vec, lib_path, localx):
   
    libf = readlines(lib_path)
    lib = []
    CH = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        for res in range(len(seq)):
        lib[-1].append(AAChar_int(seq[res]))
        if seq[res] in 'DEKR': CH.append(1.0)
        else: CH.append(0.0)
        
    nums = []
    count = 0
    for i in range(len(lib)):
        nums.append([])
        for j in range(len(lib[i])):
        count += 1
        nums[-1].append(count)
        

    seq = 'WAREIGAQLRRMADDLNAQYERR'
    labels = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']
  
    pair_list = energy_vec[0][0]
    seq_ref = energy_vec[0][3]
    res_vec = energy_vec[0][1]
    pdbinfo_vec = energy_vec[0][2]
    
    ppos = []
  
    pos_list = []
    for i in range(len(labels)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)

    ppos_list = []
    for i in range(len(labels)):
    ppos_list.append([])
    for j in range(len(labels)):
        ppos_list[i].append([])
            for k in range(20):
            ppos_list[i][j].append([])
                for l in range(20):
                ppos_list[i][j][k].append(0.0)        
  
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if not pos1 in res_vec: continue
           
        if (not pos0 in res_vec):
        for k in range(20):
            if AAChar_fasta(k) != 'G':
                pos_list[pos1 - seq_ref[0] + seq_ref[1]][k] += pair_list[0][j][k]

    spos = []
    for i in range(len(labels)):
        for j in range(len(lib[i])): spos.append(pos_list[i][lib[i][j]])

    pair_list = energy_vec[1][0]
    seq_ref = energy_vec[1][3]
    res_vec = energy_vec[1][1]
    pdbinfo_vec = energy_vec[1][2]

    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        
        aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]]) 
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G': e = 0.0
        else: e = pair_list[0][j][aa0][aa1]
    ppos_list[pos0 - seq_ref[0] + seq_ref[1]][pos1 - seq_ref[0] + seq_ref[1]][aa0][aa1] = e
    
    ppos = []
    for i in range(len(labels)):
    for j in range(i + 1, len(labels)):
            for k in range(len(lib[i])):
        for l in range(len(lib[j])): ppos.append([nums[i][k], nums[j][l], localx * ppos_list[i][j][lib[i][k]][lib[j][l]]])
        
    return [spos, ppos, CH]
    
def config_classy(rstr, lib_path, odir, run_str):
  
    coyote = False
    if run_str == 'coyote': coyote = True
  
    if not os.path.exists(odir): os.mkdir(odir)
    sold = os.path.join(odir, 'sol')
    if not os.path.exists(sold): os.mkdir(sold)
  
    libf = readlines(lib_path)
    lib = []
    posn = []
    count = 0
    flatlib = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        posn.append(len(seq))
        for res in range(len(seq)):
        flatlib.append(seq[res])
        count += 1
        lib[-1].append(AAChar_int(seq[res]))

    if rstr[0] == 'x': em = load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8')
    elif rstr[0] == 'm': em = load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1')
    elif rstr[0] == 'w': em = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    elif rstr[0] == 'f': em = load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp')
    elif rstr[0] == 'b': em = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    
    esv = []
    for i in range(len(rstr) - 1):
        if rstr[i + 1] == 'x': esv.append(load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8'))
        elif rstr[i + 1] == 'm': esv.append(load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1'))
        elif rstr[i + 1] == 'w': esv.append(load_design_energy('/home/bartolo/web/statium/bclw/bclw'))
        elif rstr[i + 1] == 'f': esv.append(load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp'))
        elif rstr[i + 1] == 'b': esv.append(load_design_energy('/home/bartolo/web/statium/bcl2/bcl2'))
        
    target = statium_classy_config(em, lib_path)
    decoys = []
    for i in range(len(esv)):
        decoys.append(statium_classy_config(esv[i], lib_path))
        
    q = 'speedy'
    its = 300
    gap0 = 0.0
    for i in range(its):
      
        token = str(i)
        solp = os.path.join(sold, 'classy_' + token + '.sol')
        if os.path.exists(solp): continue
      
        if coyote:
            while True:
                njobs = coyote_count_jobs(q)
                if njobs < 500: break
                else: time.sleep(30)
            
        gap = gap0 - 0.5 * float(i)
    
        strs = classy_strings(lib, target, decoys, gap, count)
        data_str = strs[0]
        mod_str = strs[1]
        
        
        sp = os.path.join(odir, 'classy_' + token + '.sh')
        modp = os.path.join(odir, 'classy_' + token + '.mod')
        datp = os.path.join(odir, 'classy_' + token + '.dat')
    
        write_file(mod_str, modp)
        write_file(data_str, datp)
        write_file('/net/crate-01/data/keating-stuff/software/procede/develop/bin/glpsol --math ' + modp + ' --data ' + datp + ' --output ' + solp + '\n', sp)
        os.system('chmod u+x ' + sp)
        if coyote: os.system('qsub -q ' + q + ' ' + sp)
        else: os.system(sp)
    
    if coyote:
        while True:
            njobs = coyote_count_jobs(q)
        solv = []
            soll = os.listdir(sold)
            for spp in soll:
            solp = os.path.join(sold, spp)
            try:
                seq1 = process_classy_ilp(solp, flatlib)
                use = True
                for i in range(len(solv)):
                if solv[i][-1] == seq1: use = False
                if not use: continue
                te = statium_energy_calc(em, seq1, 0.1)
                sub = [te]
                for i in range(len(esv)): sub.append(te - statium_energy_calc(esv[i], seq1, 0.1))
                sub.append(seq1)
                solv.append(sub)
            except: continue
        solv.sort()
        op = os.path.join(sold, 'results.txt')
        of = open(op, 'w')
        for i in range(len(solv)):
            for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
            of.write('\n')
        of.close()

        if njobs == 0: break
        else: time.sleep(30)
    else:
    solv = []
        soll = os.listdir(sold)
        for spp in soll:
        solp = os.path.join(sold, spp)
        try:
            seq1 = process_classy_ilp(solp, flatlib)
            use = True
            for i in range(len(solv)):
            if solv[i][-1] == seq1: use = False
            if not use: continue
            te = statium_energy_calc(em, seq1, 0.1)
            sub = [te]
            for i in range(len(esv)): sub.append(te - statium_energy_calc(esv[i], seq1, 0.1))
            sub.append(seq1)
            solv.append(sub)
        except: continue
    solv.sort()
    op = os.path.join(sold, 'results.txt')
    of = open(op, 'w')
    for i in range(len(solv)):
        for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
        of.write('\n')
    of.close()
    
def config_classy_sidechain(rstr, lib_path, odir, its, gap0, localx):
  
    coyote = False
  
    if not os.path.exists(odir): os.mkdir(odir)
    sold = os.path.join(odir, 'sol')
    if not os.path.exists(sold): os.mkdir(sold)
  
    libf = readlines(lib_path)
    lib = []
    posn = []
    count = 0
    flatlib = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        posn.append(len(seq))
        for res in range(len(seq)):
        flatlib.append(seq[res])
        count += 1
        lib[-1].append(AAChar_int(seq[res]))
        
    if rstr[0] == 'x':
    #em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3io8')
    #eml = load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3io8')
    em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3pl7')
    eml = load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3pl7')
    elif rstr[0] == 'm':
    em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/mcl1/mcl1_3pk1')
    eml = load_intralocal_energy('/home/bartolo/web/statium_local/mcl1/mcl1_3pk1')
    elif rstr[0] == 'f':
    em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bfl1/bfl1_2vm6')
    eml = load_intralocal_energy('/home/bartolo/web/statium_local/bfl1/bfl1_2vm6')
    elif rstr[0] == 'b':
    em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bcl2/bcl2')
    eml = load_intralocal_energy('/home/bartolo/web/statium_local/bcl2/bcl2')
    elif rstr[0] == 'w':
    em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclw/bclwmock')
    eml = load_intralocal_energy('/home/bartolo/web/statium_local/bclw/bclwmock')
    
    esv = []
    esl = []
    for i in range(len(rstr) - 1):
        if rstr[i + 1] == 'x':
        #esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3io8'))
        #esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3io8'))
        esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3pl7'))
        esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3pl7'))
        elif rstr[i + 1] == 'm':
        esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/mcl1/mcl1_3pk1'))
        esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/mcl1/mcl1_3pk1'))
        elif rstr[i + 1] == 'f':
        esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bfl1/bfl1_2vm6'))
        esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/bfl1/bfl1_3mqp'))
        elif rstr[i + 1] == 'b':
        esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bcl2/bcl2'))
        esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/bcl2/bcl2'))
        elif rstr[i + 1] == 'w':
        esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclw/bclwmock'))
        esl.append(load_intralocal_energy('/home/bartolo/web/statium_local/bclw/bclwmock'))
        
    target = statium_classy_config_sidechain([em, eml], lib_path, localx)
    decoys = []
    for i in range(len(esv)):
        decoys.append(statium_classy_config_sidechain([esv[i], esl[i]], lib_path, localx))
        
    q = 'speedy'
    for i in range(its):
      
        token = str(i)
        solp = os.path.join(sold, 'classy_' + token + '.sol')
        if os.path.exists(solp): continue
      
        if coyote:
            while True:
                njobs = coyote_count_jobs(q)
                if njobs < 500: break
                else: time.sleep(30)
            
        gap = gap0 - 0.5 * float(i)
    
        strs = classy_strings(lib, target, decoys, gap, count)
        data_str = strs[0]
        mod_str = strs[1]
        
        
        sp = os.path.join(odir, 'classy_' + token + '.sh')
        modp = os.path.join(odir, 'classy_' + token + '.mod')
        datp = os.path.join(odir, 'classy_' + token + '.dat')
    
        write_file(mod_str, modp)
        write_file(data_str, datp)
        write_file('/net/crate-04/data/keating/software/procede/develop/bin/glpsol --math ' + modp + ' --data ' + datp + ' --output ' + solp + '\n', sp)
        os.system('chmod u+x ' + sp)
        if coyote: os.system('qsub -q ' + q + ' ' + sp)
        else: os.system(sp)
    
    if coyote:
        while True:
            njobs = coyote_count_jobs(q)
        solv = []
            soll = os.listdir(sold)
            for spp in soll:
            solp = os.path.join(sold, spp)
            try:
                seq1 = process_classy_ilp(solp, flatlib)
                use = True
                for i in range(len(solv)):
                if solv[i][-1] == seq1: use = False
                if not use: continue
                te = statium_energy_calc_sidechain(em, seq1, 0.0)
                sub = [te]
                for i in range(len(esv)): sub.append(te - statium_energy_calc_sidechain(esv[i], seq1, 0.0))
                sub.append(seq1)
                solv.append(sub)
            except: continue
        solv.sort()
        op = os.path.join(sold, 'results.txt')
        of = open(op, 'w')
        for i in range(len(solv)):
            for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
            of.write('\n')
        of.close()

        if njobs == 0: break
        else: time.sleep(30)
    else:
    solv = []
        soll = os.listdir(sold)
        for spp in soll:
        solp = os.path.join(sold, spp)
        try:
            seq1 = process_classy_ilp(solp, flatlib)
            use = True
            for i in range(len(solv)):
            if solv[i][-1] == seq1: use = False
            if not use: continue
            te = statium_energy_calc_sidechain(em, seq1, 0.0) + localx * statium_energy_calc_intralocal(eml, seq1, 0.0, 'local')
            sub = [te]
            for i in range(len(esv)): sub.append(statium_energy_calc_sidechain(esv[i], seq1, 0.0) + localx * statium_energy_calc_intralocal(esl[i], seq1, 0.0, 'local'))
            sub.append(seq1)
            solv.append(sub)
        except: continue
    solv.sort()
    op = os.path.join(sold, 'results.txt')
    of = open(op, 'w')
    for i in range(len(solv)):
        for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
        of.write('\n')
    of.close()
    
def compile_classy(sold, lib_path, rstr):

    libf = readlines(lib_path)
    lib = []
    posn = []
    count = 0
    flatlib = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        posn.append(len(seq))
        for res in range(len(seq)):
        flatlib.append(seq[res])
        count += 1
        lib[-1].append(AAChar_int(seq[res]))
        
    if rstr[0] == 'x': em = load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8')
    elif rstr[0] == 'm': em = load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1')
    elif rstr[0] == 'w': em = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    elif rstr[0] == 'f': em = load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp')
    elif rstr[0] == 'b': em = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    
    esv = []
    for i in range(len(rstr) - 1):
        if rstr[i + 1] == 'x': esv.append(load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8'))
        elif rstr[i + 1] == 'm': esv.append(load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1'))
        elif rstr[i + 1] == 'w': esv.append(load_design_energy('/home/bartolo/web/statium/bclw/bclw'))
        elif rstr[i + 1] == 'f': esv.append(load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp'))
        elif rstr[i + 1] == 'b': esv.append(load_design_energy('/home/bartolo/web/statium/bcl2/bcl2'))
        
    if True:    
    solv = []
        soll = os.listdir(sold)
        for spp in soll:
        solp = os.path.join(sold, spp)
        try:
            seq1 = process_classy_ilp(solp, flatlib)
            use = True
            for i in range(len(solv)):
            if solv[i][-1] == seq1: use = False
            if not use: continue
            te = statium_energy_calc(em, seq1, 0.1)
            sub = [te]
            for i in range(len(esv)): sub.append(te - statium_energy_calc(esv[i], seq1, 0.1))
            sub.append(seq1)
            solv.append(sub)
        except: continue
    solv.sort()
    op = os.path.join(sold, 'results.txt')
    of = open(op, 'w')
    for i in range(len(solv)):
        for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
        of.write('\n')
    of.close()
    
def compile_classy_sidechain(sold, lib_path, rstr):

    libf = readlines(lib_path)
    lib = []
    posn = []
    count = 0
    flatlib = []
    for line in libf:
        lib.append([])
        seq = line.strip()
        posn.append(len(seq))
        for res in range(len(seq)):
        flatlib.append(seq[res])
        count += 1
        lib[-1].append(AAChar_int(seq[res]))
        
    if rstr[0] == 'x': em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    elif rstr[0] == 'm': em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    elif rstr[0] == 'f': em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    elif rstr[0] == 'b': em = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    elif rstr[0] == 'h': em = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2XPX')
    
    esv = []
    for i in range(len(rstr) - 1):
        if rstr[i + 1] == 'x': esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8'))
        elif rstr[i + 1] == 'm': esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1'))
        elif rstr[i + 1] == 'f': esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp'))
        elif rstr[i + 1] == 'b': esv.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2'))
        elif rstr[i + 1] == 'h': esv.append(load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2XPX'))
        
    if True:    
    solv = []
        soll = os.listdir(sold)
        for spp in soll:
        solp = os.path.join(sold, spp)
        try:
            seq1 = process_classy_ilp(solp, flatlib)
            use = True
            for i in range(len(solv)):
            if solv[i][-1] == seq1: use = False
            if not use: continue
            te = statium_energy_calc_sidechain(em, seq1, 0.0)
            sub = [te]
            for i in range(len(esv)): sub.append(te - statium_energy_calc_sidechain(esv[i], seq1, 0.0))
            sub.append(seq1)
            solv.append(sub)
        except: continue
    solv.sort()
    op = os.path.join(sold, 'results.txt')
    of = open(op, 'w')
    for i in range(len(solv)):
        for j in range(len(solv[i])): of.write(str(solv[i][j]) + '\t')
        of.write('\n')
    of.close()
    
def classy_strings(lib, target, decoys, gap, count):
  
    data_str = 'data;\n\nparam num_posn := ' + str(len(lib)) + ' ;\nparam num_nodes := ' + str(count) + ' ;\nparam posn_size :=\n'
    for i in range(len(lib)): data_str += str(i + 1) + ' ' + str(len(lib[i])) + '\n'
    data_str += ';\n\nparam costVT :=\n'
    for i in range(len(target[0])): data_str += str(i + 1) + ' ' + str(target[0][i]) + '\n'
    data_str += ';\n\nparam costET :=\n'
    for i in range(len(target[1])): data_str += str(target[1][i][0]) + ' ' + str(target[1][i][1]) + ' ' + str(target[1][i][2]) + '\n'
    data_str += ';\n\n'
    
    for i in range(len(decoys)):
        data_str += 'param costVN' + str(i + 1) + ' :=\n'
        for j in range(len(decoys[i][0])): data_str += str(j + 1) + ' ' + str(decoys[i][0][j]) + '\n'
        data_str += ';\n\nparam costEN' + str(i + 1) + ' :=\n'
        for j in range(len(decoys[i][1])): data_str += str(decoys[i][1][j][0]) + ' ' + str(decoys[i][1][j][1]) + ' ' + str(decoys[i][1][j][2]) + '\n'
        data_str += ';\n\n'
        
    data_str += 'param costCH :=\n'
    for i in range(len(target[2])): data_str += str(i + 1) + ' ' + str(target[2][i]) + '\n'
    data_str += ';\n\n'
        
    data_str += 'param iterations := 1 ;\nend;\n'
    
    mod_str = 'param num_posn integer >= 2;\nparam num_nodes integer >= num_posn;\nset POSN := 1..num_posn;\nset V := 1..num_nodes;\n\nparam posn_size {i in POSN} integer > 0;\ncheck: sum {i in POSN} posn_size[i] = num_nodes;\n\nset C {i in POSN} := {u in V : sum {j in POSN : j < i} posn_size[j] < u and u <= sum {j in POSN : j <= i} posn_size[j]};\ncheck: (setof{i in POSN, j in C[i]}(j) symdiff V) within {};\n\nset Efull := {(u,v) in {V,V}: u in V and v > u};\nparam costVT {V} default 0.0;\nparam costET {Efull} default 0.0;\n'
    
    for i in range(len(decoys)): mod_str += 'param costVN' + str(i + 1) + ' {V} default 0.0;\nparam costEN' + str(i + 1) + ' {Efull} default 0.0;\n'
    mod_str += 'param costCH {V} default 0.0;\n\nset negative_pairs :=\n    {(i,j) in POSN cross POSN :\n        j > i and\n        (forall {u in C[i], v in C[j]} costET[u,v] > 0) and\n        (exists {u in C[i], v in C[j]} costET[u,v] < 0)};\n\nset positive_pairs :=\n    {(i,j) in POSN cross POSN :\n        j > i and ((exists {u in C[i], v in C[j]} costET[u,v] != 0) or '
    for i in range(len(decoys)):
        mod_str += '(exists {u in C[i], v in C[j]} costEN' + str(i + 1) + '[u,v] != 0)'
        if i < len(decoys) - 1: mod_str += ' or '
        else: mod_str += ')};\n\n'
        
    mod_str += 'set NEG_EDGES :=\n    setof{(i,j) in negative_pairs,\n          (u,v) in (C[i] cross C[j]): costET[u,v] != 0.0} (u,v);\n\nset POS_EDGES :=\n    setof{(i,j) in positive_pairs,\n          (u,v) in (C[i] cross C[j])} (u,v);\n\nset E := NEG_EDGES union POS_EDGES;\n\nparam iterations integer default 1;\nparam M integer default 0;\nparam Solns {1..M, V} binary default 0;\n\nvar X {V} binary >= 0;\nvar Y {E} binary >= 0;\nminimize energy: (sum {v in V} costVT[v] * X[v]) +\n                 (sum {(u,v) in E} costET[u,v] * Y[u,v]);\n\n\nsubject to column {i in POSN}:\n    sum {u in C[i]} X[u] = 1;\nsubject to flow_i_to_j_pos {(i,j) in positive_pairs, u in C[i]} :\n    sum {v in C[j]} Y[u,v] = X[u];\n\nsubject to flow_j_to_i_pos {(i,j) in positive_pairs, v in C[j]} :\n    sum {u in C[i]} Y[u,v] = X[v];\n\nsubject to prev_sols {i in 1..M}:\n    sum {u in V} Solns[i,u] * X[u] <= num_posn - 1;\n\n'
    
    for i in range(len(decoys)): mod_str += 'subject to gapN' + str(i + 1) + ': (sum {v in V} costVT[v] * X[v]) + (sum {(u,v) in E} costET[u,v] * Y[u,v]) - (sum {v in V} costVN' + str(i + 1) + '[v] * X[v]) - (sum {(u,v) in E} costEN' + str(i + 1) + '[u,v] * Y[u,v]) <= ' + str(gap) + ';\n'
    mod_str += 'subject to gapCH: (sum {v in V} costCH[v] * X[v]) <= 10.0;\n\nend;\n'
    
    return [data_str, mod_str]
    
def process_classy_ilp(p, flatlib):
  
    seq = ''
  
    l = readlines(p)
    for line in l:
        items = line.strip().split()
        if len(items) == 6:
        if len(items[1]) > 3:
            if items[1][0] == 'X' and items[1][1] == '[' and items[1][-1] == ']':
            if int(items[3]) == 1:
                seq += flatlib[int(items[1][items[1].find('[') + 1:items[1].find(']')]) - 1]
    return seq
    
def BH3_natural():
  
    energy_bclxl = fast_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    energy_mcl1 = fast_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    energy_bclw = fast_design_energy('/home/bartolo/web/statium/bclw/bclw')
    energy_bcl2 = fast_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    energy_bfl1 = fast_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    
    seqs = []
    names = []
    natural = lines2list('/home/bartolo/web/statium/BH3_natural.txt')
    for i in range(len(natural)):
        if len(natural[i]) > 1:
            seqs.append(natural[i][0])
            names.append(natural[i][1])
        else:
            seqs.append(natural[i][0])
            names.append('seq')
    
    print 'BH3' + '\t\t' + 'sequence              ' + '\tbclxl\tmcl1\tbcl2\tbclw\tbfl1'
    for i in range(len(seqs)):
        seq = seqs[i]
        name = names[i]
        
        bclxl_energy = statium_energy(energy_bclxl, seq)
        mcl1_energy = statium_energy(energy_mcl1, seq)
        bclw_energy = statium_energy(energy_bclw, seq)
        bcl2_energy = statium_energy(energy_bcl2, seq)
        bfl1_energy = statium_energy(energy_bfl1, seq)
    print name + '\t\t' + seq + '\t' + str(bclxl_energy)[0:6] + '\t' + str(mcl1_energy)[0:6] + '\t' + str(bcl2_energy)[0:6] + '\t' + str(bclw_energy)[0:6] + '\t' + str(bfl1_energy)[0:6]
    
def statium_energy(energy_vec, seq):
  
    energy_table = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    for i in range(len(res_vec)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)
  
    energy = 0.0
    for j in range(len(energy_table)):
        aa = AAChar_int(seq[seq_ref[1] + j + (res_vec[0] - seq_ref[0])])
        if AAChar_fasta(aa) == 'G': continue
           
        energy += energy_table[j][aa]
    return energy
        
def statium_library_energy(energy_vec, library):
  
    energy_table = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    for i in range(len(res_vec)):
        pos_list.append([])
        for j in range(20): pos_list[i].append(0.0)
  
    energy = 0.0
    for j in range(len(energy_table)):
        for k in range(len(library[seq_ref[1] + j + (res_vec[0] - seq_ref[0])])):
            aa = AAChar_int(library[seq_ref[1] + j + (res_vec[0] - seq_ref[0])][k])
            if AAChar_fasta(aa) == 'G': continue
            if AAChar_fasta(aa) in 'CXP': energy += 1000.0
            else: energy += energy_table[j][aa]
    return energy
        
def print_posint(preset):
  
    seq = 'PEIWIAQELRRIGDEFNAYYARR'
    energy_vec = load_design_energy(preset)
  
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    count = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        if (pos0 in res_vec and pos1 in res_vec): e = e * 0.0
        else: print str(pos0).strip() + '\t' + str(pos1).strip()
    
def statium_calc(pair_list, seq):
    #print
    energy = 0.0
    pairs = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        aa0 = AAChar_int(seq[pos0])
        aa1 = AAChar_int(seq[pos1])
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G' or aa0 == 20 or aa1 == 20: continue
           
        e = pair_list[0][j][aa0][aa1]
        print pos0 + 1, pos1 + 1, seq[pos0], seq[pos1], e
        if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)): e = e * 30.0
        #if salt_bridge(aa0, aa1) and e < 0.0: e = e * 30.0 
        #if charge_pair(aa0, aa1) and e > 0.0: e = e * 30.0
        #print AAChar_fasta(aa0), AAChar_fasta(aa1), pos0 + 1, pos1 + 1, e
        #if salt_bridge(aa0, aa1): energy -= 1.0
        #if charge_pair(aa0, aa1): energy += 1.0

        energy += e
        pairs += 1.0
        
    print energy     
    return energy
    
def CARD_CARD_energies():

    pair_list = load_design_preset('/home/bartolo/web/CARD/card')
    inlines = lines2list('/home/bartolo/web/CARD/CARD_HUMAN_APAFCASP9_DIMERS.txt')
    
    of = open('/home/bartolo/web/CARD/CARD_HUMAN_APAFCASP9_DIMERS_energies.txt', 'w')
    for i in range(len(inlines)):
        seq = inlines[i][1]
        e = statium_calc(pair_list, seq)
        of.write(inlines[i][0] + '\t' + str(e) + '\n')
    of.close()
    
def CARD_hist():
  
    il = lines2list('/home/bartolo/web/CARD/CARD_HUMAN_APAFCASP9_DIMERS_energies.txt')
    ev = []
    for i in range(len(il)): ev.append(il[i][1])
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    ea = pylab.array(ev)
    
    pylab.hist(ea, facecolor='white', edgecolor='black', lw=2)
    #pylab.xlim(-5.0, 10.0)
    pylab.yticks([])
    pylab.savefig('/home/bartolo/web/CARD/CARD_HUMAN_APAFCASP9_DIMERS_energies.png')
    
def CARD_2face():
  
    il = lines2list('/home/bartolo/web/CARD/CARD_HUMAN_APAFCASP9_DIMERS_energies.txt')
    names = [[], [], []]
    for i in range(len(il)):
        name = il[i][0].split('_')[0]
        if not name in names[0]:
        names[0].append(name)
        names[1].append(0)
        names[2].append(0)
        
    count = 0
    for i in range(len(il)):
        if il[i][1] < 0.0:
        count += 1
        name0 = il[i][0].split('_')[0]
        name1 = il[i][0].split('_')[1]
        if name0 == name1: print name0
        idx0 = names[0].index(name0)
        idx1 = names[0].index(name1)
        names[1][idx0] = 1
        names[2][idx1] = 1
    print count
        
    for i in range(len(names[0])):
        if names[1][i] == 1 and names[2][i] == 1: print names[0][i]
    
def Orr_energies(out_path):
  
    pair_list = load_statium('/home/bartolo/web/Orr/complexstat')
    inlines = lines2list('/home/bartolo/web/Orr/TCS.txt')
    pairs = lines2list('/home/bartolo/web/Orr/pairs.txt')
    
    HK = []
    RR = []
    for i in range(len(pairs)):
        HK.append(pairs[i][0])
        RR.append(pairs[i][1])
    
    side1 = []
    side2 = []
    for i in range(20):
        side1.append(i)
        side2.append(i)
    
    order = []
    for i in range(20):
        order.append([])
        for j in range(20): order[i].append([0.0, 0, 0])
    
    ev = []
    count = 0
    for i in range(len(inlines)):
        count += 1
        j = i / 20
        k = i - (j * 20)
        seq = inlines[i][1]
        e = statium_calc(pair_list[0], seq)
        return
        order[j][k][0] = e
        ev.append(e)
        
    out_file = open('/home/bartolo/web/Orr/TCS_energies_stat.txt', 'w')
    for i in range(len(inlines)):
        out_file.write(inlines[i][0] + '\t' + str(ev[i]) + '\t' + inlines[i][1] + '\n')
    out_file.close()
    
    return
    
    for i in range(20):
        v1 = []
        for j in range(20):
        v1.append([order[i][j][0], j])
    v2 = sorted(v1, key=lambda energy: energy[0])
    for j in range(20):
        order[i][v2[j][1]][1] = j + 1
        
    for i in range(20):
        v1 = []
        for j in range(20):
        v1.append([order[j][i][0], j])
    v2 = sorted(v1, key=lambda energy: energy[0])
    for j in range(20):
        order[v2[j][1]][i][2] = j + 1
    
    sideg = []
    for i in range(20): sideg.append(i)
    
    e1 = 0
    for i in range(20):
    e1 += order[i][side2[i]][0]
    
    minima = 0
    eg = 100000000
    while True:
        random.shuffle(side2)
        e1 = 0
        for i in range(20):
        #e1 += order[i][side2[i]][1]
        #e1 += order[i][side2[i]][2]
        e1 += order[i][side2[i]][0]
    if e1 < eg:
        eg = e1
        for i in range(20): sideg[i] = side2[i]
        minima += 1
        
        out_file = open(out_path, 'w')
        for i in range(20):
            out_file.write(HK[i] + '\t' + RR[sideg[i]] + '\n')
        out_file.write(str(eg))
        out_file.close()
        
        if minima == 25: return

    #out_file = open('/home/bartolo/web/Orr/TCS_order.txt', 'w')
    #for i in range(20):
     #   for j in range(20):
    #    out_file.write(str((float(order[i][j][1]) + float(order[i][j][2])) / 2.0) + '\t')
    #out_file.write('\n')
    #out_file.close()
       
    #out_file = open('/home/bartolo/web/Orr/TCS_matrix.txt', 'w')
    #count = 0
    #for i in range(400):
    #    count += 1
    #    if count % 20 == 0: caro = '\n'
    #    else: caro = '\t'
    #    out_file.write(str(ev[i]) + caro)
 
    #out_file.close()
    
def Orr_process(in_dir):
  
    pairs = lines2list('/home/bartolo/web/Orr/pairs.txt')
    
    order = []
    for i in range(20):
        order.append([])
        for j in range(20): order[i].append([0.0, 0])
    
    HK = []
    RR = []
    for i in range(len(pairs)):
        HK.append(pairs[i][0])
        RR.append(pairs[i][1]) 
  
    in_list = os.listdir(in_dir)
    for file in in_list:
        path = os.path.join(in_dir, file)
        pairi = lines2list(path)
        for j in range(len(pairi) - 1): order[j][RR.index(pairi[j][1])][1] += 1
        
    for i in range(20):
        total = 0
        for j in range(20): total += order[i][j][1]
        for j in range(20): order[i][j][0] = 1.0 - (float(order[i][j][1]) / float(total))
        
    out_file = open('/home/bartolo/web/Orr/TCS_cplall_boltz.txt', 'w')
    for i in range(20):
        for j in range(20):
        out_file.write(str(float(order[i][j][0])) + '\t')
    out_file.write('\n')
    out_file.close()
    
def Orr_cpl():

    TCS = lines2list('/home/bartolo/web/Orr/TCS.txt')
    cpls = lines2list('/home/bartolo/web/Orr/cpl_all0.txt')
    cple = []
    for i in range(20):
        for j in range(20):
        cple.append(cpls[i][j])
        
    of = open('/home/bartolo/web/Orr/TCS_cpl.txt', 'w')
    for i in range(len(TCS)):
        of.write(TCS[i][0] + '\t' + str(cple[i] * -1.0) + '\t' + TCS[i][1] + '\n')
    of.close()
    
def Orr_energy():
  
    pair_list = load_design_preset('/home/bartolo/web/Orr/complex')
    inlines = lines2list('/home/bartolo/web/Orr/TCS.txt')
    pairs = lines2list('/home/bartolo/web/Orr/pairs.txt')
    
    HK = []
    RR = []
    for i in range(len(pairs)):
        HK.append(pairs[i][0])
        RR.append(pairs[i][1])
    
    side1 = []
    side2 = []
    for i in range(20):
        side1.append(i)
        side2.append(i)
    
    order = []
    for i in range(20):
        order.append([])
        for j in range(20): order[i].append([0.0, 0, 0])
    
    ev = []
    count = 0
    for i in range(len(inlines)):
        count += 1
        j = i / 20
        k = i - (j * 20)
        seq = inlines[i][1]
        e = statium_calc(pair_list, seq)
        order[j][k][0] = e
        ev.append(e)
        
        
    out_file = open('/home/bartolo/web/Orr/TCS_energies.txt', 'w')
    for i in range(len(inlines)):
        out_file.write(inlines[i][0] + '\t' + str(ev[i]) + '\t' + inlines[i][1] + '\n')
    out_file.close()
    
    for i in range(20):
        v1 = []
        for j in range(20):
        v1.append([order[i][j][0], j])
    v2 = sorted(v1, key=lambda energy: energy[0])
    for j in range(20):
        order[i][v2[j][1]][1] = j + 1
        
    for i in range(20):
        v1 = []
        for j in range(20):
        v1.append([order[j][i][0], j])
    v2 = sorted(v1, key=lambda energy: energy[0])
    for j in range(20):
        order[v2[j][1]][i][2] = j + 1
    
    sideg = []
    for i in range(20): sideg.append(i)
    
    e1 = 0
    for i in range(20):
    e1 += order[i][side2[i]][0]
    print e1
    
    minima = 0
    eg = 100000000
    while True:
        random.shuffle(side2)
        e1 = 0
        for i in range(20):
        #e1 += order[i][side2[i]][1]
        #e1 += order[i][side2[i]][2]
        e1 += order[i][side2[i]][0]
    if e1 < eg:
        eg = e1
        for i in range(20): sideg[i] = side2[i]
        minima += 1
        
       # out_file = open(out_path, 'w')
       # for i in range(20):
       #     out_file.write(HK[i] + '\t' + RR[sideg[i]] + '\n')
       # out_file.write(str(eg))
       # out_file.close()
        
        if minima == 25: return

    #out_file = open('/home/bartolo/web/Orr/TCS_order.txt', 'w')
    #for i in range(20):
     #   for j in range(20):
    #    out_file.write(str((float(order[i][j][1]) + float(order[i][j][2])) / 2.0) + '\t')
    #out_file.write('\n')
    #out_file.close()
       
    #out_file = open('/home/bartolo/web/Orr/TCS_matrix.txt', 'w')
    #count = 0
    #for i in range(400):
    #    count += 1
    #    if count % 20 == 0: caro = '\n'
    #    else: caro = '\t'
    #    out_file.write(str(ev[i]) + caro)
 
    #out_file.close()
    
def Orr_cple(out_path):
  
    inlines = lines2list('/home/bartolo/web/Orr/cpl_all0.txt')
    pairs = lines2list('/home/bartolo/web/Orr/pairs.txt')
    
    HK = []
    RR = []
    for i in range(len(pairs)):
        HK.append(pairs[i][0])
        RR.append(pairs[i][1])
    
    side1 = []
    side2 = []
    for i in range(20):
        side1.append(i)
        side2.append(i)
    
    order = []
    for i in range(20):
        order.append([])
        for j in range(20): order[i].append([0.0, 0, 0])
    
    ev = []
    count = 0
    for i in range(20):
        for j in range(20):
             e = inlines[i][j] * -1.0
             order[i][j][0] = e
             ev.append(e)
    
    sideg = []
    for i in range(20): sideg.append(i)
    
    e1 = 0
    for i in range(20):
    e1 += order[i][side2[i]][0]
    print e1
    
    minima = 0
    eg = 100000000
    while True:
        random.shuffle(side2)
        e1 = 0
        for i in range(20):
        #e1 += order[i][side2[i]][1]
        #e1 += order[i][side2[i]][2]
        e1 += order[i][side2[i]][0]
    if e1 < eg:
        eg = e1
        for i in range(20): sideg[i] = side2[i]
        minima += 1
        
        out_file = open(out_path, 'w')
        for i in range(20):
            out_file.write(HK[i] + '\t' + RR[sideg[i]] + '\n')
        out_file.write(str(eg))
        out_file.close()
        for i in range(20):
            print HK[i], RR[sideg[i]]
        print e1
        print
        
        if minima == 25: return

    #out_file = open('/home/bartolo/web/Orr/TCS_order.txt', 'w')
    #for i in range(20):
     #   for j in range(20):
    #    out_file.write(str((float(order[i][j][1]) + float(order[i][j][2])) / 2.0) + '\t')
    #out_file.write('\n')
    #out_file.close()
       
    #out_file = open('/home/bartolo/web/Orr/TCS_matrix.txt', 'w')
    #count = 0
    #for i in range(400):
    #    count += 1
    #    if count % 20 == 0: caro = '\n'
    #    else: caro = '\t'
    #    out_file.write(str(ev[i]) + caro)
 
    #out_file.close()
    
def Orr_submit():
    os.chdir('/home/bartolo/web/Orr/jobs_cple')
    for i in range(1, 101):
        job_path = os.path.join('/home/bartolo/web/Orr/jobs_cple', 'HKRR_' + str(i) + '.sh')
        out_path = os.path.join('/home/bartolo/web/Orr/out_cple', 'HKRR_' + str(i) + '.txt')
        of = open(job_path, 'w')
        of.write('#PBS -S /bin/bash\n/home/bartolo/web/build.py -orr_cple ' + out_path + '\n')
        of.close()
        os.system('chmod u+x ' + job_path)
        os.system('qsub -q quick ' + job_path)
    
def sequence_energy(pair_list, seq, seq_ref, res_vec, pdbinfo_vec, chargeX):
  
    pos_list = []
    pos_list.append([])
    pos_list.append([])
  
    energy = 0.0
    benergy = 0.0
    for j in range(len(pair_list[0])):
        pos0 = pair_list[1][j][0]
        pos1 = pair_list[1][j][1]
        if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
        else: aa0 = pdbinfo_vec[pos0][1]
        if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
        else: aa1 = pdbinfo_vec[pos1][1]
    
        if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
            continue
           
        e = pair_list[0][j][aa0][aa1]
        if (not pos0 in res_vec or not pos1 in res_vec): e = e * chargeX
        #if (salt_bridge(aa0, aa1) or charge_pair(aa0, aa1)) and pos1 - pos0 > 2: e = e * 3.0
    #if (pos0 in res_vec and pos1 in res_vec) and charge_pair(aa0, aa1) and pos1 - pos0 > 1: e = e * chargeX
        #print pos0 + 1, pos1 + 1, AAChar_fasta(aa0), AAChar_fasta(aa1), e
    #print str(pos0 + 1) + '\t' + str(pos1 + 1) + '\t' + AAChar_fasta(aa0) + '\t' + AAChar_fasta(aa1) + '\t' + str(e)

        energy += e
        
    return energy
    
def parse_yeast(f1, f2, f3, out_path):
  
    f1lines = readlines(f1)
    f2lines = readlines(f2)
    f3lines = readlines(f3)
    
    out_file = open(out_path, 'w')
    
    for i in range(len(f1lines)):
        items1 = f1lines[i].split()
        items2 = f2lines[i].split()
        items3 = f3lines[i].split()
        
        seq = items1[0]
        pssm1 = items1[1]
        pssm2 = items1[2]
        bclxl = items2[1]
        mcl1 = items3[1]
        
        out_file.write(seq + '\t' + pssm1 + '\t' + pssm2 + '\t' + bclxl + '\t' + mcl1 + '\n')
    out_file.close()
    
def parse_yeast2(f1, f2, f3):

    f1lines = readlines(f1)
    f2lines = readlines(f2)
    f3lines = readlines(f3)
    
    xv = [[], []]
    for i in range(len(f1lines)):
        items1 = f1lines[i].split()
        seq = items1[0]
        pssm1 = float(items1[1])
        pssm2 = float(items1[2])
        bclxl = float(items1[3])
        mcl1 = float(items1[4])
        
        xv[1].append(0.0)
        if ((pssm1 < 0.0 and pssm1 > -1.0) or (pssm1 > 0.0 and pssm1 < 1.0)) and bclxl < 1.0 and mcl1 < 6.0:
        print 'X both'
        xv[0].append(0.0)
    else: xv[0].append(pssm1)
    print len(xv[1])
    
    mv = [[], []]
    for i in range(len(f2lines)):
        items1 = f2lines[i].split()
        seq = items1[0]
        pssm1 = float(items1[1])
        pssm2 = float(items1[2])
        bclxl = float(items1[3])
        mcl1 = float(items1[4])
        
        mv[1].append(0.0)
        if ((pssm1 < 0.0 and pssm1 > -1.0) or (pssm1 > 0.0 and pssm1 < 1.0)) and bclxl < 1.0 and mcl1 < 6.0:
        print 'M both'
        mv[0].append(0.0)
    else: mv[0].append(pssm1)
    print len(mv[1])

    pv = [[], []]
    for i in range(len(f3lines)):
        items1 = f3lines[i].split()
        seq = items1[0]
        pssm1 = float(items1[1])
        pssm2 = float(items1[2])
        bclxl = float(items1[3])
        mcl1 = float(items1[4])
        
        pv[1].append(0.0)
        if ((pssm1 < 0.0 and pssm1 > -1.0) or (pssm1 > 0.0 and pssm1 < 1.0)) and bclxl < 1.0 and mcl1 < 6.0:
        pv[0].append(0.0)
        print 'P both'
    else: pv[0].append(pssm1)
    print len(pv[1])
    
    import pylab

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.scatter(pylab.array(mv[0]), pylab.array(mv[1]), c='r', marker='o', s=100, facecolor='none', edgecolors='r')
    pylab.scatter(pylab.array(xv[0]), pylab.array(xv[1]), c='b', marker='s', s=100, facecolor='none', edgecolors='b')
    pylab.scatter(pylab.array(pv[0]), pylab.array(pv[1]), c='g', marker='>', s=100, facecolor='none', edgecolors='g')

    #pylab.xlim(-10, 200)
    #pylab.ylim(-0.75, 1.75)
    pylab.savefig('/home/bartolo/web/orgWASP/data/pssm_spot200_estat_yeast_sort.png')
    pylab.close()
    
def pcoloring(fpath, label_path):
  
    labels = lines2list(label_path)
    xlabel = []
    ylabel = []
    N = len(labels)
    for i in range(N):
        xlabel.append(labels[i][1])
        ylabel.append(labels[i][0])
        
  
    lines = readlines(fpath)
    
    v1 = []
    for line in lines:
        items = line.strip().split()
        sub = []
        for item in items:
        try: sub.append(float(item))
        except: continue
    if len(sub) > 0: v1.append(sub)
    
    v2 = []
    for i in range(len(v1)):
        v2.append(v1[-i - 1])
    
    ylabel.reverse()
    import pylab
    pylab.pcolor(pylab.array(v2), edgecolors='k', linewidths=2)
    pylab.xticks(pylab.arange(N) + 0.5, xlabel, rotation= 30.0)
    pylab.yticks(pylab.arange(N) + 0.5, ylabel, rotation= 30.0)
    ind = pylab.arange(N)  # the x locations for the groups
    width = 0.0       # the width of the bars

    #fig = pylab.figure()
    #ax = fig.add_subplot(111)
    #ax.set_yticks(ind+width)
    #pylab.set_yticklabels( ylabel )
    #pylab.yticks(pylab.arange(N), ylabel)
    pylab.colorbar()
    pylab.savefig('/home/bartolo/web/statium/SPOT200_stat_matrix.png')
    pylab.close()
    
    
def sequence_energy_scan(preset_dir, seq_path):
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    exclude_path = os.path.join(file_dir, file_base + '.exclude')
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    exclude = [[], []]
    elines = readlines(exclude_path)
    for line in elines:
        items = line.split()
        exclude[0].append(int(items[0]))
        exclude[1].append(items[1])

    pair_list = load_design_preset(preset_dir)

    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    #bim = 'VIDDHERGLIRNGRDFLLALERQ'
    #bim = 'EIGKSRLEKMTNGLQLFTGLMER'
    #bim = 'TLREVSSKLRRNLQNNAEWVYQG'
    #bim = 'WAREIGAQLRRMADDLNAQYERR'
    #bim = 'LEVECATQLRRFGDKLNFRQKLL'
    #bim = 'KYEKSVKDLKDAIEVLIAEKRRR'
    #bim = 'YLYVEEQEYLQAYEDVLERYKDE'
    
    L = len(bim)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    Nres = len(pdbinfo_vec)
    
    eref = sequence_energy(pair_list, bim, seq_ref, res_vec, pdbinfo_vec, 10.0)
    

    evec = []
    posvec = []
    count = 0
    for i in range(len(seqs)):
      
        
        prot_seq = seqs[i][0]

        
        #if len(seq_vec) % 100 == 0: print i + 1, len(seq_vec)
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        count += 1
        seq = ''
        Ngly = 0
        Npro = 0
        nnaa = 0
        Ncharge = 0
        cancel = False
        for k in range(L):
            aa = prot_seq[j + k]
            if k in exclude[0]:
            if aa in exclude[1][exclude[0].index(k)]:
                cancel = True
            if aa == 'G': Ngly += 1
            if aa == 'P': Npro += 1
            if aa in 'RKED': Ncharge += 1
            if AAChar_int(aa) >= 20: nnaa += 1
            seq += aa

        energy = sequence_energy(pair_list, seq, seq_ref, res_vec, pdbinfo_vec, 10.0)
            if (nnaa > 0 or Ngly > 2 or Npro > 2 or (Ngly + Npro > 3) or Ncharge < 5 or cancel or seq[8] != 'L') and energy < 50.0: energy += 200.0
            
        evec.append(energy)
        posvec.append(count)
        
        #if energy < 0.0: print count, energy, seq
        
        if energy < 50.0: print count, energy, seq
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (24, 6)
    
    pylab.bar(pylab.array(posvec), pylab.array(evec), color='b', edgecolor='b', linewidth=0, width=0.7, alpha=0.4)

    pylab.savefig('/home/bartolo/web/orgWASP/bar.png')
    pylab.close()
    
def libars(p1):
  
    l1 = lines2list(p1)
    
    x = []
    y1 = []
    y2 = []
    for i in range(len(l1)):
        x.append(l1[i][0])
        y1.append(l1[i][1])
        y2.append(l1[i][2])

        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab

    pylab.rcParams['xtick.labelsize'] = '10'
    pylab.rcParams['ytick.labelsize'] = '10'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    pylab.bar(pylab.arange(len(x)), pylab.array(y1), color='b', edgecolor='b', linewidth=0, width=0.7, alpha=0.4)
    pylab.bar(pylab.arange(len(x)), pylab.array(y2), color='r', edgecolor='r', linewidth=0, width=0.7, alpha=0.4)
    
    pylab.xticks(pylab.array([0, 20, 40, 60, 80, 99]), [str(x[0]), str(x[20]), str(x[40]), str(x[60]), str(x[80]), str(x[99])])

    pylab.savefig('/home/bartolo/web/statium/libs/design/wx/lib1.png')
    pylab.close()   
    
def libar(p1):
  
    l1 = lines2list(p1)
    
    x1 = []
    y1 = []
    for i in range(len(l1)):
        x1.append(l1[i][0])
        y1.append(l1[i][1])
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab

    pylab.rcParams['xtick.labelsize'] = '5'
    pylab.rcParams['ytick.labelsize'] = '10'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    pylab.bar(pylab.arange(len(x1)), pylab.array(y1), color='b', edgecolor='b', linewidth=0, width=0.7, alpha=0.4)
    
    pylab.xticks([])

    pylab.savefig('/home/bartolo/web/libraryI_diff.png')
    pylab.close() 
    
def bcl2_specificity(data1_path, data2_path):

    data1_lines = readlines(data1_path)
    data2_lines = readlines(data2_path)
    
    data1_vec = []
    data2_vec = []
    
    wt = data1_lines[0].split()[0]
    
    for i in range(len(data1_lines)):
      
          line1 = data1_lines[i].split()
          line2 = data2_lines[i].split()
          #if float(line1[3]) <= 0.5 or float(line2[3]) <= 0.5:
          if True:
          
              v = []
              v.append(line1[0])
              v.append(line1[0])
              v.append(float(line1[1]))
              v.append(float(line1[2]))
              data1_vec.append(v)
          
              v = []
              line2 = data2_lines[i].split()
              v.append(line2[0])
              v.append(line2[0])
              v.append(float(line2[1]))
              v.append(float(line2[2]))
              data2_vec.append(v)
          
    N = len(data1_vec)
    ediff = []
    sdiff = []
    
    for i in range(N):
        
        name = data1_vec[i][1]
        e1 = data1_vec[i][2]
        s1 = data1_vec[i][3]
        e2 = data2_vec[i][2]
        s2 = data2_vec[i][3]
        
        ediffint = e2 - e1
        #if ediffint > 15.0 or ediffint < -15.0: continue

    ediff.append(e2 - e1)
    sdiff.append(s2 - s1)
    
        #print name, data2_vec[i][1], e1, e2, s1, s2
        
    import pylab
    earray = pylab.array(ediff)
    sarray = pylab.array(sdiff)

    totalR = str(pylab.corrcoef(earray, sarray)[0][1])
    print totalR

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.scatter(earray, sarray)
    #pylab.text(-15.0, 1.0, 'R=' + totalR[0:5], fontsize=20)

    #pylab.xlim(-10, 200)
    #pylab.ylim(-0.75, 1.75)
    pylab.savefig('WASP2/spec.png')
    pylab.close()
  
def color_string():
    return 'rgbkymcadefh'
 
def color_dictionary(color):
  
    dictionary = {'y': [1,1,0], 'm': [1,0,1], 'c': [0,1,1], 'r': [1,0,0], 'g': [0,1,0], 'b': [0,0,1], 'k': [0,0,0], 'a': [0.5,0.5,1], 'd': [1,0.5,0.5], 'e': [0.9,0.5,0.1], 'f': [0.25,0.6,1], 'h': [0.5,0,0.5]}
    return dictionary[color]
    
def parse_sanjib_lib(in_path):
  
    wt = 'DMRPEIWIAQELRRIGDEFNAYYARRVFL'
    idxs = [7, 11, 12, 14, 16, 18]
    
    lines = readlines(in_path)
    N = len(lines)
    
    readin = False
    for i in range(N):
        item = lines[i].strip()
        
        if readin:
        chars += item
        if len(chars) == 6:
            seq = ''
            for j in range(len(wt)):
            if j in idxs: seq += chars[idxs.index(j)]
            else: seq += wt[j]
        print seq
        readin = False
        chars = ''
    if not readin:
            if item[0] == 'P':
            readin = True
            chars = ''
            else: readin = False
            
def pssm_energy(pssm, seq):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    e_pssm = [0.0, 0.0]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    if AA in 'MC': continue
    AA_idx = AA_dict[AA]
    e_pssm[0] += pssm[spot_idx][AA_idx][0]
    e_pssm[1] += pssm[spot_idx][AA_idx][1]
    
    return e_pssm
    
def pssm_energy10(pssm, seq):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    e_pssm = [0.0, 0.0, 0.0, 0.0, 0.0]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    #if AA in 'MC': continue
    if AA == 'M': AA = 'L'
    if AA == 'C': AA = 'A'
    AA_idx = AA_dict[AA]
    e_pssm[0] += pssm[spot_idx][AA_idx][0]
    e_pssm[1] += pssm[spot_idx][AA_idx][1]
    e_pssm[2] += pssm[spot_idx][AA_idx][2]
    e_pssm[3] += pssm[spot_idx][AA_idx][3]
    e_pssm[4] += pssm[spot_idx][AA_idx][4]
    
    return e_pssm

def pssm_energy10_lim(pssm, seq):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    e_pssm = [0.0, 0.0, 0.0, 0.0, 0.0]
    for i in range(len(idxs)):
        if i in [4, 7]: continue
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    #if AA in 'MC': continue
    if AA == 'M': AA = 'L'
    if AA == 'C': AA = 'A'
    AA_idx = AA_dict[AA]
    e_pssm[0] += pssm[spot_idx][AA_idx][0]
    e_pssm[1] += pssm[spot_idx][AA_idx][1]
    e_pssm[2] += pssm[spot_idx][AA_idx][2]
    e_pssm[3] += pssm[spot_idx][AA_idx][3]
    e_pssm[4] += pssm[spot_idx][AA_idx][4]
    
    return e_pssm

def pssm_energy10_buried_penal(pssm, seq):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    buried_idxs = [4, 5, 8, 11, 12, 13, 15]
    
    e_pssm = [0.0, 0.0, 0.0, 0.0, 0.0]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    #if AA in 'MC': continue
    if AA == 'M': AA = 'L'
    if AA == 'C': AA = 'A'
    AA_idx = AA_dict[AA]
    e = pssm[spot_idx][AA_idx][0]
    if pos_idx in buried_idxs and e > 0.5: e = 10.0
    e_pssm[0] += e
    e = pssm[spot_idx][AA_idx][1]
    if pos_idx in buried_idxs and e > 0.5: e = 10.0
    e_pssm[1] += e
    e = pssm[spot_idx][AA_idx][2]
    if pos_idx in buried_idxs and e > 0.5: e = 10.0
    e_pssm[2] += e
    e = pssm[spot_idx][AA_idx][3]
    if pos_idx in buried_idxs and e > 0.5: e = 10.0
    e_pssm[3] += e
    e = pssm[spot_idx][AA_idx][4]
    if pos_idx in buried_idxs and e > 0.5: e = 10.0
    e_pssm[4] += e
    
    return e_pssm
    
def pssm_energy10_pos(pssm, seq):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    buried_idxs = [4, 5, 8, 11, 12, 13, 15]
    
    e_pssm = [[], [], [], [], []]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    #if AA in 'MC': continue
    if AA == 'M': AA = 'L'
    if AA == 'C': AA = 'A'
    AA_idx = AA_dict[AA]
    e_pssm[0].append(pssm[spot_idx][AA_idx][0])
    e_pssm[1].append(pssm[spot_idx][AA_idx][1])
    e_pssm[2].append(pssm[spot_idx][AA_idx][2])
    e_pssm[3].append(pssm[spot_idx][AA_idx][3])
    e_pssm[4].append(pssm[spot_idx][AA_idx][4])
    
    return e_pssm
  
def pssm_energy10_print_res():
  
    pssm = PSSM5()
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    buried_idxs = [4, 5, 8, 11, 12, 13, 15]
    
    e_pssm = [[], [], [], [], []]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    #if not pos_idx in buried_idxs: continue
    print
    print names[i]
    use = ''
    for j in range(20):
        AA = AAChar_fasta(j)
        if AA in 'MC': continue
        AA_idx = AA_dict[AA]
        e = pssm[spot_idx][AA_idx][3]
        if e < 0.10: use += AA
    print use

    
def pssm_energy10_bad_noxa(pssm, seq):
  
    pos = [1, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19]
    aa = ['D', 'E', 'K', 'R', 'H', 'N', 'Q', 'S', 'T', 'P', 'G', 'A', 'V', 'I', 'L', 'F', 'Y', 'W']
    noxa = 'LEVECATQLRRFGDKLNFRQKLL'
    bad = 'AAQRYGRELRRMSDEFVDSFKKG'
    
    #e_pssm = [0.0, 0.0]
    e_pssm = [0.0, 0.0, 0.0, 0.0, 0.0]
    for i in range(len(pos)):
        pos_idx = pos[i]
        if seq[pos_idx] in 'MC': continue
    
    if bad[pos_idx] != seq[pos_idx]: e_pssm[0] += pssm[i][aa.index(seq[pos_idx])][0]
    if noxa[pos_idx] != seq[pos_idx]: e_pssm[1] += pssm[i][aa.index(seq[pos_idx])][1]
    
    return e_pssm
    
def pssm_energy_pos(pssm, seq, pvec):
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    
    
    
    e_pssm = [0.0, 0.0]
    for i in range(len(idxs)):
    pos_idx = idxs[i]
    pos_name = names[i]
    spot_idx = pos_dict[pos_name]
    AA = seq[pos_idx]
    if AA in 'MC' or (not pos_idx in pvec): continue
    AA_idx = AA_dict[AA]
    e_pssm[0] += pssm[spot_idx][AA_idx][0]
    e_pssm[1] += pssm[spot_idx][AA_idx][1]
    
    return e_pssm
    
def load_design_energy(preset_dir):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    residue2_path = os.path.join(file_dir, file_base + '.res2')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    seqint_path = os.path.join(file_dir, file_base + '.seqint')
    weights_path = os.path.join(file_dir, file_base + '.weights')
    
    seqint_data = lines2list(seqint_path)
    seqint = []
    for i in range(len(seqint_data)): seqint.append(int(seqint_data[i][0]))
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = structure_info(template_pdb_path, template_seqdata_path)
    
    for i in range(len(seqint)): pdbinfo_vec[i][1] = seqint[i]
    
    #if os.path.exists(residue2_path):
     #   for i in range(len(seqint)): pdbinfo_vec[i][1] = -1
        
    mask_vec = []
    if os.path.exists(mask_path):
        data = lines2list(mask_path)
        for i in range(len(data)): mask_vec.append([data[i][0], data[i][1]])

    weights = []
    if os.path.exists(weights_path):
        wd = lines2list(weights_path)
    for i in range(len(wd)): weights.append(wd[i][0])
    else:
        for i in range(len(pair_list[0])): weights.append(1.0)
    
    return [pair_list, res_vec, pdbinfo_vec, seq_ref, mask_vec, weights]

def load_intralocal_energy(preset_dir):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    residue2_path = os.path.join(file_dir, file_base + '.res2')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    seqint_path = os.path.join(file_dir, file_base + '.seqint')
    weights_path = os.path.join(file_dir, file_base + '.weights')
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    
    #if os.path.exists(residue2_path):
     #   for i in range(len(seqint)): pdbinfo_vec[i][1] = -1
        
    mask_vec = []
    if os.path.exists(mask_path):
        data = lines2list(mask_path)
        for i in range(len(data)): mask_vec.append([data[i][0], data[i][1]])

    weights = []
    if os.path.exists(weights_path):
        wd = lines2list(weights_path)
    for i in range(len(wd)): weights.append(wd[i][0])
    else:
        for i in range(len(pair_list[0])): weights.append(1.0)
    
    return [pair_list, res_vec, pdbinfo_vec, seq_ref, mask_vec, weights]

def load_design_energy_sidechain(preset_dir):
  
    pair_list = load_design_preset_sidechain(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    mask_path = os.path.join(file_dir, file_base + '.mask')
    weights_path = os.path.join(file_dir, file_base + '.weights')
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = store_pdb_info(template_pdb_path)
    
    mask_vec = []
    if os.path.exists(mask_path):
        data = lines2list(mask_path)
        for i in range(len(data)): mask_vec.append([data[i][0], data[i][1]])

    
    weights = []
    if os.path.exists(weights_path):
        wd = lines2list(weights_path)
    for i in range(len(wd)): weights.append(wd[i][0])
    else:
        for i in range(len(pair_list[0])): weights.append(1.0)
        
    
    return [pair_list, res_vec, pdbinfo_vec, seq_ref, mask_vec, weights]

def load_statium(preset_dir):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    
    pdbinfo_vec = structure_info(template_pdb_path, template_seqdata_path)
    
    return [pair_list, pdbinfo_vec]
    
def fast_design_energy(preset_dir):
  
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    table_path = os.path.join(file_dir, file_base + '.table')
    
    energy_table = lines2list(table_path)
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info(template_pdb_path, template_seqdata_path)
    
    return [energy_table, res_vec, pdbinfo_vec, seq_ref]
    
def load_design_energy_PDZ(preset_dir):
  
    pair_list = load_design_preset(preset_dir)
    file_dir = os.path.split(preset_dir)[0]
    file_base = os.path.split(preset_dir)[1]
    
    template_pdb_path = os.path.join(file_dir, file_base + '.pdb')
    template_seqdata_path = os.path.join(file_dir, file_base + '.seq')
    residue_path = os.path.join(file_dir, file_base + '.res')
    cfg_path = os.path.join(file_dir, file_base + '.cfg')
    stats_path = os.path.join(file_dir, file_base + '.probs')
    
    if os.path.exists(stats_path):
        stats = lines2list(stats_path)
        stats_vec = [[],[]]
        for i in range(len(stats)):
            stats_vec[0].append(float(stats[i][0]))
            stats_vec[1].append(float(stats[i][1]))
    else: stats_vec = []
    
    line = readline(cfg_path, 1)
    cfg_items = line.strip().split('=')
    seq_ref = [int(cfg_items[0]) - 1, int(cfg_items[1])]
    
    res_vec = []
    res_lines = readlines(residue_path)
    for line in res_lines:
        res_vec.append(int(line.strip()) - 1)
    
    pdbinfo_vec = pdb_info2(template_pdb_path, template_seqdata_path)
    
    return [pair_list, res_vec, pdbinfo_vec, seq_ref, stats_vec]
    
def Energy2Prob(energy, stats_vec):

    if energy <= stats_vec[0][0]: return 1.0
    if energy >= stats_vec[0][-1]: return 0.0
    for i in range(len(stats_vec[0]) - 1):
        if energy >= stats_vec[0][i] and energy < stats_vec[0][i + 1]:
        p0 = stats_vec[1][i]
        p1 = stats_vec[1][i + 1]
        e0 = stats_vec[0][i]
        e1 = stats_vec[0][i + 1]
        de = e1 - e0
        dp = p0 - p1
        nde = (energy - e0) / de
        p = p0 - (dp * nde)
        return p
        
def bcl2_sort(data_path, header_path, out_path):
        
    bclxl = load_design_energy('/home/bartolo/web/lib_statium/bclxl/bclxl_3io8')
    mcl1 = load_design_energy('/home/bartolo/web/lib_statium/mcl1/mcl1_2pqk')
    bclw = load_design_energy('/home/bartolo/web/lib_statium/bclw/bclw')
    bcl2 = load_design_energy('/home/bartolo/web/lib_statium/bcl2/bcl2')
    bfl1 = load_design_energy('/home/bartolo/web/lib_statium/bfl1/bfl1_3mqp')
    
    SPOT_vec = PSSM5()
    
    data = lines2list(data_path)
    header = readlines(header_path)
    
    out_file = open(out_path, 'w')
    
    v1 = []
    for i in range(len(data)):
      
        if i % 1000 == 0: print float(i) / float(len(data))
        seq = data[i][0]
        bclxl_energy = xenergy(bclxl, seq, 10.0, False)
        mcl1_energy = xenergy(mcl1, seq, 10.0, False)
        bcl2_energy = xenergy(bcl2, seq, 10.0, False)
        bclw_energy = xenergy(bclw, seq, 10.0, False)
        bfl1_energy = xenergy(bfl1, seq, 10.0, False)
        
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        pssm_bclxl = energy_pssm[0]
        pssm_mcl1 = energy_pssm[1]
        pssm_bclw = energy_pssm[2]
        pssm_bfl1 = energy_pssm[3]
        pssm_bcl2 = energy_pssm[4]
        
    full_head = header[i].strip()
    start = 0
    for j in range(len(full_head)):
        if full_head[j] == '|': start = j + 1
    header_line = ''
    for j in range(start, len(full_head)): header_line += full_head[j]
        
        v1.append([seq, header_line, bclxl_energy, mcl1_energy, bcl2_energy, bclw_energy, bfl1_energy, pssm_bclxl, pssm_mcl1, pssm_bcl2, pssm_bclw, pssm_bfl1])
    xstat = sorted(v1, key=lambda energy: energy[2])
    mstat = sorted(v1, key=lambda energy: energy[3])
    bstat = sorted(v1, key=lambda energy: energy[4])
    wstat = sorted(v1, key=lambda energy: energy[5])
    fstat = sorted(v1, key=lambda energy: energy[6])
    pxstat = sorted(v1, key=lambda energy: energy[7])
    pmstat = sorted(v1, key=lambda energy: energy[8])
    pbstat = sorted(v1, key=lambda energy: energy[9])
    pwstat = sorted(v1, key=lambda energy: energy[10])
    pfstat = sorted(v1, key=lambda energy: energy[11])
    
    of = open(out_path, 'w')
    
    ptile = 500
        
    of.write('BCLXL STATIUM\n')
    pxb = []
    xfind = []
    for i in range(ptile): pxb.append(pxstat[i][0])
    for i in range(len(pxstat)):
        if pxstat[i][0] in pxb: xfind.append(pxstat[i])
        if len(xfind) == 100: break
    for i in range(len(xfind)): of.write(xfind[i][0] + ' ' + xfind[i][1] + '\n')
    
    of.write('MCL1 STATIUM\n')
    pmb = []
    mfind = []
    for i in range(ptile): pmb.append(pmstat[i][0])
    for i in range(len(pmstat)):
        if pmstat[i][0] in pmb: mfind.append(pmstat[i])
        if len(mfind) == 100: break
    for i in range(len(mfind)): of.write(mfind[i][0] + ' ' + mfind[i][1] + '\n')
    
    of.write('BCL2 STATIUM\n')
    pbb = []
    bfind = []
    for i in range(ptile): pbb.append(pbstat[i][0])
    for i in range(len(pbstat)):
        if pbstat[i][0] in pbb: bfind.append(pbstat[i])
        if len(bfind) == 100: break
    for i in range(len(bfind)): of.write(bfind[i][0] + ' ' + bfind[i][1] + '\n')
    
    of.write('BCLW STATIUM\n')
    pwb = []
    wfind = []
    for i in range(ptile): pwb.append(pwstat[i][0])
    for i in range(len(pwstat)):
        if pwstat[i][0] in pwb: wfind.append(pwstat[i])
        if len(wfind) == 100: break
    for i in range(len(wfind)): of.write(wfind[i][0] + ' ' + wfind[i][1] + '\n')

    of.write('BFL1 STATIUM\n')
    pfb = []
    ffind = []
    for i in range(ptile): pfb.append(pfstat[i][0])
    for i in range(len(pfstat)):
        if pfstat[i][0] in pfb: ffind.append(pfstat[i])
        if len(ffind) == 100: break
    for i in range(len(ffind)): of.write(ffind[i][0] + ' ' + ffind[i][1] + '\n')
    
    of.close()
    
def bcl2_scan(seq_path):

    design_energy_bclxl = load_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    design_energy_bclw = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    
    prot = readline(seq_path, 2)
  
    for i in range(len(prot) - 23):
        seq = prot[i:i + 23]
        if not seq[12] in 'AGS': continue
        if not seq[8] in 'IL': continue
        #if not seq[11] in 'ACFGHILMNPQSTVWY': continue
        #if not seq[15] in 'ACFGHILMNPQSTVWY': continue
        bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, True)
        mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, True)
        bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, True)
        bclw_energy = xenergy(design_energy_bclw, seq, 10.0, True)
        bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, True)
        
        if bclxl_energy > 0.95 or mcl1_energy > 0.95 or bclw_energy > 0.95 or bcl2_energy > 0.95 or bfl1_energy > 0.95: print seq, i + 1, bclxl_energy, mcl1_energy, bcl2_energy, bclw_energy, bfl1_energy
        
def bcl2_search(seq_path):

    design_energy_bclxl = load_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    design_energy_bclw = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    
    prots = readlines(seq_path)
    seqs = []
    
    count = 0
    for line in prots:
        count += 1
        if count % 2 != 0:
        head = line.strip()
        continue
  
        prot = line.strip()
        for i in range(len(prot) - 23):
            seq = prot[i:i + 23]
            if not seq in seqs: seqs.append(seq)
            else: continue
            if not seq[12] in 'AG': continue
            if not seq[8] in 'IL': continue
            if not seq[15] in 'ACFGHILMNPQSTVWY': continue
            if not seq[11] in 'ACFGHILMNPQSTVWY': continue
            
            bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, False)
            mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, False)
            bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, False)
            bclw_energy = xenergy(design_energy_bclw, seq, 10.0, False)
            bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, False)
        
            if bclxl_energy > 0.9 or mcl1_energy > 0.9 or bcl2_energy > 0.9 or bclw_energy > 0.9 or bfl1_energy > 0.9:
            print head
            print seq, i + 1, bclxl_energy, mcl1_energy, bcl2_energy, bclw_energy, bfl1_energy
            
def bcl2_listing(data_path, out_path):
  
    SPOT_vec = PSSM5()
    deepem = deepe_matrix('m')
    deepex = deepe_matrix('x')

    #design_energy_bclxl = load_design_energy('/home/bartolo/web/full_house/bclxl/bclxl_3fdl')
    #design_energy_mcl1 = load_design_energy('/home/bartolo/web/full_house/mcl1/mcl1_2pqk')
    #design_energy_bclw = load_design_energy('/home/bartolo/web/full_house/bclw/bclw')
    #design_energy_bcl2 = load_design_energy('/home/bartolo/web/full_house/bcl2/bcl2')
    #design_energy_bfl1 = load_design_energy('/home/bartolo/web/full_house/bfl1/bfl1_3mqp')
    
    data = lines2list(data_path)
    evec = [[], [], [], [], []]
    
    print 'Initialized...'
  
    for i in range(len(data)):
        seq = data[i][0]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
     #   bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, False)
      #  mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, False)
       # bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, False)
        #bclw_energy = xenergy(design_energy_bclw, seq, 10.0, False)
        #bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, False)
        
        pssm_bclxl = energy_pssm[0]
        pssm_mcl1 = energy_pssm[1]
        pssm_bclw = energy_pssm[2]
        pssm_bfl1 = energy_pssm[3]
        pssm_bcl2 = energy_pssm[4]
        
        deepe_x = deepe_calc(deepex, seq)
        deepe_m = deepe_calc(deepem, seq)
        
    evec[0].append(deepe_x)
    evec[1].append(deepe_m)
    evec[2].append(pssm_bcl2)
    evec[3].append(pssm_bclw)
    evec[4].append(pssm_bfl1)
    
#    evec[0].append(bclxl_energy)
#    evec[1].append(mcl1_energy)
#    evec[2].append(bcl2_energy)
#    evec[3].append(bclw_energy)
#    evec[4].append(bfl1_energy)
    
    print 'Done'
    
    import numpy
    bclxl_a = numpy.array(evec[0])
    mcl1_a = numpy.array(evec[1])
    bcl2_a = numpy.array(evec[2])
    bclw_a = numpy.array(evec[3])
    bfl1_a = numpy.array(evec[4])
    
    for i in range(len(data)):
        data[i].append(evec[0][i])
        data[i].append(evec[1][i])
        data[i].append(evec[2][i])
        data[i].append(evec[3][i])
        data[i].append(evec[4][i])
    
    out_file = open(out_path, 'w')
    for i in range(len(data)):
        for j in range(len(data[i])):
        out_file.write(str(data[i][j]) + '\t')
    out_file.write('\n')
    out_file.close()
    
def bcl2_list(data_path, out_path):

    design_energy_bclxl = load_design_energy('/home/bartolo/web/lib_statium/bclxl/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/lib_statium/mcl1/mcl1_2pqk')
    design_energy_bclw = load_design_energy('/home/bartolo/web/lib_statium/bclw/bclw')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/lib_statium/bcl2/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/lib_statium/bfl1/bfl1_3mqp')
    
    data = lines2list(data_path)
    evec = [[], [], [], [], []]
    
    print 'Initialized...'
  
    for i in range(len(data)):
        if i % 1000 == 0: print float(i) / float(len(data))
        seq = data[i][0]
        bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, False)
        mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, False)
        bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, False)
        bclw_energy = xenergy(design_energy_bclw, seq, 10.0, False)
        bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, False)
    
    evec[0].append(bclxl_energy)
    evec[1].append(mcl1_energy)
    evec[2].append(bcl2_energy)
    evec[3].append(bclw_energy)
    evec[4].append(bfl1_energy)
    
    import numpy
    bclxl_a = numpy.array(evec[0])
    mcl1_a = numpy.array(evec[1])
    bcl2_a = numpy.array(evec[2])
    bclw_a = numpy.array(evec[3])
    bfl1_a = numpy.array(evec[4])
    
    for i in range(len(data)):
        data[i].append(evec[0][i])
        data[i].append(evec[1][i])
        data[i].append(evec[2][i])
        data[i].append(evec[3][i])
        data[i].append(evec[4][i])
    
    out_file = open(out_path, 'w')
    for i in range(len(data)):
        for j in range(len(data[i])):
        out_file.write(str(data[i][j]) + '\t')
    out_file.write('\n')
    out_file.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.hist(bclxl_a, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.savefig('/home/bartolo/web/lib_statium/bclxl/bclxl_3io8.png')
    pylab.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.hist(mcl1_a, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.savefig('/home/bartolo/web/lib_statium/mcl1/mcl1_2pqk.png')
    pylab.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.hist(bcl2_a, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.savefig('/home/bartolo/web/lib_statium/bcl2/bcl2.png')
    pylab.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.hist(bclw_a, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.savefig('/home/bartolo/web/lib_statium/bclw/bclw.png')
    pylab.close()
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.hist(bfl1_a, facecolor='red', alpha=0.45, bins=40)
    pylab.rcParams['xtick.labelsize'] = '15'
    pylab.rcParams['ytick.labelsize'] = '15'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.savefig('/home/bartolo/web/lib_statium/bfl1/bfl1_3mqp.png')
    pylab.close()
    
    evec[0].sort()
    evec[1].sort()
    evec[2].sort()
    evec[3].sort()
    evec[4].sort()
    
    bclxl_p = [[], []]
    L = len(evec[0])
    erange = 1.0
    e0 = evec[0][0]
    bclxl_p[0].append(e0)
    bclxl_p[1].append(1.0)
    for i in range(L):
        e = evec[0][i]
        if e >= e0 + erange:
            prob = 1.0 - (float(i) / float(L))
        bclxl_p[0].append(e)
        bclxl_p[1].append(prob)
        e0 = e
    out_file = open('/home/bartolo/web/lib_statium/bclxl/bclxl_3io8.probs', 'w')
    for i in range(len(bclxl_p[0])):
        out_file.write(str(bclxl_p[0][i]) + '\t' + str(bclxl_p[1][i]) + '\n')
    out_file.close()
    
    mcl1_p = [[], []]
    L = len(evec[1])
    erange = 1.0
    e0 = evec[1][0]
    mcl1_p[0].append(e0)
    mcl1_p[1].append(1.0)
    for i in range(L):
        e = evec[1][i]
        if e >= e0 + erange:
            prob = 1.0 - (float(i) / float(L))
        mcl1_p[0].append(e)
        mcl1_p[1].append(prob)
        e0 = e
    out_file = open('/home/bartolo/web/lib_statium/mcl1/mcl1_2pqk.probs', 'w')
    for i in range(len(mcl1_p[0])):
        out_file.write(str(mcl1_p[0][i]) + '\t' + str(mcl1_p[1][i]) + '\n')
    out_file.close()
    
    bcl2_p = [[], []]
    L = len(evec[2])
    erange = 1.0
    e0 = evec[2][0]
    bcl2_p[0].append(e0)
    bcl2_p[1].append(1.0)
    for i in range(L):
        e = evec[2][i]
        if e >= e0 + erange:
            prob = 1.0 - (float(i) / float(L))
        bcl2_p[0].append(e)
        bcl2_p[1].append(prob)
        e0 = e
    out_file = open('/home/bartolo/web/lib_statium/bcl2/bcl2.probs', 'w')
    for i in range(len(bcl2_p[0])):
        out_file.write(str(bcl2_p[0][i]) + '\t' + str(bcl2_p[1][i]) + '\n')
    out_file.close()
    
    bclw_p = [[], []]
    L = len(evec[3])
    erange = 1.0
    e0 = evec[3][0]
    bclw_p[0].append(e0)
    bclw_p[1].append(1.0)
    for i in range(L):
        e = evec[3][i]
        if e >= e0 + erange:
            prob = 1.0 - (float(i) / float(L))
        bclw_p[0].append(e)
        bclw_p[1].append(prob)
        e0 = e
    out_file = open('/home/bartolo/web/lib_statium/bclw/bclw.probs', 'w')
    for i in range(len(bclw_p[0])):
        out_file.write(str(bclw_p[0][i]) + '\t' + str(bclw_p[1][i]) + '\n')
    out_file.close()
    
    bfl1_p = [[], []]
    L = len(evec[4])
    erange = 1.0
    e0 = evec[4][0]
    bfl1_p[0].append(e0)
    bfl1_p[1].append(1.0)
    for i in range(L):
        e = evec[4][i]
        if e >= e0 + erange:
            prob = 1.0 - (float(i) / float(L))
        bfl1_p[0].append(e)
        bfl1_p[1].append(prob)
        e0 = e
    out_file = open('/home/bartolo/web/lib_statium/bfl1/bfl1_3mqp.probs', 'w')
    for i in range(len(bfl1_p[0])):
        out_file.write(str(bfl1_p[0][i]) + '\t' + str(bfl1_p[1][i]) + '\n')
    out_file.close()
            
def luther(data_path, out_path):

    SPOT_vec = SPOT_200_PSSM()
    
    deepm = deepe_matrix('m')
    deepx = deepe_matrix('x')
    deepcm = deepcpl_matrix('m')
    deepcx = deepcpl_matrix('x')
    
    design_energy_bclxl = load_design_energy('/home/bartolo/web/Bim/bclxl/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/Bim/mcl1/mcl1_2pqk')
    design_energy_bclw = load_design_energy('/home/bartolo/web/Bim/bclw/bclw')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/Bim/bcl2/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/Bim/bfl1/bfl1_3mqp')
    #print "loaded..."

    data = lines2list(data_path)
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bim_bclxl_energy = xenergy(design_energy_bclxl, bim, 10.0, False)
    bim_mcl1_energy = xenergy(design_energy_mcl1, bim, 10.0, False)
    bim_bclw_energy = xenergy(design_energy_bclw, bim, 10.0, False)
    bim_bcl2_energy = xenergy(design_energy_bcl2, bim, 10.0, False)
    bim_bfl1_energy = xenergy(design_energy_bfl1, bim, 10.0, False)
  
    count = 0
    forbids = []
    for i in range(len(data)):
        count += 1
        seq = data[i][0]
        deepxe = deepe_calc(deepx, seq)
        deepme = deepe_calc(deepm, seq)
        bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, False)
        mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, False)
        bclw_energy = xenergy(design_energy_bclw, seq, 10.0, False)
        bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, False)
        bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, False)
        energy_pssm = pssm_energy(SPOT_vec, seq)
        #pvec = []
        #forbid = ''
    #idxs = [4, 8, 9, 11, 13, 15]
    #aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    #for i in range(len(idxs)):
        #idx = idxs[i]
        #if not seq[idx] in aas[i]:
       #     pvec.append(idx)
      #      forbid += seq[idx]
     #   else: forbid += 'X'
    #if not forbid in forbids: forbids.append(forbid)
    #else: continue
        #energy_pssm = pssm_energy_pos(SPOT_vec, seq, pvec)
        pssm_bclxl = energy_pssm[0]
        pssm_mcl1 = energy_pssm[1]
        
        #print seq, pssm_bclxl, pssm_mcl1
    
    data[i].append(bclxl_energy)
    data[i].append(mcl1_energy)
    data[i].append(bclw_energy)
    data[i].append(bcl2_energy)
    data[i].append(bfl1_energy)
    #data[i].append(pssm_bclxl)
    #data[i].append(pssm_mcl1)
    #data[i].append(deepxe)
    #data[i].append(deepme)
    if i % 1000 == 0: print float(i) / float(len(data))
    #print "done"
    
    out_file = open(out_path, 'w')
    for i in range(len(data)):
        for j in range(len(data[i])):
        out_file.write(str(data[i][j]) + '\t')
    out_file.write('\n')
    out_file.close()
    
def non_redundant(ini, oti):
  
    lines = readlines(ini)
    
    ov = []
    for line in lines:
        if not line in ov: ov.append(line)
    of = open(oti, 'w')
    for line in ov: of.write(line)
    of.close()
    
def check_BH3(seq):
    
    count = 0
    use = True
    for i in range(len(seq)):
        if AAChar_int(seq[i]) >= 20: use = False
        else: count += 1
    if count < 23 or count > 23: use = False
    
    return use
    
def stat_spot():
  
    bims = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    bads = lines2list('/home/bartolo/web/statium/bad_seq.txt')
    noxas = lines2list('/home/bartolo/web/statium/noxa_seq.txt')
  
    design_energy_bclxl = load_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    design_energy_mcl1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    design_energy_bclw = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    design_energy_bcl2 = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    design_energy_bfl1 = load_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bad = 'AAQRYGRELRRMSDEFVDSFKKG'
    noxa = 'LEVECATQLRRFGDKLNFRQKLL'
    
    bimxe = xenergy(design_energy_bclxl, bim, 10.0, False)
    bimme = xenergy(design_energy_mcl1, bim, 10.0, False)
    bimwe = xenergy(design_energy_bclw, bim, 10.0, False)
    bimbe = xenergy(design_energy_bcl2, bim, 10.0, False)
    bimfe = xenergy(design_energy_bfl1, bim, 10.0, False)
    badxe = xenergy(design_energy_bclxl, bad, 10.0, False)
    noxame = xenergy(design_energy_mcl1, noxa, 10.0, False)
    
    of = open('/home/bartolo/web/statium/SPOT200_stat.txt', 'w')
    
    for i in range(len(bims)):
        bimm = bims[i][0]
        badm = bads[i][0]
        noxam = noxas[i][0]
        
        bimmxe = xenergy(design_energy_bclxl, bimm, 10.0, False)
        bimmme = xenergy(design_energy_mcl1, bimm, 10.0, False)
        bimmwe = xenergy(design_energy_bclw, bimm, 10.0, False)
        bimmbe = xenergy(design_energy_bcl2, bimm, 10.0, False)
        bimmfe = xenergy(design_energy_bfl1, bimm, 10.0, False)
        badmxe = xenergy(design_energy_bclxl, badm, 10.0, False)
        noxamme = xenergy(design_energy_mcl1, noxam, 10.0, False)
        
        of.write(bims[i][0] + '\t' + bims[i][1] + '\t' + str(bimmxe - bimxe) + '\t' + str(bimmme - bimme) + '\t'+ str(bimmwe - bimwe) + '\t'+ str(bimmfe - bimfe) + '\t'+ str(bimmbe - bimbe) + '\t'+ str(badmxe - badxe) + '\t'+ str(noxamme - noxame) + '\n')
    of.close()
    
def glenna_test(seq):
  
    #seq = 'MRPEIWIAQELRRIGDEFNAYYARR'
    test_matrix = load_design_energy('/home/gmwink/Homology modeling/StatKS/energy')
    test_energy = xenergy(test_matrix, seq, 10.0, False)
    return test_energy
    
    
def bcl2_web_list(data):

    SPOT_vec = PSSM5()
    bnSPOT_vec = PSSM_bad_noxa()
    
    design_energy_bclxl = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    design_energy_mcl1 = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    design_energy_bclw = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')
    design_energy_bcl2 = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    design_energy_bfl1 = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    #print "loaded..."
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bim_bclxl_energy = 0.0# xenergy(design_energy_bclxl, bim, 10.0, False)
    bim_mcl1_energy = 0.0#xenergy(design_energy_mcl1, bim, 10.0, False)
    bim_bclw_energy = 0.0#xenergy(design_energy_bclw, bim, 10.0, False)
    bim_bcl2_energy = 0.0#xenergy(design_energy_bcl2, bim, 10.0, False)
    bim_bfl1_energy = 0.0#xenergy(design_energy_bfl1, bim, 10.0, False)
    
    deepem = [deepe_matrix_coupling('m'), 'm']
    deepex = [deepe_matrix_coupling('x'), 'x']
    deepexa = [deepe_matrix_coupling('xa'), 'xa']
    deepema = [deepe_matrix_coupling('ma'), 'ma']
    deepewa = [deepe_matrix_coupling('wa'), 'wa']
    deepe2a = [deepe_matrix_coupling('2a'), '2a']
    deepefa = [deepe_matrix_coupling('fa'), 'fa']
    
    table_vec = []
    table_vec.append(['BH3', 'STATBCLXL', 'STATMCL1', 'STATBCLW', 'STATBCL2', 'STATBFL1', 'PSSMBCLXL', 'PSSMMCL1', 'PSSMBCLW', 'PSSMBCL2', 'PSSMBFL1', 'PSSMBAD', 'PSSM_NOXA', 'DEEPXS', 'DEEPMS', 'DEEPX', 'DEEPM', 'DEEPW', 'DEEP2', 'DEEPF'])
  
    forbids = []
    for i in range(len(data)):
        seq = data[i]
        if check_BH3(seq):
            seq = data[i]
            bclxl_energy = statium_energy_calc_sidechain(design_energy_bclxl, seq, 0.0) 
            mcl1_energy = statium_energy_calc_sidechain(design_energy_mcl1, seq, 0.0) 
            bcl2_energy = statium_energy_calc_sidechain(design_energy_bcl2, seq, 0.0) 
            bclw_energy = statium_energy_calc_sidechain(design_energy_bclw, seq, 0.0) 
            bfl1_energy = statium_energy_calc_sidechain(design_energy_bfl1, seq, 0.0) 
            energy_pssm = pssm_energy10(SPOT_vec, seq)
            energy_pssm_bn = pssm_energy10_bad_noxa(bnSPOT_vec, seq)
            pssm_bclxl = energy_pssm[0]
            pssm_mcl1 = energy_pssm[1]
            pssm_bclw = energy_pssm[2]
            pssm_bfl1 = energy_pssm[3]
            pssm_bcl2 = energy_pssm[4]
            pssm_bad = energy_pssm_bn[0]
            pssm_noxa = energy_pssm_bn[1]
    
            nv = []
            nv.append(seq)
        nv.append(str(round(bclxl_energy, 2)))
        nv.append(str(round(mcl1_energy, 2)))
        nv.append(str(round(bclw_energy, 2)))
        nv.append(str(round(bcl2_energy, 2)))
        nv.append(str(round(bfl1_energy, 2)))
        nv.append(str(round(pssm_bclxl, 2)))
        nv.append(str(round(pssm_mcl1, 2)))
        nv.append(str(round(pssm_bclw, 2)))
        nv.append(str(round(pssm_bcl2, 2)))
        nv.append(str(round(pssm_bfl1, 2)))
        nv.append(str(round(pssm_bad, 2)))
        nv.append(str(round(pssm_noxa, 2)))
        nv.append(str(round(deepe_calc_coupling(deepex, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepem, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepexa, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepema, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepewa, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepe2a, seq, 1.0, 0.0), 2)))
        nv.append(str(round(deepe_calc_coupling(deepefa, seq, 1.0, 0.0), 2)))
        table_vec.append(nv)
    else:
            nv = []
            nv.append("unacceptable format")
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            nv.append('N/A')
            table_vec.append(nv)
    
    return HTML_table_notitle(table_vec)
    
def process_ArrayIII():
  
    data = lines2list('/home/bartolo/web/statium/ArrayIII/A3_XMF_run_PMT420_50micron_111511.txt')
    seqs = lines2list('/home/bartolo/web/statium/ArrayIII/sequences.txt')
    
    xbim = 17694043.41
    mbim = 52958340.39
    fbim = (52681384.45 + 57672222.32) / 2.0
    
    count = 0
    while True:
      if count > 583: break      
      if count <= 285:
      if count >= 276:
          print seqs[count][0],
          for k in range(2): print round(data[count + k][2] / xbim, 2),
          print
          count += 2
      else:
          print seqs[count][0],
          for k in range(4): print round(data[count + k][2] / xbim, 2),
          print
          count += 4
      
      if count > 285 and count <= 397:
      if count >= 389:
          print seqs[count][0],
          for k in range(2): print round(data[count + k][2] / mbim, 2),
          print
          count += 2
      else:
          print seqs[count][0],
          for k in range(4): print round(data[count + k][2] / mbim, 2),
          print
          count += 4

      if count > 397:
      if count >= 574:
          print seqs[count][0],
          for k in range(2): print round(data[count + k][2] / fbim, 2),
          print
          count += 2
      else:
          print seqs[count][0],
          for k in range(4): print round(data[count + k][2] / fbim, 2),
          print
          count += 4
        
def comp_deepe_pssm(d, p):
  
    dl = lines2list(d)
    pl = lines2list(p)
    
    count = 0
    for i in range(len(dl)):
    #if dl[i][0] == 'PEIWFAQELRRDGDEYNAYYARR': print dl[i][0], dl[i][1], dl[i][2], pl[i][1], pl[i][2]
        if dl[i][2] < 0.0 and pl[i][2] > pl[i][1]:
        #if (dl[i][2] < -4.0 and pl[i][2] < -0.0) and not 'C' in dl[i][0] and not 'M' in dl[i][0]:
    #if (pl[i][2] < -0.0) and not 'C' in dl[i][0] and not 'M' in dl[i][0]:
        count += 1
        print 'UR' + dl[i][0] + 'V', dl[i][1], dl[i][2], pl[i][1], pl[i][2]
        
    print count
    
def deep_total_nr(in_dir, out_path):
  
    seqs = []
    in_list = os.listdir(in_dir)
    for file in in_list:
        if len(file.split('.')) > 1:
        if file.split('.')[1] == 'txt':
            print file
        path = os.path.join(in_dir, file)
        lines = readlines(path)
        for line in lines:
            if not line in seqs: seqs.append(line)
    of = open(out_path, 'w')
    for line in seqs: of.write(line)
    of.close()
    
def luther_pos(data_path, out_path):

    SPOT_vec = SPOT_200_PSSM()
    
    #design_energy_bclxl = load_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    #design_energy_mcl1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    #design_energy_bclw = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    #design_energy_bcl2 = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    #design_energy_bfl1 = load_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    #print "loaded..."

    data = lines2list(data_path)
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    #bim_bclxl_energy = xenergy(design_energy_bclxl, bim, 10.0, False)
    #bim_mcl1_energy = xenergy(design_energy_mcl1, bim, 10.0, False)
    #bim_bclw_energy = xenergy(design_energy_bclw, bim, 10.0, False)
    #bim_bcl2_energy = xenergy(design_energy_bcl2, bim, 10.0, False)
    #bim_bfl1_energy = xenergy(design_energy_bfl1, bim, 10.0, False)
  
    count = 0
    forbids = []
    data2 = []
    for i in range(len(data)):
        count += 1
        seq = data[i][0]
        #bclxl_energy = xenergy(design_energy_bclxl, seq, 10.0, False)
        #mcl1_energy = xenergy(design_energy_mcl1, seq, 10.0, False)
        #bclw_energy = xenergy(design_energy_bclw, seq, 10.0, False)
        #bcl2_energy = xenergy(design_energy_bcl2, seq, 10.0, False)
        #bfl1_energy = xenergy(design_energy_bfl1, seq, 10.0, False)
        #energy_pssm = pssm_energy(SPOT_vec, seq)
        pvec = []
        forbid = ''
    idxs = [4, 8, 9, 11, 13, 15]
    aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    for i in range(len(idxs)):
        idx = idxs[i]
        if not seq[idx] in aas[i]:
            pvec.append(idx)
            forbid += seq[idx]
        else: forbid += 'X'
    if not forbid in forbids: forbids.append(forbid)
    else: continue
        energy_pssm = pssm_energy_pos(SPOT_vec, seq, pvec)
        pssm_bclxl = energy_pssm[0]
        pssm_mcl1 = energy_pssm[1]
        
        if pssm_bclxl == 0.0 and pssm_mcl1 == 0.0: continue
    
    #data[i].append(bclxl_energy - bim_bclxl_energy)
    #data[i].append(mcl1_energy - bim_mcl1_energy)
    #data[i].append(bclw_energy - bim_bclw_energy)
    #data[i].append(bcl2_energy - bim_bcl2_energy)
    #data[i].append(bfl1_energy - bim_bfl1_energy)
    #data[i].append(pssm_bclxl)
    #data[i].append(pssm_mcl1)
    di = [seq, pssm_bclxl, pssm_mcl1]
    data2.append(di)
    #if i % 1000 == 0: print float(i) / float(len(data))
    #print "done"
    
    out_file = open(out_path, 'w')
    for i in range(len(data2)):
        for j in range(len(data2[i])):
        out_file.write(str(data2[i][j]) + '\t')
    out_file.write('\n')
    out_file.close()
    
def PDZ_energy(preset_dir, data_path, out_path):

    #SPOT_vec = SPOT_200_PSSM()
    
    PDZ_energy = load_design_energy_PDZ(preset_dir)

    data = lines2list(data_path)
    
    for i in range(len(data)):
        seq = data[i][0]
        energy = xenergy(PDZ_energy, seq, 10.0, False)
    
    data[i].append(energy)
    
    out_file = open(out_path, 'w')
    for i in range(len(data)):
        for j in range(len(data[i])):
        out_file.write(str(data[i][j]) + '\t')
    out_file.write('\n')
    out_file.close()
    
def yeast_hist(m, b, c1, c2, out_path, r):
  
    ms = lines2list(m)
    bs = lines2list(b)
    
    mv = []
    bv = []

    if r == 'm': tt = 2
    else: tt = 1
    
    for i in range(len(ms)):
        mv.append(ms[i][tt])
    for i in range(len(bs)):
        bv.append(bs[i][tt])
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    ma = pylab.array(mv)
    ba = pylab.array(bv)
    pylab.hist(ma, normed=True, facecolor=c1, alpha=0.45)
    pylab.hist(ba, normed=True, facecolor=c2, alpha=0.45)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.yticks([])
    pylab.xticks([])
    pylab.savefig(out_path)
    pylab.close()
    
def luther_yeast(m, b, out_path):
  
    ms = lines2list(m)
    bs = lines2list(b)
    
    mv = []
    bv = []
    
    for i in range(len(ms)):
        mv.append(ms[i][1] - ms[i][2])
        #if ms[i][1] - ms[i][2] > 4.0: print ms[i][0], ms[i][1], ms[i][2], 'm'
    for i in range(len(bs)):
        bv.append(bs[i][1] - bs[i][2])
        #if bs[i][1] - bs[i][2] < -4.0: print bs[i][0], bs[i][1], bs[i][2], 'b'
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    ma = pylab.array(mv)
    ba = pylab.array(bv)
    pylab.hist(ma, facecolor='red', alpha=0.45)
    pylab.hist(ba, facecolor='blue', alpha=0.45)
   # pylab.rcParams['xtick.labelsize'] = '20'
   # pylab.rcParams['ytick.labelsize'] = '20'
    pylab.savefig(out_path)
    pylab.close()
    
def normalize_data(ip, op):
  
    l = lines2list(ip)
    seqs = []
    bs = []
    ms = []
    for i in range(len(l)):
        seqs.append(l[i][0])
        bs.append(l[i][1])
        ms.append(l[i][2])
      
    import pylab
    import numpy
    ba = pylab.array(bs)
    ma = pylab.array(ms)
    
    bmin = numpy.min(ba)
    bmax = numpy.max(ba)
    
    mmin = numpy.min(ma)
    mmax = numpy.max(ma)
    
    o = open(op, 'w')
    for i in range(len(l)):
        bsn = (((bs[i] - bmin) / (bmax - bmin)) * 2) - 1
        msn = (((ms[i] - mmin) / (mmax - mmin)) * 2) - 1
    o.write(l[i][0] + '\t' + str(bsn) + '\t' + str(msn) + '\n')
    o.close()
    
def average_energies(f1, f2, op):
  
    l1 = lines2list(f1)
    l2 = lines2list(f2)
    
    o = open(op, 'w')
    for i in range(len(l1)):
        e1 = (l1[i][1] + l2[i][1]) / 2.0
        e2 = (l1[i][2] + l2[i][2]) / 2.0
        o.write(l1[i][0] + '\t' + str(e1) + '\t' + str(e2) + '\n')
    o.close()
    
def combine_energies(f1, f2, op):
  
    l1 = lines2list(f1)
    l2 = lines2list(f2)
    
    o = open(op, 'w')
    for i in range(len(l1)):
        e1 = (l1[i][1] + l2[i][1]) / 2.0
        e2 = (l1[i][2] + l2[i][2]) / 2.0
        o.write(l1[i][0] + '\t' + str(e1) + '\t' + str(e2) + '\n')
    o.close()
    
def luther_yeast_scatter(m, b, out_path):
  
    ms = lines2list(m)
    bs = lines2list(b)
    
    mmv = []
    mbv = []
    bmv = []
    bbv = []
    
    #for i in range(len(ms)): print ms[i][1], ms[i][2]
    #print
    #for i in range(len(bs)): print bs[i][1], bs[i][2]
    #print
    #for i in range(len(ns)): print ns[i][1], ns[i][2]
    
    
    for i in range(len(ms)):
        mmv.append(ms[i][2])
        mbv.append(ms[i][1])
    for i in range(len(bs)):
        bmv.append(bs[i][2])
        bbv.append(bs[i][1])
 
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    mma = pylab.array(mmv)
    mba = pylab.array(mbv)
    bma = pylab.array(bmv)
    bba = pylab.array(bbv)
    #xa = pylab.arange(-50, 250)
    #ya = pylab.arange(-50, 250)
    pylab.scatter(mma, mba, c='r', marker='o', s=100, facecolor='none', edgecolors='r')
    pylab.scatter(bma, bba, c='b', marker='s', s=100, facecolor='none', edgecolors='b')
    #pylab.plot(xa, ya, 'k')
    #pylab.xlim(-50, 250)
    #pylab.ylim(-50, 250)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.savefig(out_path)
    pylab.close()
    
def yeast_comp_scatter(p, e, p2, e2, out_path):
  
    ps = lines2list(p)
    es = lines2list(e)
    pv = []
    ev = []
    for i in range(len(es)):
        pv.append(ps[i][1] - ps[i][2])
        ev.append(es[i][1] - es[i][2])
    ps2 = lines2list(p2)
    es2 = lines2list(e2)
    pv2 = []
    ev2 = []
    for i in range(len(es2)):
        pv2.append(ps2[i][1] - ps2[i][2])
        ev2.append(es2[i][1] - es2[i][2])
 
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pa = pylab.array(pv)
    ea = pylab.array(ev)
    pa2 = pylab.array(pv2)
    ea2 = pylab.array(ev2)
    #xa = pylab.arange(-50, 250)
    #ya = pylab.arange(-50, 250)
    pylab.scatter(pa, ea, c='r', marker='o', s=100, facecolor='none', edgecolors='r')
    pylab.scatter(pa2, ea2, c='b', marker='o', s=100, facecolor='none', edgecolors='b')
    #pylab.plot(xa, ya, 'k')
    #pylab.xlim(-50, 250)
    #pylab.ylim(-50, 250)
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.savefig(out_path)
    pylab.close()
    
def yeast_allowed(inf, ouf, r):
  
    ilines = readlines(inf)

    if r in 'xm':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    if r in 'w2':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 7, 8, 9, 11, 12, 14]
        aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    if r in 'f':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 5, 7, 8, 11, 14, 15]
        aas = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    
    
    seqs = []
    for line in ilines:
        seq = line.strip()
        cont = False
        for i in range(len(seq)):
        if i in idxs:
            if not seq[i] in aas[idxs.index(i)]: cont = True
        else:
            if seq[i] != wt[i]: cont = True
    if cont:
        #print seq
        continue
    if not seq in seqs: seqs.append(seq)
      
    ofile = open(ouf, 'w')
    for i in range(len(seqs)): ofile.write(seqs[i] + '\n')
    ofile.close()
    
def yeast_allowed_loop(idir, odir):
  
    ilist = os.listdir(idir)
    for file in ilist:
        if len(file.split('.')) > 1:
        if file.split('.')[1] == 'txt':
            ipath = os.path.join(idir, file)
            opath = os.path.join(odir, file)
            yeast_allowed(ipath, opath)
            
def yeast_not_allowed(inf, ouf):
  
    ilines = readlines(inf)

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    ofile = open(ouf, 'w')
    
    for line in ilines:
        seq = line.strip()
        use = False
        for i in range(len(seq)):
        if i in idxs:
            if not seq[i] in aas[idxs.index(i)]: use = True
        else:
            if seq[i] != wt[i]: use = True
    if use: ofile.write(seq + '\n')
    ofile.close()
    
def yeast_not_allowed_loop(idir, odir):
  
    ilist = os.listdir(idir)
    for file in ilist:
        if len(file.split('.')) > 1:
        if file.split('.')[1] == 'txt':
            ipath = os.path.join(idir, file)
            opath = os.path.join(odir, file)
            yeast_not_allowed(ipath, opath)
    
def simulate_yeast():
  
    o = open('/home/bartolo/web/yeast_full_lib.txt', 'w')

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    sv = []
    for i in range(L): sv.append(wt[i])
    
    count = 0
    for aa2d in range(len(aas[0])):
        sv[idxs[0]] = aas[0][aa2d]
    for aa3a in range(len(aas[1])):
        sv[idxs[1]] = aas[1][aa3a]
        for aa3b in range(len(aas[2])):
        sv[idxs[2]] = aas[2][aa3b]
        for aa3d in range(len(aas[3])):
            sv[idxs[3]] = aas[3][aa3d]
            for aa3f in range(len(aas[4])):
            sv[idxs[4]] = aas[4][aa3f]
            for aa4a in range(len(aas[5])):
                sv[idxs[5]] = aas[5][aa4a]
                
                seq = ''
                for i in range(L): seq += sv[i]
                o.write(seq + '\n')
                count += 1
                if count % 100 == 0: print count
    o.close()
    
def allowedf():
  
    #ip = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr.txt'
    #op = '/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr_allowed.txt'
    
    #ip = '/home/bartolo/web/statium/bfl1_sorts/express_nr.txt'
    #op = '/home/bartolo/web/statium/bfl1_sorts/express_nr_allowed.txt'
  
    ip = '/home/bartolo/web/statium/deepseq/w2/bclw_sort.txt'
    op = '/home/bartolo/web/statium/deepseq/w2/bclw_sort_allowed.txt'

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 7, 8, 9, 11, 12, 14]
    aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    #wt = 'PEIWIAQELRRIGDEFNAYYARR'
    #L = len(wt)
    #idxs = [4, 5, 7, 8, 11, 14, 15]
    #names = ['2d', '3a', '3b', '3d', '3f', '4a']
    #aas = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    
    data = lines2list(ip)
    
    of = open(op, 'w')
    for i in range(len(data)):
        seq = data[i][0]
        wr = True
        for j in range(len(idxs)):
        if not seq[idxs[j]] in aas[j]: wr = False
    for j in range(L):
        if not j in idxs:
            if seq[j] != wt[j]: wr = False
    if wr: of.write(seq + '\n')
    of.close()
    
def simulate_bfl1_library():

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 5, 7, 8, 11, 14, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    aas = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    
    sv = []
    for i in range(L): sv.append(wt[i])
    
    seqs = []
    
    count = 0
    for aa2d in range(len(aas[0])):
        sv[idxs[0]] = aas[0][aa2d]
    for aa3a in range(len(aas[1])):
        sv[idxs[1]] = aas[1][aa3a]
        for aa3b in range(len(aas[2])):
        sv[idxs[2]] = aas[2][aa3b]
        for aa3d in range(len(aas[3])):
            sv[idxs[3]] = aas[3][aa3d]
            for aa3f in range(len(aas[4])):
            sv[idxs[4]] = aas[4][aa3f]
            for aa4a in range(len(aas[5])):
                sv[idxs[5]] = aas[5][aa4a]
                for aanew in range(len(aas[6])):
                    sv[idxs[6]] = aas[6][aanew]
                
                    seq = ''
                    for i in range(L): seq += sv[i]
                    seqs.append(seq)
                    count += 1
                    if count % 10000 == 0: print count

    o = open('/home/bartolo/web/statium/bfl1_sorts/bfl1_full_lib.txt', 'w')
    for seq in seqs: o.write(seq + '\n')
    o.close()
    
def simulate_w2_library():

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 7, 8, 9, 11, 12, 14]
    aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    sv = []
    for i in range(L): sv.append(wt[i])
    
    seqs = []
    
    count = 0
    for aa2d in range(len(aas[0])):
        sv[idxs[0]] = aas[0][aa2d]
    for aa3a in range(len(aas[1])):
        sv[idxs[1]] = aas[1][aa3a]
        for aa3b in range(len(aas[2])):
        sv[idxs[2]] = aas[2][aa3b]
        for aa3d in range(len(aas[3])):
            sv[idxs[3]] = aas[3][aa3d]
            for aa3f in range(len(aas[4])):
            sv[idxs[4]] = aas[4][aa3f]
            for aa4a in range(len(aas[5])):
                sv[idxs[5]] = aas[5][aa4a]
                for aanew in range(len(aas[6])):
                    sv[idxs[6]] = aas[6][aanew]
                
                    seq = ''
                    for i in range(L): seq += sv[i]
                    seqs.append(seq)
                    count += 1
                    if count % 10000 == 0: print count

    o = open('/home/bartolo/web/statium/deepseq/w2/w2_full.txt', 'w')
    for seq in seqs: o.write(seq + '\n')
    o.close()
    
def yeast_data_analysis():
  
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a'] 
  
    mcl1_lines = readlines('/home/bartolo/web/orgWASP/data/yeast_mcl1_spec.txt')
    bclxl_lines = readlines('/home/bartolo/web/orgWASP/data/yeast_bclxl_spec.txt')
    mcl1_bclxl_lines = readlines('/home/bartolo/web/orgWASP/data/yeast_mcl1_bclxl.txt')
    
    mcl1_out = open('/home/bartolo/web/orgWASP/data/yeast_mcl1_spot200_1.txt', 'w')
    bclxl_out = open('/home/bartolo/web/orgWASP/data/yeast_bclxl_spot200_1.txt', 'w')
    mcl1_bclxl_out = open('/home/bartolo/web/orgWASP/data/yeast_mcl1_bclxl_spot200_1.txt', 'w')
    
    mcl1_seqs = []
    bclxl_seqs = []
    mcl1_bclxl_seqs = []
    
    for line in mcl1_lines: mcl1_seqs.append(line.strip())
    for line in bclxl_lines: bclxl_seqs.append(line.strip())
    for line in mcl1_bclxl_lines: mcl1_bclxl_seqs.append(line.strip())
  
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    SPOT_vec = SPOT_360_PSSM()
    
    mcl1_vec = [[], []]
    for seq in mcl1_seqs:
        e_pssm_bclxl = 0.0
        e_pssm_mcl1 = 0.0
        for i in range(len(idxs)):
        pos_idx = idxs[i]
        pos_name = names[i]
        spot_idx = pos_dict[pos_name]
        AA = seq[pos_idx]
        AA_idx = AA_dict[AA]
        
        e_pssm_bclxl += SPOT_vec[spot_idx][AA_idx][0]
        e_pssm_mcl1 += SPOT_vec[spot_idx][AA_idx][1]
    
    diff = e_pssm_bclxl - e_pssm_mcl1
    if (diff < 1.0 and diff > 0.0) or (diff < 0.0 and diff > -1.0): print 'M error'
     
    mcl1_out.write(seq + '\t' + str(e_pssm_bclxl - e_pssm_mcl1) + '\t' + str(e_pssm_mcl1 - e_pssm_bclxl) + '\n')
    #if e_pssm_bclxl < -3.0 or e_pssm_mcl1 < -3.0: continue
        mcl1_vec[0].append(e_pssm_bclxl - e_pssm_mcl1)
        mcl1_vec[1].append(0.0)
        
    bclxl_vec = [[], []]
    for seq in bclxl_seqs:
        e_pssm_bclxl = 0.0
        e_pssm_mcl1 = 0.0
        for i in range(len(idxs)):
        pos_idx = idxs[i]
        pos_name = names[i]
        spot_idx = pos_dict[pos_name]
        AA = seq[pos_idx]
        AA_idx = AA_dict[AA]
        
        e_pssm_bclxl += SPOT_vec[spot_idx][AA_idx][0]
        e_pssm_mcl1 += SPOT_vec[spot_idx][AA_idx][1]
        
    diff = e_pssm_bclxl - e_pssm_mcl1
    if (diff < 1.0 and diff > 0.0) or (diff < 0.0 and diff > -1.0): print 'X error'
    
    bclxl_out.write(seq + '\t' + str(e_pssm_bclxl - e_pssm_mcl1) + '\t' + str(e_pssm_mcl1 - e_pssm_bclxl) + '\n')
    #if e_pssm_bclxl < -3.0 or e_pssm_mcl1 < -3.0: continue
        bclxl_vec[0].append(e_pssm_bclxl - e_pssm_mcl1)
        bclxl_vec[1].append(0.0)
        
    mcl1_bclxl_vec = [[], []]
    for seq in mcl1_bclxl_seqs:
        e_pssm_bclxl = 0.0
        e_pssm_mcl1 = 0.0
        for i in range(len(idxs)):
        pos_idx = idxs[i]
        pos_name = names[i]
        spot_idx = pos_dict[pos_name]
        AA = seq[pos_idx]
        AA_idx = AA_dict[AA]
        
        e_pssm_bclxl += SPOT_vec[spot_idx][AA_idx][0]
        e_pssm_mcl1 += SPOT_vec[spot_idx][AA_idx][1]
    
    diff = e_pssm_bclxl - e_pssm_mcl1
    if (diff < 1.0 and diff > 0.0) or (diff < 0.0 and diff > -1.0): print 'P error'
    mcl1_bclxl_out.write(seq + '\t' + str(e_pssm_bclxl - e_pssm_mcl1) + '\t' + str(e_pssm_mcl1 - e_pssm_bclxl) + '\n')
    #if e_pssm_bclxl < -3.0 or e_pssm_mcl1 < -3.0: continue
        mcl1_bclxl_vec[0].append(e_pssm_bclxl - e_pssm_mcl1)
        mcl1_bclxl_vec[1].append(0.0)
        
    import pylab

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'

    pylab.scatter(pylab.array(mcl1_vec[0]), pylab.array(mcl1_vec[1]), c='r', marker='o', s=100, facecolor='none', edgecolors='r')
    pylab.scatter(pylab.array(bclxl_vec[0]), pylab.array(bclxl_vec[1]), c='b', marker='s', s=100, facecolor='none', edgecolors='b')
    pylab.scatter(pylab.array(mcl1_bclxl_vec[0]), pylab.array(mcl1_bclxl_vec[1]), c='g', marker='>', s=100, facecolor='none', edgecolors='g')

    #pylab.xlim(-10, 200)
    #pylab.ylim(-0.75, 1.75)
    pylab.savefig('/home/bartolo/web/orgWASP/data/pssm_spec360_1.png')
    pylab.close()
    
    mcl1_bclxl_out.close()
    mcl1_out.close()
    bclxl_out.close()
    
def SPOT_200_PSSM():
  
    data_path = '/home/bartolo/web/orgWASP/data/SPOT_200p.txt'
    data_vec = []
    data_lines = readlines(data_path)
    for line in data_lines:
        items = line.split()
        sub = []
        sub.append(items[0])
        sub.append(items[1])
        sub.append(float(items[2]))
        sub.append(float(items[3]))
        data_vec.append(sub)
        
    N = len(data_vec)
        
    SPOT_vec = []
    for i in range(10):
        SPOT_vec.append([])
        for j in range(18): SPOT_vec[i].append([0.0, 0.0])
  
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    
    wt_counts = 0
    bclxl_wt = 0.0
    mcl1_wt = 0.0
    for i in range(N):
        seq = data_vec[i][0]
        name = data_vec[i][1]
        namel = len(name)
        bclxl = data_vec[i][2]
        mcl1 = data_vec[i][3]
        if name == 'WT' or (namel == 4 and name[0] == name[-1]):
        wt_counts += 1
        bclxl_wt += bclxl
        mcl1_wt += mcl1

            
    bclxl_wt = bclxl_wt / float(wt_counts)
    mcl1_wt = mcl1_wt / float(wt_counts)

    for i in range(N):
        seq = data_vec[i][0]
        name = data_vec[i][1]
        namel = len(name)
        bclxl = data_vec[i][2]
        mcl1 = data_vec[i][3]
        if namel == 4 and name[0] != name[-1]:
            pos_idx = pos_dict[name[1] + name[2]]
            AA_idx = AA_dict[name[-1]]
            SPOT_vec[pos_idx][AA_idx][0] = -1.0 * math.log10(bclxl / bclxl_wt)
            SPOT_vec[pos_idx][AA_idx][1] = -1.0 * math.log10(mcl1 / mcl1_wt)
            
    return SPOT_vec
    
def append_column(p1, p2, op):
  
    l1 = lines2list(p1)
    l2 = lines2list(p2)
    
    of = open(op, 'w')
    for i in range(len(l1)):
        for j in range(len(l1[i])): of.write(str(l1[i][j]) + '\t')
        of.write(str(l2[i][0]) + '\n')
    of.close()
    
def PSSM5():
  
    data_path = '/home/bartolo/web/statium/SPOT200.txt'
    data_vec = []
    data_lines = readlines(data_path)
    for line in data_lines:
        items = line.split()
        sub = []
        sub.append(items[0])
        sub.append(items[1])
        sub.append(float(items[2]))
        sub.append(float(items[3]))
        sub.append(float(items[4]))
        sub.append(float(items[5]))
        sub.append(float(items[6]))
        data_vec.append(sub)
        
    N = len(data_vec)
        
    SPOT_vec = []
    for i in range(10):
        SPOT_vec.append([])
        for j in range(18): SPOT_vec[i].append([0.0, 0.0, 0.0, 0.0, 0.0])
  
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    
    wt_counts = 0
    bclxl_wt = 0.0
    mcl1_wt = 0.0
    bcl2_wt = 0.0
    bclw_wt = 0.0
    bfl1_wt = 0.0
    for i in range(N):
        seq = data_vec[i][0]
        name = data_vec[i][1]
        namel = len(name)
        bclxl = data_vec[i][2]
        mcl1 = data_vec[i][3]
        bclw = data_vec[i][4]
        bfl1 = data_vec[i][5]
        bcl2 = data_vec[i][6]
        if name == 'WT' or (namel == 4 and name[0] == name[-1]):
        wt_counts += 1
        bclxl_wt += bclxl
        mcl1_wt += mcl1
        bclw_wt += bclw
        bfl1_wt += bfl1
        bcl2_wt += bcl2

            
    bclxl_wt = bclxl_wt / float(wt_counts)
    mcl1_wt = mcl1_wt / float(wt_counts)
    bclw_wt = bclw_wt / float(wt_counts)
    bfl1_wt = bfl1_wt / float(wt_counts)
    bcl2_wt = bcl2_wt / float(wt_counts)

    for i in range(N):
        seq = data_vec[i][0]
        name = data_vec[i][1]
        namel = len(name)
        bclxl = data_vec[i][2]
        mcl1 = data_vec[i][3]
        bclw = data_vec[i][4]
        bfl1 = data_vec[i][5]
        bcl2 = data_vec[i][6]
        if namel == 4 and name[0] != name[-1]:
            pos_idx = pos_dict[name[1] + name[2]]
            AA_idx = AA_dict[name[-1]]
            SPOT_vec[pos_idx][AA_idx][0] = -1.0 * math.log10(bclxl / bclxl_wt)
            SPOT_vec[pos_idx][AA_idx][1] = -1.0 * math.log10(mcl1 / mcl1_wt)
            SPOT_vec[pos_idx][AA_idx][2] = -1.0 * math.log10(bclw / bclw_wt)
            SPOT_vec[pos_idx][AA_idx][3] = -1.0 * math.log10(bfl1 / bfl1_wt)
            SPOT_vec[pos_idx][AA_idx][4] = -1.0 * math.log10(bcl2 / bcl2_wt)
            
    return SPOT_vec
    
def PSSM_bad_noxa():
  
    bad_data = lines2list('/home/bartolo/web/statium/bad_noxa/bad_log.txt')
    noxa_data = lines2list('/home/bartolo/web/statium/bad_noxa/noxa_log.txt')
        
    N = len(bad_data)
        
    SPOT_vec = []
    for i in range(13):
        SPOT_vec.append([])
        for j in range(18): SPOT_vec[i].append([0.0, 0.0])
        
    pos = [1, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19]
    aa = ['D', 'E', 'K', 'R', 'H', 'N', 'Q', 'S', 'T', 'P', 'G', 'A', 'V', 'I', 'L', 'F', 'Y', 'W']
    noxa = 'LEVECATQLRRFGDKLNFRQKLL'
    bad = 'AAQRYGRELRRMSDEFVDSFKKG'
    
    for i in range(len(bad_data)):
        seq = bad_data[i][0]
        if seq == bad: continue
        posi = -1
        AA = ''
        for j in range(len(seq)):
        if seq[j] != bad[j]:
            posi = j
            AA = seq[j]
            break
    pos_idx = pos.index(posi)
    aa_idx = aa.index(AA)
    SPOT_vec[pos_idx][aa_idx][0] = bad_data[i][1]
    
    for i in range(len(noxa_data)):
        seq = noxa_data[i][0]
        if seq == noxa: continue
        posi = -1
        AA = ''
        for j in range(len(seq)):
        if seq[j] != noxa[j]:
            posi = j
            AA = seq[j]
            break
    pos_idx = pos.index(posi)
    aa_idx = aa.index(AA)
    #if pos_idx == 4 and aa_idx == 1: print noxa_data[i][1]
    SPOT_vec[pos_idx][aa_idx][1] = noxa_data[i][1]

    return SPOT_vec
    
def spot_convert(op):
  
    data = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    pv = []
    for i in range(len(data)): pv.append(data[i][1])
  
    pos_dict = {'2d': 4, '2e': 5, '2g': 7, '3a': 8, '3b': 9, '3d': 11, '3e': 12, '3f': 13, '3g': 14, '4a': 15}
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    
    seq0 = 'AAQRYGRELRRMSDEFVDSFKKG'
    
    for i in range(len(pv)):
        if len(pv[i]) == 4:
        pos_idx = pos_dict[pv[i][1] + pv[i][2]]
        pv[i] = seq0[pos_idx] + pv[i][-3] + pv[i][-2] + pv[i][-1]
        
    
    of = open(op, 'w')
    
    for i in range(len(pv)):
        if pv[i] == 'WT' or pv[i][0] == pv[i][-1]: of.write(seq0 + '\t' + pv[i] + '\n')
        else: 
            pos_idx = pos_dict[pv[i][1] + pv[i][2]]
            seq1v = []
            for j in range(len(seq0)): seq1v.append(seq0[j])
            seq1v[pos_idx] = pv[i][-1]
            seq1 = ''
            for j in range(len(seq1v)): seq1 += seq1v[j]
            of.write(seq1 + '\t' + pv[i] + '\n')
    of.close()
    
def SPOT_360_PSSM():

    SPOT200_vec = SPOT_200_PSSM()
  
    wt = 'DMRPEIWIAQELRRIGDEFNAYYARRVFL'
    idxs = [7, 8, 10, 11, 12, 14, 15, 16, 17, 18]
    names = ['2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a']
  
    data_path = '/home/bartolo/web/orgWASP/data/SPOT_360p.txt'
    data_vec = []
    data_lines = readlines(data_path)
    for line in data_lines:
        items = line.split()
        sub = []
        sub.append(items[0])
        sub.append(items[1])
        sub.append(float(items[2]))
        sub.append(float(items[3]))
        data_vec.append(sub)
        
    N = len(data_vec)
    
    wt_vec = []
    for i in range(10):
        wt_vec.append([0.0, 0.0, 0.0, 0.0])
        
    tally_vec = []
    for i in range(10):
        tally_vec.append([])
        for j in range(18): tally_vec[i].append([0.0, 0.0, 0.0, 0.0])
        
    SPOT_vec = []
    for i in range(10):
        SPOT_vec.append([])
        for j in range(18): SPOT_vec[i].append([0.0, 0.0])
  
    pos_dict = {'2d': 0, '2e': 1, '2g': 2, '3a': 3, '3b': 4, '3d': 5, '3e': 6, '3f': 7, '3g': 8, '4a': 9}
    AA_dict =  {'A': 0, 'D': 1, 'E': 2, 'F': 3, 'G': 4, 'H': 5, 'I': 6, 'K': 7, 'L': 8, 'N': 9, 'P': 10, 'Q': 11, 'R': 12, 'S': 13, 'T': 14, 'V': 15, 'W': 16, 'Y': 17}
    
    for i in range(N):
        seq = data_vec[i][0]
        bclxl = data_vec[i][2]
        mcl1 = data_vec[i][3]
        for i in range(len(idxs)):
        idx = idxs[i]
        name = names[i]
        pos_idx = pos_dict[name]
        AA = seq[idx]
        wt_AA = wt[idx]
        AA_idx = AA_dict[AA]
        wt_res = (AA == wt_AA)
        if bclxl > (10 ** 6.5):
            if wt_res:
                wt_vec[pos_idx][0] += bclxl
                wt_vec[pos_idx][2] += 1.0
        else:
                tally_vec[pos_idx][AA_idx][0] += bclxl
                tally_vec[pos_idx][AA_idx][2] += 1.0
                
        if mcl1 > (10 ** 6.5):
            if wt_res:
                wt_vec[pos_idx][1] += mcl1
                wt_vec[pos_idx][3] += 1.0
        else:
                tally_vec[pos_idx][AA_idx][1] += mcl1
                tally_vec[pos_idx][AA_idx][3] += 1.0
            
    for i in range(10):
        for j in range(18):
        if tally_vec[i][j][2] > 0.0: SPOT_vec[i][j][0] = -1.0 * (math.log10(tally_vec[i][j][0] / tally_vec[i][j][2]))
        if tally_vec[i][j][3] > 0.0: SPOT_vec[i][j][1] = -1.0 * (math.log10(tally_vec[i][j][1] / tally_vec[i][j][3]))
        
        if SPOT_vec[i][j][0] == 0.0: SPOT_vec[i][j][0] = max(0.0, SPOT200_vec[i][j][0])
        if SPOT_vec[i][j][1] == 0.0: SPOT_vec[i][j][1] = max(0.0, SPOT200_vec[i][j][1])
        
    SPOT_vec[pos_dict['4a']][AA_dict['I']][0] = SPOT_vec[pos_dict['4a']][AA_dict['V']][0]
    SPOT_vec[pos_dict['4a']][AA_dict['I']][1] = SPOT_vec[pos_dict['4a']][AA_dict['V']][1]
            
    return SPOT_vec

def submit_design(preset_dir, pdb_path, seqdata_path, param_path, submit_dir):
    
    if not os.path.exists(submit_dir): os.mkdir(submit_dir)
    
    for i in range(75):
    script_path = os.path.join(submit_dir, 'design_' + str(i + 1) + '.sh')
    out_path = os.path.join(submit_dir, 'design_' + str(i + 1) + '.txt')
    
    script_line = '/home/secoops/web/build.py -bayes_preset ' + preset_dir + ' ' + pdb_path + ' ' + seqdata_path + ' ' + param_path + ' ' + out_path
    script_file = open(script_path, 'w')
    script_file.write(script_line)
    script_file.close()
    
    os.system('chmod u+x ' + script_path)
    submit_sge_job(script_path, 'secoops', 200, 10, 100)


def salt_bridge(aa0, aa1):
    
    if (AAChar_fasta(aa0) == 'E' and AAChar_fasta(aa1) == 'R') or (AAChar_fasta(aa0) == 'E' and AAChar_fasta(aa1) == 'K') or (AAChar_fasta(aa0) == 'D' and AAChar_fasta(aa1) == 'R') or (AAChar_fasta(aa0) == 'D' and AAChar_fasta(aa1) == 'K') or (AAChar_fasta(aa0) == 'K' and AAChar_fasta(aa1) == 'E') or (AAChar_fasta(aa0) == 'K' and AAChar_fasta(aa1) == 'D') or (AAChar_fasta(aa0) == 'R' and AAChar_fasta(aa1) == 'E') or (AAChar_fasta(aa0) == 'R' and AAChar_fasta(aa1) == 'D'): return True
    else: return False

def charge_pair(aa0, aa1):
    
    if (AAChar_fasta(aa0) == 'E' and AAChar_fasta(aa1) == 'D') or (AAChar_fasta(aa0) == 'E' and AAChar_fasta(aa1) == 'E') or (AAChar_fasta(aa0) == 'D' and AAChar_fasta(aa1) == 'D') or (AAChar_fasta(aa0) == 'D' and AAChar_fasta(aa1) == 'E') or (AAChar_fasta(aa0) == 'K' and AAChar_fasta(aa1) == 'R') or (AAChar_fasta(aa0) == 'R' and AAChar_fasta(aa1) == 'K') or (AAChar_fasta(aa0) == 'K' and AAChar_fasta(aa1) == 'K') or (AAChar_fasta(aa0) == 'R' and AAChar_fasta(aa1) == 'R'): return True
    else: return False
        
def plot_helix():

    lines = readlines('/home/secoops/web/Hpos_probs.txt')
    
    vals = []
    for i in range(20):
    vals.append([])
    for j in range(12): vals[i].append(0.0)
    
    for i in range(len(lines) - 1):
    items = lines[i + 1].split()
    print items
    for j in range(20):
        print float(items[j + 1])
        vals[j][i] = float(items[j + 1])
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.xticks(pylab.arange(12), ['N-1', 'N0', 'N+1', 'N+2', 'N+3', 'N+4', 'C-4', 'C-3', 'C-2', 'C-1', 'C0', 'C+1'])
    pylab.xlabel('Helix position', fontsize=20)
    pylab.ylabel('Preference', fontsize=20)
        
    for i in range(20):
    if AAChar_fasta(i) in ['R', 'E', 'D', 'K']:
        pylab.plot(pylab.arange(12), pylab.array(vals[i]), lw=2, label=AAChar_fasta(i))
        
    pylab.legend()
    
    pylab.savefig('/home/secoops/web/HHpos_charge.png')
    pylab.close()
    
def plot_helix2():

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.xticks(pylab.arange(20), ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'])
    pylab.yticks(pylab.arange(20), ['A', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'K', 'L', 'M', 'N', 'P', 'Q', 'R', 'S', 'T', 'V', 'W', 'Y'])
    #pylab.xlabel('Helix position', fontsize=20)
    #pylab.ylabel('AA', fontsize=20)
        
    pylab.contourf(pylab.load('/home/secoops/web/TT_doublet_probs.txt'))
    
    pylab.savefig('/home/secoops/web/TT.png')
    pylab.close()
    
def casp_search():
    
    seqdata_dir = '/home/secoops/web/PDB/seqdata_90'
    seqdata_list = os.listdir(seqdata_dir)
    pdb_dir = '/home/secoops/web/PDB/culled_90'
    
    for file in seqdata_list:
    name = file.split('.')[0]
    seqdata_path = os.path.join(seqdata_dir, file)
    pdb_path = os.path.join(pdb_dir, name + '.pdb')
        try: lib_pdbinfo_vec = pdb_info(pdb_path, seqdata_path)
    except: continue
    
    libN = len(lib_pdbinfo_vec)
        lib_ss_vec = []
        for i in range(libN):
        if lib_pdbinfo_vec[i][4] == 'H': lib_ss_vec.append('H')
        elif lib_pdbinfo_vec[i][4] == 'E': lib_ss_vec.append('E')
        else: lib_ss_vec.append('C')
    
    start_pos = 0
    final_pos = 0
    Ecount = 0
        lib_cont_vec = []
        lib_cont_vec.append(0)
        for i in range(1, libN):
        if lib_ss_vec[i] != lib_ss_vec[i - 1]:
        lib_cont_vec.append(lib_cont_vec[-1] + 1)
        if lib_ss_vec[i] == 'E':
            Ecount += 1
            if Ecount == 1: start_pos = i
        elif lib_ss_vec[i] == 'H':
            if Ecount > 3:
            final_pos = i
            break
            Ecount = 0
        else: lib_cont_vec.append(lib_cont_vec[-1])
    if Ecount > 3: final_pos = i
        
    if Ecount < 4: continue
    
    ccount = 0
    hcount = 0
    cvec = []
    hvec = []
    for i in range(len(lib_pdbinfo_vec)):
        if AAChar_fasta(lib_pdbinfo_vec[i][1]) == 'C' and i >= start_pos and i <= final_pos:
            ccount += 1
        cvec.append(i)
        if AAChar_fasta(lib_pdbinfo_vec[i][1]) == 'H' and i >= start_pos and i <= final_pos:
        hcount += 1
        hvec.append(i)
    if hcount < 2 or ccount < 2: continue
        
        template_distance_matrix = distance_matrixCB(lib_pdbinfo_vec)
    
    hasE = False
    for i in range(len(lib_pdbinfo_vec)):
        if lib_pdbinfo_vec[i][4] == 'E':
        hasE = True
        break
    if not hasE: continue
    
    bvec = []
    for i in range(len(cvec)):
        for j in range(len(hvec)):
        if template_distance_matrix[cvec[i]][hvec[j]] < 8.0:
           bvec.append([cvec[i], hvec[j]])
           
    done = False
    if len(bvec) > 1:
        for i in range(len(bvec)):
        for j in range(i + 1, len(bvec)):
            if bvec[j][0] - bvec[i][0] == 3 and bvec[i][1] < bvec[j][0] and bvec[j][1] < bvec[j][0] and bvec[i][1] < bvec[i][0] and bvec[j][1] < bvec[i][0] and bvec[i][0] == bvec[j][1] + 1 and bvec[j][1] - bvec[i][1] < 40 and bvec[j][1] - bvec[i][1] > 20:
                if template_distance_matrix[bvec[i][0]][bvec[j][0]] < 8.0 and template_distance_matrix[bvec[i][1]][bvec[j][1]] < 8.0:
                done = True
                print pdb_path
                break
            if done: break
        
def run_refine(rand_label):
    
    home_dir = '/home/secoops/web'
    cfgdir = os.path.join('/home/secoops/web/REFINE_CFG', rand_label)
    lib_dir = '/home/secoops/web/haipeng/clOOPS/bin'
    model_dir = '/home/secoops/web/REFINE_MODELS'
    in_dir = '/home/secoops/web/haipeng/refine/in'
    model_path = os.path.join(model_dir, rand_label + '.pdb')
    in_path = os.path.join(in_dir, rand_label + '.pdb')
    traj_path = os.path.join('/home/secoops/web/haipeng/refine/trj', rand_label + '.pdt')
    iolibdir = os.path.join(lib_dir, 'io')
    refin_path = '/home/secoops/web/REFINE_REF/' + rand_label + '.pdb'
    refout_path = '/home/secoops/web/haipeng/refine/ref/' + rand_label + '_ref.pdb'
    secseq_path = '/home/secoops/web/haipeng/refine/ssq/' + rand_label + '.secseq'
    
    os.chdir(lib_dir)
    os.system(os.path.join(lib_dir, 'sconv ') + model_path + ' ' + in_path + ' -in ' + os.path.join(iolibdir, 'libPDBread.so') + ' -out ' + os.path.join(iolibdir, 'libPDBwrite.so') + ' -tHET -H')
    
    ssq = get_refine_ssq(in_path)
    secseq_file = open(secseq_path, 'w')
    secseq_file.write(ssq)
    secseq_file.close()
    
    if os.path.exists(refin_path): os.system('cp ' + refin_path + ' ' + refout_path)
    else: os.system('cp ' + in_path + ' ' + refout_path)
    os.chdir(home_dir)
    
    sdir = '/home/secoops/web/REFINE_LOGS_top/' + rand_label
    if not os.path.exists(sdir): os.mkdir(sdir)
    
    for stage in range(1, 4):
        print 'Stage: ' + str(stage) + '... of ' + rand_label
    
    ssubdir = os.path.join(sdir, str(stage))
    if not os.path.exists(ssubdir): os.mkdir(ssubdir)
    os.chdir(ssubdir)
        
        stage_dict = {1: '1', 2: '4', 3: '6'}
        flag_dict = {1: '-sCB', 2: '-sCB', 3: ''}
        cmd = 'cd ' + lib_dir + '\n' + os.path.join(lib_dir, 'oops') + ' -c ' + os.path.join(cfgdir, 'refineFold' + stage_dict[stage] + '.cfg') + ' -i ' + in_path + ' -o ' + traj_path + ' -max 1000 -brk -rSC -sSC ' + flag_dict[stage] + ' -aH -sH -n 20 -s 0'
        file = open(rand_label, 'w')
        file.write(cmd + '\n')
        file.close()
    
        os.system('chmod u+x ' + rand_label)
        os.system('qsub -cwd ' + rand_label)
        
        time.sleep(60)
        while(check_refinejob_status(rand_label)):
            time.sleep(60)
    
        FinalStructure(traj_path, in_path)
    os.remove(traj_path)
    
        print 'Stage: ' + str(stage) + ' finished'
    update_refine_page(rand_label, stage)
    
def check_refinejob_status(job_num):
    
        qtmp = tempfile.mktemp('.txt')
    os.system('qstat | grep ' + job_num + ' > ' + qtmp)
    lines = readlines(qtmp)
    os.remove(qtmp)
        if len(lines) > 0:
            return True
        else:
            return False
    
#def update_refine_job_status():
    
    #job_dir = '/home/secoops/web/REFINE_CURRENT_JOB'
    #job_list = os.listdir(job_dir)
    
    #for job in job_list:
    #job_path = os.path.join(job_dir, job)
    #job_lines = readlines(job_path)
    #for line in job_lines:
        #items = line.strip()
        #if items[0] == 'job_type': ed = True
        #else ed = False
        
    #table_length = 3
    #if (ed): table_length = 4
        
        #table = []
    #table += [['Stage', 'job status', 'Status']]
    #table += [['TOP1', 'not submitted', 'incomplete']]
    #table += [['TOP2', 'not submitted', 'incomplete']]
    #table += [['TOP3', 'not submitted', 'incomplete']]
    #if (ed): table += [['Density Minimization', 'Stage', 'incomplete']]
    
        
        #job_id = job.split('.')[0]
    #web_dir = '/var/www/refine/' + job_id
    #html_path = os.path.join(web_dir, job_id + '.html')
    #for i in range(3):
        #stage = i + 1
        #stage_html_path = os.path.join(os.path.join(web_dir, stage), job_id + '.html')
        #stage_complete = False
        #if os.path.exists(stage_html_path):
        #stage_lines = readlines(stage_html_path)
        #for stage_line in stage_lines:
            #stage_items = stage_line.split()
            #if len(stage_items) > 0:
            #if stage_items[0] == '<table':
                #stage_complete = True
                #break
            
        #if (stage_compete): table[stage][1] = 'COMPLETE'
                
        

def get_refine_ssq(pdb_path):
    
    temp_path = tempfile.mktemp('.dssp')
    os.system('/home/secoops/web/haipeng/refine/pdb/dsspcmbi ' + pdb_path + ' > ' + temp_path)
    dssp_output_file = open(temp_path, 'r')
    
    native_dssp = ''
    start_reading = 'no'
    found_index = 'no'
    SecStr_string = 'HESTBG'
    subunit_string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    line = dssp_output_file.readline()
    index = 3
    while line:
        line = line.strip()
    line = line.split()
    if start_reading == 'yes':
        if found_index == 'no':
        line_2 = 'no'
        line_3 = 'no'
            for i in range(len(subunit_string)):
            if line[2] == subunit_string[i]:
            line_2 = 'yes'
        for i in range(len(subunit_string)):
            if line[3] == subunit_string[i]:
            line_3 = 'yes'
        if line_2 == 'yes' and line_3 == 'yes':
            index = 4
        found_index = 'yes'
        found_a_SecStr = 'no'
        for i in range(len(SecStr_string)):
            if line[index] == SecStr_string[i]:
            SecStr_char = SecStr_string[i]
            found_a_SecStr = 'yes'
            if found_a_SecStr == 'no': 
                SecStr_char = 'N'
        native_dssp = native_dssp + SecStr_char
    if line[0] == '#' and line[1] == 'RESIDUE':
        start_reading = 'yes'
    line = dssp_output_file.readline()

    dssp = ''
    for i in range(len(native_dssp)):
    if native_dssp[i] == 'H' or native_dssp[i] == 'E': dssp += native_dssp[i]
    else: dssp += 'A'
    
    dssp_output_file.close()
    os.remove(temp_path)
    return dssp

def coil_orient():

    data_dir = '/home/secoops/web/PDB/seqdata_90'
    data_list = os.listdir(data_dir)

    for file in data_list:
        if not file[-5] == 'A': continue
        B_path = os.path.join(data_dir, file[0:5] + 'B.seq')
    if not os.path.exists(B_path): continue
        A_path = os.path.join(data_dir, file)
    chain_ex = 'CDEFGHIJKLMNOPQRSTUVWXYZ0123456789'
    other_chains = False
    for i in range(len(chain_ex)):
        #print os.path.join(data_dir, file[0:5] + chain_ex[i] + '.seq')
        if os.path.exists(os.path.join(data_dir, file[0:5] + chain_ex[i] + '.seq')):
            other_chains = True
    if other_chains: continue
        A_lines = readlines(A_path)
    B_lines = readlines(B_path)
        AL = 0
    AH = 0
    Abreaks = False
    for i in range(len(A_lines)):
        if len(A_lines[i].split()) > 3:
            AL += 1
        if A_lines[i].split()[7] == 'H': AH += 1
        else: Abreaks = True
    if AL > 50 or ((float(AH) / float(AL)) < 0.85): continue
        BL = 0
    BH = 0
    Bbreaks = False
    for i in range(len(B_lines)):
        if len(B_lines[i].split()) > 3:
            BL += 1
        if B_lines[i].split()[7] == 'H': BH += 1
        else: Bbreaks = True
    if BL > 50 or ((float(BH) / float(BL)) < 0.85): continue
        print file

#def modeller_format_ali(thread_sequence, template_sequence, out_path):

    #name = os.path.split(out_path)[1].split('.')[0]
    
    #L = str(len(thread_sequence))
 
    #dashes_seq = ''
    #for i in range(len(template_sequence)):
        #if i % 75 == 0: dashes_seq += '\n'
        #dashes_seq += template_sequence[i]  
    
    #dashes_thread = ''
    #for i in range(len(thread_sequence)):
        #if i % 75 == 0: dashes_thread += '\n'
        #dashes_thread += thread_sequence[i] 

    #out_file = open(out_path, 'w')
    #out_file.write('\n>P1;template\nstructureX:template:   1 :A:+' + L + ' :A:undefined:undefined:-1.00:-1.00' + dashes_seq + '*\n\n>P1;thread\nsequence:thread:     : :     : ::: 0.00: 0.00' + dashes_thread + '*\n')
    #out_file.close()
    
def insert(old, new, pos):
    '''Inserts new inside original at pos.'''
    return old[:pos] + new + old[pos:]
    
def modeller_format_ali(thread_sequence, template_sequence, out_path):

    name = os.path.split(out_path)[1].split('.')[0]

    out_file = open(out_path, 'w')
    out_file.write('\n>P1;template\nstructure:template:FIRST:@ END::::::\n' + template_sequence + '*\n\n>P1;thread\nsequence:thread::::::::\n' + thread_sequence + '*\n')
    out_file.close()

def modeller_automodel(thread_seq, pdb_path, out_path, break_pos):

    tmp_dir = coyote_temp('dir')
    template_path = os.path.join(tmp_dir, 'template.pdb')
    os.system('cp ' + pdb_path + ' ' + template_path)

    write_file(thread_seq, os.path.join(tmp_dir, 'thread.fasta'))

    template_seq = FASTA_from_structure(pdb_path)
    
    tseq = ''
    for i in range(len(thread_seq)):
        tseq += template_seq[i]
    template_seq = tseq
    
    if len(template_seq) != len(thread_seq):
        print 'ERROR: Length of sequence and template do not match!'
    return
    
    if break_pos >= 0:
        thread_seq = insert(thread_seq, '/', break_pos)
        template_seq = insert(template_seq, '/', break_pos)
    modeller_format_ali(thread_seq, template_seq, os.path.join(tmp_dir, 'template-thread.ali'))

    py_path = os.path.join(tmp_dir, 'model-thread.py')
    write_file('#!/usr/bin/python\n\nfrom modeller import *\nfrom modeller.automodel import *\nlog.verbose()\nenv = environ()\na = automodel(env, alnfile  = \'template-thread.ali\', knowns   = \'template\', sequence =\'thread\')\na.starting_model= 1\na.ending_model  = 1\n\na.make()', py_path)
    os.system('chmod u+x ' + py_path)

    currdir = os.getcwd()
    os.chdir(tmp_dir)

    os.system('/home/bartolo/bin/modeller9v8/bin/mod9v8 model-thread.py')
    os.chdir(currdir)

    os.system('cp ' + os.path.join(tmp_dir, 'thread.B99990001.pdb') + ' ' + out_path)

    ClearDirectory(tmp_dir)
    os.rmdir(tmp_dir)   

def write_file(contents_str, file_path):
    out_file = open(file_path, 'w')
    out_file.write(contents_str)
    out_file.close()
    
def sequence_entropy(in_path):
  
    lines = readlines(in_path)
    L = len(lines[0])
    types = []
    counts = []
    for i in range(L):
        types.append([])
        counts.append([])
    for line in lines:
         for i in range(L):
         if not line[i] in types[i]:
             types[i].append(line[i])
             counts[i].append(1)
         else:
             counts[i][types[i].index(line[i])] += 1
             
    totals = []
    for i in range(L):
        tot = 0
        for j in range(len(counts[i])):
        tot += counts[i][j]
    totals.append(tot)
    
    plogp = []
    for i in range(L):
        plogp.append(0.0)
        for j in range(len(counts[i])):
        if totals[i] > 0.0:
            P = float(counts[i][j]) / float(totals[i])
            plogp[i] += (-1.0 * P * math.log(P))
            
    #print i + 1, plogp[i]
    print i + 1, len(types[i])
        
def bcl2_entropy_plots(path1, path2):


    l1 = readlines(path1)
    l2 = readlines(path2)
    
    N = len(l1)
    v1 = []
    v2 = []
    for i in range(N):
        v1.append(float(l1[i].split()[1]))
        v2.append(float(l2[i].split()[1]))
        
    import matplotlib
    matplotlib.use( 'Agg' )
        
    import pylab
    
    a1 = pylab.array(v1)
    a2 = pylab.array(v2)
    

    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.bar(pylab.arange(N), a1, color='b', edgecolor='b', align='center', linewidth=0, width=0.7, alpha=0.4)
    pylab.bar(pylab.arange(N), a2, color='r',edgecolor='r', width=0.25, align='center')
    pylab.ylim(0.0, 12.0)
    pylab.xlim(-1, 23)
    pylab.xticks([])
    pylab.xticks(pylab.arange(23), ['', '\na', '\nb', '\nc', '\nd', '\ne', '\nf', '\ng', '\na', '\nb', '\nc', '\nd', '\ne', '\nf', '\ng', '\na', '\nb', '\nc', '\nd', '\ne', '\nf', '\ng', ''])
    #pylab.xlabel('position in sequence', fontsize=20)
    #pylab.ylabel('change in TSP3', fontsize=20)
    #pylab.title('Change in TSP3 by position', fontsize=20)
    pylab.savefig('/home/bartolo/web/statium/data/plots/entropy.png')
    pylab.close()
    
def parse_pfam(fpath, opath):
  
    upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lower = 'abcdefghijklmnopqrstuvwxyz'
  
    ofile = open(opath, 'w')
    lines = readlines(fpath)
    for line in lines:
        items = line.split()
        item0 = items[0].split('_')
        if len(item0) > 1:
        if item0[1][0:5] == 'CHICK' or item0[1][0:5] == 'HUMAN':
            #ofile.write(item0[0] + '\n')
            ofile.write(item0[1][0:5] + '\t')
            seq = ''
            mseq = items[-1]
            for i in range(len(mseq)):
                seq += mseq[i]
                #seq += upper[lower.index(mseq[i])]
            ofile.write(seq + '\n')
        
    ofile.close()
    
def search_pfam(fpath, opath):
  
    upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lower = 'abcdefghijklmnopqrstuvwxyz'
  
    ofile = open(opath, 'w')
    lines = readlines(fpath)
    for line in lines:
        items = line.split()
        item0 = items[0].split('_')
        if len(item0) > 1:
        if item0[1][0:5] == 'HUMAN':
            ofile.write(item0[0] + '\t')
            seq = ''
            mseq = items[-1]
            for i in range(len(mseq)):
                if mseq[i] in upper: seq += mseq[i]
                elif mseq[i] in lower: seq += upper[lower.index(mseq[i])]
                else: seq += mseq[i]
            ofile.write(seq + '\n')
        
    ofile.close()
    
def sort_pfam(ipath, name, out_path):
  
    upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    lower = 'abcdefghijklmnopqrstuvwxyz'
    
    items = lines2list(ipath)
    
    for i in range(len(items)):
        if items[i][0] == name: ref_seq = items[i][1]
        
    parsed = []
    for i in range(len(items)):
        seq = items[i][1]
        clean_seq = ''
        for j in range(len(seq)):
        if seq[j] in upper or seq[j] in lower:
            if seq[j] in upper: clean_seq += seq[j]
            elif seq[j] in lower: clean_seq += upper[lower.index(seq[j])]
        else:
            if seq[j] == '.' or seq[j] == '-': clean_seq += '-'
            else:
            print 'failure'
            return
    if items[i][0] == name: ref_seq = clean_seq
    parsed.append([items[i][0], clean_seq])
    
    out = []
    for i in range(len(parsed)):
        out_seq = ''
        for j in range(len(ref_seq)):
        if ref_seq[j] != '-': out_seq += parsed[i][1][j]
    out.append([parsed[i][0], out_seq])
    
    of = open(out_path, 'w')
    for i in range(len(out)):
        of.write(out[i][0] + '\t------' + out[i][1] + '----\n')
    of.close()
    
def CARD_dimers():
  
    apaf = lines2list('/home/bartolo/web/DED/CARD_HUMAN_APAF.txt')
    casp9 = lines2list('/home/bartolo/web/DED/CARD_HUMAN_CASP9.txt')
    
    of = open('/home/bartolo/web/DED/CARD_HUMAN_APAFCASP9_DIMERS.txt', 'w')
    for i in range(len(apaf)):
        for j in range(len(casp9)):
        of.write(apaf[i][0] + '_' + casp9[j][0] + '\t' + apaf[i][1] + casp9[j][1] + '\n')
    of.close()
        
def find_BH3(in_path, out_path):
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    seq_lines = readlines(seq_path)
    
    BH3 = [[],[],[],[]]
    lines = readlines(in_path)
    for line in lines:
        seq = line.split()[0]
        BH3[0].append(seq)
        BH3[1].append('')
        
        name = ''
        start = line.find('|') + 1
        for i in range(start, len(line)): name += line[i]
        BH3[2].append(name.strip())
        #sname = ''
        #start = line.index(line.split()[5])
        #end = line.index(':::::') - 1
        #for i in range(start, end): sname += line[i]
        #BH3[3].append(sname.strip())
        #print sname.strip()
       
    count = 0
    out = []
    L = len(BH3[0][0])    
    sc = 0
    for prot in seq_lines:
        sc += 1
        cont = True
        for name in BH3[2]:
        if seq_lines[sc - 2].strip().find(name) > -1: cont = False
        if cont: continue
        #else: print seq_lines[sc - 2].strip()
    if len(prot) > L: 
        for i in range(len(prot) - L):
        comp = ''
            for j in range(L):
            comp += prot[i + j]
        if comp in BH3[0] and BH3[1][BH3[0].index(comp)] == '':
            count += 1
            #print count
            out_seq = ''
            for j in range(L + 3): out_seq += prot[i - 2 + j]
            BH3[1][BH3[0].index(comp)] = out_seq
            
    of = open(out_path, 'w')
    for i in range(len(lines)):
        print BH3[0][i] + '\t' + BH3[1][i] + '\t' + BH3[2][i]
        of.write(BH3[1][i] + '\t' + BH3[2][i] + '\n')
    of.close()
    
def unsampled_yeast():
  
    all_path = '/home/bartolo/web/statium/deepseq/nonredundant/after_express/all.txt'
    stat = lines2list('/home/bartolo/web/statium/data/yeast_full_lib_energy.txt')
    pssm = lines2list('/home/bartolo/web/statium/data/yeast_full_lib_pssm.txt')
    alls = readlines(all_path)
    
    pres = []
    for i in range(len(alls)): pres.append(alls[i].strip())
    
    stats = sorted(stat, key=lambda energy: energy[1])
    pssms = sorted(pssm, key=lambda energy: energy[1])
    
    topl = 500
    stats_top = []
    se = []
    for i in range(topl):
        stats_top.append(stats[i][0])
        se.append(stats[i][1])
    pssms_top = []
    pe = []
    for i in range(topl):
        pssms_top.append(pssms[i][0])
    pe.append(pssms[i][1])
    
    chosen = []
    
    for i in range(topl):
        if not pssms_top[i] in pres: 
        chosen.append(pssms_top[i])
        print pssms_top[i]
        

def yeast_full_spec(i):

    data = lines2list(i)
    L = len(data)
    for i in range(L):
        if data[i][1] < -0.0 and data[i][2] > 10.0:
        print data[i][0]
#, data[i][1], data[i][2]

def trim_dssp(pdb_path, opath):

    currdir = os.getcwd()
    os.chdir('/home/bartolo/')
    t = tempfile.mktemp('.txt')
    os.system('./dssp ' + pdb_path + ' > ' + t)
    os.chdir(currdir)

    ofile = open(opath, 'w')
    lines = readlines(t)
    started = 0
    prev_num = 100000
    for line in lines:
        if started:
            num = line[5:10]
            chain = line[11:12]
            aa = line[13:14]
            ss = line[16:17]
            ins = line[10:11]
            asa = line[35:38]

            if num.strip():
                if int(prev_num) + 1 < int(num):
                    ofile.write('BREAK\n')

                if not(ins.strip()):
                    if ss == ' ':
                        ss = '-'
                    ofile.write(num + '\t' + chain + '\t' + aa + '\t' + ss + '\t' + asa + '\n')
                chain_break = 0

                prev_num = int(num)
        else:
            if (line.split()[0].strip()[0] == '#'):
                started = 1

    ofile.close()
    os.remove(t)
    
def bcl2_deep_sequencing(i, o, r):

    if r in 'xm':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 8, 9, 11, 13, 15]
        aas = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    if r in 'w2':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 7, 8, 9, 11, 12, 14]
        aas = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    if r in 'f':
        wt = 'PEIWIAQELRRIGDEFNAYYARR'
        L = len(wt)
        idxs = [4, 5, 7, 8, 11, 14, 15]
        aas = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']

    iseqs = lines2list(i)
    seqs = []
    
    count = 0
    for l in iseqs:
        count += 1
        if count % 1000 == 0: print 100.0 * (float(count) / float(len(iseqs))), len(seqs), seqs[-1]
        seqv = []
        for i in range(L): seqv.append(wt[i])
        for i in range(len(l[0])): seqv[idxs[i]] = l[0][i]
        
        seq = ''
        for i in range(L): seq += seqv[i]
        
        if not seq in seqs: seqs.append(seq)
        
    of = open(o, 'w')
    for seq in seqs: of.write(seq + '\n')
    of.close()
    
def deep_roc(n, m, x):
  
    nl = lines2list(n)
    ml = readlines(m)
    xl = readlines(x)
    
    mspex = []
    for line in ml: msplex.append(line.strip())
    spex = []
    for line in xl: xsplex.append(line.strip())
    
   # nbv = 
    #for line in nl:
    
def bcl2_deep_search(ipath, idir):

    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    idxs = [4, 8, 9, 11, 13, 15]
    names = ['2d', '3a', '3b', '3d', '3f', '4a']
    
    dirl = os.listdir(idir)
    
    spec_lines = readlines(ipath)
    
    finds = [[], []]
    
    for f in dirl:
        fpath = os.path.join(idir, f)
        deep_lines = readlines(fpath)
        for seq in spec_lines:
        if seq in deep_lines:
            if seq in finds[0]: finds[1][finds[0].index(seq)].append(f)
            else:
            finds[0].append(seq)
            finds[1].append([f])
    
    xspex = 0
    mspex = 0
    for i in range(len(finds[0])):
        select = 0
        mselect = 0
        xselect = 0
        for j in range(len(finds[1][i])):
        if len(finds[1][i][j].split('_')) > 1:
            if finds[1][i][j][0] == 'm': mselect += 1
            if finds[1][i][j][0] == 'x': xselect += 1
            if finds[1][i][j].split('_')[0] != 'total': select += 1
        valid = 0
        valid += len(finds[1][i])
        if 'total_naive.txt' in finds[1][i]: valid -= 1
        if 'expressing.txt' in finds[1][i]: valid -= 1
        if valid < 2 or select < 1 or (mselect > 0 and xselect > 0): continue
        print finds[0][i],
        for j in range(len(finds[1][i])): print finds[1][i][j]
        print
        if mselect > 1 and xselect == 0: mspex += 1
        if xselect > 1 and mselect == 0: xspex += 1
    print 'x', xspex, 'm', mspex
    
def deep_spec_search(mpath, xpath):
  
    bclxl = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/xs4_mn1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/xs4_mn2.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/xs4_mn3.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/xs4_mn3_xs1.txt')]
    mcl1 = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/ms4_xn1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/ms4_xn2.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/ms4_xn3.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/ms4_xn3_ms1.txt')]
    
    xspex0 = []
    for seq in bclxl[0]:
        count = 0
        for i in range(len(bclxl)):
        if seq in bclxl[i]: count += 1
    if count == len(bclxl): xspex0.append(seq.strip())
    
    mspex0 = []
    for seq in mcl1[0]:
        count = 0
        for i in range(len(mcl1)):
        if seq in mcl1[i]: count += 1
    if count == len(mcl1): mspex0.append(seq.strip())
    
    xf = open(xpath, 'w')
    for seq in xspex0:
        if not seq in mspex0: xf.write(seq + '\n')
    xf.close()
    
    mf = open(mpath, 'w')
    for seq in mspex0:
        if not seq in xspex0: mf.write(seq + '\n')
    mf.close()
    
def deep_affin_search(mpath, xpath):
  
    bclxl = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs2.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs3.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs4.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs5.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/xs6.txt')]
    mcl1 = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/ms1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/ms4.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/ms5.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/allowed/ms6.txt')]
    xspex0 = []
    for seq in bclxl[0]:
        count = 0
        for i in range(len(bclxl)):
        if seq in bclxl[i]: count += 1
    if count == len(bclxl): xspex0.append(seq.strip())
    
    mspex0 = []
    for seq in mcl1[0]:
        count = 0
        for i in range(len(mcl1)):
        if seq in mcl1[i]: count += 1
    if count == len(mcl1): mspex0.append(seq.strip())
    
    xf = open(xpath, 'w')
    for seq in xspex0:
        if not seq in mspex0: xf.write(seq + '\n')
    xf.close()
    
    mf = open(mpath, 'w')
    for seq in mspex0:
        if not seq in xspex0: mf.write(seq + '\n')
    mf.close()
    
def deep_forbid_spec_search(mpath, xpath):
  
    bclxl = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/xs4_mn1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/xs4_mn2.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/xs4_mn3.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/xs4_mn3_xs1.txt')]
    mcl1 = [readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/ms4_xn1.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/ms4_xn2.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/ms4_xn3.txt'), readlines('/home/bartolo/web/statium/deepseq/nonredundant/notallowed/ms4_xn3_ms1.txt')]
    
    xspex0 = []
    for seq in bclxl[0]:
        count = 0
        for i in range(len(bclxl)):
        if seq in bclxl[i]: count += 1
    if count == len(bclxl): xspex0.append(seq.strip())
    
    mspex0 = []
    for seq in mcl1[0]:
        count = 0
        for i in range(len(mcl1)):
        if seq in mcl1[i]: count += 1
    if count == len(mcl1): mspex0.append(seq.strip())
    
    xf = open(xpath, 'w')
    for seq in xspex0:
        if not seq in mspex0: xf.write(seq + '\n')
    xf.close()
    
    mf = open(mpath, 'w')
    for seq in mspex0:
        if not seq in xspex0: mf.write(seq + '\n')
    mf.close()
    
def find_forbidden(stat, pssm):
  
    statl = lines2list(stat)
    pssml = lines2list(pssm)
    L = len(statl)
    
    for i in range(L):
        #print statl[0], pssml[2], pssml[1] - pssml[2]
        if statl[i][1] < 40.0 and (statl[i][1] - statl[i][2]) < -20.0: print statl[i][0], pssml[i][1], pssml[i][1] - pssml[i][2]
    
def general_trim_dssp(tools_path, pdb_path, opath):

    currdir = os.getcwd()
    os.chdir(tools_path)
    t = tempfile.mktemp('.txt')
    os.system('./dssp ' + pdb_path + ' > ' + t)
    os.chdir(currdir)

    ofile = open(opath, 'w')
    lines = readlines(t)
    started = 0
    prev_num = 100000
    for line in lines:
        if started:
            num = line[5:10]
            chain = line[11:12]
            if chain == ' ': chain = 'A'
            aa = line[13:14]
            ss = line[16:17]
            ins = line[10:11]
            asa = line[35:38]

            if num.strip():
                if int(prev_num) + 1 < int(num):
                    ofile.write('BREAK\n')

                if not(ins.strip()):
                    if ss == ' ':
                        ss = '-'
                    ofile.write(num + '\t' + chain + '\t' + aa + '\t' + ss + '\t' + asa + '\n')
                chain_break = 0

                prev_num = int(num)
        else:
            if (line.split()[0].strip()[0] == '#'):
                started = 1

    ofile.close()
    os.remove(t)
    
def coil_pdb(idir, odir):
  
    if not os.path.exists(odir): os.mkdir(odir)
    pdb_list = os.listdir(idir)
    for pdb in pdb_list:
        pdb_path = os.path.join(idir, pdb)
        seq_path = os.path.join(odir, pdb.split('.')[0] + '.seq')
        trim_dssp(pdb_path, seq_path)
        
def kink_angle(p1, p2, p3, pdb_path):
  
    c1 = [0.0, 0.0, 0.0]
    c2 = [0.0, 0.0, 0.0]
    c3 = [0.0, 0.0, 0.0]
    done = False
    lines = readlines(pdb_path)
    for line in lines:
        if line[0:4] == 'ATOM':
        if line[13:15] == 'CA':
        p = int(line[22:28].strip())
        if p == p1: c1 = [float(line[30:38]), float(line[39:46]), float(line[47:54])]
        if p == p2: c2 = [float(line[30:38]), float(line[39:46]), float(line[47:54])]
        if p == p3: c3 = [float(line[30:38]), float(line[39:46]), float(line[47:54])]
    if c1 != [0.0, 0.0, 0.0] and c2 != [0.0, 0.0, 0.0] and c3 != [0.0, 0.0, 0.0]:
        done = True
        break
        
    if done:
        return vector_angle([c2, c1], [c2, c3])
    else: return -1
        
def Phelix():
  
    seqdata = os.listdir('/home/bartolo/web/PDB/seqdata_90')
    pdbdir = '/home/bartolo/web/PDB/culled_90'
    
    Pv = []
    NPv = []
    for seqd in seqdata:
        sp = os.path.join('/home/bartolo/web/PDB/seqdata_90', seqd)
        lines = readlines(sp)
        seq = ''
        ps = []
        for line in lines:
        items = line.split()
        if len(items) < 5: continue
        AA = AAConvertTS(items[2])
        pos = int(items[1])
        SS = items[7]
        if SS == 'H':
            seq += AA
            ps.append(pos)
        else:
            seq = ''
            ps = []
        pc = 0
        for i in range(len(seq)):
            if seq[i] == 'P': pc += 1
        if len(seq) == 19 and seq[9] != 'P' and pc == 0:
            pdb_path = os.path.join(pdbdir, seqd.split('.')[0] + '.pdb') 
            try: NPv.append(kink_angle(ps[0], ps[9] , ps[-1], pdb_path))
            except: print seqd, 'failed NP', seq
            seq = ''
        pc = 0
        for i in range(len(seq)):
            if seq[i] == 'P': pc += 1
        if len(seq) == 19 and seq[9] == 'P' and pc == 1:
            pdb_path = os.path.join(pdbdir, seqd.split('.')[0] + '.pdb') 
            try:
            Pv.append(kink_angle(ps[0], ps[9] , ps[-1], pdb_path))
            print pdb_path, kink_angle(ps[0], ps[9] , ps[-1], pdb_path)
            except: print seqd, 'failed P', seq
            seq = ''
            
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    Pa = pylab.array(Pv)
    NPa = pylab.array(NPv)
    
    pylab.hist(Pa, normed=1, facecolor='red', alpha=0.45)
    pylab.hist(NPa, normed=1, facecolor='blue', alpha=0.45)
    
    pylab.savefig('/home/bartolo/web/kink.png')
    pylab.close()
    
def PearsonFunction(r, n):
  
  from pylab import gamma
  from scipy import constants
  
  pi = constants.pi
  
  return (1.0 / math.sqrt(pi)) * (gamma((n + 1) / 2) / gamma((n) / 2)) * ((1 - r*r)**((n - 2) / 2))
  
#def pearsonP(r, n):
  
 #   from scipy import integrate
  #  print integrate.quad(PearsonFunction, -1.0 * r, r, args=(n))
  
def gamma_function(t, n):
  
    return (t ** (n - 1)) * math.exp(-1.0 * t)

def gamma(n):
  
    from scipy import integrate
    w = float('inf')

    print integrate.quad(gamma_function, 0, w, args=(n))[0]
    return integrate.quad(gamma_function, 0, w, args=(n))[0]
    
    
def pearsonP(r, n):
  
  import pylab
  from scipy import special
  from scipy import constants
  
  return (1.0 / math.sqrt(constants.pi)) * (gamma((n + 1.0) / 2.0) / gamma(n / 2.0)) * 2.0 * pylab.absolute(r) * special.hyp2f1(0.5, -1.0 * ((n - 2.0) / 2.0), 3.0/2.0, r*r)
  
def line_num(ifi, ofi):
  
  count = 0
  of = open(ofi, 'w')
  lines = readlines(ifi)
  for line in lines:
      count += 1
      try:
      int(line.split()[0])
      of.write(line)
      except: of.write(str(count) + '\t' + line)
  of.close()
  
def res_file(n1, n2, op):
  
    of = open(op, 'w')
    for i in range(int(n1), int(n2) + 1): of.write(str(i) + '\n')
    of.close()
  
def rink(ifi, ofi):

    of = open(ofi, 'w')
    lines = readlines(ifi)
    for line in lines:
        seq = line.strip()
        seq = seq + 'Z\n'
    of.write(seq)
    of.close()
    
def png_gif(ind, oud):
  
    in_list = os.listdir(ind)
    for file in in_list:
        in_path = os.path.join(ind, file)
        out_path = os.path.join(oud, file.split('.')[0] + '.gif')
        os.system('convert ' + in_path + ' ' + out_path)

def png_gif_single(in_path, out_path):
    os.system('convert ' + in_path + ' ' + out_path)
        
def Orr_align(pair_path, HKA_path, HK_path, RR_path):
  
    pairs = lines2list(pair_path)
    hkv = []
    rrv = []
    for i in range(len(pairs)):
        hkv.append(pairs[i][0])
        rrv.append(pairs[i][1])
    HKA = lines2list(HKA_path)
    HK = lines2list(HK_path)
    RR = lines2list(RR_path)
  
    Nloop = '-----'
    loop1 = '----------------------------------------------'
    loop2 = '------'
    Cloop = '-----'
    
    out_file = open('/home/bartolo/web/Orr/TCS.txt', 'w')
  
    for i in range(len(hkv)):
        for k in range(len(rrv)):
        
            HKi = hkv[i]
            RRi = rrv[k]
      
            found = False
            for j in range(len(HKA)):
            if HKA[j][0] == HKi:
                HKAj = HKA[j][1]
                found = True
                break
        if not found:
            print 'could not find HKA', HKi
            return
        
            found = False
            for j in range(len(HK)):
            if HK[j][0] == HKi:
                HKj = HK[j][1]
                found = True
                break
        if not found:
            print 'could not find HK', HKi
            return
        
            found = False
            for j in range(len(RR)):
            if RR[j][0] == RRi:
                RRj = RR[j][1]
                found = True
                break
        if not found:
            print 'could not find RR', RRi
            return
        
        
            out_file.write(HKi + '_' + RRi + '\t' + Nloop + HKAj + loop1 + HKj + loop2 + RRj + Cloop + '\n')
            
def stat_ref(n1, n2):
  
    out_file = open(n2, 'w')
    lines = readlines(n1)
    for line in lines:
        items = line.split()
        p1 = int(items[0])
        p2 = int(items[1])
        out_file.write(str(p1 - 244) + '\t' + str(p2 + 237) + '\n')
    out_file.close()
    
def kill_coyote():
  
    kill_path = '/home/bartolo/kill.txt'
    os.system('qstat | grep bartolo > ' + kill_path)
    lines = readlines(kill_path)
    for line in lines:
        os.system('qdel ' + line.split('.')[0])
        
def SPOT_correlation(op):
    
    spots = lines2list('/home/bartolo/web/statium/SPOT200_stat.txt')
    
    xv = []
    mv = []
    wv = []
    fv = []
    bv = []
    dv = []
    nv = []
    for i in range(len(spots)):
        xv.append(spots[i][2])
        mv.append(spots[i][3])
        wv.append(spots[i][4])
        fv.append(spots[i][5])
        bv.append(spots[i][6])
        dv.append(spots[i][7])
        nv.append(spots[i][8])
        
    import pylab
    xa = pylab.array(xv)
    ma = pylab.array(mv)
    wa = pylab.array(wv)
    fa = pylab.array(fv)
    ba = pylab.array(bv)
    da = pylab.array(dv)
    na = pylab.array(nv)
    
    spotsa = []
    spotsa.append(xa)
    spotsa.append(ba)
    spotsa.append(wa)
    spotsa.append(fa)
    spotsa.append(ma)
    spotsa.append(da)
    spotsa.append(na)
    
    of = open(op, 'w')
    for i in range(len(spotsa)):
        for j in range(len(spotsa)):
        of.write(str(stats.spearmanr(spotsa[i], spotsa[j])[0]) + '\t')
    of.write('\n')
    of.close()
    
def SPOT_file(op):
  
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    spots = []
    for i in range(len(SPOT200[0])): spots.append([])
    for i in range(len(SPOT200)):
        for j in range(len(spots)):
        spots[j].append(SPOT200[i][j])
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    L = len(bim)
    
    sig = []
    for i in range(7):
        sig.append([])
        v = spots[2 + i]
        count = 0.0
        wt = 0.0
        for j in range(len(v)):
            if spots[0][j] == bim:
            count += 1.0
            wt += v[j]
        wt = wt / count
        
        for j in range(len(v)):
        sig[i].append(-1.0 * math.log10(v[j] / wt))
        

    of = open(op, 'w')
    for i in range(len(SPOT200)):
        of.write(SPOT200[i][0] + '\t' + SPOT200[i][1] + '\t')
        for j in range(len(sig)): of.write(str(sig[j][i]) + '\t')
        of.write('\n')
    of.close()
    
def SPOT360_file(op):
  
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT_360p.txt')
    spots = []
    for i in range(len(SPOT200[0])): spots.append([])
    for i in range(len(SPOT200)):
        for j in range(len(spots)):
        spots[j].append(SPOT200[i][j])
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR' #bim
    L = len(bim)
    
    sig = []
    for i in range(2):
        sig.append([])
        v = spots[2 + i]
        count = 0.0
        wt = 0.0
        for j in range(len(v)):
            if spots[0][j] == bim:
            count += 1.0
            wt += v[j]
        wt = wt / count
        
        for j in range(len(v)):
        sig[i].append(-1.0 * math.log10(v[j] / wt))
        

    of = open(op, 'w')
    for i in range(len(SPOT200)):
        of.write(SPOT200[i][0] + '\t' + SPOT200[i][1] + '\t')
        for j in range(len(sig)): of.write(str(sig[j][i]) + '\t')
        of.write('\n')
    of.close()
    
def ROC_plots():
  
    fl = ['/home/bartolo/web/statium/data/ROC/spec/ROC_pssm.txt', '/home/bartolo/web/statium/data/ROC/spec/ROC_deepe.txt', '/home/bartolo/web/statium/data/ROC/spec/ROC_deepe_affinity.txt', '/home/bartolo/web/statium/data/ROC/spec/ROC_deepe_affinity_exclusive.txt' , '/home/bartolo/web/statium/data/ROC/spec/ROC_statium.txt']

    dv = []
    for i in range(5):
        dv.append([])
        dv[i].append([])
        dv[i].append([])
        
    for i in range(5):
        lines = readlines(fl[i])
        for line in lines:
        items = line.split()
        if len(items) == 2:
            dv[i][0].append(float(items[0]))
            dv[i][1].append(float(items[1]))
            
    c = ['r', 'b', 'k', 'g', 'm']
    
    import pylab
    import matplotlib
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
            
    for i in range(5):
        
        pylab.plot(pylab.array(dv[i][0]), pylab.array(dv[i][1]), c[i], lw=4)
        
    pylab.savefig('/home/bartolo/web/statium/data/plots/ROC_spec.png')
    
    pylab.close()
    
def ROC_plot():
  
    fl = ['/home/bartolo/web/vlad_roc.txt']

    dv = []
    for i in range(1):
        dv.append([])
        dv[i].append([])
        dv[i].append([])
        
    for i in range(1):
        lines = readlines(fl[i])
        for line in lines:
        items = line.split()
        if len(items) == 2:
            dv[i][0].append(float(items[0]))
            dv[i][1].append(float(items[1]))
            
    c = ['r']
    
    import pylab
    import matplotlib
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['xtick.major.pad'] = '6'
    
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
            
    for i in range(1):
        
        pylab.plot(pylab.array(dv[i][0]), pylab.array(dv[i][1]), c[i], lw=4)
        
    pylab.savefig('/home/bartolo/web/vlad_roc.png')
    
    pylab.close()
    
def combine_compare(p1, p2):
  
    l1 = readlines(p1)
    l2 = readlines(p2)
    
    for i in range(len(l1)):
        line1 = l1[i].strip()
        line2 = l2[i].strip()
        i1 = line1.split()[1]
        i2 = line2.split()[1]
        if i1 != i2: print i1, i2, i + 1
        
def tempf(p1, p2):
  
    l1 = lines2list(p1)
    l2 = lines2list(p2)
    for i in range(len(l1)):
        x = str(l1[i][1])
        m = str(l2[i][1])
    ss = str(l1[i][1] - l2[i][1])
    sts = str(l1[i][2] - l2[i][2])
    ps = str(l1[i][3] - l2[i][3])
    ds = str(l1[i][4] - l2[i][4])
        print l1[i][0] + '\t' + x[0:min(5, len(x))] + '\t' + m[0:min(5, len(m))]  + '\t' + ss[0:min(5, len(ss))] + '\t' + sts[0:min(5, len(sts))] + '\t' + ps[0:min(5, len(ps))] + '\t' + ds[0:min(5, len(ds))]

def tempf2(p1):
  
    lines = readlines(p1)
    for i in range(len(lines)):
        line = lines[i]
        items = line.split()
        if float(items[1]) > 0.5 or float(items[2]) > 0.5 or float(items[3]) > 0.5 or float(items[4]) > 0.5 or float(items[5]) > 0.5: print line.strip()
        #print l1[i][0] + '\t' + x[0:min(5, len(x))] + '\t' + m[0:min(5, len(m))]  + '\t' + ss[0:min(5, len(ss))] + '\t' + sts[0:min(5, len(sts))] + '\t' + ps[0:min(5, len(ps))] + '\t' + ds[0:min(5, len(ds))]

def tempf3(p1):
  
    lines = readlines(p1)
    for i in range(len(lines)):
        line = lines[i].strip()
        items = line.split()
        
        seq = items[0]
        
        if len(seq) == 27:
        
        sv = []
        for j in range(len(seq)): sv.append(seq[j])
        
        sv[10] = 'D'
        L3aD = ''
        for j in range(len(seq)): L3aD += sv[j]
        sv[10] = seq[10]
        
        sv[14] = 'L'
        G3eL = ''
        for j in range(len(items[0])): G3eL += sv[j]
        sv[14] = seq[14]
        
        print seq
        print L3aD
        print G3eL
        
        if len(seq) == 24:
        
        sv = []
        for j in range(len(seq)): sv.append(seq[j])
        
        sv[8] = 'D'
        L3aD = ''
        for j in range(len(seq)): L3aD += sv[j]
        sv[8] = seq[8]
        
        sv[12] = 'L'
        G3eL = ''
        for j in range(len(items[0])): G3eL += sv[j]
        sv[12] = seq[12]
        
        print seq
        print L3aD
        print G3eL
        
        continue
        
        print line
        
        line2 = ''
        for j in range(len(line)):
        if j >= len(seq): line2 += line[j]
        else: line2 += L3aD[j]
    line2 += ' (L3aD)'
    print line2
    
        line3 = ''
        for j in range(len(line)):
        if j >= len(seq): line3 += line[j]
        else: line3 += G3eL[j]
    line3 += ' (G3eL)'
    print line3

def XMpred(p1):
  
    l1 = lines2list(p1)
    sig = []
    stat = []
    pssm = []
    deep = []
    for i in range(len(l1)):
      
        sig.append(l1[i][1])
        stat.append(l1[i][2])
        pssm.append(l1[i][3])
        deep.append(l1[i][4])
    
    import pylab
    siga = pylab.array(sig)
    stata = pylab.array(stat)
    pssma = pylab.array(pssm)
    deepa = pylab.array(deep)
    
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    

    pylab.scatter(deepa, siga)
    r = stats.spearmanr(siga, deepa)[0]
    p = stats.spearmanr(siga, deepa)[1]
    print r, p
    print 'Pearson:', str(pylab.corrcoef(siga, deepa)[0][1])
    #pylab.yticks([])

    pylab.savefig('/home/bartolo/web/statium/data/plots/XMpred_forbid_scatter_deepe.png')
    pylab.close()
     
def design_sample(p1):
  
    l1 = lines2list(p1)
    
    sampler = []
    for i in range(len(l1[0][0])): sampler.append([''])
    
    for i in range(len(l1)):
        seq = l1[i][0]
        RK = 0
        DE = 0
        for j in range(len(seq)):
        if seq[j] in 'RK': RK += 1
        if seq[j] in 'DE': DE += 1
        if not seq[j] in sampler[j]: sampler[j].append(seq[j])
    #print seq, RK, DE, RK + DE
    tot = 1
    for i in range(len(sampler)):
        samp_str = ''
        for j in range(len(sampler[i])): samp_str += sampler[i][j]
        print samp_str
        tot = tot * len(samp_str)
    #print tot
    
def design_sampler(p1):
  
    l1 = readlines(p1)
    
    tot = 1
    for i in range(len(l1)):
        line = l1[i].strip()
        tot = tot * len(line)
    print tot, (float(tot) / 2500000) / (60.0 * 60.0)
    
def join_str(l1):
    s1 = ''
    for i in l1: s1 += i
    return s1
    
def BH3_statium_design():
  
    specx = 1.0
  
    em2 = load_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    em1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    sampler = lines2list('/home/bartolo/web/statium/lib_all.txt')
    N = len(sampler)
    
    #Generate initial random sequence
    seq = []
    for i in range(N):
        allowed = sampler[i][0]
        L = len(allowed)
        if L == 1: seq.append(allowed[0])
        else:
            randi = random.randint(0, L - 1)
            seq.append(allowed[randi])
    print 'Bim:', xenergy(em1, 'PEIWIAQELRRIGDEFNAYYARR', 10.0, False), xenergy(em2, 'PEIWIAQELRRIGDEFNAYYARR', 10.0, False)
    e1 = xenergy(em1, join_str(seq), 10.0, False)
    e2 = xenergy(em2, join_str(seq), 10.0, False)
    
    e = e1
    
    desN = 0
    while True:
        desN += 1
        
        rand_pos = random.randint(0, N - 1)
        allowed = sampler[rand_pos][0]
        if len(allowed) == 1: continue
        
        oldAA = seq[rand_pos]
        L = len(allowed)
        if L == 1: seq[rand_pos] = allowed[0]
        else:
            randi = random.randint(0, L - 1)
            seq[rand_pos] = allowed[randi]
        
        en1 = xenergy(em1, join_str(seq), 10.0, False)
        en2 = xenergy(em2, join_str(seq), 10.0, False)
        
        score = en1
        
        charge = 0
        for i in range(N):
        if seq[i] in 'RKED': charge += 1 
        
        if score <= e and charge <= 9:
        if score < e and charge <= 9: print join_str(seq), en1, en2
        e = score
    else: seq[rand_pos] = oldAA
    
def BH3_statium_spec_design(ev, esv, specx, lib):
  
    sampler = lines2list(lib)
    N = len(sampler)
    
    #Generate initial random sequence
    seq = []
    for i in range(N):
        allowed = sampler[i][0]
        L = len(allowed)
        if L == 1: seq.append(allowed[0])
        else:
            randi = random.randint(0, L - 1)
            seq.append(allowed[randi])
    
    em1 = statium_energy_calc(ev, join_str(seq), 0.1) 
    e = em1
    for i in range(len(esv)): e -= specx * (statium_energy_calc(esv[i], join_str(seq), 0.1) - em1)
    
    rfin = []
    for i in range(len(esv)): rfin.append(0.0)
    seqfin = join_str(seq)
    scorefin = e
    enfin = em1
    
    desN = 0
    while True:
        desN += 1
        
        rand_pos = random.randint(0, N - 1)
        allowed = sampler[rand_pos][0]
        if len(allowed) == 1: continue
        
        oldAA = seq[rand_pos]
        L = len(allowed)
        if L == 1: seq[rand_pos] = allowed[0]
        else:
            randi = random.randint(0, L - 1)
            seq[rand_pos] = allowed[randi]
            
        en1 = statium_energy_calc(ev, join_str(seq), 0.1) 
        score = en1
        for i in range(len(esv)): score -= specx * ((statium_energy_calc(esv[i], join_str(seq), 0.1) - en1))
        
        charge = 0
        for i in range(N):
        if seq[i] in 'RKED': charge += 1 
        
        if score < e and charge < 9:
        desN = 0
        e = score
        for i in range(len(esv)): rfin[i] = statium_energy_calc(esv[i], join_str(seq), 0.1)
        seqfin = join_str(seq)
        scorefin = score
        enfin = en1
    else: seq[rand_pos] = oldAA
    
    if desN > 1000: break
    return [enfin, rfin, seqfin, scorefin]
    
def BH3_spec_sample(rstr, specx, op):
  
    lib = '/home/bartolo/web/statium/lib_all.txt'
    
    if rstr[0] == 'x': em = load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8')
    elif rstr[0] == 'm': em = load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1')
    elif rstr[0] == 'w': em = load_design_energy('/home/bartolo/web/statium/bclw/bclw')
    elif rstr[0] == 'f': em = load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp')
    elif rstr[0] == 'b': em = load_design_energy('/home/bartolo/web/statium/bcl2/bcl2')
    
    esv = []
    for i in range(len(rstr) - 1):
        if rstr[i + 1] == 'x': esv.append(load_design_energy('/home/bartolo/web/statium/bclxl2/bclxl_3io8'))
        elif rstr[i + 1] == 'm': esv.append(load_design_energy('/home/bartolo/web/statium/mcl12/mcl1_3pk1'))
        elif rstr[i + 1] == 'w': esv.append(load_design_energy('/home/bartolo/web/statium/bclw/bclw'))
        elif rstr[i + 1] == 'f': esv.append(load_design_energy('/home/bartolo/web/statium/bfl12/bfl1_3mqp'))
        elif rstr[i + 1] == 'b': esv.append(load_design_energy('/home/bartolo/web/statium/bcl2/bcl2'))
 
    if len(esv) > 0: specx = specx / float(len(esv))
    else: specx = 0.0
    
    score = 0.0
    attempts = 0 
    while True:
        attempts += 1
        print attempts
        design = BH3_statium_spec_design(em, esv, specx, lib)
        score1 = design[3]
        if score1 < score:
        print 'found'
        score = score1
        #print design[0],
        #for i in range(len(design[1])): print design[1][i],
        #print design[3]
        #print design[2]
        #print
        attempts = 0
        of = open(op, 'a')
        of.write(design[2] + '\t' + str(design[0]) + '\t')
        for i in range(len(design[1])): of.write(str(design[1][i] - design[0]) + '\t')
        of.write(str(design[3]) + '\t' + rstr + '\n')
        of.close()
    if attempts == 50: break
    
def classy_sweep(rstr, od, q):
  
    coyote = True
    if coyote:
        sd = os.path.join(od, 'scripts')
        if not os.path.exists(sd): os.mkdir(sd)
  
    points = 50
    specx0 = 0.0
    for i in range(2000):
        specx = specx0 + float(i) * (1.0 / float(points))
        op = os.path.join(od, rstr + '_' + str(i) + '.txt')
        if coyote:
        while True:
            if coyote_count_jobs(q) < 500:
                sp = os.path.join(sd, rstr + '_' + str(i) + '.sh')
                of = open(sp, 'w')
                of.write('/home/bartolo/web/build.py -BH3_spec_design ' + rstr + ' ' + str(specx) + ' ' + op + '\n\n')
                of.close()
                os.system('chmod u+x ' + sp)
                os.system('qsub -q ' + q + ' ' + sp)
                break
            else:
            time.sleep(60)
        else: BH3_spec_sample(rstr, specx, op)

def coyote_count_jobs(q):
  
    try:
        cp = '/home/bartolo/web/count_' + q + '.txt'
        os.system('qstat | grep bartolo | grep ' + q + ' | wc -l > ' + cp)
        line = readline(cp, 1)
        return int(line.strip())
    except: return 0

def search_BH3_list(out_path):
  
    design_energy_bclxl = load_design_energy('/home/bartolo/web/statium/bfl1/bfl1_3mqp')
    sequences = lines2list('/home/bartolo/web/statium/BH3_seq_full.txt')
    header = readlines('/home/bartolo/web/statium/BH3_names_full.txt')
    
    o = open(out_path, 'w')
    for i in range(len(sequences)):
        if i % 1000 == 0: print i
        seq = sequences[i][0]
        e = xenergy(design_energy_bclxl, seq, 10.0, False)
    full_head = header[i].strip()
    start = 0
    for j in range(len(full_head)):
        if full_head[j] == '|': start = j + 1
    header_line = ''
    for j in range(start, len(full_head)): header_line += full_head[j]
        o.write(seq + '\t' + str(e) + '\t' + header_line + '\n')
    o.close()
    
def BH3_hist(p1, p2):
  
    l1 = lines2list(p1)

    v1 = []
    for i in range(len(l1)): v1.append(l1[i][1])
    
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab

    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['xtick.major.pad'] = '6'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.hist(pylab.array(v1), facecolor='white', edgecolor='black', lw=2)
    pylab.xlim(-800.0, 1000.0)
   
    pylab.savefig(p2)
    pylab.close()
    
def arrayII():
  
    a1p = '/home/bartolo/web/statium/bclxl_genome_screen_results.txt'
    xp = '/home/bartolo/web/statium/ArrayII_Xselect.txt'
    wp = '/home/bartolo/web/statium/ArrayII_Wselect.txt'
    mp = '/home/bartolo/web/statium/ArrayII_Mselect.txt'
    fp = '/home/bartolo/web/statium/ArrayII_Fselect.txt'
    
    a1l = lines2list(a1p)
    xl = lines2list(xp)
    wl = lines2list(wp)
    ml = lines2list(mp)
    fl = lines2list(fp)
    
    a1s = []
    xs = []
    ws = []
    ms = []
    fs = []
    
    for i in range(len(a1l)): a1s.append(a1l[i][0])
    for i in range(len(xl)): xs.append(xl[i][0])
    for i in range(len(wl)): ws.append(wl[i][0])
    for i in range(len(ml)): ms.append(ml[i][0])
    for i in range(len(fl)): fs.append(fl[i][0])
    
    xc = []
    wc = []
    mc = []
    fc = []
    
    for i in range(len(xs)):
        seq = xs[i]
        if not seq in a1s: xc.append(seq)
        if len(xc) == 200: break
        
    for i in range(len(ws)):
        seq = ws[i]
        if not seq in a1s and not seq in xc: wc.append(seq)
        if len(wc) == 200: break
        
    for i in range(len(ms)):
        seq = ms[i]
        if not seq in a1s and not seq in xc and not seq in wc: mc.append(seq)
        if len(mc) == 200: break
        
    for i in range(len(fs)):
        seq = fs[i]
        if not seq in a1s and not seq in xc and not seq in wc and not seq in mc: fc.append(seq)
        if len(fc) == 200: break
        
    for i in range(200):
        print xc[i]
        
    for i in range(200):
        print wc[i]
        
    for i in range(200):
        print mc[i]
        
    for i in range(200):
        print fc[i]
        
def STATIUM_position_eval(rdir, seq_path, out_dir):

    energy_vec = load_design_energy(rdir)
    
    pair_list = energy_vec[0]
    seq_ref = energy_vec[3]
    res_vec = energy_vec[1]
    pdbinfo_vec = energy_vec[2]
    
    Npairs = len(pair_list[1])
    
    seqs = []
    lines = readlines(seq_path)
    for line in lines: seqs.append(line.strip())
    
    energy_pos = []
    for i in range(Npairs): energy_pos.append([])
    energy_counts = []
    for i in range(Npairs): energy_counts.append(0)
    
    for seq in seqs:
        for i in range(Npairs):
            pos0 = pair_list[1][i][0]
            pos1 = pair_list[1][i][1]
        
            if pos0 in res_vec: aa0 = AAChar_int(seq[pos0 - seq_ref[0] + seq_ref[1]])
            else: aa0 = pdbinfo_vec[pos0][1]
            if pos1 in res_vec: aa1 = AAChar_int(seq[pos1 - seq_ref[0] + seq_ref[1]])
            else: aa1 = pdbinfo_vec[pos1][1]
    
            if AAChar_fasta(aa0) == 'G' or AAChar_fasta(aa1) == 'G':
                continue
           
            e = pair_list[0][i][aa0][aa1]
            if (not pos0 in res_vec or not pos1 in res_vec):
            energy_pos[i].append(e)
            energy_counts[i] += 1
            
    ave_vec = []
    std_vec = []
    positions_vec = []
    count = 0
    for i in range(Npairs):
        if energy_counts[i] > 0:
            pos0 = pair_list[1][i][0]
            pos1 = pair_list[1][i][1]
            mean_e = mean(array(energy_pos[i]))
            std_e = std(array(energy_pos[i]))
            if mean_e < 0.0:
            print pos0 + 1, pos1 + 1
            out_path = os.path.join(out_dir, str(pos0 + 1) + '_' + str(pos1 + 1) + '_probs.txt')
            probs_path = os.path.join(rdir, str(pos0 + 1) + '_' + str(pos1 + 1) + '_probs.txt')
            os.system('cp ' + probs_path + ' ' + out_path)
        ave_vec.append(mean_e)
        std_vec.append(std_e)
        positions_vec.append(count)
        count += 1
        
    ave_array = array(ave_vec)
    std_array = array(std_vec)
    positions_array = array(positions_vec)
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '17'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    pylab.rcParams['figure.figsize'] = (16, 6)

    fig = pylab.figure()
    ax = fig.add_subplot(111)

    ax.errorbar(positions_array, ave_array, std_array, fmt='o', mfc='green', ecolor='green')
    pylab.xlim(min(positions_array), max(positions_array))
    
    pylab.savefig('/home/bartolo/web/statium/data/plots/bclxl_energy_pairs.png')
    
    pylab.close()
    
def BH3_PI(in_path, out_path):
  
    data = lines2list(in_path)
    
    pi_vec = []
    d_vec = []
    
    for i in range(len(data)):
        diff = data[i][2] - data[i][3]
        pI = data[i][1]
        #if diff < 0.5 and diff > 0.0 and pI < 9.0 and pI > 8.0: print data[i]
        #if (data[i][2] < 0.5 or data[i][3] < 0.5):
        if True:
            pi_vec.append(pI)
            d_vec.append(data[i][2])
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '17'
    pylab.rcParams['ytick.labelsize'] = '20'
    pylab.rcParams['ytick.direction'] = 'out'
    pylab.rcParams['xtick.direction'] = 'out'
    
    pylab.scatter(array(pi_vec), array(d_vec))
    
    print stats.spearmanr(array(pi_vec), array(d_vec))[0], stats.spearmanr(array(pi_vec), array(d_vec))[1]
    
    pylab.savefig(out_path)
    
    pylab.close()
    
def FP_comp_concentration(start_nm, points):
  
    v1 = []
    nm0 = start_nm
    for i in range(points):
        
        if i > 1: nm0 = nm0 * 0.4
        if i == 0: nm1 = nm0 * 0.75
        else: nm1 = nm0 * 0.75 * 0.4
        
        #print i, nm0, nm1, math.log10(nm1)
        #v1.append(math.log10(nm1))
        v1.append(nm1)
        
    nm_vec = []
    for i in range(len(v1)):
        nm_vec.append(v1[-1 - i])
    return nm_vec
    
def FP_direct_concentration(nm0):
  
    v1 = []
    for i in range(12):
        
        if i == 0: nm = nm0
        elif i == 11: nm = 0.0
        else: nm = nm * 0.4
        v1.append(nm)
        
    nm_vec = []
    for i in range(len(v1)):
        nm_vec.append(v1[-1 - i])
    return nm_vec
    
def conc_file(p1):
  
    data = lines2list(p1)
    cv = []
    for i in range(len(data)): cv.append(data[i][0])
      
    return cv
        
def parse_FP_comp(ip, cp, rows, plot_path):
  
    import pylab
    
    rsv = rows.split(',')
    riv = []
    for i in range(len(rsv)): riv.append(int(rsv[i]) - 1)
    
    marker_vec = ['o', '>', '+', '*', 's', 'v', 'D', 'H']
    color_vec = ['blue', 'red', 'green', 'purple', 'yellow', 'magenta', 'cyan', 'orange']
    
    c0v = conc_file(cp)
    lines = readlines(ip)
    lnum = 0
    use_vec = []
    for i in range(len(riv)):
        riv_idx = riv[i]
        line = lines[3 + riv_idx]
        items0 = line.strip().split()
    cv = FP_comp_concentration(c0v[riv_idx], 11)
    ca = pylab.array(cv)
        items1 = []
        if len(items0) == 12:
        for j in range(11): items1.append(float(items0[j]))
        else:
        for j in range(11): items1.append(float(items0[j + 1]))
        
    vv = []
    for j in range(len(items1)): vv.append(items1[-1 - j])
    va = pylab.array(vv)
    
    plot_index = i

    plot_save = pylab.semilogx(ca, va, linestyle=' ', marker=marker_vec[plot_index], markerfacecolor='white', markeredgecolor=color_vec[plot_index], markeredgewidth=1.0)
    use_vec.append(plot_save)
    #pylab.legend(use_vec, ('Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2'))
    #pylab.legend(use_vec, ('Bim & Bcl-w', 'PCNA & Bcl-w', 'Bim & Mcl-1', 'PCNA & Mcl-1'), 'lower left')
    #pylab.legend(use_vec, ('Bim & Bcl-w', 'TRAP80 Bcl-w'), 'lower left')

    pylab.savefig(plot_path)
    
def parse_FP_direct(ip, cp, rows, plot_path):
  
    #import pylab
    
    rsv = rows.split(',')
    riv = []
    for i in range(len(rsv)): riv.append(int(rsv[i]) - 1)
    print riv
    
    marker_vec = ['o', '>', '+', '*']
    color_vec = ['blue', 'red', 'green', 'purple']
    
    #c0v = conc_file(cp)
    lines = readlines(ip)
    lnum = 0
    use_vec = []
    for i in range(len(riv)):
        riv_idx = riv[i]
        line = lines[3 + riv_idx]
        items0 = line.strip().split()
    #cv = FP_direct_concentration(c0v[riv_idx])
    #ca = pylab.array(cv)
        items1 = []
        if len(items0) == 12:
        for j in range(11):
            items1.append(float(items0[j]))
            print str(float(items0[j])) + ',',
        print
        else:
        for j in range(11):
            items1.append(float(items0[j + 1]))
            print str(float(items0[j + 1])) + ',',
        print
    #vv = []
    #for j in range(len(items1)): vv.append(items1[-1 - j])
    #va = pylab.array(vv)
    
    #plot_index = i

    #plot_save = pylab.semilogx(ca, va, linestyle=' ', marker=marker_vec[plot_index], markerfacecolor='white', markeredgecolor=color_vec[plot_index], markeredgewidth=1.0)
    #use_vec.append(plot_save)
    ##pylab.legend(use_vec, ('Bim & Bcl-w', 'PCNA & Bcl-w', 'Bim & Mcl-1', 'PCNA & Mcl-1'), 'lower left')
    ##pylab.legend(use_vec, ('Bim & Bcl-w', 'TRAP80 Bcl-w'), 'lower left')

    #pylab.savefig(plot_path)
    
def average_points(points):
  
    import pylab
    import scipy
  
    L = len(points[0])
    val = []
    for i in range(L): val.append([])
    for i in range(len(points)):
        for j in range(len(points[i])): val[j].append(points[i][j])
        
    mean_val = []
    for i in range(L): mean_val.append(mean(pylab.array(val[i])))
    
    std_val = []
    for i in range(L): std_val.append(std(pylab.array(val[i])))
        
    return [pylab.array(mean_val), pylab.array(std_val)]
    
def direct_binding_anis(info):
  
    import pylab
    import scipy
    
    Fpep = info[-1]
    xv = []
    for i in range(len(info[0])): xv.append(info[0][i])
    xval = pylab.array(xv)
    
    use_yerror = False
    if len(info[1]) > 1:
        yinfo = average_points(info[1])
        use_yerror = True
        yval = yinfo[0]
        yerror = yinfo[1]
    else:
        yv = []
        for i in range(len(info[1][0])): yv.append(info[1][0][i])
        yval = pylab.array(yv)
        yerror = []
        
    print len(xval), len(yval)

    #para(0) is the concentration of the ligand (fluorescent peptide), 
    #para(1) and para(2) are the anisotropy values when the ligand is free and bound respectively
    #para(3) is the Kd
    #x is the concentration of the receptor
    #fitfunc = lambda p, x: p[1]+(((p[2]-p[1])/(2*p[0]))*((p[0]+x+p[3])-sqrt(((p[0]+x+p[3])**2)-4*(p[0]*x))))
    fitfunc = lambda p, x: p[0]+(((p[1]-p[0])/(2*Fpep))*((Fpep+x+p[2])-sqrt(((Fpep+x+p[2])**2)-4*(Fpep*x))))
    errfunc = lambda p, x, y: fitfunc(p, x) - y # Distance to the target function
    
    #p0 = [50.0, 0.18, 0.1, 10.0] # Initial guess for the parameters
    p0 = [yval[-1], yval[0], 10.0] # Initial guess for the parameters
    
    p1, success = scipy.optimize.leastsq(errfunc, p0[:], args=(xval, yval))
    print p1
    
    xfunc = linspace(xval.min(), xval.max(), 100000)
    yfunc = fitfunc(p1, xfunc)
    
    return [xval, yval, xfunc, yfunc, p1[-1], yerror]
    
def competition_binding_anis(info):
  
    import pylab
    import scipy
    
    Fpep = info[-2]
    Rec = info[-1]
    xv = []
    for i in range(len(info[0])): xv.append(info[0][i])
    xval = pylab.array(xv)
    
    use_yerror = False
    if len(info[1]) > 1:
        yinfo = average_points(info[1])
        use_yerror = True
        yval = yinfo[0]
        yerror = yinfo[1]
    else:
        yv = []
        for i in range(len(info[1][0])): yv.append(info[1][0][i])
        #yv.reverse()
        yval = pylab.array(yv)
        yerror = []
        
        
    print len(xval), len(yval)

    #para(0) is Kd1
    #para(1) is Kd2
    #para(2) is concentration of Fl-Bim
    #x  is concentration of unlabeled peptide
    #para(3) is the receptor concentration
    #para(4) is bottom baseline
    #para(5) is upper baseline
    #fitfunc = lambda p, x: p[1]+(((p[2]-p[1])/(2*p[0]))*((p[0]+x+p[3])-sqrt(((p[0]+x+p[3])**2)-4*(p[0]*x))))
    
    try:
        fitfunc = lambda p, x: p[2]+(p[3]-p[2])*((2*sqrt(p[0]+p[1]+Fpep+x-Rec**2-3*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1])*cos(arccos((-2*p[0]+p[1]+Fpep+x-Rec**3+9*p[0]+p[1]+Fpep+x-Rec*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1]-27*-p[0]*p[1]*Rec)/(2*sqrt((p[0]+p[1]+Fpep+x-Rec**2-3*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1])**3)))/3)-p[0]+p[1]+Fpep+x-Rec)/(3*p[0]+2*sqrt(p[0]+p[1]+Fpep+x-Rec**2-3*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1])*cos(arccos((-2*p[0]+p[1]+Fpep+x-Rec**3+9*p[0]+p[1]+Fpep+x-Rec*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1]-27*-p[0]*p[1]*Rec)/(2*sqrt((p[0]+p[1]+Fpep+x-Rec**2-3*p[0]*(x-Rec)+p[1]*(Fpep-Rec)+p[0]*p[1])**3)))/3)-p[0]+p[1]+Fpep+x-Rec))
        errfunc = lambda p, x, y: fitfunc(p, x) - y # Distance to the target function
    
        p0 = [10.0, 10.0, yval[0], yval[-1]] # Initial guess for the parameters
    
        p1, success = scipy.optimize.leastsq(errfunc, p0[:], args=(xval, yval))
        print p1, success
    
        xfunc = linspace(xval.min(), xval.max(), 100000)
        yfunc = fitfunc(p1, xfunc)
    except:
        xfunc = []
        yfunc = []
        p1 = ['X']
        yerror = []
        
    
    return [xval, yval, xfunc, yfunc, p1[-1], yerror]
    
def FP_plots(fits, fit_dec, exp, plot_path, labels):
 
    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['figure.figsize'] = (10, 8)
    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    
    marker_vec = ['o', '>', '+', '*', 's', 'v', 'D', 'H']
    color_vec = ['blue', 'red', 'green', 'purple', 'magenta', 'cyan', 'orange']
  
    maxy = 0
    miny = 100000
    for i in range(len(fits)):
        yval = fits[i][1]
        if min(yval) < miny: miny = min(yval)
        if max(yval) > maxy: maxy = max(yval)
        
    for i in range(len(fits)):
        info = fits[i]
        xval = fits[i][0]
        yval = fits[i][1]
        xfunc = fits[i][2]
        yfunc = fits[i][3]
        #pylab.scatter(log10(xval), yval, marker='o', facecolors='none', edgecolors=color_vec[i], s=80, label=labels[i])
        #pylab.scatter([1000.0], maxy + 1.0, marker='o', facecolors='none', edgecolors=color_vec[i], s=10, label=labels[i])
        pylab.scatter(log10(xval), yval, marker='o', facecolors='none', edgecolors=color_vec[i], s=80, label=labels[i])
        #if exp == 'DIRECT': pylab.scatter(xval, yval, marker='o', facecolors='none', edgecolors=color_vec[i], s=80, label=labels[i])
        if len(info[-1]) > 0: pylab.errorbar(log10(xval), yval, yerr=info[-1], linestyle='None', color=color_vec[i])
        if fit_dec[i] == 'FIT': pylab.plot(log10(xfunc), yfunc, color=color_vec[i])
        #if fit_dec[i] == 'FIT': pylab.plot(xfunc, yfunc, color=color_vec[i])
    #if exp == 'DIRECT': pylab.xscale('log')
    #pylab.xscale('log')
    #pylab.ylabel('Anisotropy', fontsize=18, fontweight='bold')
    #pylab.legend(loc='upper left', scatterpoints=1)
    pylab.xticks(fontweight='bold')
    pylab.yticks(fontweight='bold')
    #if exp == 'DIRECT': pylab.xlabel('Log10 receptor concentration (nM)', fontsize=18, fontweight='bold')
    #if exp == 'DIRECT': pylab.xlabel('Receptor concentration (nM)', fontsize=18, fontweight='bold')
    #else: pylab.xlabel('Log10 of unlabeled peptide concentration (nM)', fontsize=18, fontweight='bold')
    #pylab.xlim(0.6, 250)
    diff = (maxy - miny) * 0.15
    pylab.ylim(miny - diff, maxy + diff)
    #pylab.ylim(0.05, 0.17)
    #pylab.xlim(0.01, 500.00)

    pylab.savefig(plot_path)
    
def FP_archive_query(query):
  
    archive = lines2list('/home/bartolo/web/statium/F_labeled/bcl2_FP_data.txt')
    #archive = lines2list('/home/bartolo/web/statium/F_labeled/aggregate.txt')
    items = query.split(',')
    
    name = items[0]
    receptor = items[1]
    bind_type = items[2]
    dats = items[4].split('.')
    
    found = False
    response = []
    for i in range(len(archive)):
        if len(archive[i]) > 0: var = archive[i][0]
        else: var = ''
        if var == 'NAME:':
            if archive[i][1].strip() == name and archive[i + 1][1] == receptor and archive[i + 2][1] == bind_type:
            conc = []
            for j in range(len(archive[i + 3]) - 1 - 1): conc.append(archive[i + 3][j + 1 + 1])
            response.append(conc)
            count = 0
            response.append([])
            while True:
            count += 1
            anis = []
            if len(archive[i + 3 + count]) == 0: break
            if not archive[i + 3 + count][0][0:len(archive[i + 3 + count][0]) - 1] in dats: continue
            for j in range(len(archive[i + 3 + count]) - 1 - 1): anis.append(archive[i + 3 + count][j + 1 + 1])
            response[-1].append(anis)
            response.append(archive[i][2])
            if len(archive[i + 1]) == 3: response.append(archive[i + 1][2])
            break
   
    return response

def FP_archive_queryL(query):

    archive = lines2list('/home/bartolo/web/statium/F_labeled/bcl2_FP_data.txt')

    items = query.split(',')

    name = items[0]
    receptor = items[1]
    bind_type = items[2]
    dats = items[4].split('.')

    found = False
    response = []
    for i in range(len(archive)):
        if len(archive[i]) > 0: var = archive[i][0]
        else: var = ''
        if var == 'NAME:':
            if archive[i][1].strip() == name and archive[i + 1][1] == receptor and archive[i + 2][1] == bind_type:
                conc = []
                for j in range(len(archive[i + 3]) - 1): conc.append(archive[i + 3][j + 1])
                response.append(conc)
                count = 0
                response.append([])
                while True:
                    count += 1
                    anis = []
                    if len(archive[i + 3 + count]) == 0: break
                    if not archive[i + 3 + count][0][0:len(archive[i + 3 + count][0]) - 1] in dats: continue
                    for j in range(len(archive[i + 3 + count]) - 1): anis.append(archive[i + 3 + count][j + 1])
                    response[-1].append(anis)
                response.append(archive[i][2])
                if len(archive[i + 1]) == 3: response.append(archive[i + 1][2])
                break

    return response

def FP_archive_query_BD(query):

    archive = lines2list('/home/bartolo/web/statium/F_labeled/bcl2_FP_data.txt')

    items = query.split(',')

    name = items[0]
    receptor = items[1]
    bind_type = items[2]
    dats = items[4].split('.')

    found = False
    response = []
    for i in range(len(archive)):
        if len(archive[i]) > 0: var = archive[i][0]
        else: var = ''
        if var == 'NAME:':
            if archive[i][1].strip().split('_')[0] == name and archive[i + 1][1] == receptor and archive[i + 2][1] == bind_type:
        count = 0
                while True:
            count += 1
                    anis = []
                    if len(archive[i + 3 + count]) == 0: break
                    if not archive[i + 3 + count][0][0:len(archive[i + 3 + count][0]) - 2] == 'FIT': continue
                    for j in range(len(archive[i + 3 + count]) - 1): anis.append(archive[i + 3 + count][j + 1])
            print archive[i][1].strip(), anis[0]

def FP_archives(query, plot_path):
  
    Rdict = dict([['X', 'Bcl-xL'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['F', 'Bfl-1'], ['B', 'Bcl-2'], ['H', 'BHRF1']])
    fits = []
    fit_dec = []
    labels = []
    choices = query.split(':')
    exp = choices[0].split(',')[2]
    for i in range(len(choices)):
        items = choices[i].split(',')
        name = items[0]
        Rname = Rdict[items[1]]
        labels.append(name + ' (' + Rname + ')')
        fit = items[3]
        fit_dec.append(fit)
        response = FP_archive_query(choices[i])
        if items[2] == 'DIRECT': fits.append(direct_binding_anis(response))
        else: fits.append(competition_binding_anis(response))
    FP_plots(fits, fit_dec, exp, plot_path, labels)

def FP_archivesL(query, option):

    Rdict = dict([['X', 'Bcl-xL'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['F', 'Bfl-1'], ['B', 'Bcl-2'], ['H', 'BHRF1']])
    fits = []
    fit_dec = []
    labels = []
    choices = query.split(':')
    exp = choices[0].split(',')[2]
    for i in range(len(choices)):
        items = choices[i].split(',')
        name = items[0]
        Rname = Rdict[items[1]]
        labels.append(name + ' (' + Rname + ')')
        fit = items[3]
        fit_dec.append(fit)
    response = FP_archive_query(choices[i])
    if True:
        response[1][0].pop(0)
        response[1][1].pop(0)
        response[0].pop(0)
    perp = str(response[1][0])
    para = str(response[1][1])
    conc = str(response[0])
    
    if option == 'old': matlab_str = 'matlab -nodesktop -njvm -r \"rdata=[' + conc + '\',' + perp + '\',' + para + '\']; fdata=anisotropie(rdata,[10],\'oldmod\'); sprintf(\'%20.6f\', fdata), quit;\"'
    if option == 'new': matlab_str = 'matlab -nodesktop -njvm -r \"rdata=[' + conc + '\',' + perp + '\',' + para + '\']; fdata=anisotropie(rdata,[10]); sprintf(\'%20.6f\', fdata), quit;\"'
    os.system(matlab_str)

def FP_archivesBD(query):

    Rdict = dict([['X', 'Bcl-xL'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['F', 'Bfl-1'], ['B', 'Bcl-2'], ['H', 'BHRF1']])
    fits = []
    fit_dec = []
    labels = []
    choices = query.split(':')
    exp = choices[0].split(',')[2]
    for i in range(len(choices)):
        items = choices[i].split(',')
        name = items[0]
        Rname = Rdict[items[1]]
        labels.append(name + ' (' + Rname + ')')
        fit = items[3]
        fit_dec.append(fit)
        response = FP_archive_query_BD(choices[i])

def FP_archivesL_plot(query, outpath):

    Rdict = dict([['X', 'Bcl-xL'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['F', 'Bfl-1'], ['B', 'Bcl-2'], ['H', 'BHRF1']])
    fits = []
    fit_dec = []
    labels = []
    choices = query.split(':')
    exp = choices[0].split(',')[2]
    for i in range(len(choices)):
        items = choices[i].split(',')
        name = items[0]
        Rname = Rdict[items[1]]
        labels.append(name + ' (' + Rname + ')')
        fit = items[3]
        fit_dec.append(fit)
        response = FP_archive_queryL(choices[i])
        response[1][0].pop(0)
        response[0].pop(0)
        anis = response[1][0]
        conc = response[0]
    log_conc = []
    for i in conc: log_conc.append(math.log10(i))
    fits.append([log_conc, anis])
    if fit_dec[-1] == 'NOFIT': continue
    pvec = response[1][1]
    c0 = math.log10(response[0][-1]) - 0.5
    c1 = math.log10(response[0][0]) + 0.5
    dp = 40
    inc = (c1 - c0) / float(dp)
    
    fit_vec = [[], []]
    for i in range(dp):
        c = 10**(c0 + (inc * float(i)))
        anis_val = direkt_binding(pvec, 10, c)
        fit_vec[1].append(anis_val)
        fit_vec[0].append(math.log10(c))
    fits[-1].append(fit_vec)

    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['figure.figsize'] = (10, 8)
    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0

    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')

    marker_vec = ['o', '>', '+', '*', 's', 'v', 'D', 'H']
    color_vec = ['blue', 'red', 'green', 'purple', 'magenta', 'cyan', 'orange']

    for i in range(len(fits)):
    print i
        pylab.scatter(fits[i][0], fits[i][1], marker='o', facecolors='none', edgecolors=color_vec[i], s=80)
        if fit_dec[i] == 'NOFIT': continue
        pylab.plot(fits[i][2][0], fits[i][2][1], color=color_vec[i])

    pylab.savefig(outpath)
    
def das_heterodimer(aganz, bganz, KD):
    p1 = 1.0/2.0*KD
    p2 = 1.0/2.0*bganz
    p3 = 1.0/2.0*aganz
    p4 = 1.0/2.0*(KD**2.0+2.0*KD*bganz+2.0*KD*aganz+bganz**2.0-2.0*aganz*bganz+aganz**2.0)**(1.0/2.0)
    hv = p1 + p2 + p3 - p4
    
    return hv

def direkt_binding(pvec, aganz, x):
    
    KD = float(pvec[0])
    parfrei = float(pvec[1])
    rechtfrei = float(pvec[2])
    parbund = float(pvec[3])
    rechtbund = float(pvec[4])
    
    return ((parfrei-rechtfrei)*aganz+(parbund-rechtbund-parfrei+rechtfrei)*das_heterodimer(aganz,x,KD))/((parfrei+2.0*rechtfrei)*aganz+(parbund+2.0*rechtbund-parfrei-2.0*rechtfrei)*das_heterodimer(aganz,x,KD))

def seqdata2AAint(seq_path):

    data = lines2list(seq_path)
    for i in range(len(data)): print AACode(data[i][2])
    
def feather_nest():
  
    for i in range(23):
        spacer = ''
        brack = ''
        for j in range(i * 4 + 4): spacer = spacer + ' '
        for j in range(i * 4 + 4): brack = brack + ' '
        brack = brack + '{'
        print spacer + 'for (int pos' + str(i) + ' = 0; pos' + str(i) + ' < Library[' + str(i) + '].size(); pos' + str(i) + '++)'
        print brack
        if i < 5 : print spacer + '    if (' + str(i) + ' >= ref1) AAints[' + str(i) + ' + ref0 - ref1] = Library[' + str(i) + '][pos' + str(i) + '];'
        else: print spacer + '    AAints[' + str(i) + ' + ref0 - ref1] = Library[' + str(i) + '][pos' + str(i) + '];'
    for i in range(23):
        brack = ''
        im = 22 - i
        for j in range(im * 4 + 4): brack = brack + ' '
        brack = brack + '}'
        print brack
        
def feather_nest2():
  
    for i in range(23):
        spacer = ''
        brack = ''
        for j in range(i * 4 + 4): spacer = spacer + ' '
        for j in range(i * 4 + 4): brack = brack + ' '
        brack = brack + '{'
        print spacer + 'for (int pos' + str(i) + ' = 0; pos' + str(i) + ' < Library[' + str(i) + '].size(); pos' + str(i) + '++)'
        print brack
        print spacer + '    seqi[' + str(i) + '] = Library[' + str(i) + '][pos' + str(i) + '];'
    for i in range(23):
        brack = ''
        im = 22 - i
        for j in range(im * 4 + 4): brack = brack + ' '
        brack = brack + '}'
        print brack
        
def yeast_genetic_code(codon):
  
    if codon in ['TTT', 'TTC']: return 'F'
    elif codon in ['TTA', 'TTG', 'CTT', 'CTC', 'CTA', 'CTG']: return 'L'
    elif codon in ['ATT', 'ATC', 'ATA']: return 'I'
    elif codon in ['ATG']: return 'M'
    elif codon in ['GTT', 'GTC', 'GTA', 'GTG']: return 'V'
    elif codon in ['TCT', 'TCC', 'TCA', 'TCG']: return 'S'
    elif codon in ['CCT', 'CCC', 'CCA', 'CCG']: return 'P'
    elif codon in ['ACT', 'ACC', 'ACA', 'ACG']: return 'T'
    elif codon in ['GCT', 'GCC', 'GCA', 'GCG']: return 'A'
    elif codon in ['TAT', 'TAC']: return 'Y'
    elif codon in ['TAA', 'TAG', 'TGA']: return 'X'
    elif codon in ['CAT', 'CAC']: return 'H'
    elif codon in ['CAA', 'CAG']: return 'Q'
    elif codon in ['AAT', 'AAC']: return 'N'
    elif codon in ['AAA', 'AAG']: return 'K'
    elif codon in ['GAT', 'GAC']: return 'D'
    elif codon in ['GAA', 'GAG']: return 'E'
    elif codon in ['TCT', 'TGC', 'TGT']: return 'C'
    elif codon in ['TGG']: return 'W'
    elif codon in ['CGT', 'CGC', 'CGA', 'CGG', 'AGA', 'AGG']: return 'R'
    elif codon in ['AGT', 'AGC']: return 'S'
    elif codon in ['GGT', 'GGC', 'GGA', 'GGG']: return 'G'
    elif codon in ['TAG']: return 'X'
    
def yeast_translation(aa):
  
    if aa == 'A': return 'GCT'
    elif aa == 'C': return 'TGT'
    elif aa == 'D': return 'GAT'
    elif aa == 'E': return 'GAA'
    elif aa == 'F': return 'TTT'
    elif aa == 'G': return 'GGT'
    elif aa == 'H': return 'CAT'
    elif aa == 'I': return 'ATT'
    elif aa == 'K': return 'AAA'
    elif aa == 'L': return 'TTA'
    elif aa == 'M': return 'ATG'
    elif aa == 'N': return 'AAT'
    elif aa == 'P': return 'CCA'
    elif aa == 'Q': return 'CAA'
    elif aa == 'R': return 'AGA'
    elif aa == 'S': return 'TCT'
    elif aa == 'T': return 'ACT'
    elif aa == 'V': return 'GTT'
    elif aa == 'W': return 'TGG'
    elif aa == 'Y': return 'TAC'
    elif aa == 'X': return 'TAA'
    
def translate_w2_data(ip, op):
  
    seqs = []
    bases = ['A', 'G', 'C', 'T']
    lines = readlines(ip)
    count = 0
    for line in lines:
        item = line.strip()
        use = True
        seq = 'PEIW'
        for i in range(len(item)):
            idx = 3 * i
            codon = item[idx:idx+3]
            if len(codon) != 3: continue
            if not codon[0] in bases or not codon[1] in bases or not codon[2] in bases:
            use = False 
            break
            aa = yeast_genetic_code(codon)
            if aa == 'X': use = False 
            if AAChar_int(aa) > 19 and aa != 'X':
            print codon
            return
            seq += aa
        if use:
        seq += 'NAYYARR'
            if not seq in seqs:
            seqs.append(seq)
    
    of = open(op, 'w')
    for seq in seqs: of.write(seq + '\n')
    of.close()
                
def w2_sort(p1, p2, op):
  
    l1 = readlines(p1)
    seqs1 = []
    for line in l1:
        seq = line.strip()
        seqs1.append(seq)
        
    l2 = readlines(p2)
    seqs2 = []
    for line in l2:
        seq = line.strip()
        seqs2.append(seq)
        
    of = open(op, 'w')
    for i in range(len(seqs1)):
        if seqs1[i] in seqs2: of.write(seqs1[i] + '\n')
    of.close()
    
def w2_express():
  
    l1 = lines2list('/home/bartolo/web/statium/deepseq/w2/Luther/2s4_0')
    l2 = lines2list('/home/bartolo/web/statium/deepseq/w2/Luther/2s8_0')
    of = open('/home/bartolo/web/statium/deepseq/w2/Luther/bcl2_nr_allowed.txt', 'w')
    idxs = [4, 7, 8, 9, 11, 12, 14]
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    allows = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    seq1 = []
    for i in range(len(l1)):
        aas = l1[i][0]
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq1 and allowed: seq1.append(seq)
    
    seq2 = []
    for i in range(len(l2)):
        aas = l2[i][0]
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq2 and allowed: seq2.append(seq)
    
    for seq in seq1:
        if seq in seq2: of.write(seq + '\n')
    of.close()
    
def mx_express():
  
    l1 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/xs4')
    l2 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/xs5')
    l3 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/xs6')
    of = open('/home/bartolo/web/statium/deepseq/mx/Luther/bclxl_ps_nr_allowed.txt', 'w')
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    idxs = [4, 8, 9, 11, 13, 15]
    allows = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    seq1 = []
    for aas in l1:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if seq[5] != bim[5] or seq[6] != bim[6] or seq[7] != bim[7] or seq[10] != bim[10] or seq[12] != bim[12] or seq[14] != bim[14]: allowed = False
        if not seq in seq1 and allowed: seq1.append(seq)
    
    seq2 = []
    for aas in l2:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
        if not seq in seq2 and allowed: seq2.append(seq)
    
    seq3 = []
    for aas in l3:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
        if not seq in seq3 and allowed: seq3.append(seq)
    
    for seq in seq1:
        if seq in seq2 and seq in seq3: of.write(seq + '\n')
    of.close()
    
def mx_spec_express():
  
    l1 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/ms4_xn1')
    l2 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/ms4_xn2')
    l3 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/ms4_xn3')
    l4 = readlines('/home/bartolo/web/statium/deepseq/mx/Luther/ms4_xn3_ms1')
    of = open('/home/bartolo/web/statium/deepseq/mx/Luther/mcl1_ns_nr_allowed.txt', 'w')
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    idxs = [4, 8, 9, 11, 13, 15]
    allows = ['FSYITNVAD', 'FSLPITVA', 'HRQNKSDEG', 'FSYITNVAD', 'HRQNKSDEG', 'FSYITNVAD']
    
    seq1 = []
    for aas in l1:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if seq[5] != bim[5] or seq[6] != bim[6] or seq[7] != bim[7] or seq[10] != bim[10] or seq[12] != bim[12] or seq[14] != bim[14]: allowed = False
        if not seq in seq1 and allowed: seq1.append(seq)
    
    seq2 = []
    for aas in l2:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
        if not seq in seq2 and allowed: seq2.append(seq)
    
    seq3 = []
    for aas in l3:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
        if not seq in seq3 and allowed: seq3.append(seq)
        
    seq4 = []
    for aas in l4:
        seq = aas.strip()
        allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
        if not seq in seq4 and allowed: seq4.append(seq)
    
    for seq in seq1:
        if seq in seq2 and seq in seq3 and seq in seq4: of.write(seq + '\n')
    of.close()
    
def f_express():
  
    l1 = readlines('/home/bartolo/web/statium/bfl1_sorts/Luther/ps2_0')
    print 'done1'
    l2 = readlines('/home/bartolo/web/statium/bfl1_sorts/Luther/ps4_0')
    print 'done2'
    l3 = readlines('/home/bartolo/web/statium/bfl1_sorts/Luther/ps5_0')
    print 'done3'
    of = open('/home/bartolo/web/statium/bfl1_sorts/Luther/bfl1_nr_allowed.txt', 'w')
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    idxs = [4, 5, 7, 8, 11, 14, 15]
    allows = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    
    seq1 = []
    i = 0
    for aas in l1:
        i += 1
        if i % 10000 == 0: print float(i) / float(len(l1))
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq1 and allowed: seq1.append(seq)
    
    seq2 = []
    i = 0
    for aas in l2:
        i += 1
        if i % 10000 == 0: print float(i) / float(len(l2))
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq2 and allowed: seq2.append(seq)
    
    seq3 = []
    i = 0
    for aas in l3:
        i += 1
        if i % 10000 == 0: print float(i) / float(len(l3))
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq3 and allowed: seq3.append(seq)
    
    for seq in seq1:
        if seq in seq2 and seq in seq3: of.write(seq + '\n')
    of.close()
    
def w2express():
  
    l1 = lines2list('/home/bartolo/web/statium/deepseq/w2/Luther/expressing.txt')
    of = open('/home/bartolo/web/statium/deepseq/w2/Luther/expressing_nr_allowed.txt', 'w')
    idxs = [4, 7, 8, 9, 11, 12, 14]
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    allows = ['CDEFGHIKLMNQRSVWY', 'CDEFGIKLMNRSVWY', 'ADFHLPSVY', 'AEGIKLRSTV', 'ACDEFGIKLMNRSTVWY', 'AG', 'EGQR']
    
    seq1 = []
    for i in range(len(l1)):
        aas = l1[i][0]
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq1 and allowed: of.write(seq + '\n')
    
    of.close()
    
def fexpress():
  
    l1 = readlines('/home/bartolo/web/statium/bfl1_sorts/Luther/express.txt')
    of = open('/home/bartolo/web/statium/bfl1_sorts/Luther/express_nr_allowed.txt', 'w')
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    idxs = [4, 5, 7, 8, 11, 14, 15]
    allows = ['FIKLMNY', 'ADHPSY', 'CDEFGIKLMNRSVWY', 'DHILNV', 'ACDFGHILNPRSTVY', 'AEIKLPQTV', 'CFIKLMNRSWY']
    
    print 'starting...'
    seq1 = []
    i = 0
    for aas in range(l1):
        i += 1
        if i % 1000 == 0: print i, 'of', len(l1)
        seq = ''
        for j in range(L):
        if j in idxs: seq += aas[idxs.index(j)]
        else: seq += bim[j]
    allowed = True
    for j in idxs:
        if not seq[j] in allows[idxs.index(j)]: allowed = False
    if not seq in seq1 and allowed: of.write(seq + '\n')
    of.close()
    
def sample_bh3_dna_library(preset, preset_spec):
  
    energy_bclxl = fast_design_energy(preset)
    energy_mcl1 = fast_design_energy(preset_spec)
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    DNA = []
    for i in range(L):
        DNA.append([])
        for j in range(3): DNA[i].append([])
    cod = yeast_translation('A')
    for i in range(3): DNA[5][i].append(cod[i])
    cod = yeast_translation('L')
    for i in range(3): DNA[8][i].append(cod[i])
    cod = yeast_translation('G')
    for i in range(3): DNA[12][i].append(cod[i])
    cod = yeast_translation('D')
    for i in range(3): DNA[13][i].append(cod[i])
    cod = yeast_translation('E')
    for i in range(3): DNA[14][i].append(cod[i])
    
    sample = [0, 1, 2, 3, 4, 6, 7, 9, 10, 11, 15, 16, 17, 18, 19, 20, 21, 22]
    
    for i in range(len(sample)):
        cod = yeast_translation(bim[sample[i]])
        for j in range(3): DNA[sample[i]][j].append(cod[j])
        
    lib_data = dna_lib_size(DNA)
    trans_lib = lib_data[1]
    size = lib_data[0]
    
    e = statium_library_energy(energy_bclxl, trans_lib)
    
    while size < 10 ** 8:
    pos = sample[random.randint(0, len(sample) - 1)]
    site = random.randint(0, 2)
    choices = ''
    for base in 'ACTG':
        if not base in DNA[pos][site]: choices += base
    if choices == '': continue
    choice = choices[random.randint(0, len(choices) - 1)]
    DNA[pos][site].append(choice)
    lib_data = dna_lib_size(DNA)
    trans_lib = lib_data[1]
    size = lib_data[0]
    e1 = statium_library_energy(energy_bclxl, trans_lib)
    if e1 < e: e = e1
    else: DNA[pos][site].remove(choice)
    
    attempts = 0
    status = 0
    while (status == 0):
        attempts += 1
        if attempts == 10000: status = 1
        option = random.randint(0, 2)
        if option == 0:
        pos = sample[random.randint(0, len(sample) - 1)]
        site = random.randint(0, 2)
        choices = ''
        for base in 'ACTG':
            if not base in DNA[pos][site]: choices += base
        if choices == '': continue
        choice = choices[random.randint(0, len(choices) - 1)]
        DNA[pos][site].append(choice)
        lib_data = dna_lib_size(DNA)
        trans_lib = lib_data[1]
        size = lib_data[0]
        e1 = statium_library_energy(energy_bclxl, trans_lib)
        if e1 < e and size < 10 ** 8:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: DNA[pos][site].remove(choice)
        elif option == 1:
        pos = sample[random.randint(0, len(sample) - 1)]
        site = random.randint(0, 2)
        choices = ''
        for base in 'ACTG':
            if base in DNA[pos][site]: choices += base
        if len(choices) == 1: continue
        choice = choices[random.randint(0, len(choices) - 1)]
        DNA[pos][site].remove(choice)
        lib_data = dna_lib_size(DNA)
        trans_lib = lib_data[1]
        size = lib_data[0]
        e1 = statium_library_energy(energy_bclxl, trans_lib)
        if e1 < e and size > 10 ** 4:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: DNA[pos][site].append(choice)
        elif option == 2:
        pos = sample[random.randint(0, len(sample) - 1)]
        site = random.randint(0, 2)
        choices = ''
        for base in 'ACTG':
            if not base in DNA[pos][site]: choices += base
        if len(choices) == 0: continue
        base_idx = random.randint(0, len(DNA[pos][site]) - 1)
        aa0 = DNA[pos][site][base_idx]
        choice = choices[random.randint(0, len(choices) - 1)]
        DNA[pos][site][base_idx] = choice
        lib_data = dna_lib_size(DNA)
        trans_lib = lib_data[1]
        size = lib_data[0]
        e1 = statium_library_energy(energy_bclxl, trans_lib)
        if e1 < e and size > 10 ** 4 and size < 10 ** 8:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: DNA[pos][site][base_idx] = aa0
        
        
    lib_data = dna_lib_size(DNA)
    trans_lib = lib_data[1]
    size = lib_data[0]
    
    for i in range(len(trans_lib)):
        s1 = ''
        for j in range(len(trans_lib[i])): s1 += trans_lib[i][j]
        print s1
    e = statium_library_energy(energy_bclxl, trans_lib)
    e_spec = statium_library_energy(energy_mcl1, trans_lib)
    print e, e_spec
    
def sample_bh3_prot_library(preset, preset_spec):
  
    energy_bclxl = fast_design_energy(preset)
    energy_mcl1 = fast_design_energy(preset_spec)
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    prot = []
    for i in range(L):
        prot.append([])
    prot[5].append('A')
    prot[8].append('L')
    prot[12].append('G')
    prot[13].append('D')
    prot[14].append('E')
    
    sample = [0, 1, 2, 3, 4, 6, 7, 9, 10, 11, 15, 16, 17, 18, 19, 20, 21, 22]
    
    for i in range(len(sample)): prot[sample[i]].append(bim[sample[i]])

    size = prot_lib_size(prot)
    
    e = statium_library_energy(energy_bclxl, prot)
    
    while size < 10 ** 5:
    pos = sample[random.randint(0, len(sample) - 1)]
    choices = ''
    for aa in 'ACDEFGHIKLMNPQRSTVWY':
        if not aa in prot[pos]: choices += aa
    if choices == '': continue
    choice = choices[random.randint(0, len(choices) - 1)]
    prot[pos].append(choice)
    size = prot_lib_size(prot)
    e1 = statium_library_energy(energy_bclxl, prot)
    if e1 < e: e = e1
    else: prot[pos].remove(choice)
    
    attempts = 0
    status = 0
    while (status == 0):
        attempts += 1
        if attempts == 10000: status = 1
        option = random.randint(0, 2)
        if option == 0:
        pos = sample[random.randint(0, len(sample) - 1)]
        choices = ''
        for aa in 'ACDEFGHIKLMNPQRSTVWY':
            if not aa in prot[pos]: choices += aa
        if choices == '': continue
        choice = choices[random.randint(0, len(choices) - 1)]
        prot[pos].append(choice)
        size = prot_lib_size(prot)
        e1 = statium_library_energy(energy_bclxl, prot)
        if e1 < e and size < 10 ** 8:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: prot[pos].remove(choice)
        elif option == 1:
        pos = sample[random.randint(0, len(sample) - 1)]
        choices = ''
        for aa in 'ACDEFGHIKLMNPQRSTVWY':
            if aa in prot[pos]: choices += aa
        if len(choices) == 1: continue
        choice = choices[random.randint(0, len(choices) - 1)]
        prot[pos].remove(choice)
        size = prot_lib_size(prot)
        e1 = statium_library_energy(energy_bclxl, prot)
        if e1 < e and size > 10 ** 4:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: prot[pos].append(choice)
        elif option == 2:
        pos = sample[random.randint(0, len(sample) - 1)]
        choices = ''
        for aa in 'ACDEFGHIKLMNPQRSTVWY':
            if not aa in prot[pos]: choices += aa
        if len(choices) == 0: continue
        aa_idx = random.randint(0, len(prot[pos]) - 1)
        aa0 = prot[pos][aa_idx]
        choice = choices[random.randint(0, len(choices) - 1)]
        prot[pos][aa_idx] = choice
        size = prot_lib_size(prot)
        e1 = statium_library_energy(energy_bclxl, prot)
        if e1 < e and size > 10 ** 4 and size < 10 ** 8:
            e = e1
            print option, e, size, attempts
            attempts = 0
        else: prot[pos][aa_idx] = aa0
        
        
    size = prot_lib_size(prot)
    
    for i in range(len(prot)):
        s1 = ''
        for j in range(len(prot[i])): s1 += prot[i][j]
        print s1
    e = statium_library_energy(energy_bclxl, prot)
    e_spec = statium_library_energy(energy_mcl1, prot)
    print e, e_spec
    
def dna_lib_size(lib):
  
    trans_lib = []
    for i in range(len(lib)):
        aas = []
        for f0 in lib[i][0]:
        for f1 in lib[i][1]:
            for f2 in lib[i][2]:
            cod = f0 + f1 + f2
            aa = yeast_genetic_code(cod)
            if not aa in aas: aas.append(aa)
    trans_lib.append(aas)
    
    size = 1
    for i in range(len(trans_lib)):
        size = size * len(trans_lib[i])
      
    return [size, trans_lib]
    
def prot_lib_size(lib):
    
    size = 1
    for i in range(len(lib)):
        size = size * len(lib[i])
      
    return size
    
def compare_libs(lp):

    l = []
    lines = readlines(lp)
    for i in range(len(lines)):
        seq = lines[i].strip()
        l.append([])
        for j in range(len(seq)): l[i].append(seq[j])
        
    print l
        
    energy_bclxl = fast_design_energy('/home/bartolo/web/statium/bclxl/bclxl_3io8')
    energy_mcl1 = fast_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    print 'x', statium_library_energy(energy_bclxl, l)
    print 'm', statium_library_energy(energy_mcl1, l)
    
def plot_spec(in_path, op):
  
    data = lines2list(in_path)
    
    val = []
    val.append([])
    val.append([])
    
    L = 0
    for i in range(len(data)):
        if len(data[i]) == len(data[1]):
        val[0].append(data[i][0])
        mspec = 100000.0
            #for j in range(len(data[i]) - 2):
            #if data[i][j + 1] < mspec:
            #mspec = data[i][j + 1]
        #val[1].append(mspec)
        val[1].append(data[i][4])
           
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    a = pylab.array(val[0])
    a1 = pylab.array(val[1])
    pylab.plot(a, a1, 'k', lw=2)
    pylab.savefig(op)
    
def plot_classy(in_path, rstr, op):
  
    cstr = []
    for i in range(len(rstr)):
        if rstr[i] == 'm': cstr.append('r')
        elif rstr[i] == 'x': cstr.append('b')
        elif rstr[i] == 'w': cstr.append('g')
        elif rstr[i] == 'f': cstr.append('k')
        elif rstr[i] == 'b': cstr.append('c')
  
    data = lines2list(in_path)
    
    val = []
    for i in range(len(data[1]) - 1): val.append([])
    
    L = 0
    for i in range(len(data)):
        val[0].append(data[i][0])
        for j in range(len(val) - 1):
        val[j + 1].append(data[i][j + 1])
           
    import matplotlib
    matplotlib.use( 'Agg' )      
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')

    a0 = pylab.array(val[0])
    for i in range(len(val) - 1):
        a = pylab.array(val[i + 1])
        if rstr[i + 1] == 'm': l = 'Mcl-1'
        elif rstr[i + 1] == 'x': l = 'Bcl-xL'
        elif rstr[i + 1] == 'w': l = 'Bcl-w'
        elif rstr[i + 1] == 'f': l = 'Bfl-1'
        elif rstr[i + 1] == 'b': l = 'Bcl-2'
        pylab.plot(a0, a, cstr[i + 1], lw=2, label=l)
    pylab.legend(loc='lower right')
    pylab.savefig(op)
    
def stephanie(su, sun):
    print su
    print su[0]
    print su[-1]
    print su[0:-2]
    print sun
    print su+sun
    
def analyze_classy(in_dir):
  
    od = os.path.join(in_dir, 'plots')
    if not os.path.exists(od): os.mkdir(od)
    rstr = in_dir.split('_')[1]
    op = os.path.join(od, rstr + '_classy.png')
    
    energies = []
    classy = []
    in_list = os.listdir(in_dir)
    for file in in_list:
        if len(file.split('.')) > 1:
        data = lines2list(os.path.join(in_dir, file))
        if not data[-1][1] in energies:
        energies.append(data[-1][1])
        sub = []
        for j in range(len(rstr) + 1): sub.append(data[-1][j + 1])
        sub.append(data[-1][0])
        classy.append(sub)
        
    classy.sort()
    
    cstr = []
    for i in range(len(rstr)):
        if rstr[i] == 'm': cstr.append('r')
        elif rstr[i] == 'x': cstr.append('b')
        elif rstr[i] == 'w': cstr.append('g')
        elif rstr[i] == 'f': cstr.append('k')
        elif rstr[i] == 'b': cstr.append('c')
    
    val = []
    for i in range(len(rstr)): val.append([])
    
    
    for i in range(len(classy)):
        print classy[i][-1]
        val[0].append(classy[i][0])
        for j in range(len(rstr) - 1): val[j + 1].append(classy[i][j + 1] * -1.0)
           
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
    #print len(val[0])
    a0 = pylab.array(val[0])
    for i in range(len(val) - 1):
        a = pylab.array(val[i + 1])
        if rstr[i + 1] == 'm': l = 'Mcl-1'
        elif rstr[i + 1] == 'x': l = 'Bcl-xL'
        elif rstr[i + 1] == 'w': l = 'Bcl-w'
        elif rstr[i + 1] == 'f': l = 'Bfl-1'
        elif rstr[i + 1] == 'b': l = 'Bcl-2'
        pylab.plot(a0, a, cstr[i + 1], lw=2, label=l)
    pylab.legend(loc='upper right')
    pylab.savefig(op)
    
def combine_classy(in_dirs, op):
  
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '20'
    pylab.rcParams['ytick.labelsize'] = '20'
  
    for in_dir in in_dirs:
  
        rstr = in_dir.split('_')[1]
    
        energies = []
        classy = []
        in_list = os.listdir(in_dir)
        for file in in_list:
            if len(file.split('.')) > 1:
            data = lines2list(os.path.join(in_dir, file))
            if not data[-1][1] in energies:
            energies.append(data[-1][1])
            sub = []
            for j in range(len(rstr) + 1): sub.append(data[-1][j + 1])
            sub.append(data[-1][0])
            classy.append(sub)
        
        classy.sort()
    
        cstr = []
        for i in range(len(rstr)):
            if rstr[i] == 'm': cstr.append('r')
            elif rstr[i] == 'x': cstr.append('b')
            elif rstr[i] == 'w': cstr.append('g')
            elif rstr[i] == 'f': cstr.append('k')
            elif rstr[i] == 'b': cstr.append('c')
    
        val = []
        for i in range(len(rstr)): val.append([])
    
    
        for i in range(len(classy)):
            val[0].append(classy[i][0])
            for j in range(len(rstr) - 1): val[j + 1].append(classy[i][j + 1] * -1.0)
           

        #print len(val[0])
        a0 = pylab.array(val[0])
        for i in range(len(val) - 1):
            a = pylab.array(val[i + 1])
            if rstr[i + 1] == 'm': l = 'Mcl-1'
            elif rstr[i + 1] == 'x': l = 'Bcl-xL'
            elif rstr[i + 1] == 'w': l = 'Bcl-w'
            elif rstr[i + 1] == 'f': l = 'Bfl-1'
            elif rstr[i + 1] == 'b': l = 'Bcl-2'
            pylab.plot(a0, a, cstr[i + 1], lw=2, label=l)
            
    pylab.legend(loc='upper right')
    pylab.savefig(op)
    
def delete_coyote():
  
    tmp = '/home/bartolo/web/coy_del.txt'
    os.system('qstat | grep bartolo | grep test > ' + tmp)
    lines = readlines(tmp)
    for line in lines:
        os.system('qdel ' + line.split()[0].split('.')[0])
        
def ccsort(ip, op):
  
    if not os.path.exists(op): os.mkdir(op)
  
    l = os.listdir(ip)
    for file in l:
        p = os.path.join(ip, file)
        n = file[0:len(file) - 1]
        p2 = os.path.join(op, n)
        os.system('cp ' + p + ' ' + p2)
        
def bfl1_seq_sort(ip, op):
  
    lines = lines2list(ip)
    seqs = []
    for i in range(len(lines)):
        line = lines[i][0].strip()
        use = True
        for j in range(len(line)):
        if AAChar_int(line[j]) >= 20:
            use = False
    if use:
            seq = 'PEIW' + line + 'NAYYARR'
            if not seq in seqs:
            seqs.append(seq)
                if len(seqs) % 10000 == 0: print len(seqs), i, 'of', len(lines)
            
    of = open(op, 'w')
    for i in range(len(seqs)): of.write(seqs[i] + '\n')
    of.close()
    
def bfl1_seq_sort2():
  
    l = readlines('/home/bartolo/web/statium/bfl1_sorts/ps4cs2_new_nr.txt')
    l1 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps2_new_nr.txt')
    l2 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps4_new_nr.txt')
    l3 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps5_new_nr.txt')
    
    seqs = []
    for line in l:
        if line in l1 and line in l2: seqs.append(line)
        
    of = open('/home/bartolo/web/statium/bfl1_sorts/bfl1_ns_nr.txt', 'w')
    for seq in seqs: of.write(seq)
    of.close()
    
def general_deep_sort():
  
    #l = readlines('/home/bartolo/web/statium/bfl1_sorts/ps4cs2_new_nr.txt')
    l1 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps2_new_nr.txt')
    l2 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps4_new_nr.txt')
    l3 = readlines('/home/bartolo/web/statium/bfl1_sorts/ps5_new_nr.txt')
    
    seqs = []
    for line in l3:
        if line in l1 and line in l2: seqs.append(line)
        
    of = open('/home/bartolo/web/statium/bfl1_sorts/test.txt', 'w')
    for seq in seqs: of.write(seq)
    of.close()
    
def print_pair_energy(p, a2):
  
    preset = os.path.split(p)[0]
    pos0 = int(os.path.split(p)[1].split('_')[0]) - 1
    seqint_data = lines2list(preset + '.seqint')
    seqint = []
    for i in range(len(seqint_data)): seqint.append(int(seqint_data[i][0]))
  
    d = lines2list(p)
    print AAChar_fasta(seqint[pos0]), round(float(d[seqint[pos0] + 1][AAChar_int(a2) + 1]), 3)
 
def arrayIII_bar():
  
    data = lines2list('/home/bartolo/web/statium/ArrayIII/signal.txt')
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '4'
    pylab.rcParams['ytick.labelsize'] = '4'
    pylab.rcParams['savefig.dpi'] = '300'
    
    count = 0
    for i in range(len(data)):
        if len(data[i]) == 6:
        r = data[i][5].split('_')[0]
        BH3 = data[i][5].split('_')[1]
        #if BH3 in ['Bim', 'Hrk', 'Bad', 'Mule', 'Noxa', 'Puma', 'Bmf', 'Bak']: continue
        #if not BH3 in ['design1', 'design2', 'design3', 'design4']: continue
        if BH3 != 'Lyso': continue
        count += 1
        labels = ['WT', '3aD', '3eL']

        print data[i]
        
        xs = pylab.arange(3)
        ys = pylab.array([data[i][1], data[i][2], data[i][4]])
        #matplotlib.pyplot.subplot(1, 1, count)
        #matplotlib.pyplot.title(r + ', ' + BH3, fontsize=8)
        #matplotlib.pyplot.bar(xs, ys, 0.35, color='r', align='center')
            pylab.bar(xs, ys, 0.35, color='r', align='center')
        pylab.xticks([], [])
        pylab.yticks([], [])
        #pylab.ylim(0.0, 1.2)
        pylab.savefig('/home/bartolo/web/statium/ArrayIII/DesignBH3_' + BH3 + '.png')
        return
    
def noxa_spots():
  
    sigs = lines2list('/home/bartolo/web/statium/bad_noxa/bad_raw.txt')
    
    p = [1, 4, 5, 7, 8, 9, 11, 12, 13, 14, 15, 16, 19]
    aa = ['D', 'E', 'K', 'R', 'H', 'N', 'Q', 'S', 'T', 'P', 'G', 'A', 'V', 'I', 'L', 'F', 'Y', 'W']
    #noxa = 'LEVECATQLRRFGDKLNFRQKLL'
    noxa = 'AAQRYGRELRRMSDEFVDSFKKG'
    seq = []
    for i in range(len(noxa)): seq.append(noxa[i])
    
    sig = []
    for i in range(len(sigs)):
        if (i + 1) % 20 != 0: sig.append(sigs[i][0])
    
    seqs = []
    for i in range(len(p)):
        seqs.append(noxa)
        for j in range(len(aa)):
        seq = []
            for k in range(len(noxa)): seq.append(noxa[k])
            seq[p[i]] = aa[j]
            bh3 = ''
            for k in range(len(noxa)): bh3 += seq[k]
            seqs.append(bh3)
    
    wt = 0.0
    counts = 0.0
    for i in range(len(seqs)):
        if i + 1 in [1, 21, 41, 61, 81, 101, 121, 141]: continue
        if seqs[i] == noxa:
        wt += sig[i]
        counts += 1.0
    wt_sig = wt / counts
    
    for i in range(len(seqs)):
        print seqs[i], -1.0 * math.log10(sig[i] / wt_sig)
        
def seqint(p):
  
    l = readline(p, 1)
    for i in range(len(l)): print AAChar_int(l[i])
    
def sort_corr():
  
    #import pylab
    #print pylab.rcParams
    #return
  
    ip = '/home/bartolo/web/statium/SPOT200_logs.txt'
    np = '/home/bartolo/web/statium/bad_noxa/noxa_log.txt'
    bp = '/home/bartolo/web/statium/bad_noxa/bad_log.txt'
    
    data = lines2list(ip)
    nd = lines2list(np)
    bd = lines2list(bp)
    
    spots = []
    for i in range(7):spots.append([])
    
    rvec = ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1', 'Bcl-2', 'Bcl-xL-Bad', 'Mcl-1-Noxa']
    pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bad = 'AAQRYGRELRRMSDEFVDSFKKG'
    noxa = 'LEVECATQLRRFGDKLNFRQKLL'
    N = len(bim)
    for i in range(len(data)):
        bim_seq = data[i][0]
        change = False
        for j in range(N):
        if bim_seq[j] != bim[j]:
            change = True
            change_pos = j
            change_aa = bim_seq[j]
            break
    if change:
        foundb = False
        for j in range(len(bd)):
            bseq = bd[j][0]
            if bseq[change_pos] != bad[change_pos] and bseq[change_pos] == change_aa:
            b = bd[j][1]
            foundb = True
            break
        foundn = False
        for j in range(len(nd)):
            nseq = nd[j][0]
            if nseq[change_pos] != noxa[change_pos] and nseq[change_pos] == change_aa:
            foundn = True
            n = nd[j][1]
            break
        if foundb and foundn:
                for j in range(5):
                spots[j].append(data[i][2 + j])
            spots[5].append(b)
        spots[6].append(n)
     
    rvec2 = ['Mcl-1\nNoxa', 'Mcl-1\nBim', 'Bcl-xL\nBim', 'Bcl-2\nBim', 'Bcl-w\nBim', 'Bcl-xL\nBad', 'Bfl-1\nBim']
    spots2 = []
    spots2.append(spots[6])
    spots2.append(spots[1])
    spots2.append(spots[0])
    spots2.append(spots[4])
    spots2.append(spots[2])
    spots2.append(spots[5])
    spots2.append(spots[3])

    
    import pylab
    v1 = []
    for i in range(7):
        sub = []
        for j in range(7):
        sub.append(round(pylab.corrcoef(pylab.array(spots2[i]), pylab.array(spots2[j]))[0][1], 2))
    v1.append(sub)
        
    xlabel = []
    ylabel = []
    N = len(rvec2)
    for i in range(N): xlabel.append(rvec2[i])
    for i in range(N): ylabel.append(rvec2[i])
    
    #v2 = []
    #for i in range(len(v1)):
        #v2.append(v1[-i - 1])
    
    #ylabel.reverse()
    #labels = [r'$PSSM_{SPOT}$', r'$PSSM_{DEEP}$', r'$STATIUM$']
        
    import pylab
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['image.cmap'] = 'Blues'
    #pylab.rcParams['font.style'] = 'bold'
    #pylab.rcParams['text.usetex'] = True
    pylab.pcolor(pylab.array(v1), edgecolors='k', linewidths=2)
    #cmd=pylab.cm.datad['Greys'])
    pylab.xticks(pylab.arange(N) + 0.5, xlabel, rotation= 30.0, style = 'oblique')
    pylab.yticks(pylab.arange(N) + 0.5, ylabel, rotation= 30.0)
    ind = pylab.arange(N)  # the x locations for the groups
    width = 0.0       # the width of the bars

    #fig = pylab.figure()
    #ax = fig.add_subplot(111)
    #ax.set_yticks(ind+width)
    #pylab.set_yticklabels( ylabel )
    #pylab.yticks(pylab.arange(N), ylabel)
    pylab.colorbar()
    pylab.savefig('/home/bartolo/web/statium/SPOT200_stat_matrix2.png')
    pylab.close()

def hist_double():
  
    xd = lines2list('/home/sdutta/deepsequencing/xl2wlib/naivexllibmscore')
    yd = lines2list('/home/sdutta/deepsequencing/xl2wlib/mscorews8')
    
    xv = []
    yv = []
    
    for i in range(len(xd)): xv.append(xd[i][0] * -1.0)
    for i in range(len(yd)): yv.append(yd[i][0] * -1.0)
  
    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.hist(pylab.array(yv), normed=True, facecolor='white', edgecolor='blue', lw=2)
    pylab.hist(pylab.array(xv), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
    #pylab.yticks([])
    #pylab.xticks([])
    pylab.savefig('/home/bartolo/web/statium/sanjib_mws8.png')
    pylab.close()
        
def compo():

    data = lines2list('/home/bartolo/web/Orr/TCS_energies.txt')
    
    count = 0
    e = 0.0
    for i in range(len(data)):
        count += 1
        e += data[i][1]
        if count % 20 == 0:
        print data[i][0], e / float(count)
        e = 0.0

def sort_Nir():

    mine = lines2list('/home/bartolo/web/SPOT_360p.txt')
    nir = lines2list('/home/bartolo/web/statium/Nir/seq_360.txt')
    xe = lines2list('/home/bartolo/web/statium/Nir/xe_360.txt')
    xs = lines2list('/home/bartolo/web/statium/Nir/xs_360.txt')
    me = lines2list('/home/bartolo/web/statium/Nir/me_360.txt')
    ms = lines2list('/home/bartolo/web/statium/Nir/ms_360.txt')
    
    data = []
    for i in range(len(mine)):
        for j in range(len(nir)):
        if nir[j][0] == mine[i][0]:
            print nir[j][0], xe[j][0], xs[j][0], me[j][0], ms[j][0]
            
def bfl1_what():
  
  data = lines2list('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr_allowed.txt')
  
  of = open('/home/bartolo/web/statium/bfl1_sorts/bfl1_ps_nr_allowed_fixE.txt', 'w')
  for i in range(len(data)):
      #if data[i][0][4] == 'E' and data[i][0][2] == 'A' and data[i][0][4] == 'E' and data[i][0][5] == 'L' and data[i][0][11] == 'E' and data[i][0][8] == 'T': of.write(data[i][0] + '\n')
      if data[i][0][5] == 'V': of.write(data[i][0] + '\n')
  of.close()
  
def genome_sorting(ridx):
  
    base = 2
  
    data = lines2list('/home/bartolo/web/statium/BH3_test_loose_twoscores.txt')
    N = len(data)
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    bcl2_primary_network = ['BCL2L1', 'MCL1', 'BCL2L2', 'BCL2A1', 'BCL2']
       
    bcln = []
    bcln.append(retrieve_network(interactions, 'BCL2L1', base))
    bcln.append(retrieve_network(interactions, 'MCL1', base))
    bcln.append(retrieve_network(interactions, 'BCL2L2', base))
    bcln.append(retrieve_network(interactions, 'BCL2A1', base))
    bcln.append(retrieve_network(interactions, 'BCL2', base))
    
    #for i in range(5):
        #for j in range(len(bcln[i])):
        #if not bcln[i][j] in bcl2_primary_network:
            #bcln.append(retrieve_network(interactions, bcln[i][j], base))
            #bcl2_primary_network.append(bcln[i][j])
    
    hits = []
    for i in range(len(data)):
        if len(data[i]) != 12: continue
        try: target_short = ls_dict[string.join(data[i][-1].strip().split('_'), ' ')]
    except: continue
        flat_target = retrieve_network(interactions, target_short, base)
        try: target_locals = local_dict[target_short]
        except: target_locals = '-'
        shared_vec = []
        shared_names = []
        shared_hit = False
        if len(flat_target) > 0:
        for j in range(len(bcln)):
            sharing = network_shared(bcln[j], flat_target)
            shared = sharing[0]
            shared_names.append(sharing[1])
                shared_vec.append(shared)
                if shared > 0.0: shared_hit = True
        else: shared_vec = [-1, -1, -1, -1, -1]
                
        for j in range(11): print data[i][j],
        for j in range(5): print shared_vec[j],
        print string.join(data[i][-1].strip().split('_'), ' '),
        print ':::::', target_locals
        
        if data[i][0][8] == 'C' or data[i][0][13] in 'MC': continue
        if not shared_hit: continue
        
        if (data[i][1] < 1.0 or data[i][2] < 2.5 or data[i][3] < 0.5 or data[i][4] < 0.5 or data[i][5] < 0.5) and (data[i][6] - 5.33 < 2.5 or data[i][7] - 8.13 < -3.0 or data[i][8] - 8.41 < 0.0 or data[i][9] - 3.41 < 0.0 or data[i][10] - 5.5 < 0.0):
        hits.append([data[i][ridx], data[i], shared_vec, target_locals])
        #print sl_dict[target_short]
        #print data[i][0], data[i][ridx], string.join(data[i][-1].strip().split('_'), ' ')
        #for j in range(len(shared_names)):
            #if len(shared_names[j]) > 0:
                #print '\t', bcl2_primary_network[j]
                #for k in range(len(shared_names[j])): print '\t\t', shared_names[j][k]
        #print
        #print
        
    hits.sort()
    for i in range(len(hits)):
        for j in range(6): print hits[i][1][j],
        #for j in range(5): print round(hits[i][2][j], 2),
        print string.join(hits[i][1][-1].strip().split('_'), ' '),
        print ':::::', hits[i][3]
        
def genome_ordering():
  
    #paths = ['/home/bartolo/web/statium/BH3_heuristic_all.txt', '/home/bartolo/web/statium/BH3_heuristic_energy_nonetwork2.txt', '/home/bartolo/web/statium/BH3_heuristic_noenergy_innetwork.txt', '/home/bartolo/web/statium/BH3_heuristic_energy_innetwork2.txt']
    paths = ['/home/bartolo/web/statium/BH3_heuristic_all.txt', '/home/bartolo/web/statium/BH3_heuristic_energy_nonetwork2_pssm_only.txt', '/home/bartolo/web/statium/BH3_heuristic_energy_nonetwork2_statium_only.txt', '/home/bartolo/web/statium/BH3_heuristic_energy_innetwork2_pssmalign.txt']
    data = []
    for path in paths: data.append(lines2list(path))
  
    known = ['WAREIGAQLRRMADDLNAQYERR','PEIWIAQELRRIGDEFNAYYARR','LEVECATQLRRFGDKLNFRQKLL','AAQRYGRELRRMSDEFVDSFKKG','TMGQVGRQLAIIGDDINRRYDSE','STKKLSECLKRIGDELDSNMELQ','EGEKEVEALKKSADWVSDWSSRP','AAQLTAARLKALGDELHQRTMWR','AEVQIARKLQCIADQFHRLHVQQ','GSDALALRLACIGDEMDVSLRAP','IIRNIARHLAQVGDSMDRSIPPG','MTQEVGQLLQDMGDDVYQQYRSL','TMENLSRRLKVTGDLFDIMSGQT','RLAEVCAVLLRLGDELEMIRPSV','VLGKAVHSLSRIGDELYLEPLED','VFGKAVQALSRISDEFWLDPSKK','EFARIARDLSHIGDAVVISAAKD','ILAKIVELLKYSGDQLERKDTAF','ILAKIVELLKYSGDQLERKLKKD','VPPVVHLTLRQAGDDFSRRYRRD','AADPLHQAMRAAGDEFETRFRRT'
,'PMAAVKQALREAGDEFELRYRRA','TSRKALETLRRVGDGVQRNHETA', 'DVAIIAGRLRMLGDQFNGELEAS']

    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    import matplotlib
    
    for k in range(len(data)):
        totalc = 0
        knownc = 0
        toplot = [[], []]
        for i in range(len(data[k])):
            seq = data[k][i][0]
            totalc += 1
            toplot[0].append(i + 1)
            if seq in known: knownc += 1
            toplot[1].append(float(knownc) / float(totalc))
        
        knownf = float(knownc) / float(totalc)
        print knownf

        matplotlib.pyplot.subplot(2, 2, k + 1)
        #matplotlib.pyplot.figure(figsize=(8,8))
        #matplotlib.pyplot.axes([0.1, 0.1, 0.8, 0.8])
        matplotlib.pyplot.pie([knownf, 1 - knownf], explode=[0.05, 0.0], labels=[str(round(knownf * 100.0, 1)) + '%', ''], colors=['r', 'b'], autopct=None, shadow=True)
    pylab.savefig('/home/bartolo/web/statium/BH3_heuristic_piechart2.png')
    pylab.close()
        
def genome_sorting2():

    import matplotlib
    matplotlib.use( 'Agg' )
  
    known = ['ILAKIVELLKYSGDQLERKDTAF', 'ILAKIVELLKYSGDQLERKLKKD', 'VFGKAVQALSRISDEFWLDPSKK', 'VLGKAVHSLSRIGDELYLEPLED', 'EFARICRDLSHIGDAVVISCAKD', 'RLAEVCAVLLRLGDELEMIRPSV', 'TMENLSRRLKVTGDLFDIMSGQT', 'LEVECATQLRRFGDKLNFRQKLL', 'AEVQIARKLQCIADQFHRLHVQQ', 'STKKLSECLKRIGDELDSNMELQ', 'MTQEVGQLLQDMGDDVYQQYRSL', 'AAQLTAARLKALGDELHQRTMWR', 'IIRNIARHLAQVGDSMDRSIPPG', 'AADPLHQAMRAAGDEFETRFRRT', 'AAQRYGRELRRMSDEFVDSFKKG', 'GSDALALRLACIGDEMDVSLRAP', 'VPPVVHLTLRQAGDDFSRRYRRD', 'PEIWIAQELRRIGDEFNAYYARR', 'TMGQVGRQLAIIGDDINRRYDSE', 'WAREIGAQLRRMADDLNAQYERR']
  
    data = lines2list('/home/bartolo/web/statium/BH3_test_loose_twoscores_IN.txt')
    
    data_sort = []
    for i in range(10): data_sort.append([])
    
    for i in range(10):
        for j in range(len(data)):
        #print data[j]
        data_sort[i].append([data[j][1 + i], data[j]])
    data_sort[i].sort()
    
    tops = []
    tops_nostat = []
    tops_nonet = []
    tops_pred = []
    for i in range(10):
        tops.append([[], []])
        tops_nostat.append([[], []])
        tops_nonet.append([[], []])
        tops_pred.append([[], []])
        
        found = 0
        total = 0
        for j in range(len(data_sort[i])):
        
        if data_sort[i][j][1][0][13] != 'D': continue
        
        in_network = False
        if data_sort[i][j][1][11] > 0.0 or data_sort[i][j][1][12] > 0.0 or data_sort[i][j][1][13] > 0.0 or data_sort[i][j][1][14] > 0.0 or data_sort[i][j][1][15] > 0.0:
            in_network = True
        if not in_network: continue
        
        stat_check = False
        if data_sort[i][j][1][6] - 5.33 <= 4.95 or data_sort[i][j][1][7] - 8.15 <= -3.76: stat_check = True
        
        
        if not stat_check: continue
        
        total += 1
        if data_sort[i][j][1][0] in known:
            found += 1
            
        if found < 1: continue
        tops[i][0].append(total)
        tops[i][1].append(round(float(found) / float(total), 5))
        if i == 0:
            print data_sort[i][j][1][0], data_sort[i][j][1][1], data_sort[i][j][1][2],
            for k in range(16, len(data_sort[i][j][1])): print data_sort[i][j][1][k],
            print
        
        found = 0
        total = 0
        for j in range(len(data_sort[i])):
      
        if data_sort[i][j][1][0][13] != 'D': continue
      
        #if data_sort[i][j][1][0] in known: continue
      
        in_network = False
        if data_sort[i][j][1][11] > 0.0 or data_sort[i][j][1][12] > 0.0 or data_sort[i][j][1][13] > 0.0 or data_sort[i][j][1][14] > 0.0 or data_sort[i][j][1][15] > 0.0:
            in_network = True
        #if not in_network: continue
        
        stat_check = False
        if data_sort[i][j][1][6] - 5.33 <= 4.95 or data_sort[i][j][1][7] - 8.15 <= -3.76: stat_check = True
        
        
        if not stat_check: continue
        
        total += 1
        if in_network:
            found += 1
            
        if found < 1: continue
        tops_pred[i][0].append(total)
        tops_pred[i][1].append(round(float(found) / float(total), 5))

        found = 0
        total = 0
        for j in range(len(data_sort[i])):
      
        if data_sort[i][j][1][0][13] != 'D': continue
      
        in_network = False
        if data_sort[i][j][1][11] > 0.0 or data_sort[i][j][1][12] > 0.0 or data_sort[i][j][1][13] > 0.0 or data_sort[i][j][1][14] > 0.0 or data_sort[i][j][1][15] > 0.0:
            in_network = True
        if not in_network: continue
        
        stat_check = False
        if data_sort[i][j][1][6] - 5.33 <= 4.95 or data_sort[i][j][1][7] - 8.15 <= -3.76: stat_check = True
        
        
        #if not stat_check: continue
        
        total += 1
        if data_sort[i][j][1][0] in known:
            found += 1
        if found < 1: continue
        tops_nostat[i][0].append(total)
        tops_nostat[i][1].append(round(float(found) / float(total), 5))
        
        found = 0
        total = 0
        for j in range(len(data_sort[i])):
      
        if data_sort[i][j][1][0][13] != 'D': continue
      
        out_network = False
        if data_sort[i][j][1][11] < 0.0 or data_sort[i][j][1][12] < 0.0 or data_sort[i][j][1][13] < 0.0 or data_sort[i][j][1][14] < 0.0 or data_sort[i][j][1][15] < 0.0:
            out_network = True
        if out_network: continue
        
        stat_check = False
        if data_sort[i][j][1][6] - 5.33 <= 4.95 or data_sort[i][j][1][7] - 8.15 <= -3.76: stat_check = True
        
        
        #if not stat_check: continue
        
        total += 1
        if data_sort[i][j][1][0] in known:
            found += 1
        if found < 1: continue
        tops_nonet[i][0].append(total)
        tops_nonet[i][1].append(round(float(found) / float(total), 5))
        
    
    
    for midx in range(5):
        import pylab
        pylab.plot(tops_nostat[midx][0], tops_nostat[midx][1], label='no STATIUM')
        pylab.plot(tops_nonet[midx][0], tops_nonet[midx][1], label='non-netork interactions')
        #pylab.plot(tops_pred[midx][0], tops_pred[midx][1], label='prediction')
        pylab.plot(tops[midx][0], tops[midx][1], label='STATIUM')
        pylab.xlim(0, 100)
        #pylab.legend()
        pylab.savefig('/home/bartolo/web/here' + str(midx) + '.png')
        pylab.close()
        
def complete_genome_sorting():

    base = 2

    data = lines2list('/home/bartolo/web/statium/BH3_test_heuristicKRHNQST.txt')
    N = len(data)
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    bcl2_primary_network = ['BCL2L1', 'MCL1', 'BCL2L2', 'BCL2A1', 'BCL2']
       
    bcln = []
    bcln.append(retrieve_network(interactions, 'BCL2L1', base))
    bcln.append(retrieve_network(interactions, 'MCL1', base))
    bcln.append(retrieve_network(interactions, 'BCL2L2', base))
    bcln.append(retrieve_network(interactions, 'BCL2A1', base))
    bcln.append(retrieve_network(interactions, 'BCL2', base))
    
    #for i in range(5):
        #for j in range(len(bcln[i])):
        #if not bcln[i][j] in bcl2_primary_network:
            #bcln.append(retrieve_network(interactions, bcln[i][j], base))
            #bcl2_primary_network.append(bcln[i][j])
    
    hits = []
    for i in range(len(data)):
        if len(data[i]) != 12: continue
        #if i % 1000 == 0 and i != 0: break
        try: target_short = ls_dict[string.join(data[i][-1].strip().split('_'), ' ')]
    except: continue
        flat_target = retrieve_network(interactions, target_short, base)
        try: target_locals = local_dict[target_short]
        except: target_locals = '-'
        shared_vec = []
        shared_names = []
        shared_hit = False
        if len(flat_target) > 0:
        for j in range(len(bcln)):
            sharing = network_shared(bcln[j], flat_target)
            shared = sharing[0]
            shared_names.append(sharing[1])
                shared_vec.append(shared)
                if shared > 0.0: shared_hit = True
        else: shared_vec = [-1, -1, -1, -1, -1]
                
        #for j in range(11): print data[i][j],
        #for j in range(5): print shared_vec[j],
        #print string.join(data[i][-1].strip().split('_'), ' '),
        #print ':::::', target_locals
        
        if not shared_hit: continue
        
        #if (data[i][1] < 0.9 or data[i][2] < 1.59 or data[i][3] < 0.0 or data[i][5] < 0.0) and (data[i][6] - 5.33 < -1.0 or data[i][7] - 8.13 < -3.0):
    if (data[i][1] < 1.5 or data[i][2] < 2.5 or data[i][3] < 0.0 or data[i][5] < 0.0) and (data[i][6] - 5.33 < -1.0 or data[i][7] - 8.13 < -3.0):
    #if (data[i][6] - 5.33 < 0.0 or data[i][7] - 8.13 < 0.0):
    #if (data[i][1] < 0.9 or data[i][2] < 1.59 or data[i][3] < 0.0 or data[i][5] < 0.0):
    #if data[i][1] < 0.6 and data[i][6] < 0.0:

    #if True:
        hits.append([data[i][2], data[i], shared_vec, target_locals])
        #print sl_dict[target_short]
        #print data[i][0], data[i][ridx], string.join(data[i][-1].strip().split('_'), ' ')
        #for j in range(len(shared_names)):
            #if len(shared_names[j]) > 0:
                #print '\t', bcl2_primary_network[j]
                #for k in range(len(shared_names[j])): print '\t\t', shared_names[j][k]
        #print
        #print
        
    hits.sort()
    for i in range(len(hits)):
        for j in range(1):
        #if j == 4: continue
        print hits[i][1][j],
        print hits[i][1][1],
        print hits[i][1][2],
    print hits[i][1][6],
    print hits[i][1][7],

        for j in range(5): print round(hits[i][2][j], 2),
        print string.join(hits[i][1][-1].strip().split('_'), ' '),
        print ':::::', hits[i][3]
        
def screen_outnetwork():
  
    data = readlines('/home/bartolo/web/statium/homology_score_innetwork.txt')
    
    for i in range(len(data)):
        items = data[i].split()
        seq = items[0]
        #if not seq[4] in 'ACFGILMVWY': continue
        #if not seq[5] in 'ACGSTVI': continue
        #if not seq[8] in 'AFILMVWY': continue
        #if not seq[13] in 'D': continue
        
        #if float(items[1]) > 0.0 and float(items[2]) > 0.0: continue
        
        print data[i].strip()
        
def network_shared(rn, tn):
    
    shared = 0
    names = []
    for m in rn:
        if m in tn: 
            shared += 1
            names.append(m)
    return [float(shared) / float(len(tn)), names]
        
def retrieve_network(interactions, receptor, base):

    flat_network = []
    network = []
    for i in range(base - 1): network.append([])
    for i in range(len(network)):
        if i == 0:
            for j in range(len(interactions)):
                if interactions[j][0] == receptor and not interactions[j][1] in network[i]: network[i].append(interactions[j][1])
                if interactions[j][1] == receptor and not interactions[j][0] in network[i]: network[i].append(interactions[j][0])
        else:
        for k in range(len(network[i - 1])):
                for j in range(len(interactions)):
                    if interactions[j][0] == network[i - 1][k] and not interactions[j][1] in network[i]: network[i].append(interactions[j][1])
                    if interactions[j][1] == network[i - 1][k] and not interactions[j][0] in network[i]: network[i].append(interactions[j][0])

    for i in range(len(network)):
        for j in range(len(network[i])):
        if not network[i][j] in flat_network: flat_network.append(network[i][j])
        
    return flat_network

def find_interactions(receptor, target, base):
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
        
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    flat_receptor = retrieve_network(interactions, receptor, base)
    
    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.labelsize'] = '8'
    pylab.rcParams['ytick.labelsize'] = '8'
    pylab.rcParams['xtick.major.pad']='8'
    pylab.rcParams['ytick.major.pad']='8'
        
    chist = []
    cbar = []
    for i in range(21): cbar.append(0)
    nbar = ['0.0']
    n0 = 0.0
    for i in range(20):
        nbar.append(str((i + 1) * 0.05))
        n0 += 0.05
        
    c = 0
    for name in names:
        c += 1
        if c % 1000 == 0: print float(c) / float(len(names))
        flat_target = retrieve_network(interactions, name, base)
        count = 0
        for i in range(len(flat_receptor)):
            if flat_receptor[i] in flat_target: count += 1
        #print len(flat_target), count, sl_dict[name]
        
        if len(flat_target) > 0:
        p = float(count) / float(len(flat_target))
            chist.append(p)
            if p == 0.0: cbar[0] += 1
            n0 = 0.0
            for i in range(20):
            if p > 0.0 and p <= 0.05 * float(i + 1):
                cbar[i + 1] += 1
                break
            
    #for i in range(20): print i, float(chist[i]) / float(len(names))
    #pylab.hist(chist, facecolor='blue', bins=20)
    #pylab.ylim(0.0, 220)
    #pylab.savefig('/home/bartolo/web/mapxxx.png')
    
    for i in range(len(cbar)): print cbar[i]
    
    import matplotlib
    import numpy as np
    
    pts = pylab.array(chist)

    ax = matplotlib.pyplot.subplot(211)
    matplotlib.pyplot.bar(arange(len(cbar)), cbar, align='center')
    matplotlib.pyplot.ylim(100, 10000)
    matplotlib.pyplot.xticks([])
    ax.spines['bottom'].set_visible(False)
    
    ax2 = matplotlib.pyplot.subplot(212)
    matplotlib.pyplot.bar(arange(len(cbar)), cbar, align='center')
    matplotlib.pyplot.ylim(0, 100)
    matplotlib.pyplot.xticks(arange(len(cbar)), nbar, rotation=30.0)
    ax2.xaxis.tick_bottom()
    ax2.spines['top'].set_visible(False)

    pylab.savefig('/home/bartolo/web/mapfff.png')
    
def R_hist():
  
    ps = ['/home/bartolo/web/statium/xm_360_spec_deepA_bootstrap.txt', '/home/bartolo/web/statium/xm_360_spec_deepS_bootstrap.txt', '/home/bartolo/web/statium/xm_360_spec_pssm_bootstrap.txt', '/home/bartolo/web/statium/xm_360_spec_statium_bootstrap.txt']
    import pylab
    labels = ['PSSM_DEEP_AFFIN', 'PSSM_DEEP_SPEC', 'PSSM_SPOT', 'STATIUM']
    arrays = []
    for i in range(len(ps)):
        dv = []
        data = lines2list(ps[i])
        for j in range(len(data)):
        dv.append(data[j][0])
        arrays.append(pylab.array(dv))
    for i in range(len(arrays)):
        pylab.hist(arrays[i], bins=10, alpha=0.8, label=labels[i])
        #print stats.shapiro(arrays[i])[1]
        quantiles = stats.mstats.mquantiles(arrays[i], prob=pylab.array([0.05, 0.5, 0.95]))
    print str(round(quantiles[0], 2)) + '\t' + str(round(quantiles[1], 2)) + '\t' + str(round(quantiles[2], 2)), labels[i]
    for i in range(len(arrays)):
        for j in range(i + 1, len(arrays)):
        print stats.mannwhitneyu(arrays[i], arrays[j])[1]
    pylab.legend(loc='upper left')
    pylab.ylim(0, 1000)
    pylab.xlabel('Pearson R')
    pylab.savefig('/home/bartolo/web/statium/Boostrap360.png')
    pylab.close()
    
def analyze_bootstrap():
  
    import pylab
    
    bdir = '/home/bartolo/web/statium/bootstrap'
    datasets = ['Bcl-xL200', 'Mcl-1200', 'Bcl-w200', 'Bfl-1200', 'Bcl-2200', '360_Mpred', '360_Xpred', 'Mcl-1_BN', 'Bcl-xL_BN']
    dataset_names = ['Bcl-xL substitution SPOTS', 'Mcl-1 substitution SPOTS', 'Bcl-w substitution SPOTS', 'Bfl-1 substitution SPOTS', 'Bcl-2 substitution SPOTS', 'Mcl-1 library SPOTS', 'Bcl-xL library SPOTS', 'Mcl-1 (Noxa) substitution SPOTS', 'Bcl-xL (Bad) substitution SPOTS']
    flist = os.listdir(bdir)
    
    edict = dict([['x', 'Bcl-xL'], ['X', 'Bcl-xL'], ['m', 'Mcl-1'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['2', 'Bcl-2'], ['F', 'Bfl-1'], ['Mnoxa', 'Mcl-1 (Noxa)'], ['Xbad', 'Bcl-xL (Bad)']])
    
    deepdict = dict([['xa', 'Bcl-xL affinity PSSM_DEEP'], ['x', 'Bcl-xL specificity PSSM_DEEP'], ['ma', 'Mcl-1 affinity PSSM_DEEP'], ['m', 'Mcl-1 specificity PSSM_DEEP'], ['wa', 'Bcl-w affinity PSSM_DEEP'], ['fa', 'Bfl-1 affinity PSSM_DEEP'], ['2a', 'Bcl-2 affinity PSSM_DEEP']])
    
    ToCompare = []
    MedDiff = []
    Mann = []
    names = []
    
    for i in range(len(datasets)):
        ToCompare.append([])
        names.append([])
    
    for file in flist:
       for key in datasets:
       if file.find(key) > -1:
           ToCompare[datasets.index(key)].append(os.path.join(bdir, file))
           
           items = file.split('_')
           efunc = items[0]
           efunc2 = items[-2]
           if efunc2 in ['statium', 'pssm']:
           efuncv = edict[efunc]
           if efunc2 == 'statium': name = efuncv + ' STATIUM'
           if efunc2 == 'pssm': name = efuncv + ' PSSM_SPOT'
           else:
           name = deepdict[efunc]
           name += ', ' + dataset_names[datasets.index(key)]
           if file == 'ma_Mcl-1_BN_pred_deep_bootstrap.txt': print name
           names[datasets.index(key)].append(name)
       
    comparea = []
    d0_vec = []
    for i in range(len(ToCompare)):
        comparea.append([])
        d0_vec.append([])
        for j in range(len(ToCompare[i])):
            dv = []
            data = lines2list(ToCompare[i][j])
            for k in range(len(data)):
            dv.append(data[k][1])
        da = pylab.array(dv)
        comparea[i].append(da)
        d0_vec[i].append(data[0][0])

    for i in range(len(comparea)):
        for j in range(len(comparea[i])):
        quantiles = stats.mstats.mquantiles(comparea[i][j], prob=pylab.array([0.05, 0.5, 0.95]))
        #print str(round(quantiles[0], 2)) + '\t' + str(round(quantiles[1], 2)) + '\t' + str(round(quantiles[2], 2)) +'\t' + names[i][j]
        MedDiff.append(mean(comparea[i][j]) - d0_vec[i][j])
            for k in range(j + 1, len(comparea[i])):
            #print ToCompare[i][j]
            #print ToCompare[i][k]
            Mann.append(stats.mannwhitneyu(comparea[i][j], comparea[i][k])[1])
            
    #pylab.hist(pylab.array(Mann))

    ##pylab.legend(loc='upper left')
    ##pylab.ylim(0, 1000)
    #pylab.xlabel('Mann_Whitney U test p-value')
    #pylab.savefig('/home/bartolo/web/statium/Boostrap_AUC_MannWhitneyU.png')
    #pylab.close()
    
def analyze_bootstrap_enrich():
  
    datasets = ['JMB_xspec', 'JMB_mspec', 'deep_xspec', 'deep_mspec', 'deep_xaffin', 'deep_maffin', 'deep_faffin', 'deep_waffin', 'deep_2affin']
  
    import pylab
    
    bdir = '/home/bartolo/web/statium/bootstrap'
    dataset_names = ['JMB Bcl-xL specific', 'JMB Mcl-1 specific', 'Deep Bcl-xL specific', 'Deep Mcl-1 specific', 'Deep Bcl-xL affinity', 'Deep Mcl-1 affinity', 'Deep Bfl-1 affinity', 'Deep Bcl-w affinity', 'Deep Bcl-2 affinity']
    flist = os.listdir(bdir)
    
    edict = dict([['x', 'Bcl-xL'], ['X', 'Bcl-xL'], ['m', 'Mcl-1'], ['M', 'Mcl-1'], ['W', 'Bcl-w'], ['w', 'Bcl-w'], ['2', 'Bcl-2'], ['F', 'Bfl-1'], ['f', 'Bfl-1'], ['noxa', 'Mcl-1 (Noxa)'], ['bad', 'Bcl-xL (Bad)']])
    
    deepdict = dict([['xa', 'Bcl-xL affinity PSSM_DEEP'], ['x', 'Bcl-xL specificity PSSM_DEEP'], ['ma', 'Mcl-1 affinity PSSM_DEEP'], ['m', 'Mcl-1 specificity PSSM_DEEP'], ['wa', 'Bcl-w affinity PSSM_DEEP'], ['fa', 'Bfl-1 affinity PSSM_DEEP'], ['2a', 'Bcl-2 affinity PSSM_DEEP']])
    
    ToCompare = []
    MedDiff = []
    Mann = []
    names = []
    
    for i in range(len(datasets)):
        ToCompare.append([])
        names.append([])
    
    for file in flist:
       for key in datasets:
       if file.find(key) > -1:
           items = file.split('_')
           if items[-3] != 'enrich': continue
           ToCompare[datasets.index(key)].append(os.path.join(bdir, file))
           efunc = items[0]
           efunc2 = items[-2]
           if efunc2 in ['statium', 'pssm']:
           efuncv = edict[efunc]
           if efunc2 == 'statium': name = efuncv + ' STATIUM'
           if efunc2 == 'pssm': name = efuncv + ' PSSM_SPOT'
           else:
           name = deepdict[efunc]
           name += ', ' + dataset_names[datasets.index(key)]
           #print file
           #print name
           #print
           names[datasets.index(key)].append(name)

       
    comparea = []
    d0_vec = []
    for i in range(len(ToCompare)):
        comparea.append([])
        d0_vec.append([])
        for j in range(len(ToCompare[i])):
            dv = []
            data = lines2list(ToCompare[i][j])
            for k in range(len(data)):
            dv.append(data[k][1])
        da = pylab.array(dv)
        comparea[i].append(da)
        d0_vec[i].append(data[0][0])

    for i in range(len(comparea)):
        for j in range(len(comparea[i])):
        quantiles = stats.mstats.mquantiles(comparea[i][j], prob=pylab.array([0.05, 0.5, 0.95]))
        print str(round(quantiles[0], 2)) + '\t' + str(round(quantiles[1], 2)) + '\t' + str(round(quantiles[2], 2)) +'\t' + names[i][j], d0_vec[i][j]
        #MedDiff.append(mean(comparea[i][j]) - d0_vec[i][j])
            #for k in range(j + 1, len(comparea[i])):
            #print ToCompare[i][j]
            #print ToCompare[i][k]
            #Mann.append(stats.mannwhitneyu(comparea[i][j], comparea[i][k])[1])
            
    #pylab.hist(pylab.array(Mann))

    ##pylab.legend(loc='upper left')
    ##pylab.ylim(0, 1000)
    #pylab.xlabel('Mann_Whitney U test p-value')
    #pylab.savefig('/home/bartolo/web/statium/Boostrap_AUC_MannWhitneyU.png')
    #pylab.close()
    
def human_interactions():

    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
    return interactions
    
def get_calmodulin_proteome_peptides():
  
    wt = 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV'

    interactions = human_interactions()
    calnet = retrieve_network(interactions, 'CALM1', 2)

    calnet2 = retrieve_network(interactions, 'CALM2', 2)
    for namex in calnet2:
        if not namex in calnet: calnet.append(namex)
    calnet3 = retrieve_network(interactions, 'CALM3', 2)
    for namex in calnet3:
        if not namex in calnet: calnet.append(namex)
    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]
    
    from_struc = ['Sodium channel, voltage gated, type 5, alpha subunit', 'CaMK II delta subunit', 'CaM kinase II beta subunit', 'Solute carrier family 9, isoform A1', 'Calcium channel, voltage dependent, L type, alpha 1C subunit', 'CaMK II alpha subunit', 'Myosin 6', 'Calcium channel, voltage-dependent, L type, alpha-1S subunit', 'Myosin light chain kinase 2', 'Myosin 5A', 'Nitric oxide synthase 3']
    from_struc_short = []
    for namex in from_struc:
        try:
        shortname = ls_dict[namex]
        print namex
        print shortname
        print
    except: shortname = ''
    from_struc_short.append(shortname)
    for namex in from_struc_short:
        if not namex in calnet: calnet.append(namex)
        
    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break
    
    for thing in calnet: print thing
    print len(calnet)
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/calmodulin/Calmodulin2be6_IN_seq.txt'
    nout_path = '/home/bartolo/web/statium/calmodulin/Calmodulin2be6_IN_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: shortname = ''
    if not shortname in calnet: continue
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            P = 0
            for k in range(3, 26):
            if seq[k] == 'P':
                P += 1
                break
        if P == 1: continue
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 8: continue
        
        if not seq[12] in 'FILVYWM': continue
        if not seq[6] in 'FILVYWM': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def get_calmodulin1cdl_proteome_peptides():
  
    wt = 'RRKWQKTGHAVRAIGRLSS'
    

    interactions = human_interactions()
    calnet = retrieve_network(interactions, 'CALM1', 2)

    calnet2 = retrieve_network(interactions, 'CALM2', 2)
    for namex in calnet2:
        if not namex in calnet: calnet.append(namex)
    calnet3 = retrieve_network(interactions, 'CALM3', 2)
    for namex in calnet3:
        if not namex in calnet: calnet.append(namex)
    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]
    
    from_struc = ['Sodium channel, voltage gated, type 5, alpha subunit', 'CaMK II delta subunit', 'CaM kinase II beta subunit', 'Solute carrier family 9, isoform A1', 'Calcium channel, voltage dependent, L type, alpha 1C subunit', 'CaMK II alpha subunit', 'Myosin 6', 'Calcium channel, voltage-dependent, L type, alpha-1S subunit', 'Myosin light chain kinase 2', 'Myosin 5A', 'Nitric oxide synthase 3']
    from_struc_short = []
    for namex in from_struc:
        try:
        shortname = ls_dict[namex]
        print namex
        print shortname
        print
    except: shortname = ''
    from_struc_short.append(shortname)
    for namex in from_struc_short:
        if not namex in calnet: calnet.append(namex)
        
    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break
    
    for thing in calnet: print thing
    print len(calnet)
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_IN_seq.txt'
    nout_path = '/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_IN_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: shortname = ''
    if not shortname in calnet: continue
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            P = 0
            for k in range(3, 16):
            if seq[k] == 'P':
                P += 1
                break
        if P == 1: continue
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 8: continue
        
        if not seq[3] in 'WYFILVM': continue
        if not seq[10] in 'WYFILVM': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()

def bcl2_sidechain_peptides():

    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')

    SPOT_vec = PSSM5()

    zstd = [12.5964280762, 9.59343423497, 11.751603669, 11.8554232701, 10.1877121464]
    zmean = [19.1906407971, 14.274283119, 20.6483026992, 22.0019210125, 17.3106609485]

    zstdp = [0.957525719117, 0.917711243381, 0.518798747972, 0.948616660627, 0.635063414077]
    zmeanp = [3.98243723171, 4.41547882232, 1.69542278603, 2.94382294585, 2.62386345361]
 
    zstdo = [7.82148011783, 8.42545057961, 7.8113492244, 8.06076907477, 9.56253284139]
    zmeano = [8.88202577979, 3.59344777264, 16.9838604234, 13.6195053537, 12.9646255606]   
 
    zstdo_aff = [63.5242791301, 69.6244743843, 47.2824198646, 62.6257663696, 64.9647511437]
    zmeano_aff = [68.2460060157, 67.0483148038, 64.3481389591, 78.5934248038, 72.6519383473]

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)

    #clf = bcl2_svm()
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    #sout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt'
    #nout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_names.txt'
    sout_path = '/home/bartolo/web/statium/all_array_analysis/bcl2/bseq.txt'
    nout_path = '/home/bartolo/web/statium/all_array_analysis/bcl2/bnames.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    count = 0
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        count += 1
        #if not count % 10 == 0: continue
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa

            if seq in seq_vec: continue

        try:
                energy_pssm = pssm_energy10(SPOT_vec, seq)
                pw = energy_pssm[4]
                ew = statium_energy_calc_sidechain(bmode, seq, 0.0)
            zpw = (pw - zmeanp[3]) / zstdp[3]
                zw = (ew - zmean[3]) / zstd[3]
        except: continue

        if zpw > -3.0 or zw > -2.0: continue
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        #if chg < 8: continue


        seq_vec.append(seq)
        try: BH3_entropy_plot('/home/bartolo/web/BLAST/hprd_align/hprd_' + str(i + 1) + '.out', '/home/bartolo/web/statium/all_array_analysis/bcl2/cons/c' + str(i + 1) + '_' + str(seq_vec.index(seq) + 1) + '.png', j+1, 'b')
        except: continue
         print seq, seq_lines[seqs[i][1] - 2].strip(), len(seq_vec), zw, zpw
        
        #if not seq[8] in 'FILVYWM': continue
        #if not seq[12] in 'ACGS': continue
                    
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()

def bcl2_random_peptides():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)

    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    #sout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt'
    #nout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_names.txt'
    sout_path = '/home/bartolo/web/statium_sidechain_wGly/random_seq.txt'
    nout_path = '/home/bartolo/web/statium_sidechain_wGly/random_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    count = 0
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        count += 1
        #if not count % 10 == 0: continue
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa

            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1

        if chg < 8: continue

            if seq in seq_vec: continue

        seq_vec.append(seq)

        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
        if len(seq_vec) > 500000: break

    soutfile.close()
    noutfile.close()

def bcl2_simplest_peptides():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    #sout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt'
    #nout_path = '/home/bartolo/web/statium_sidechain/bcl2_expand_names.txt'
    #soutfile = open(sout_path, 'w')
    #noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
            if not seq[8] in 'ACFILVYWM': continue
        if not seq[12] in 'ACGS': continue
        if not seq[13] in 'D': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        #soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        #noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    #soutfile.close()
    #noutfile.close()
    print
    print 'TOTAL:'
    print len(seq_vec) 
    
def bcl2_end_peptides():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    cm = load_BH3_conserve_matrix2('/home/bartolo/web/statium/all_array_analysis/binder_align_tight.txt')
    
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa

        if not seq[12] in 'ACGS': continue
        if not seq[13] in 'DEGHKNQRST': continue
        if not seq[8] in 'ILM': continue

        try: cme = BH3_conserve_score2(cm, seq)
        except: continue
        if cme > 20.0:
            if not seq in seq_vec:
            print seq_lines[seqs[i][1] - 2].strip()
            print seq, cme
            seq_vec.append(seq)

def JF_peptides():
  
    cc = 'gabcdefgabcdefgabcdefgabcdefgabcdefgab'
    wt = 'RIARLEEKVKTLKAQNSELASTANMLREQVAQLKQKVM'
    mode = load_design_energy_sidechain('/home/bartolo/web/CC/JunFos/jf_1fos')
    #print statium_energy_calc_sidechain(mode, wt, 0.0)
    
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    aidx = [11, 14, 25, 28, 33, 39]
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/CC/JunFos/JF_seq.txt'
    nout_path = '/home/bartolo/web/CC/JunFos/JF_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        #if i % 1000 == 0: print len(seq_vec)
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 1000 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
        Lc = 0
        for k in range(len(seq)):
            if cc[k] in 'ad':
                if seq[k] in 'FLIMVWY': Lc += 1
        if Lc < 5: continue
        
        match = 0
        for k in range(len(seq)):
            #if seq[k] == wt[k]: match += 1
        if seq[k] in 'DEHKNQRST': match += 1
        if match < 18: continue
        prcid = float(match) / float(len(wt))
        #if prcid < 0.0: continue
        
        P = 0
        for k in range(len(seq)):
            if seq[k] == 'P': P += 1
        if P > 2: continue
        
        G = 0
        for k in range(len(seq)):
            if seq[k] == 'G': P += 1
        if G > 3: continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
        try: e = statium_energy_calc_sidechain(mode, seq, 0.0)
        except: continue
        if e < -15.0:
                print seq_lines[seqs[i][1] - 2].strip()
            print seq
            print e
            print
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def kinesin_peptides2():
  
    cc = 'bcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefgabcdefg'
    wt = 'ERTEERAELAESKCSELEEELKNVTNNLKSLEAQAEKYSQKEDKYEEEIKILTDKLKEAETRAEFAERSVAKLEKTIDDLEDELYAQKLKYKAISEELDHALND'

    #mode = load_design_energy_sidechain('/home/bartolo/web/CC/JunFos/jf_1fos')
    #print statium_energy_calc_sidechain(mode, wt, 0.0)
    
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    aidx = [11, 14, 25, 28, 33, 39]
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/CC/tropomyosin/tropomyosin_seq.txt'
    nout_path = '/home/bartolo/web/CC/tropomyosin/tropomyosin_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        #if i % 1000 == 0: print len(seq_vec)
        #if not 'inesin' in seq_lines[seqs[i][1] - 2].strip(): continue     
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 1000 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
        match = 0
        for k in range(len(seq)):
            if seq[k] == wt[k]: match += 1
        prcid = float(match) / float(len(wt))
        if prcid < 0.30: continue
        
        #core = ''
        #phil = 0
        #for k in range(len(cc)):
            #if cc[k] in 'ad':
            #core += seq[k]
            #if seq[k] in 'DEGHKNPQRST': phil += 1
        
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            
        print seq_lines[seqs[i][1] - 2].strip()
        print seq, prcid
        print
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()    
    
def kinesin_peptides():
  
    cc = 'bcdefgabcdefgabcdefgabcdefgabcde'
    wt = 'EQWKKKYEKEKEKNKILRNTIQWLENELNRWR'
    #mode = load_design_energy_sidechain('/home/bartolo/web/CC/JunFos/jf_1fos')
    #print statium_energy_calc_sidechain(mode, wt, 0.0)
    
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    aidx = [11, 14, 25, 28, 33, 39]
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/CC/kinesin/kinesin_seq.txt'
    nout_path = '/home/bartolo/web/CC/kinesin/kinesin_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        #if i % 1000 == 0: print len(seq_vec)
        if not 'inesin' in seq_lines[seqs[i][1] - 2].strip(): continue     
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        if i % 1000 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
        match = 0
        for k in range(len(seq)):
            if seq[k] == wt[k]: match += 1
        prcid = float(match) / float(len(wt))
        if prcid < 0.25: continue
        
        core = ''
        phil = 0
        for k in range(len(cc)):
            if cc[k] in 'ad':
            core += seq[k]
            if seq[k] in 'DEGHKNPQRST': phil += 1
        
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            
        print seq_lines[seqs[i][1] - 2].strip()
        print seq, prcid, core, phil
        print
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def MYC_peptides():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    network_dicts = network_dictionaries()
    
    cc = 'defgabcdefgabcdefgabcdefgabcdefgabcdefgabcd'
    wt = 'RAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRAL'
    myc ='KVVILKKATAYILSVQAEEQKLISEEDLLRKRREQLKHKLEQL'
    mad ='TLSLLTKAKLHIKKLEDCDRKAVHQIDQLQREQRHLKRQLEKL'
    nmyc='KVVILKKATEYVHSLQAEEHQLLLEKEKLQARQQQLLKKIEHA'
    lmyc='KVVILSKALEYLQALVGAEKRMATEKRQLRCRQQQLQKRIAYL'
    mxi1='TLGLLNKAKAHIKKLEEAERKSQHQLENLEREQRFLKWRLEQL'
    mad4='TLSLLKRAKVHIKKLEEQDRRALSIKEQLQQEHRFLKRRLEQL'
    mad3='TLSLLRRARMHIQKLEDQEQRARQLKERLRSKQQSLQRQLEQL'
    mnt ='NLSVLRTALRYIQSLKRKEKEYEHEMERLAREKIATQQRLAEL'
    mga ='KSLILTRAFSEIQGLTDQADKLIGQKNLLTRKRNILIRKVSSL'
    mlx ='KAIVLQKTIDYIQFLHKEKKKQEEEVSTLRKDVTALKIMKVNY'
    mond='HAITLQKTVEYITKLQQERGQMQEEARRLREEIEELNATIISC'
    mxp1='KATTLQKTAEYILMLQQERAGLQEEAQQLRDEIEELNAAINLC'
    mdl1='AGETINALKGRISELQWSVMDQEMRVKRLESEKQELQEQLDLQ'
    ups= 'KGGILSKACDYIRELRQTNQRMQETFKEAERLQMDNELLRQQI'
    mit1='KGTILKASVDYIRKLQREQQRAKELENRQKKLEHANRHLLLRI'
    myf6='KVEILRSAISYIERLQDLLHRLDQQEKMQELGVDPFSYRPKQE'
    heyl='KAEVLQMTVDHLKMLHATGGTGFFDARALAVDFRSIGFRECLT'
    lmy2='KVMILVKATEYLHELAEAEERMATEKRQLECQRRQLQKRIEYL'

    aln=[wt, myc, mad, nmyc, lmyc, mxi1, mad4, mad3, mnt, mga, mlx, mond, mxp1, mdl1, ups, mit1, myf6, heyl, lmy2]
    
    subs_vec = ['RK', 'MLIV', 'ED', 'YWF']
    MSA = []
    for i in range(len(wt)):
        MSA.append([])
        for j in range(len(aln)):
            if not aln[j][i] in MSA[-1]: MSA[-1].append(aln[j][i])
        for j in MSA[-1]:
        for p in subs_vec:
            if j in p:
            for l in p:
                if not l in MSA[-1]: MSA[-1].append(l)
     #'LDEEEERRKRRREKNKVAAARCRNKKKERTEFLQRESERLELMNAELKTQIEELKQERQQLILMLNRHR'
     #'TLSLLKRAKVHIKKLEEQDRRALSIKEQLQQEHRFLKRRLEQL'

    L = len(wt)
    #mode = load_design_energy_sidechain('/home/bartolo/web/CC/MYC/myc_1nkp')
    
    #print statium_energy_calc_sidechain(mode, wt, 0.0)
    #print statium_energy_calc_sidechain(mode, myc, 0.0)

    #aidx = [9, 13, 23, 30, 37, 48, 58, 65, 76, 86, 93, 100]
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/CC/MYC2/MycMax_seq.txt'
    nout_path = '/home/bartolo/web/CC/MYC2/MycMax_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        #if i % 1000 == 0: print len(seq_vec)
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
    
    ls_dict = network_dicts[1]
    try: shortname = ls_dict[namex]
    except: shortname = '??'
    
    #partner = False
    #if shortname in myci: partner = True
    #if not partner: continue
    
          
        prot_seq = seqs[i][0]
        if i % 1000 == 0 and i > 0:

        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
        match = 0
        for k in range(len(seq)):
            if seq[k] in MSA[k]: match += 1
        prcid = float(match) / float(len(wt))

        if prcid < 0.85: continue
        
        #Pc = 0
        #for k in range(len(seq)):
            #if seq[k] in 'P': Pc += 1
        #if Pc > 1: continue
        
        if not seq in seq_vec:
            
        #try: e = statium_energy_calc_sidechain(mode, seq, 0.0)
        #except: continue
        seq_vec.append(seq)
        #if prcid1 <= 0.3 and prcid2 <= 0.40 and prcid3 >= 0.34:
        if prcid > 0.80:
                print seq_lines[seqs[i][1] - 2].strip()
                print prcid
            print seq
            print
            #for k in range(len(idata)):
                #if (idata[k][7] == 'MYC' and idata[k][8] == shortname) or (idata[k][8] == 'MYC' and idata[k][7] == shortname):
                #s = ''
                #for l in range(10, len(idata[k])): s += str(idata[k][l]) + ' '
                #print s
            #print e, prcid
            #print len(seq_vec)
            #if partner: print 'partner'
            #print
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def composition_rmsd(cvec, seq):
  
    sub = [0.0] * 20
    for j in range(len(seq)):
    aa = seq[j]
    sub[AAChar_int(aa)] += 1.0
    tot = 0.0
    for j in range(20): tot += sub[j]
    totd = 0.0
    for j in range(20):
    p = sub[j] / tot
    totd += ((p - cvec[j]) * (p - cvec[j]))
    return math.sqrt(totd / 20.0)
    
def measure():
  
    data = lines2list('/home/bartolo/web/CC/MYC2/fullmyc/align.txt')
    
    align = []
    for i in range(len(data)): align.append(data[i][0])
    
    for seq in align:
        count = 0
        for j in range(len(seq)):
        #if seq[j] in 'DEHKNQRST': count += 1
        if seq[j] in 'FILMVWY': count += 1
        print count

def BHLH_peptides():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    wt = 'ELKRSFFALRDQIKVVILKKATAYILSVQAEEQKLISEEDLLRKRREQLKHKLEQL'
    L = len(wt)
    
    align = lines2list('/home/bartolo/web/CC/MYC2/fullmyc/align_expand.txt')
    alist = []
    for i in range(len(align)): alist.append(align[i][0])
        
    llist = []
    ldata = lines2list('/home/bartolo/web/CC/MYC2/fullmyc/BHLHloop_seq.txt')
    for i in range(len(ldata)): llist.append(ldata[i][0])
    lclist = [0.0] * 20
    for i in range(len(llist)):
        sub = [0.0] * 20
        for j in range(len(llist[i])):
        aa = llist[i][j]
        sub[AAChar_int(aa)] += 1.0
    tot = 0.0
    for j in range(20): tot += sub[j]
    for j in range(20): lclist[j] += sub[j] / tot
    for j in range(20): lclist[j] = lclist[j] / float(len(llist))
    
    H1list = []
    for i in range(len(alist)): H1list.append(alist[i][0:13])
    H1matrix = [0.0] * 20
    for i in range(len(H1list)):
        sub = [0.0] * 20
        for j in range(len(H1list[i])):
        aa = H1list[i][j]
        sub[AAChar_int(aa)] += 1.0
    tot = 0.0
    for j in range(20): tot += sub[j]
    for j in range(20): H1matrix[j] += sub[j] / tot
    for j in range(20): H1matrix[j] = H1matrix[j] / float(len(H1list))

    H2list = []
    for i in range(len(alist)): H2list.append(alist[i][13:len(alist[i])])
    H2matrix = [0.0] * 20
    for i in range(len(H2list)):
        sub = [0.0] * 20
        for j in range(len(H2list[i])):
        aa = H2list[i][j]
        sub[AAChar_int(aa)] += 1.0
    tot = 0.0
    for j in range(20): tot += sub[j]
    for j in range(20): H2matrix[j] += sub[j] / tot
    for j in range(20): H2matrix[j] = H2matrix[j] / float(len(H2list))

    H2clist = []
    H2plist = []
    H2elist = []
    for i in range(15):
        H2clist.append([])
        H2plist.append([])
        H2elist.append([])
        for j in range(20): H2clist[i].append(0.0)
        for j in range(20): H2plist[i].append(0.0)
        for j in range(20): H2elist[i].append(0.0)
    for i in range(15):
        for j in range(len(alist)): H2clist[i][AAChar_int(alist[j][i + 13])] += 1.0

    for i in range(15):
    for j in range(20):
        if H2clist[i][j] == 0.0: H2clist[i][j] = 1.0
        
    H1clist = []
    H1plist = []
    H1elist = []
    for i in range(13):
        H1clist.append([])
        H1plist.append([])
        H1elist.append([])
        for j in range(20): H1clist[i].append(0.0)
        for j in range(20): H1plist[i].append(0.0)
        for j in range(20): H1elist[i].append(0.0)
    for i in range(13):
        for j in range(len(alist)): H1clist[i][AAChar_int(alist[j][i])] += 1.0

    for i in range(13):
    for j in range(20):
        if H1clist[i][j] == 0.0: H1clist[i][j] = 1.0
        
    for i in range(15):
        tot = 0.0
        for j in range(20): tot += H2clist[i][j]
        for j in range(20):
        H2plist[i][j] = H2clist[i][j] / tot
        if H2plist[i][j] > 0.0: H2elist[i][j] = -1.0 * math.log10(H2plist[i][j])

    for i in range(13):
        tot = 0.0
        for j in range(20): tot += H1clist[i][j]
        for j in range(20):
        H1plist[i][j] = H1clist[i][j] / tot
        if H1plist[i][j] > 0.0: H1elist[i][j] = -1.0 * math.log10(H1plist[i][j])

    for seq in alist:
        H1 = seq[0:13]
        H2 = seq[13:len(seq)]
        
        e = 0
    for b in range(len(H1)): e += H1elist[b][AAChar_int(H1[b])]
    print e,
    
        e = 0
    for b in range(len(H2)): e += H2elist[b][AAChar_int(H2[b])]
    print e,
    
    print composition_rmsd(H1matrix, H1),
    print composition_rmsd(H2matrix, H2)
        
    return

    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    
    seq_vec = []
    seq_names_vec = []
    seq_e_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        hprd_name = seq_lines[seqs[i][1] - 2].strip()
        
        #if i % 1000 == 0: print len(seq_vec)
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]

    
          
        prot_seq = seqs[i][0]
        if i % 1000 == 0 and i > 0:

        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'

        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
        try: H2 = seq[13:56]
        except: continue

        try:
        H2e = 0
        for b in range(15): H2e += H2elist[b][AAChar_int(H2[b])]
        if H2e > 20.0: continue
        except: continue
    
        try:
            if composition_rmsd(H2matrix, H2) > 0.12: continue
        except: continue
        
        for k in range(5, 20):
            if j - k < 0: continue
            try: H1 = prot_seq[j - k:j - k + 13]
            except: continue
            
            try:
            H1e = 0
            for g in range(len(H1)): H1e += H1elist[g][AAChar_int(H1[g])]
            if H1e > 18.0: continue
        except: continue
        
        try:
            if composition_rmsd(H1matrix, H1) > 0.12: continue
        except: continue
        
        bhlh = H1 + H2
        
        if len(bhlh) != L: continue
        
        loop = prot_seq[prot_seq.find(H1) + len(H1):prot_seq.find(H2)]
        try: lcomp = composition_rmsd(lclist, loop)
        except: continue
        if lcomp > 0.12: continue
        
        phob = 0
        for xx in range(28):
            if bhlh[xx] in 'FILMVWY': phob += 1
        if phob > 15: continue
        
        phil = 0
        for xx in range(28):
            if bhlh[xx] in 'DEHKNQRST': phil += 1
        if phil < 8: continue
        
        Pc = 0
        for xx in range(28):
            if bhlh[xx] in 'P': Pc += 1
        if Pc > 0: continue
        
            if not bhlh in seq_vec:
            
            seq_vec.append(bhlh)
            seq_names_vec.append(namex)
            seq_e_vec.append(H1e)

            #print seq_lines[seqs[i][1] - 2].strip()
                #print bhlh
                #print H1e, H2e, lcomp
            #print
                else: continue

    sout_path = '/home/bartolo/web/CC/MYC2/fullmyc/BHLHplus_seq.txt'
    nout_path = '/home/bartolo/web/CC/MYC2/fullmyc/BHLHplus_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')

    for i in range(len(seq_vec)):

        soutfile.write(seq_vec[i] + '\n')
        noutfile.write(seq_names_vec[i] + '\n')

    soutfile.close()
    noutfile.close()

def BmyoS2_sidechain_peptides2():

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    wt = 'LTNLEGIYNSETEKLRSDLERLQLSEEEAKVATGRVLSLQEEIAKLRKDLEQTRSEKKCIEEHADRYKQETEQLVSNLKEENTLLKQEKEALNHRIVQQAKEMTETMEKKLVEETKQLELDLNDERLRYQ'
    L = len(wt)
    
    aidx = [9, 13, 23, 30, 37, 48, 58, 65, 76, 86, 93, 100]
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/CC/MYO5_seq.txt'
    nout_path = '/home/bartolo/web/CC/MYO5_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        #if i % 1000 == 0: print len(seq_vec)
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
          
        prot_seq = seqs[i][0]
        #if i % 100 == 0 and i > 0:
        #print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
        Lc = 0
        for k in range(len(aidx)):
            idx = aidx[k]
            if seq[idx] == 'L': Lc += 1
        #if Lc < 8: continue
        
        match = 0
        for k in range(len(seq)):
            if seq[k] == wt[k]: match += 1
        prcid = float(match) / float(len(wt))
        if prcid < 0.3: continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            print seq_lines[seqs[i][1] - 2].strip(), prcid
            bur = ''
            #for k in range(len(aidx)): bur += seq[aidx[k]]
            #print bur
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def get_CAMP_proteome_peptides():
  
    wt = 'TTYADFIASGRTGRRASIHD'
    

    interactions = human_interactions()
    calnet = retrieve_network(interactions, 'PRKACA', 2)

    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]
    
    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break
    
    #for thing in calnet: print thing
    #print len(calnet)
    #return
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/CAMP/CAMP_IN_seq.txt'
    nout_path = '/home/bartolo/web/statium/CAMP/CAMP_IN_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: shortname = ''
    if not shortname in calnet: continue
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            #P = 0
            #for k in range(3, 26):
            #if seq[k] == 'P':
                #P += 1
                #break
        #if P == 1: continue
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 10: continue
        
        if not seq[13] in 'KR': continue
        if not seq[14] in 'KR': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def get_GAI1_proteome_peptides():
  
    wt = 'DFFSLILRSQAKRMDEQRVLL'
    

    interactions = human_interactions()
    calnet = retrieve_network(interactions, 'GNAI1', 2)

    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]
    
    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break
    
    #for thing in calnet: print thing
    #print len(calnet)
    #return
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/GAI1/GAI1_IN_seq.txt'
    nout_path = '/home/bartolo/web/statium/GAI1/GAI1_IN_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: shortname = ''
    if not shortname in calnet: continue
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            #P = 0
            #for k in range(3, 26):
            #if seq[k] == 'P':
                #P += 1
                #break
        #if P == 1: continue
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 10: continue
        
        if not seq[5] in 'FILMV': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def MDM_get_proteome_peptides():
  
    wt = 'TSFAEYWNLLSA'
    

    interactions = human_interactions()
    calnet = retrieve_network(interactions, 'MDM2', 2)

    calnet2 = retrieve_network(interactions, 'MDMX', 2)
    for namex in calnet2:
        if not namex in calnet: calnet.append(namex)
    #calnet3 = retrieve_network(interactions, 'CALM3', 2)
    #for namex in calnet3:
        #if not namex in calnet: calnet.append(namex)
    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]
    
    #from_struc = ['Sodium channel, voltage gated, type 5, alpha subunit', 'CaMK II delta subunit', 'CaM kinase II beta subunit', 'Solute carrier family 9, isoform A1', 'Calcium channel, voltage dependent, L type, alpha 1C subunit', 'CaMK II alpha subunit', 'Myosin 6', 'Calcium channel, voltage-dependent, L type, alpha-1S subunit', 'Myosin light chain kinase 2', 'Myosin 5A', 'Nitric oxide synthase 3']
    #from_struc_short = []
    #for namex in from_struc:
        #try:
        #shortname = ls_dict[namex]
        #print namex
        #print shortname
        #print
    #except: shortname = ''
    #from_struc_short.append(shortname)
    #for namex in from_struc_short:
        #if not namex in calnet: calnet.append(namex)
        
    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break
    
    for thing in calnet: print thing
    #print len(calnet)
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/MDM_IN_seq.txt'
    nout_path = '/home/bartolo/web/statium/MDM_IN_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: shortname = ''
    if not shortname in calnet: continue
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'

        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            P = 0
            for k in range(L):
            if seq[k] == 'P':
                P += 1
        if P > 2: continue
        
            chg = 0
            for k in range(L):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 5: continue
        
        if not seq[2] in 'ACFILMVWYP' or not seq[6] in 'ACFILMVWYP' or not seq[9] in 'ACFILMVWYP' or not seq[10] in 'ACFILMVWYP': continue
        
        if not seq in seq_vec: seq_vec.append(seq)
            else: continue
            
            #e = 0.0
            #try: e = statium_energy_calc(calmode, seq, 0.0)
            #except: print seq
            #if e <= wte:
            #print wt
                #print seq, statium_energy_calc(calmode, seq, 0.0), seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def score_genomic_bh3s():
  
    matrix = uniprot_bcl2_matrix()
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    natural = ['WAREIAAQLRRMADDLNAQYERR','PEIWIAQELRRIGDEFNAYYARR','LEVECATQLRRFGDKLNFRQKLL','AAQRYGRELRRMSDEFVDSFKKG','TMGQVGRQLAIIGDDINRRYDSE','STKKLSECLKRIGDELDSNMELQ',
'EGEKEVEALKKSADWVSDWSSRP','AAQLTAARLKALGDELHQRTMWR','AEVQIARKLQCIADQFHRLHVQQ','GSDALALRLACIGDEMDVSLRAP','IIRNIARHLAQVGDSMDRSIPPG','MTQEVGQLLQDMGDDVYQQYRSL','TMENLSRRLKVTGDLFDIMSGQT','RLAEVCAVLLRLGDELEMIRPSV','VLGKAVHSLSRIGDELYLEPLED','VFGKAVQALSRISDEFWLDPSKK','EFARICRDLSHIGDAVVISAAKD','ILAKIVELLKYSGDQLERKDTAF','ILAKIVELLKYSGDQLERKLKKD','VPPVVHLTLRQAGDDFSRRYRRD','AADPLHQAMRAAGDEFETRFRRT', 'IIHKLAMQLRHIGDNIDHRMVRE']
   
    enatural = []
    for seq in natural:
        enatural.append(bcl2_uniprot_score(matrix, seq))
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    L = len(bim)
    
    #egenome = []
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/BH3_heuristicKRHNQST_seq.txt'
    nout_path = '/home/bartolo/web/statium/BH3_heuristicKRHNQST_names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    for i in range(len(seqs)):
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        #import pylab
        #pylab.hist(egenome, normed=1, alpha=0.8)
        #pylab.hist(enatural, normed=1, alpha=0.8)
        #pylab.savefig('/home/bartolo/web/statium/homology_scored_hist.png')
        #pylab.close()
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
            
            P = 0
            for k in range(5, 19):
            if seq[k] == 'P':
                P += 1
                break
        if P == 1: continue
        
        if not seq[8] in 'AFILMVWY' or not seq[12] in 'AGSV' or not seq[13] in 'KRHNQST': continue
        #if not seq[5] in 'ACGSTV': continue
            if seq[13] in 'CM': continue
            seq2 = ''
            for k in range(L):
            if k == 13: seq2 += seq[k]
            else: seq2 += seq[k]
            if not seq2 in seq_vec: seq_vec.append(seq2)
            else: continue
            
            #print seq, seq_lines[seqs[i][1] - 2].strip()
            
        soutfile.write(seq2 + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()
    
def bcl2_homology_score(matrix, seq):
  
    e = 0.0
    for j in range(len(seq)):
    aa = AAChar_int(seq[j])
    if aa < 20:
        e += matrix[j][aa]
    return e
    
def pfam_uniprot():
  
    fpath = '/home/bartolo/web/homology/PF00452.full'
    idx = [62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 74, 75, 76, 77]
    
    lines = readlines(fpath)
    for line in lines:
        items = line.split()
        if len(items) > 1:
        if items[0][0] != '#' and items[0] != '//':
            print items[0].split('/')[0]
            
def bcl2_uniprot_score(matrix, seq):
  
    e = 0.0
    for j in range(12):
    aa = AAChar_int(seq[j + 4])
    if aa < 20:
        e -= matrix[j][aa]
    return e
            
def uniprot_bcl2_matrix():
  
    fpath = '/home/bartolo/web/homology/PF00452_uniprot2.txt'
    use_idx = [37, 38, 39, 40, 41, 42, 43, 54, 55, 56, 57, 59]
    gap_idx = [44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 58]
    
    lines = readlines(fpath)
    items = lines[0].split()
    align = []
    for item in items:
        if len(item) > 20:
        align.append(item)
        
    seqs = []
    for raw in align:
        seq = ''
        use = True
        for j in range(len(raw)):
        if j in use_idx:
            if AAChar_int(raw[j]) < 20: seq += raw[j]
            else: use = False
        if j in gap_idx and raw[j] != '-': use = False
    if not seq in seqs and use: seqs.append(seq)

    for i in range(len(seqs)): print seqs[i]
    
    homology = []
    for i in range(12):
        homology.append([])
        for j in range(20): homology[i].append(0.0)
        
    for k in range(len(seqs)):
        seq = seqs[k]
        for i in range(12):
        aa = AAChar_int(seq[i])
        if aa < 20:
            homology[i][aa] += 1.0
            
    return homology
    
def return_number(val):
  
    print val[3]
    s = str(val)
    if s.find('x') > -1:
        pre = float(s.split('x')[0])
        exp = float(s.split('x')[1][2:len(s.split('x')[1])])
        return pre * (10 ** exp)
    else: return float(val)
    
def uniprot_blast(ip):

   data = lines2list(ip)
   names = []
   species = []
   for i in range(len(data)):
       if len(data[i]) > 5:
       find = False
       for j in range(len(data[i])):
           if str(data[i][j])[-1] == '%':
           #print data[i]
           name = data[i - 2][1]
           try: specie = name.split('_')[1]
           except: continue
           percent = float(data[i][j][0:len(data[i][j]) - 1])
           if str(data[i][j + 2]).find('-') > -1: evalue = 0.000001
           else: evalue = data[i][j + 2]
           if not name in names and percent > 50.0 and evalue < 0.05 and not specie in species:
                   names.append(name)
                   species.append(specie)
                   print name
                   

def uniprot_align(ip):

    data = lines2list(ip)
    name = os.path.split(ip)[1].split('.')[0]
    align = [[], []]
    for i in range(1000):
        if len(data[2 + i]) > 1:
            if len(data[2 + i][0].split('|')) > 2:
            align[0].append(data[2 + i][0])
            align[1].append('')
        else: break
       
    for i in range(len(data)):
        if len(data[i]) > 1:
            if len(data[i][0].split('|')) > 2:
            align[1][align[0].index(data[i][0])] += data[i][1]
           
    of = open(os.path.join('/home/bartolo/web/statium/BH3_conserve/', name + '_align.txt'), 'w')
    for i in range(len(align[0])):
        of.write(align[1][i] + '\t' + align[0][i] + '\n')
        #print align[1][i] + '\t' + align[0][i]
    of.close()
    #BH3_entropy('/home/bartolo/web/statium/BH3_conserve/Noxa_align.txt')
    
def BH3_entropies():
    
    #known = ['Bmf','Pcna','Bclw','Bid','Bclg','Bfk','Hrk','Puma','Bfl1','Bok','Bak','Bcl2','Bik','Bax','Mcl1','Bclxl','Noxa','Rad9','Bim','Mule','Beclin']
    known = ['RAD50I', 'Karyopherin', 'DNAdepProtKin', 'Efil', 'Clatherin', 'CRKass', 'InisitolPhosRtype3', 'MAPK8I', 'HistDacet3', 'Prohib', 'Vincul', 'AdenlateCyc8', 'ChromAss', 'ChaperoninT', 'Kinesin13A', 'Mtor', 'SpermAssAnt', 'AdenlateCyc6', 'LipSens', 'Crebb', 'StriatinCal', 'NucRecepCorep', 'Ron', 'HIRA']
    SPOT_vec = PSSM5()
    ents = [[], []]
    kdir = '/home/bartolo/web/statium/BH3_conserve'
    l = os.listdir(kdir)
    for i in range(len(l)):
        if len(l[i].split('.')[0].split('_')) == 2:
        if l[i].split('.')[0].split('_')[1] == 'align':
            name = l[i].split('.')[0].split('_')[0]
            #print name
            path = os.path.join(kdir, l[i])
            ent = BH3_entropy(path)
            #try: ent = BH3_entropy(path)
            #except:
            #print name, 'error'
            #continue
        pssm_info = BH3_align_PSSM(SPOT_vec, path)
            print name, round(ent[0], 2), round(ent[1], 2)
            print pssm_info[0], pssm_info[1], pssm_info[2], pssm_info[3]
            print pssm_info[4], pssm_info[5], pssm_info[6], pssm_info[7]
            print pssm_info[8]
            if name in known:
                ents[0].append(ent[0])
                ents[1].append(ent[1])
    #return
    import pylab

    #print pylab.rcParams
    pylab.rcParams['xtick.labelsize'] = '14'
    pylab.rcParams['ytick.labelsize'] = '14'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='8'
    pylab.rcParams['ytick.major.pad']='8'
    #pylab.rcParams['figure.figsize'] = (10.0, 10.0)
    #pylab.rcParams['svg.image_noscale'] = True
    minp = min(min(ents[0]), min(ents[1]))
    maxp = max(max(ents[0]), max(ents[1]))
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    ax.scatter(ents[0], ents[1], marker='o', s=100, facecolor='none', edgecolors='red')
    ax.plot([minp, maxp], [minp, maxp], lw=3)
    ax.set_xlim([minp, maxp])
    ax.set_ylim([minp, maxp])
    ax.set_aspect('equal')
    pylab.savefig('/home/bartolo/web/statium/BH3_conserve/pred_scatter2.png')
    
def BH3_align_PSSM(SPOT_vec, align_path):
  
    data = lines2list(align_path)
    start = int(data[0][0].split('-')[0])
    end = int(data[0][0].split('-')[1])
    
    seqs = []
    for i in range(len(data) - 1):
        prot = data[i + 1][0]
        seq = 'PEIW'
        for j in range(start, end + 1): seq += prot[j]
        seq += 'NAYARR'
        if not seq in seqs: seqs.append(seq)
      
    e0 = []
    e1 = []
    e2 = []
    e4 = []
    wt = pssm_energy10(SPOT_vec, seqs[0])
    ewt0 = wt[0]
    ewt1 = wt[1]
    ewt2 = wt[2]
    ewt4 = wt[4]
    for seq in seqs:
        epssm = pssm_energy10(SPOT_vec, seq)
        e0.append(epssm[0])
    e1.append(epssm[1])
    e2.append(epssm[2])
    e4.append(epssm[4])
    
    return [round(mean(e0), 2), round(mean(e1), 2), round(mean(e2), 2), round(mean(e4), 2), round(ewt0, 2), round(ewt1, 2), round(ewt2, 2), round(ewt4, 2), len(e0)]
        
def BH3_entropy(p):
  
    data = lines2list(p)
    
    frame = [int(data[0][0].split('-')[0]), int(data[0][0].split('-')[1])]
    
    count = []
    probs = []
    pos = []
    entropy = []
    for i in range(len(data[1][0])):
        aafind = 0
        for j in range(len(data) - 1):
        if AAChar_int(data[j + 1][0][i]) < 20: aafind += 1
        probs.append([])
        count.append([])
        pos.append(i)
        if float(aafind) / float(len(data) - 1) < 0.75:
        entropy.append('x')
        continue
        for j in range(20): probs[i].append(0.0)
        for j in range(20): count[i].append(0)
        
        for j in range(len(data) - 1):
        if AAChar_int(data[j + 1][0][i]) < 20: count[i][AAChar_int(data[j + 1][0][i])] += 1
    total = 0
    for j in range(20): total += count[i][j]
    if total > 0:
        for j in range(20): probs[i][j] = float(count[i][j]) / float(total)
    ent = 0.0
    for j in range(20):
        if probs[i][j] > 0.0: ent -= probs[i][j] * math.log(probs[i][j])
    entropy.append(ent)
    
    bh3_count = 0
    bh3 = 0.0
    out_count = 0
    out = 0.0
    count1 = 0
    inv = [[], []]
    outv = [[], []]
    for i in range(len(entropy)):
        if entropy[i] != 'x':
        if pos[i] + 11 < len(entropy):
            entmp = 0.0
        find = True
            for k in range(12):
            if entropy[i + k] == 'x':
            find = False
            break
            entmp += entropy[i + k]
        if find:
                count1 += 1
                if pos[i] == frame[0]:
                    inv[0].append(count1)
                    inv[1].append(entmp / 12.0)
                else:
                    outv[0].append(count1)
                    outv[1].append(entmp / 12.0)
      
      
    #print bh3_count, out_count
    return [inv[1][0], mean(outv[1])]
    
def BH3_entropy_value(p, frame):
  
    data = lines2list(p)
    
    seqs = []
    for i in range(len(data)):
        dash_count = 0
        for j in range(len(data[i])):
        if data[i][0][j] == '-': dash_count += 1
        if float(dash_count) / float(len(data[0][0])) < 0.10: seqs.append(data[i][0])
    
    count = []
    probs = []
    pos = []
    entropy = []
    for i in range(len(seqs[0])):

        aafind = 0
        for j in range(len(seqs)):
        if AAChar_int(seqs[j][i]) < 20: aafind += 1
        probs.append([])
        count.append([])
        pos.append(i)
        if float(aafind) / float(len(seqs)) < 0.50:
        entropy.append('x')
        continue
        for j in range(20): probs[i].append(0.0)
        for j in range(20): count[i].append(0)
        
        for j in range(len(seqs)):
        if AAChar_int(seqs[j][i]) < 20: count[i][AAChar_int(seqs[j][i])] += 1
    total = 0
    for j in range(20): total += count[i][j]
    if total > 0:
        for j in range(20): probs[i][j] = float(count[i][j]) / float(total)
    ent = 0.0
    for j in range(20):
        if probs[i][j] > 0.0: ent -= probs[i][j] * math.log(probs[i][j])
    entropy.append(ent)
    
    inv = [[], []]
    outv = [[], []]
    count1 = 0
    for i in range(len(entropy)):
        if entropy[i] != 'x':
        if pos[i] + 11 < len(entropy):
            entmp = 0.0
        find = True
            for k in range(12):
            if entropy[i + k] == 'x':
            find = False
            break
            entmp += entropy[i + k]
        if find:
                count1 += 1
                if pos[i] == frame:
                    inv[0].append(count1)
                    inv[1].append(entmp / 12.0)
                else:
                    outv[0].append(count1)
                    outv[1].append(entmp / 12.0)
        
    if mean(outv[1]) > 0: return inv[1][0] / mean(outv[1])
    else: return 0.0
    
def BH3_entropy_plot(p, op, frame0, r):

    zstd = [12.5964280762, 9.59343423497, 11.751603669, 11.8554232701, 10.1877121464]
    zmean = [19.1906407971, 14.274283119, 20.6483026992, 22.0019210125, 17.3106609485]

    zstdp = [0.957525719117, 0.917711243381, 0.518798747972, 0.948616660627, 0.635063414077]
    zmeanp = [3.98243723171, 4.41547882232, 1.69542278603, 2.94382294585, 2.62386345361]

    SPOT_vec = PSSM5()
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    data = lines2list(p)
    data1 = []
    for i in range(len(data)):
    dcount = 0
    for j in range(len(data[i][0])):
         if data[i][0][j] == '-': dcount += 1
    if float(dcount) / float(len(data[0][0])) < 0.25: data1.append(data[i][0])

    eby_pos = []
    eby_pos0 = []
    eby_idx = []
    for j in range(len(data1[0]) - 23):
    eby_pos.append([])
    eby_pos0.append(0.0)

    #v2 = [[], []]
    #for i in range(len(data[0][0])):
    #    v2[0].append(0.0)
#    v2[1].append(0.0)
 #   for i in range(len(data)):
#    prot = data[i][0]
#    for j in range(len(prot)):
#        if prot[j] == data[0][0][j]: v2[0][j] += 1.0
#        if AAChar_int(prot[j]) < 20: v2[1][j] += 1.0
 #   tal = 0.0
  #  for j in range(len(v2[0])):
#    rat = v2[0][j] / v2[1][j]
#    if rat == 1.0: tal += 1.0
    #print tal / float(len(v2[0]))


    for i in range(len(data1)):
    prot = data1[i]
    for j in range(len(prot) - 23):
        if i == 0: eby_idx.append(j + 1)
        seq = prot[j:j+23]
        try:
            energy_pssm = pssm_energy10(SPOT_vec, seq)

            px = energy_pssm[0]
            pm = energy_pssm[1]
            pf = energy_pssm[3]
            pw = energy_pssm[2]
            pb = energy_pssm[4]
    
            ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
        eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
        ef = statium_energy_calc_sidechain(fmode, seq, 0.0)

        zx = (ex - zmean[0]) / zstd[0]
        zm = (em - zmean[1]) / zstd[1]
            zw = (ew - zmean[2]) / zstd[2]
            zb = (eb - zmean[3]) / zstd[3]
            zf = (ef - zmean[4]) / zstd[4]

            zpx = (px - zmeanp[0]) / zstdp[0]
            zpm = (pm - zmeanp[1]) / zstdp[1]
            zpw = (pw - zmeanp[2]) / zstdp[2]
            zpb = (pb - zmeanp[3]) / zstdp[3]
            zpf = (pf - zmeanp[4]) / zstdp[4]
        eby_pos[j].append((eval('z' + r) + eval('zp' + r)) / 2.0)
        if i == 0: eby_pos0[j] = (eval('z' + r) + eval('zp' + r)) / 2.0
        if i == 0 and j == frame0-1: print seq, eval('z' + r), eval('zp' + r)
        except:
        if i == 0: eby_pos0[j] = 0.0
        eby_pos[j].append(0.0)

    eby_mean = []
    for i in range(len(eby_pos)): eby_mean.append(mean(eby_pos[i]))
    eby_std = []
    for i in range(len(eby_pos)): eby_std.append(std(eby_pos[i]))

    print eby_mean[frame0 - 1], eby_std[frame0 - 1]
    print eby_pos0[frame0 - 1]
    print data1[0][frame0-1:frame0+23]
    #return
      
    pos_idx = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
    
    frame = [frame0 - 1]
    
    count = []
    probs = []
    pos = []
    entropy = []
    for i in range(len(data1[0])):

        aafind = 0
        for j in range(len(data1)):
        if AAChar_int(data1[j][i]) < 20: aafind += 1
        probs.append([])
        count.append([])
        pos.append(i)
        if float(aafind) / float(len(data1)) < 0.0:
        entropy.append('x')
        continue
        for j in range(20): probs[i].append(0.0)
        for j in range(20): count[i].append(0)
        
        for j in range(len(data1)):
        if AAChar_int(data1[j][i]) < 20: count[i][AAChar_int(data1[j][i])] += 1
    total = 0
    for j in range(20): total += count[i][j]
    if total > 0:
        for j in range(20): probs[i][j] = float(count[i][j]) / float(total)
    ent = 0.0
    for j in range(20):
        if probs[i][j] > 0.0: ent -= probs[i][j] * math.log(probs[i][j])
    entropy.append(ent)
    
    inv = [[], []]
    outv = [[], []]
    count1 = 0
    for i in range(len(entropy)):
    #if i > 200: break
        if entropy[i] != 'x':
        if pos[i] + 16 < len(entropy):
            entmp = 0.0
        find = True
            for k in range(len(pos_idx)):
            seq_pos = i + pos_idx[k]
            if entropy[seq_pos] == 'x':
            find = False
            break
            comb_prob = 0.0
            ent = 0.0
#            for j in range(20):
#                if AAChar_fasta(j) in pos_tol[k]: comb_prob += probs[seq_pos][j]
#                else:
#                if probs[seq_pos][j] > 0.0: ent -= probs[seq_pos][j] * math.log(probs[seq_pos][j])
#            if comb_prob > 0.0: ent -= comb_prob * math.log(comb_prob)    
            for j in range(20):
            if probs[seq_pos][j] > 0.0: ent -= probs[seq_pos][j] * math.log(probs[seq_pos][j])
            entmp += ent
        if find:
                count1 += 1
                if pos[i] == frame[0]:
                    inv[0].append(count1)
                    inv[1].append(entmp / len(pos_idx))
                else:
                    outv[0].append(count1)
                    outv[1].append(entmp / len(pos_idx))
            
    import pylab
    import matplotlib

    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['figure.figsize'] = (15.0, 5.0)
    pylab.rcParams['axes.linewidth'] = 3.0
    #pylab.rcParams['svg.image_noscale'] = True
    #minp = min(min(ents[0]), min(ents[1]))
    #maxp = max(max(ents[0]), max(ents[1]))
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    #ax.scatter(ents[0], ents[1], marker='o', s=100, facecolor='none', edgecolors='red')
    matplotlib.pyplot.subplot(2, 1, 1)
    lwv1 = []
    for i in range(len(inv[0])): lwv1.append(4.0)
    lwv2 = []
    for i in range(len(outv[0])): lwv2.append(3.0)
    pylab.scatter(outv[0], outv[1], marker='o', s=120, facecolor='none', edgecolors='black', linewidths=lwv2)
    pylab.scatter(inv[0], inv[1], marker='o', s=200, facecolor='none', edgecolors='red', linewidths=lwv1)
    #if outv[0] > inv[0]: ax.set_xlim([inv[0][0] - 1, outv[0][-1] + 1])
    pylab.xlim(-1, len(data[0][0]) - 20)
    pylab.xticks([])
    #else: ax.set_xlim([outv[0][0] - 1, outv[0][-1] + 1])
    #ax.set_ylim([outv2[0][0], ])
    #ax.set_aspect('equal')
    matplotlib.pyplot.subplot(2, 1, 2)
    
    lws = []
    for i in range(len(eby_mean)):
    if i == frame0 - 1: lws.append(0.0)
    else: lws.append(3.0)
    pylab.scatter(eby_idx, eby_mean, marker='o', s=120, facecolor='none', edgecolors='black', linewidths=lws)
    pylab.scatter(inv[0], eby_mean[frame0 - 1], marker='o', s=200, facecolor='none', edgecolors='red', linewidth=4.0)
    pylab.xlim(-1, len(data[0][0]) - 20)
    pylab.savefig(op)            

    
def general_entropy_plot(p, op, frame0):

    data = lines2list(p)
    data1 = []
    for i in range(len(data)):
    dcount = 0
    for j in range(len(data[i][0])):
         if data[i][0][j] == '-': dcount += 1
    if float(dcount) / float(len(data[0][0])) < 0.25: data1.append(data[i][0])
    pos_idx = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
    
    frame = [frame0 - 1]
    
    count = []
    probs = []
    pos = []
    entropy = []
    for i in range(len(data1[0])):

        aafind = 0
        for j in range(len(data1)):
        if AAChar_int(data1[j][i]) < 20: aafind += 1
        probs.append([])
        count.append([])
        pos.append(i)
        if float(aafind) / float(len(data1)) < 0.0:
        entropy.append('x')
        continue
        for j in range(20): probs[i].append(0.0)
        for j in range(20): count[i].append(0)
        
        for j in range(len(data1)):
        if AAChar_int(data1[j][i]) < 20: count[i][AAChar_int(data1[j][i])] += 1
    total = 0
    for j in range(20): total += count[i][j]
    if total > 0:
        for j in range(20): probs[i][j] = float(count[i][j]) / float(total)
    ent = 0.0
    for j in range(20):
        if probs[i][j] > 0.0: ent -= probs[i][j] * math.log(probs[i][j])
    entropy.append(ent)
    
    inv = [[], []]
    outv = [[], []]
    count1 = 0
    for i in range(len(entropy)):
    #if i > 200: break
        if entropy[i] != 'x':
        if pos[i] + len(pos_idx) < len(entropy):
            entmp = 0.0
        find = True
            for k in range(len(pos_idx)):
            seq_pos = i + pos_idx[k]
            if entropy[seq_pos] == 'x':
            find = False
            break
            comb_prob = 0.0
            ent = 0.0
#            for j in range(20):
#                if AAChar_fasta(j) in pos_tol[k]: comb_prob += probs[seq_pos][j]
#                else:
#                if probs[seq_pos][j] > 0.0: ent -= probs[seq_pos][j] * math.log(probs[seq_pos][j])
#            if comb_prob > 0.0: ent -= comb_prob * math.log(comb_prob)    
            for j in range(20):
            if probs[seq_pos][j] > 0.0: ent -= probs[seq_pos][j] * math.log(probs[seq_pos][j])
            entmp += ent
        if find:
                count1 += 1
                if pos[i] == frame[0]:
                    inv[0].append(count1)
                    inv[1].append(entmp / len(pos_idx))
                else:
                    outv[0].append(count1)
                    outv[1].append(entmp / len(pos_idx))
            
    import pylab
    import matplotlib

    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['figure.figsize'] = (15.0, 5.0)
    pylab.rcParams['axes.linewidth'] = 3.0
    #pylab.rcParams['svg.image_noscale'] = True
    #minp = min(min(ents[0]), min(ents[1]))
    #maxp = max(max(ents[0]), max(ents[1]))
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    lwv1 = []
    for i in range(len(inv[0])): lwv1.append(4.0)
    lwv2 = []
    for i in range(len(outv[0])): lwv2.append(3.0)
    pylab.scatter(outv[0], outv[1], marker='o', s=120, facecolor='none', edgecolors='black', linewidths=lwv2)
    pylab.scatter(inv[0], inv[1], marker='o', s=200, facecolor='none', edgecolors='red', linewidths=lwv1)
    #if outv[0] > inv[0]: ax.set_xlim([inv[0][0] - 1, outv[0][-1] + 1])
    pylab.xlim(-1, len(data[0][0]) - 20)
    #pylab.xticks([])
    #else: ax.set_xlim([outv[0][0] - 1, outv[0][-1] + 1])
    #ax.set_ylim([outv2[0][0], ])
    #ax.set_aspect('equal')
    pylab.savefig(op)        

def Calmodulin_screening():
    import pylab

    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    #pylab.rcParams['figure.figsize'] = (7.0, 3.0)
    pylab.rcParams['axes.linewidth'] = 3.0
    #pylab.rcParams['svg.image_noscale'] = True
    #minp = min(min(ents[0]), min(ents[1]))
    #maxp = max(max(ents[0]), max(ents[1]))
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    #ax.scatter(ents[0], ents[1], marker='o', s=100, facecolor='none', edgecolors='red')
    a1 = pylab.array([44.1558441558, 29.1553133515, 21.0478771454, 16.8229166667, 15.3746210481, 14.7890208931, 14.9612719119, 14.7319544111, 15.2011225444, 14.7459727385, 14.9220489978, 13.8888888889])
    pylab.bar(pylab.arange(len(a1)), a1, color='w', edgecolor='b', linewidth=3, width=1.0, alpha=0.8, align='center')
    n = ['<-7', '<3', '<13', '<23', '<33', '<43', '<53', '<63', '<73', '<83', '<93', '>93']
    pylab.xticks(pylab.arange(len(a1)), n, rotation=30.0)
    pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([14.3, 14.3]), 'r--', lw=3)
    pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([2.3, 2.3]), 'g--', lw=3)
    #ax.set_ylim([outv2[0][0], ])
    #ax.set_aspect('equal')
    pylab.savefig('/home/bartolo/web/statium/Calmodulin_screening_test.png')            

def Calmodulin_pie():
  
    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    import matplotlib
    
    data = [0.02, 0.14, 0.44, 1.0]
    
    for k in range(len(data)):
        
        matplotlib.pyplot.subplot(2, 2, k + 1)
        #matplotlib.pyplot.figure(figsize=(8,8))
        #matplotlib.pyplot.axes([0.1, 0.1, 0.8, 0.8])
        matplotlib.pyplot.pie([data[k], 1 - data[k]], explode=[0.05, 0.0], labels=[str(round(data[k] * 100.0, 1)) + '%', ''], colors=['r', 'b'], autopct=None, shadow=True)
    pylab.savefig('/home/bartolo/web/statium/Calmodulin_pie.png')
    pylab.close()

def bcl2_homology_matrix():
  
    genome = lines2list('/home/bartolo/web/statium/BH3_test_loose_twoscores_IN.txt')
  
    fpath = '/home/bartolo/web/homology/PF00452.full'
    idx = [62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 74, 75, 76, 77]
    #fpath = '/home/bartolo/web/homology/PF02747.full'
    #idx = [129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 141, 143, 145, 151, 158, 160, 162, 165, 166, 169, 172, 174]
    #fpath = '/home/bartolo/web/homology/PF04139.full'
    #idx = [69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 81, 82, 83, 84, 85, 86, 87, 88, 96, 103, 109]
    append = '--------'
    #append = '-'
    
    bh3s = []
    lines = readlines(fpath)
    for line in lines:
        items = line.split()
        if len(items) > 1:
        if items[0][0] != '#' and items[0] != '//':
            bh3 = append
            for i in range(len(idx)):
            bh3 += line[idx[i]]
        if not bh3 in bh3s:
            bh3s.append(bh3)
            
    homology = []
    for i in range(23):
        homology.append([])
        for j in range(20): homology[i].append(0.0)
        
    for k in range(len(bh3s)):
        seq = bh3s[k]
        for i in range(23):
        aa = AAChar_int(seq[i])
        if aa < 20:
            homology[i][aa] += 1.0
            
    return homology
            
    for k in range(len(sample)):
        seq = sample[k][0:23]
        e = 0
        for j in range(len(seq)):
        aa = AAChar_int(seq[j])
        if aa < 20:
            e += homology[j][aa]
    #if e > 500: print e, sample[k].strip()
         
    pcna = 'PEIWIAQELRRIGDEFNAYYARR'
    #for i in range(23):
        #print pcna[i]
        #for j in range(20): print AAChar_fasta(j), homology[i][j]
        #print
        #print
        
    natural = ['WAREIAAQLRRMADDLNAQYERR','PEIWIAQELRRIGDEFNAYYARR','LEVECATQLRRFGDKLNFRQKLL','AAQRYGRELRRMSDEFVDSFKKG','TMGQVGRQLAIIGDDINRRYDSE','STKKLSECLKRIGDELDSNMELQ',
'EGEKEVEALKKSADWVSDWSSRP','AAQLTAARLKALGDELHQRTMWR','AEVQIARKLQCIADQFHRLHVQQ','GSDALALRLACIGDEMDVSLRAP','IIRNIARHLAQVGDSMDRSIPPG','MTQEVGQLLQDMGDDVYQQYRSL','TMENLSRRLKVTGDLFDIMSGQT','RLAEVCAVLLRLGDELEMIRPSV','VLGKAVHSLSRIGDELYLEPLED','VFGKAVQALSRISDEFWLDPSKK','EFARIARDLSHIGDAVVISAAKD','ILAKIVELLKYSGDQLERKDTAF','ILAKIVELLKYSGDQLERKLKKD','VPPVVHLTLRQAGDDFSRRYRRD','AADPLHQAMRAAGDEFETRFRRT', 'IIHKLAMQLRHIGDNIDHRMVRE']
        
        
    e_vec = []
    for i in range(len(genome)):
        seq = genome[i][0]
        if seq in natural: continue
        e = 0.0
        for j in range(len(seq)):
        aa = AAChar_int(seq[j])  
        if aa < 20:
            e += homology[j][aa]
    e_vec.append(e)
    
    en_vec = []
    for i in range(len(natural)):
        seq = natural[i]
        e = 0.0
        for j in range(len(seq)):
        aa = AAChar_int(seq[j])  
        if aa < 20:
            e += homology[j][aa]
    print seq, e
    en_vec.append(e)
    
    import pylab
    pylab.hist(e_vec, normed=1, alpha=0.8)
    pylab.hist(en_vec, normed=1, alpha=0.8)
    pylab.savefig('/home/bartolo/web/here2.png')
    
def screen_bar(idx, path):
    import matplotlib
    matplotlib.use( 'Agg' ) 
    import pylab

    print pylab.rcParams
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['axes.labelsize'] = '20'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['figure.figsize'] = (12.0, 10.0)
    pylab.rcParams['axes.linewidth'] = 3.0
    #pylab.rcParams['svg.image_noscale'] = True
    #minp = min(min(ents[0]), min(ents[1]))
    #maxp = max(max(ents[0]), max(ents[1]))
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')

    data = lines2list('/home/bartolo/web/statium/genome_screen_results.txt')
    #data = lines2list('/home/bartolo/web/statium/ArrayIII/signal.txt')
    
    
    for i in range(len(data)):
        if i == idx - 1:
    #    pylab.bar(pylab.arange(3), [data[i][1], data[i][2], data[i][4]], color='r', align='center')
        pylab.bar(pylab.arange(4), [data[i][1], data[i][2], data[i][3], data[i][4]], color='r', align='center')
        #pylab.yticks([])
            #pylab.xticks(pylab.arange(3), ['WT', '3aD', '3eL'])
            pylab.xticks(pylab.arange(4), ['Bcl-xL', 'Mcl-1', 'Bcl-w', 'Bfl-1'])
            pylab.ylabel('Fraction of Bim signal', labelpad=15)
            pylab.savefig(path)
            return
            
def array4():

    data = readlines('/home/bartolo/web/chosen_tmp.txt')
    
    for i in range(len(data)):
        if len(data[i].split()) > 1:
        if len(data[i].split()[0]) == 26:
            seq = data[i].split()[0]
            seqn = ''
            for j in range(len(seq)):
            if seq[j] == 'C': seqn += 'A'
            elif seq[j] == 'M': seqn += 'U'
            else: seqn += seq[j]
        print seqn + 'Z\t' + data[i][27:len(data[i])].strip()
        seqc = ''
        for j in range(len(seq)):
            if j == 10: seqc += 'D'
            else: seqc += seqn[j]
        print seqc + 'Z\t' + data[i][27:len(data[i])].strip()
        seqc = ''
        for j in range(len(seq)):
            if j == 14: seqc += 'L'
            else: seqc += seqn[j]
        print seqc + 'Z\t' + data[i][27:len(data[i])].strip()
            
        else: print data[i].strip()
    else: print data[i].strip()
    
def mdm_energy():
  
    mdme = load_design_energy('/home/bartolo/web/statium/MDM/mdm_3eqs')
    wt = 'TSFAEYWNLLSA'
    L = len(wt)
    
    print statium_energy_calc(mdme, wt, 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLPE', 0.0)
    print statium_energy_calc(mdme, 'TAFAEYWNLLSA', 0.0)
    print statium_energy_calc(mdme, 'LTFEHYWAQLTS', 0.0)
    print statium_energy_calc(mdme, 'PRFWEYWLRLME', 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLAE', 0.0)
    print statium_energy_calc(mdme, 'KSFQQYWQELML', 0.0)
    print statium_energy_calc(mdme, 'KTFEEYWLMLMS', 0.0)
    print statium_energy_calc(mdme, 'PSFWEHWVELML', 0.0)
    print statium_energy_calc(mdme, 'KRFQDYWSELML', 0.0)
    print statium_energy_calc(mdme, 'SVFPFLWMDLVA', 0.0)
    print statium_energy_calc(mdme, 'AVFPFLWLDLMA', 0.0)
    print statium_energy_calc(mdme, 'LYFLSELMELIA', 0.0)
    print statium_energy_calc(mdme, 'LFHWLNLYLHVA', 0.0)
    print statium_energy_calc(mdme, 'WKILSKFCLWLA', 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLPE', 0.0)
    
def mdx_energy():
  
    mdme = load_design_energy('/home/bartolo/web/statium/MDM/mdx_3fdo')
    wt = 'LTFEHYWAQLTS'
    L = len(wt)
    
    print statium_energy_calc(mdme, wt, 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLPE', 0.0)
    print statium_energy_calc(mdme, 'TAFAEYWNLLSA', 0.0)
    print statium_energy_calc(mdme, 'TSFAEYWNLLSA', 0.0)
    print statium_energy_calc(mdme, 'LTFEHYWAQLTS', 0.0)
    print statium_energy_calc(mdme, 'PRFWEYWLRLME', 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLAE', 0.0)
    print statium_energy_calc(mdme, 'KSFQQYWQELML', 0.0)
    print statium_energy_calc(mdme, 'KTFEEYWLMLMS', 0.0)
    print statium_energy_calc(mdme, 'PSFWEHWVELML', 0.0)
    print statium_energy_calc(mdme, 'KRFQDYWSELML', 0.0)
    print statium_energy_calc(mdme, 'SVFPFLWMDLVA', 0.0)
    print statium_energy_calc(mdme, 'AVFPFLWLDLMA', 0.0)
    print statium_energy_calc(mdme, 'LYFLSELMELIA', 0.0)
    print statium_energy_calc(mdme, 'LFHWLNLYLHVA', 0.0)
    print statium_energy_calc(mdme, 'WKILSKFCLWLA', 0.0)
    print statium_energy_calc(mdme, 'ETFSDLWKLLPE', 0.0)
        
def calmodulin_energy(energy_path):
  
    calmode = load_design_energy_sidechain('/home/bartolo/web/statium/calmodulin/calmodulin_2be6')
    fas = 'MLGIWTLLPLVLTSVARLSSKSVNAQVTDINSKGLELRKTVTTVETQNLEGLHHDGQFCHKPCPPGERKARDCTVNGDEPDCVPCQEGKEYTDKAHFSSKCRRCRLCDEGHGLEVEINCTRTQNTKCRCKPNFFCNSTVCEHCDPCTKCEHGIIKECTLTSNTKCKEEGSRSNLGWLCLLLLPIPLIVWVKRKEVQKTCRKHRKENQGSHESPTLNPETVAINLSDVDLSKYITTIAGVMTLSQVKGFVRKNGVNEAKIDEIKNDNVQDTAEQKVQLLRNWHQLHGKKEAYDTLIKDLKKANLCTLAEKIQTIILKDITSDSENSNFRNEIQSLV'
    civ = 'MVNENTRMYIPEENHQGSNYGSPRPAHANMNANAAAGLAPEHIPTPGAALSWQAAIDAARQAKLMGSAGNATISTVSSTQRKRQQYGKPKKQGSTTATRPPRALLCLTLKNPIRRACISIVEWKPFEIIILLTIFANCVALAIYIPFPEDDSNATNSNLERVEYLFLIIFTVEAFLKVIAYGLLFHPNAYLRNGWNLLDFIIVVVGLFSAILEQATKADGANALGGKGAGFDVKALRAFRVLRPLRLVSGVPSLQVVLNSIIKAMVPLLHIALLVLFVIIIYAIIGLELFMGKMHKTCYNQEGIAAEDDPSPCALETGHGRQCQNGTVCKPGWDGPKHGITNFDNFAFAMLTVFQCITMEGWTDVLYWVNDAVGRDWPWIYFVTLIIIGSFFVLNLVLGVLSGEFSKEREKAKARGDFQKLREKQQLEEDLKGYLDWITQAEDIDPENEDEGMDEEKPRNMSMPTSETESVNTENVAGGDIEGENCGARLAHRISKSKFSRYWRRWNRFCRRKCRAAVKSNVFYWLVIFLVFLNTLTIASEHYNQPNWLTEVQDTANKALLALFTAEMLLKMYSLGLQAYFVSLFNRFDCFVVCGGILETILVETKIMSPLGISVLRCVRLLRIFKITRYWNSLSNLVASLLNSVRSIASLLLLLFLFIIIFSLLGMQLFGGKFNFDEMQTRRSTFDNFPQSLLTVFQILTGEDWNSVMYDGIMAYGGPSFPGMLVCIYFIILFICGNYILLNVFLAIAVDNLADAESLTSAQKEEEEEKERKKLARTASPEKKQELVEKPAVGESKEEKIELKSITADGESPPATKINMDDLQPNENEDKSPYPNPETTGEEDEEEPEMPVGPRPRPLSELHLKEKAVPMPEASAFFIFSSNNRFRLQCHRIVNDTIFTNLILFFILLSSISLAAEDPVQHTSFRNHILFYFDIVFTTIFTIEIALKMTAYGAFLHKGSFCRNYFNILDLLVVSVSLISFGIQSSAINVVKILRVLRVLRPLRAINRAKGLKHVVQCVFVAIRTIGNIVIVTTLLQFMFACIGVQLFKGKLYTCSDSSKQTEAECKGNYITYKDGEVDHPIIQPRSWENSKFDFDNVLAAMMALFTVSTFEGWPELLYRSIDSHTEDKGPIYNYRVEISIFFIIYIIIIAFFMMNIFVGFVIVTFQEQGEQEYKNCELDKNQRQCVEYALKARPLRRYIPKNQHQYKVWYVVNSTYFEYLMFVLILLNTICLAMQHYGQSCLFKIAMNILNMLFTGLFTVEMILKLIAFKPKGYFSDPWNVFDFLIVIGSIIDVILSETNPAEHTQCSPSMNAEENSRISITFFRLFRVMRLVKLLSRGEGIRTLLWTFIKSFQALPYVALLIVMLFFIYAVIGMQVFGKIALNDTTEINRNNNFQTFPQAVLLLFRCATGEAWQDIMLACMPGKKCAPESEPSNSTEGETPCGSSFAVFYFISFYMLCAFLIINLFVAVIMDNFDYLTRDWSILGPHHLDEFKRIWAEYDPEAKGRIKHLDVVTLLRRIQPPLGFGKLCPHRVACKRLVSMNMPLNSDGTVMFNATLFALVRTALRIKTEGNLEQANEELRAIIKKIWKRTSMKLLDQVVPPAGDDEVTVGKFYATFLIQEYFRKFKKRKEQGLVGKPSQRNALSLQAGLRTLHDIGPEIRRAISGDLTAEEELDKAMKEAVSAASEDDIFRRAGGLFGNHVSYYQSDGRSAFPQTFTTQRPLHINKAGSSQGDTESPSHEKLVDSTFTPSSYSSTGSNANINNANNTALGRLPRPAGYPSTVSTVEGHGPPLSPAIRVQEVAWKLSSNRCHSRESQAAMAGQEETSQDETYEVKMNHDTEACSEPSLLSTEMLSYQDDENRQLTLPEEDKRDIRQSPKRGFLRSASLGRRASFHLECLKRQKDRGGDISQKTVLPLHLVHHQALAVAGLSPLLQRSHSPASFPRPFATPPATPGSRGWPPQPVPTLRLEGVESSEKLNSSFPSIHCGSWAETTPGGGGSSAARRVRPVSLMVPSQAGAPGRQFHGSASSLVEAVLISEGLGQFAQDPKFIEVTTQELADACDMTIEEMESAADNILSGGAPQSPNGALLPFVNCRDAGQDRAGGEEDAGCVRARGRPSEEELQDSRVYVSSL'
    mlck = 'MGDVKLVASSHISKTSLSVDPSRVDSMPLTEAPAFILPPRNLCIKEGATAKFEGRVRGYPEPQVTWHRNGQPITSGGRFLLDCGIRGTFSLVIHAVHEEDRGKYTCEATNGSGARQVTVELTVEGSFAKQLGQPVVSKTLGDRFSAPAVETRPSIWGECPPKFATKLGRVVVKEGQMGRFSCKITGRPQPQVTWLKGNVPLQPSARVSVSEKNGMQVLEIHGVNQDDVGVYTCLVVNGSGKASMSAELSIQGLDSANRSFVRETKATNSDVRKEVTNVISKESKLDSLEAAAKSKNCSSPQRGGSPPWAANSQPQPPRESKLESCKDSPRTAPQTPVLQKTSSSITLQAARVQPEPRAPGLGVLSPSGEERKRPAPPRPATFPTRQPGLGSQDVVSKAANRRIPMEGQRDSAFPKFESKPQSQEVKENQTVKFRCEVSGIPKPEVAWFLEGTPVRRQEGSIEVYEDAGSHYLCLLKARTRDSGTYSCTASNAQGQLSCSWTLQVERLAVMEVAPSFSSVLKDCAVIEGQDFVLQCSVRGTPVPRITWLLNGQPIQYARSTCEAGVAELHIQDALPEDHGTYTCLAENALGQVSCSAWVTVHEKKSSRKSEYLLPVAPSKPTAPIFLQGLSDLKVMDGSQVTMTVQVSGNPPPEVIWLHNGNEIQESEDFHFEQRGTQHSLCIQEVFPEDTGTYTCEAWNSAGEVRTQAVLTVQEPHDGTQPWFISKPRSVTASLGQSVLISCAIAGDPFPTVHWLRDGKALCKDTGHFEVLQNEDVFTLVLKKVQPWHAGQYEILLKNRVGECSCQVSLMLQNSSARALPRGREPASCEDLCGGGVGADGGGSDRYGSLRPGWPARGQGWLEEEDGEDVRGVLKRRVETRQHTEEAIRQQEVEQLDFRDLLGKKVSTKTLSEDDLKEIPAEQMDFRANLQRQVKPKTVSEEERKVHSPQQVDFRSVLAKKGTSKTPVPEKVPPPKPATPDFRSVLGGKKKLPAENGSSSAETLNAKAVESSKPLSNAQPSGPLKPVGNAKPAETLKPMGNAKPAETLKPMGNAKPDENLKSASKEELKKDVKNDVNCKRGHAGTTDNEKRSESQGTAPAFKQKLQDVHVAEGKKLLLQCQVSSDPPATIIWTLNGKTLKTTKFIILSQEGSLCSVSIEKALPEDRGLYKCVAKNDAGQAECSCQVTVDDAPASENTKAPEMKSRRPKSSLPPVLGTESDATVKKKPAPKTPPKAAMPPQIIQFPEDQKVRAGESVELFGKVTGTQPITCTWMKFRKQIQESEHMKVENSENGSKLTILAARQEHCGCYTLLVENKLGSRQAQVNLTVVDKPDPPAGTPCASDIRSSSLTLSWYGSSYDGGSAVQSYSIEIWDSANKTWKELATCRSTSFNVQDLLPDHEYKFRVRAINVYGTSEPSQESELTTVGEKPEEPKDEVEVSDDDEKEPEVDYRTVTINTEQKVSDFYDIEERLGSGKFGQVFRLVEKKTRKVWAGKFFKAYSAKEKENIRQEISIMNCLHHPKLVQCVDAFEEKANIVMVLEIVSGGELFERIIDEDFELTERECIKYMRQISEGVEYIHKQGIVHLDLKPENIMCVNKTGTRIKLIDFGLARRLENAGSLKVLFGTPEFVAPEVINYEPIGYATDMWSIGVICYILVSGLSPFMGDNDNETLANVTSATWDFDDEAFDEISDDAKDFISNLLKKDMKNRLDCTQCLQHPWLMKDTKNMEAKKLSKDRMKKYMARRKWQKTGNAVRAIGRLSSMAMISGLSGRKSSTGSPTSPLNAEKLESEEDVSQAFLEAVAEEKPHVKPYFSKTIRDLEVVEGSAARFDCKIEGYPDPEVVWFKDDQSIRESRHFQIDYDEDGNCSLIISDVCGDDDAKYTCKAVNSLGEATCTAELIVETMEEGEGEGEEEEE'
    
    wt = 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV'
    #wt = 'RRKWQKTGHAVRAIGRLSS'
    L = len(wt)
    
    #inv = [[], []]
    #outv = [[], []]
    #for i in range(0, len(mlck) - L):
        #seq = ''
        #for j in range(L): seq += mlck[i + j]
        #e = statium_energy_calc(calmode, seq, 0.0)
        #if seq == 'KDRMKKYMARRKWQKTGNAVRAIGRLSSM':
              
        #inv[0].append(i + 1)
        #inv[1].append(e)
    #else:
        #outv[0].append(i + 1)
        #outv[1].append(e)
    
    print statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
    print statium_energy_calc(calmode, 'EVTVGKEYATFLIQEYFRKFKKRKEQGLV', 0.0)
    return
    #print statium_energy_calc(calmode, 'SKYITVIAEHMTISQVRDFVRKNGVNEAK', 0.0)
    #print statium_energy_calc(calmode, 'NTYIPTIAEQMTLTQVKVFVRKNGVNEAK', 0.0)
    #print statium_energy_calc(calmode, 'GKYITRIAEQMKITEVKDFVRKNGIEETK', 0.0)
    #print statium_energy_calc(calmode, 'SKYILAIAELMELDKVKKFVRKNGISETK', 0.0)
    #print statium_energy_calc(calmode, 'SKHIPKITEIMTINEVREFVRKNGVPEAK', 0.0)
    #print statium_energy_calc(calmode, 'SKYIISIAEEMTINQVREFVRKNGINEAK', 0.0)
    #print statium_energy_calc(calmode, 'LKFIFEYVDIVPFDSWNRFMRQIGLTDNQI', 0.0)
    #print statium_energy_calc(calmode, 'SNFLKLKNAATLIQRHWRGHNCRKNYGLM', 0.0)
    #print statium_energy_calc(calmode, 'QLWLANEGLITRLQARCRGYLVRQEFRSR', 0.0)
    #print statium_energy_calc(calmode, 'RRYKIRRAATIVLQSYLRGFLARNRYRKI', 0.0)
    
    #import pylab

    #pylab.rcParams['xtick.labelsize'] = '16'
    #pylab.rcParams['ytick.labelsize'] = '16'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.rcParams['xtick.major.pad']='12'
    #pylab.rcParams['ytick.major.pad']='12'
    #pylab.rcParams['figure.figsize'] = (20.0, 10.0)
    #pylab.rcParams['axes.linewidth'] = 3.0
    ##pylab.rcParams['svg.image_noscale'] = True
    ##minp = min(min(ents[0]), min(ents[1]))
    ##maxp = max(max(ents[0]), max(ents[1]))
    #fig = pylab.figure()    # Create a figure
    #ax = fig.gca()
    #for tick in ax.xaxis.get_major_ticks():
        #tick.label1.set_fontsize('18')
        #tick.label1.set_fontweight('bold')
    #for tick in ax.yaxis.get_major_ticks():
        #tick.label1.set_fontsize('18')
        #tick.label1.set_fontweight('bold')
    ##ax.scatter(ents[0], ents[1], marker='o', s=100, facecolor='none', edgecolors='red')
    #lwv1 = []
    #for i in range(len(inv[0])): lwv1.append(4.0)
    #lwv2 = []
    #for i in range(len(outv[0])): lwv2.append(3.0)
    #ax.scatter(outv[0], outv[1], marker='o', s=120, facecolor='none', edgecolors='black', linewidths=lwv2)
    #ax.scatter(inv[0], inv[1], marker='o', s=250, facecolor='none', edgecolors='red', linewidths=lwv1)
    #if outv[0] > inv[0]: ax.set_xlim([inv[0][0] - 1, outv[0][-1] + 1])
    #else: ax.set_xlim([outv[0][0] - 1, outv[0][-1] + 1])
    ##ax.set_ylim([outv2[0][0], ])
    ##ax.set_aspect('equal')
    #pylab.savefig('/home/bartolo/web/statium/Calmodulin_mlck_profile.png')            

    L = len(wt)
    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(calmode, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/Group_101912/Calmodulin_hist.png')
        pylab.close()
        print 'done'

def scanergy():
  
    scan_stat = load_design_energy('/home/bartolo/web/statium/SCAN/scan_3lhr')
    print statium_energy_calc(scan_stat, 'IFRQRFRQFGYQDSPGPREAVSQLRELCRLWLRPETHTKEQILELVVLEQFVAILPKELQTWVRDHHPENGEEAVTVLEDLESIFRQRFRQFGYQDSPGPREAVSQLRELCRLWLRPETHTKEQILELVVLEQFVAILPKELQTWVRDHHPENGEEAVTVLEDLES', 0.0)

def scand_matrix():

    e_vec = []
    seq_list = []
    scan_stat = load_design_energy('/home/bartolo/web/statium/SCAN/scan_3lhr')
    data = lines2list('/home/bartolo/web/statium/SCAN/SCAN_human_unique.pfam')
    same_vec = []
    diff_vec = []
    for i in range(len(data)):
        sub = []
        for j in range(len(data)):
        name = data[i][0] + '_' + data[j][0]
        seq = data[i][1] + data[j][1]
        seq_list.append(seq)
        L = len(seq)
        e = statium_energy_calc(scan_stat, seq, 0.0)
        if i != j: sub.append(e)
        if i == j: same = e
        if i == j:  e_vec.append(e)
        #print name + '\t' + str(round(statium_energy_calc(scan_stat, seq, 0.0), 2)) + '\t' + seq
        min_e = min(sub)
    max_e = max(sub)
    if same < min_e: min_e = same
    if same > max_e: max_e = same
    #print min_e, max_e, same
    same_n = (same - min_e) / (max_e - min_e)
    same_vec.append(same - mean(sub))
    for k in range(len(sub)): diff_vec.append((sub[k] - min_e) / (max_e - min_e))

    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(scan_stat, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/Group_101912/SCAN.png')
        pylab.close()
        print 'done'

def random_seq(L):
  
    new = ''
    for i in range(L):
        new += AAChar_fasta(random.randint(0, 19))
    return new
    
def random_seq_from_list(seq_list, L):
  
    new = ''
    for i in range(L):
        seq_idx = random.randint(0, len(seq_list))
        new += seq_list[seq_idx][i]
    return new
    
def cal_sim_lib():
  
    calmode = load_design_energy('/home/bartolo/web/statium/calmodulin/calmodulin_2be6')
  
    select = []
    print statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
  
    #select.append(statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0))
    
    tlib = []
    for i in range(1000000):
        tlib.append(statium_energy_calc(calmode, random_cal_seq(), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(select), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), normed=True, facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/test.png')
        pylab.close()
        print 'done'

def calmodulin_energy2():
  
    calmode = load_design_energy('/home/bartolo/web/statium/calmodulin_custom/calmodulin_2vb6')
    #fas = 'MLGIWTLLPLVLTSVARLSSKSVNAQVTDINSKGLELRKTVTTVETQNLEGLHHDGQFCHKPCPPGERKARDCTVNGDEPDCVPCQEGKEYTDKAHFSSKCRRCRLCDEGHGLEVEINCTRTQNTKCRCKPNFFCNSTVCEHCDPCTKCEHGIIKECTLTSNTKCKEEGSRSNLGWLCLLLLPIPLIVWVKRKEVQKTCRKHRKENQGSHESPTLNPETVAINLSDVDLSKYITTIAGVMTLSQVKGFVRKNGVNEAKIDEIKNDNVQDTAEQKVQLLRNWHQLHGKKEAYDTLIKDLKKANLCTLAEKIQTIILKDITSDSENSNFRNEIQSLV'
    civ = 'MVNENTRMYIPEENHQGSNYGSPRPAHANMNANAAAGLAPEHIPTPGAALSWQAAIDAARQAKLMGSAGNATISTVSSTQRKRQQYGKPKKQGSTTATRPPRALLCLTLKNPIRRACISIVEWKPFEIIILLTIFANCVALAIYIPFPEDDSNATNSNLERVEYLFLIIFTVEAFLKVIAYGLLFHPNAYLRNGWNLLDFIIVVVGLFSAILEQATKADGANALGGKGAGFDVKALRAFRVLRPLRLVSGVPSLQVVLNSIIKAMVPLLHIALLVLFVIIIYAIIGLELFMGKMHKTCYNQEGIAAEDDPSPCALETGHGRQCQNGTVCKPGWDGPKHGITNFDNFAFAMLTVFQCITMEGWTDVLYWVNDAVGRDWPWIYFVTLIIIGSFFVLNLVLGVLSGEFSKEREKAKARGDFQKLREKQQLEEDLKGYLDWITQAEDIDPENEDEGMDEEKPRNMSMPTSETESVNTENVAGGDIEGENCGARLAHRISKSKFSRYWRRWNRFCRRKCRAAVKSNVFYWLVIFLVFLNTLTIASEHYNQPNWLTEVQDTANKALLALFTAEMLLKMYSLGLQAYFVSLFNRFDCFVVCGGILETILVETKIMSPLGISVLRCVRLLRIFKITRYWNSLSNLVASLLNSVRSIASLLLLLFLFIIIFSLLGMQLFGGKFNFDEMQTRRSTFDNFPQSLLTVFQILTGEDWNSVMYDGIMAYGGPSFPGMLVCIYFIILFICGNYILLNVFLAIAVDNLADAESLTSAQKEEEEEKERKKLARTASPEKKQELVEKPAVGESKEEKIELKSITADGESPPATKINMDDLQPNENEDKSPYPNPETTGEEDEEEPEMPVGPRPRPLSELHLKEKAVPMPEASAFFIFSSNNRFRLQCHRIVNDTIFTNLILFFILLSSISLAAEDPVQHTSFRNHILFYFDIVFTTIFTIEIALKMTAYGAFLHKGSFCRNYFNILDLLVVSVSLISFGIQSSAINVVKILRVLRVLRPLRAINRAKGLKHVVQCVFVAIRTIGNIVIVTTLLQFMFACIGVQLFKGKLYTCSDSSKQTEAECKGNYITYKDGEVDHPIIQPRSWENSKFDFDNVLAAMMALFTVSTFEGWPELLYRSIDSHTEDKGPIYNYRVEISIFFIIYIIIIAFFMMNIFVGFVIVTFQEQGEQEYKNCELDKNQRQCVEYALKARPLRRYIPKNQHQYKVWYVVNSTYFEYLMFVLILLNTICLAMQHYGQSCLFKIAMNILNMLFTGLFTVEMILKLIAFKPKGYFSDPWNVFDFLIVIGSIIDVILSETNPAEHTQCSPSMNAEENSRISITFFRLFRVMRLVKLLSRGEGIRTLLWTFIKSFQALPYVALLIVMLFFIYAVIGMQVFGKIALNDTTEINRNNNFQTFPQAVLLLFRCATGEAWQDIMLACMPGKKCAPESEPSNSTEGETPCGSSFAVFYFISFYMLCAFLIINLFVAVIMDNFDYLTRDWSILGPHHLDEFKRIWAEYDPEAKGRIKHLDVVTLLRRIQPPLGFGKLCPHRVACKRLVSMNMPLNSDGTVMFNATLFALVRTALRIKTEGNLEQANEELRAIIKKIWKRTSMKLLDQVVPPAGDDEVTVGKFYATFLIQEYFRKFKKRKEQGLVGKPSQRNALSLQAGLRTLHDIGPEIRRAISGDLTAEEELDKAMKEAVSAASEDDIFRRAGGLFGNHVSYYQSDGRSAFPQTFTTQRPLHINKAGSSQGDTESPSHEKLVDSTFTPSSYSSTGSNANINNANNTALGRLPRPAGYPSTVSTVEGHGPPLSPAIRVQEVAWKLSSNRCHSRESQAAMAGQEETSQDETYEVKMNHDTEACSEPSLLSTEMLSYQDDENRQLTLPEEDKRDIRQSPKRGFLRSASLGRRASFHLECLKRQKDRGGDISQKTVLPLHLVHHQALAVAGLSPLLQRSHSPASFPRPFATPPATPGSRGWPPQPVPTLRLEGVESSEKLNSSFPSIHCGSWAETTPGGGGSSAARRVRPVSLMVPSQAGAPGRQFHGSASSLVEAVLISEGLGQFAQDPKFIEVTTQELADACDMTIEEMESAADNILSGGAPQSPNGALLPFVNCRDAGQDRAGGEEDAGCVRARGRPSEEELQDSRVYVSSL'
    
    wt = 'HWLTCSRWKKVQWCSLSVIKLKNKIKYR'
#         'EVTVGKFYATFLIQEYFRKFKKRKEQGLV'
    L = len(wt)

    #for i in range(0, len(civ) - L):
        #seq = ''
        #for j in range(L): seq += civ[i + j]
        #print seq, statium_energy_calc(calmode, seq, 0.0)
    
    print statium_energy_calc(calmode, wt, 0.0)
    
def calenergycalc(epath, seq):
  
    calmode = load_design_energy_sidechain(epath)
    print statium_energy_calc_sidechain(calmode, seq, 0.0)
    
def statiumcalc(epath, seq):
  
    mode = load_design_energy_sidechain(epath)
    print statium_energy_calc_sidechain(mode, seq, 0.0)
    
def statiumlistcalc(epath, seq_path):
  
    mode = load_design_energy_sidechain(epath)
    data = lines2list(seq_path)
    for i in range(len(data)):
        seq = data[i][0]
        print statium_energy_calc_sidechain(mode, seq, 0.0)
        
def statiumcalc_jmb(epath, seq):
  
    mode = load_design_energy(epath)
    print statium_energy_calc(mode, seq, 0.0)
    
def statiumlistcalc_jmb(epath, seq_path):
  
    mode = load_design_energy(epath)
    data = lines2list(seq_path)
    for i in range(len(data)):
        seq = data[i][0]
        print statium_energy_calc(mode, seq, 0.0)

def calhist(epath, plot_path):

    calmode = load_design_energy_sidechain(epath)
    ewt = statium_energy_calc_sidechain(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
    print 'Wild type energy', ewt
    seq_data = lines2list('/home/bartolo/web/statium/Calmodulin_seq.txt')
    seq2_data = lines2list('/home/bartolo/web/hered.txt')
    
    ehist = []
    for i in range(len(seq_data)):
        if i % 10000 == 0: print float(i) / float(len(seq_data))
        seq = seq_data[i][0]
    e = statium_energy_calc_sidechain(calmode, seq, 0.0)
    ehist.append(e)

    ehist2 = []
    for i in range(len(seq2_data)):
        seq = seq2_data[i][0]
    e = statium_energy_calc_sidechain(calmode, seq, 0.0)
    ehist2.append(e)
    
    import matplotlib
    matplotlib.use( 'Agg' )      
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        
    hdata = pylab.hist(pylab.array(ehist), normed=True, facecolor='white', edgecolor='black', lw=2)
    hdata2 = pylab.hist(pylab.array(ehist2), normed=True, facecolor='white', edgecolor='blue', lw=2)
    #ymax = max(hdata[0]) * 1.2
    #pylab.plot([ewt, ewt], [0, ymax], 'b', lw=2)
    #pylab.ylim(0, ymax)
    pylab.savefig(plot_path)

def Cal_genome_all_energy():
  
    calmode = load_design_energy('/home/bartolo/web/statium/calmodulin/calmodulin_2be6') 
    ewt = statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
    seq_data = lines2list('/home/bartolo/web/statium/Calmodulin_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/Calmodulin_names.txt')
    shared_data = lines2list('/home/bartolo/web/statium/Calmodulin_INhomol_wstruc23_20r.txt')
    al2 = lines2list('/home/bartolo/web/statium/Calmodulin_shared_wstruc23_20.txt')
    of = open('/home/bartolo/web/statium/Calmodulin_2be6_energies.txt', 'w')
    
    names = []
    e_hist = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)

    elims = []
    for i in range(12): elims.append(ewt + float(i) * 10.0)
    esegs = []
    for i in range(12): esegs.append([[], [], 0, 0])
    
    #ps = '['
    #for i in range(12):
        #if i == 11: ps += '\'>' + str(round(elims[10], 0)) + '\']'
        #else: ps += '\'<' + str(round(elims[i], 0)) + '\', '
    #print ps
    #return
    
    
        
    low_unique = [[], [], 0, 0]
    all_unique = [[], [], 0, 0]
    high_unique = [[], [], 0, 0]
    shared_unique1 = [[], [], 0, 0]
    shared_unique2 = [[], [], 0, 0]
    for i in range(len(seq_data)):
    
    if not names[i] in all_unique[0]:
        all_unique[0].append(names[i])
        all_unique[1].append(shared_data[i][0])
        if shared_data[i][0] == 1.0: all_unique[2] += 1
        all_unique[3] += 1

        seq = seq_data[i][0]
        try: e = statium_energy_calc(calmode, seq, 0.0)
        except: continue
        e_index = 0
        eif = False
        for x in range(11):
        if e <= elims[x]:
            e_index = x
            eif = True
            break
    if not eif: e_index = 11
        e_hist.append(e)
        if True:
        if not names[i] in high_unique[0]:
            high_unique[0].append(names[i])
            high_unique[1].append(shared_data[i][0])
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: high_unique[2] += 1
            if al2[i][0] > 0.0: high_unique[3] += 1
            
    if e <= ewt:
        if not names[i] in low_unique[0]:
            low_unique[0].append(names[i])
            low_unique[1].append(shared_data[i][0])
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: low_unique[2] += 1
            if al2[i][0] > 0.0: low_unique[3] += 1
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: print seq, e, names[i]
        else:
            #if shared_data[i][0] == 1.0 and al2[i][0] > 0.0:
            if al2[i][0] > 0.0:
            print seq, e, names[i]
            
    if True:
        if not names[i] in esegs[e_index][0]:
            esegs[e_index][0].append(names[i])
            esegs[e_index][1].append(shared_data[i][0])
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: esegs[e_index][2] += 1
            if al2[i][0] > 0.0: esegs[e_index][3] += 1
            #if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: print seq, e, names[i]
        #else:
            #if shared_data[i][0] == 1.0 and al2[i][0] > 0.0:
            #print seq, e, names[i]

    #fins = []
    #for i in range(12):
        #if float(esegs[i][3]) > 0.0: print elims[i], fins.append(float(esegs[i][2]) / float(esegs[i][3]))
        
    #for i in range(12): print str(100.0 * fins[i]) + ',',
    if all_unique[3] > 0: print float(all_unique[2]) / float(all_unique[3])
    if high_unique[3] > 0: print float(high_unique[2]) / float(high_unique[3])
    if low_unique[3] > 0:print float(low_unique[2]) / float(low_unique[3])
    print
    
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        
    pylab.hist(pylab.array(e_hist), normed=False, facecolor='white', edgecolor='black', lw=2)
    pylab.savefig('/home/bartolo/web/statium/Calmodulin_2be6_dist.png')
    
def Cal_genome_all_energy_bar(epath, enrich_path, plot_path):
  
    calmode = load_design_energy(epath)
    ewt = statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
    print statium_energy_calc(calmode, 'NDEDSDIKKIKKVQSFLRGWLCRRKWKTI', 0.0)
    return
    #ewt = statium_energy_calc(calmode, 'RRKWQKTGNAVRAIGRLSS', 0.0)
    seq_data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin2be6_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/calmodulin/Calmodulin2be6_names.txt')
    shared_data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin2be6_INhomolr.txt')
    al2 = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin2be6_shared.txt')
    elist = statium_evec(epath, '/home/bartolo/web/statium/calmodulin/Calmodulin2be6_seq.txt', 0.0)
    ofile = open(enrich_path, 'w')
    emin = min(elist)
    emax = max(elist)
    print ewt
    
    names = []
    e_hist = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)

    esegs = []
    for i in range(10): esegs.append([[], [], 0, 0])
        
    for i in range(len(seq_data)):
    
    try: e_index = int(((elist[i] - emin) / (emax - emin)) / 0.1)
    except: continue
    if e_index > 9: continue
    if not names[i] in esegs[e_index][0]:
        esegs[e_index][0].append(names[i])
        esegs[e_index][1].append(shared_data[i][0])
        if shared_data[i][0] == 1.0 and al2[i][0] > 0.0:
            if elist[i] < -20.0: print seq_data[i][0], names[i]
            esegs[e_index][2] += 1
        if al2[i][0] > 0.0: esegs[e_index][3] += 1
    else:
        if shared_data[i][0] == 1.0 and al2[i][0] > 0.0:
            if elist[i] < -20.0: print seq_data[i][0], names[i]
        
    enrich = []
    cutoff = []
    for i in range(10):
        if (i + 1) % 2 == 0: cutoff.append('')
        else: cutoff.append('<' + str(round(0.1 + float(i) * 0.1, 2)))
        if float(esegs[i][3]) > 0.0: enrich.append(float(esegs[i][2]) / float(esegs[i][3]))
        else: enrich.append(0.0)
        ofile.write(str(round(0.1 + float(i) * 0.1, 2)) + '\t' + str(enrich[-1]) + '\t' + str(esegs[i][3]) + '\n')
    ofile.close()
    
    try:
        import matplotlib
        matplotlib.use( 'Agg' )            
    except:
        print 'no pylab'
        return
    try: import pylab
    except:
        print 'no pylab, no plot'
        return

    pylab.rcParams['xtick.labelsize'] = '4'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    #####a1 = pylab.array(enrich)
    #####pylab.bar(pylab.arange(len(a1)), a1, color='w', edgecolor='b', linewidth=3, width=1.0, alpha=0.8, align='center')
    #####n = cutoff
    #####pylab.xticks(pylab.arange(len(a1)), n, rotation=30.0)
    #####pylab.ylim(0.0, 0.65)
    #####pylab.xlim(-1, 20)
    ######pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([14.3, 14.3]), 'r--', lw=3)
    ######pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([2.3, 2.3]), 'g--', lw=3)
    ######ax.set_ylim([outv2[0][0], ])
    ######ax.set_aspect('equal')
    #####pylab.savefig(plot_path)
    
    pylab.close()
    import pylab
    pylab.hist(elist)
    pylab.savefig(plot_path)
    
def CAMP_genome_all_energy_bar(epath, enrich_path, plot_path):
  
    calmode = load_design_energy(epath) 
    wt = readline('/home/bartolo/web/statium/CAMP/camp_4dg2.fasta', 1)
    ewt = statium_energy_calc(calmode, wt, 0.0)
    wt_base = wt[0:347]
    seq_data = lines2list('/home/bartolo/web/statium/CAMP/CAMP_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/CAMP/CAMP_names.txt')
    shared_data = lines2list('/home/bartolo/web/statium/CAMP/CAMP_INhomolr.txt')
    al2 = lines2list('/home/bartolo/web/statium/CAMP/CAMP_shared.txt')
    #elist = statium_evec(epath, '/home/bartolo/web/statium/Calmodulin_seq.txt', 0.0)
    elist = []
    for i in range(len(seq_data)):
        seq = wt_base + seq_data[i][0]
        try: elist.append(statium_energy_calc(calmode, seq, 0.0))
        except:
        print seq
        return
    ofile = open(enrich_path, 'w')
    emin = min(elist)
    emax = max(elist)
    
    names = []
    e_hist = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)

    esegs = []
    for i in range(20): esegs.append([[], [], 0, 0])
        
    for i in range(len(seq_data)):
    
    try: e_index = int(((elist[i] - emin) / (emax - emin)) / 0.05)
    except: continue
    if e_index > 19: continue
    if not names[i] in esegs[e_index][0]:
        esegs[e_index][0].append(names[i])
        esegs[e_index][1].append(shared_data[i][0])
        if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: esegs[e_index][2] += 1
        if al2[i][0] > 0.0: esegs[e_index][3] += 1
        
    enrich = []
    cutoff = []
    for i in range(20):
        if (i + 1) % 2 == 0: cutoff.append('')
        else: cutoff.append('<' + str(round(0.05 + float(i) * 0.05, 2)))
        if float(esegs[i][3]) > 0.0: enrich.append(float(esegs[i][2]) / float(esegs[i][3]))
        else: enrich.append(0.0)
        ofile.write(str(round(0.05 + float(i) * 0.05, 2)) + '\t' + str(enrich[-1]) + '\t' + str(esegs[i][3]) + '\n')
    ofile.close()
    
    try:
        import matplotlib
        matplotlib.use( 'Agg' )            
    except:
        print 'no pylab'
        return
    try: import pylab
    except:
        print 'no pylab, no plot'
        return

    pylab.rcParams['xtick.labelsize'] = '4'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    a1 = pylab.array(enrich)
    pylab.bar(pylab.arange(len(a1)), a1, color='w', edgecolor='b', linewidth=3, width=1.0, alpha=0.8, align='center')
    n = cutoff
    pylab.xticks(pylab.arange(len(a1)), n, rotation=30.0)
    #pylab.ylim(0.0, 0.65)
    #pylab.xlim(-1, 20)
    #pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([14.3, 14.3]), 'r--', lw=3)
    #pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([2.3, 2.3]), 'g--', lw=3)
    #ax.set_ylim([outv2[0][0], ])
    #ax.set_aspect('equal')
    pylab.savefig(plot_path)
    
def GAI1_genome_all_energy_bar(epath, enrich_path, plot_path):
  
    calmode = load_design_energy(epath) 
    wt = readline('/home/bartolo/web/statium/GAI1/gai1_4g5q.fasta', 1)
    ewt = statium_energy_calc(calmode, wt, 0.0)
    wt_base = wt[0:320]
    seq_data = lines2list('/home/bartolo/web/statium/GAI1/GAI1_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/GAI1/GAI1_names.txt')
    shared_data = lines2list('/home/bartolo/web/statium/GAI1/GAI1_INhomolr.txt')
    al2 = lines2list('/home/bartolo/web/statium/GAI1/GAI1_shared.txt')
    #seq_txt = ''
    #for i in range(len(seq_data)): seq_txt += wt_base + seq_data[i][0] + '\n'
    #rpath = '/home/bartolo/' + str(random.randint(0, 1000)) + '.txt'
    #ofile = open(rpath, 'w')
    #ofile.write(seq_txt)
    #ofile.close()
    #elist = statium_evec(epath, rpath, 0.0)
    #os.remove(rpath)
    elist = []
    for i in range(len(seq_data)):
        if i % 1000 == 0: print float(i) / float(len(seq_data))
        seq = wt_base + seq_data[i][0]
        try:
        e = statium_energy_calc(calmode, seq, 0.0)
        elist.append(e)
        except:
        print seq
        return
    ofile = open(enrich_path, 'w')
    emin = min(elist)
    emax = max(elist)
    
    names = []
    e_hist = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)

    esegs = []
    for i in range(20): esegs.append([[], [], 0, 0])
        
    for i in range(len(seq_data)):
    
    try: e_index = int(((elist[i] - emin) / (emax - emin)) / 0.05)
    except: continue
    if e_index > 19: continue
    if not names[i] in esegs[e_index][0]:
        esegs[e_index][0].append(names[i])
        esegs[e_index][1].append(shared_data[i][0])
        if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: esegs[e_index][2] += 1
        if al2[i][0] > 0.0: esegs[e_index][3] += 1
        
    enrich = []
    cutoff = []
    for i in range(20):
        if (i + 1) % 2 == 0: cutoff.append('')
        else: cutoff.append('<' + str(round(0.05 + float(i) * 0.05, 2)))
        if float(esegs[i][3]) > 0.0: enrich.append(float(esegs[i][2]) / float(esegs[i][3]))
        else: enrich.append(0.0)
        ofile.write(str(round(0.05 + float(i) * 0.05, 2)) + '\t' + str(enrich[-1]) + '\t' + str(esegs[i][3]) + '\n')
    ofile.close()
    
    try:
        import matplotlib
        matplotlib.use( 'Agg' )            
    except:
        print 'no pylab'
        return
    try: import pylab
    except:
        print 'no pylab, no plot'
        return

    pylab.rcParams['xtick.labelsize'] = '4'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    a1 = pylab.array(enrich)
    pylab.bar(pylab.arange(len(a1)), a1, color='w', edgecolor='b', linewidth=3, width=1.0, alpha=0.8, align='center')
    n = cutoff
    pylab.xticks(pylab.arange(len(a1)), n, rotation=30.0)
    #pylab.ylim(0.0, 0.65)
    #pylab.xlim(-1, 20)
    #pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([14.3, 14.3]), 'r--', lw=3)
    #pylab.plot(pylab.array([-1.0, 12.0]), pylab.array([2.3, 2.3]), 'g--', lw=3)
    #ax.set_ylim([outv2[0][0], ])
    #ax.set_aspect('equal')
    pylab.savefig(plot_path)
    
def Cal_genome_hist(e_path, plot_path, elist_path):
  
    calmode = load_design_energy(e_path) 
    ewt = statium_energy_calc(calmode, 'EVTVGKFYATFLIQEYFRKFKKRKEQGLV', 0.0)
    print 'Wild-type energy:', ewt
    seq_data = lines2list('/home/bartolo/web/statium/Calmodulin_seq.txt')
    efile = open(elist_path, 'w')
    efile.write(str(ewt) + '\n')
    
    e_hist = []
    for i in range(len(seq_data)):
    if i > 0 and i % 10000 == 0:
        break
        print float(i) / float(len(seq_data))
    seq = seq_data[i][0]
    try: e = statium_energy_calc(calmode, seq, 0.0)
        except: continue
        efile.write(str(e) + '\n')
        e_hist.append(e)
        
    efile.close()
    
    try: import pylab
    except:
    'Sorry, no Pylab installed here. Go fuck yourself.'
        return
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        
    hdata = pylab.hist(pylab.array(e_hist), normed=False, facecolor='white', edgecolor='black', lw=2)
    ymax = max(hdata[0]) * 1.2
    pylab.plot([ewt, ewt], [0, ymax], 'b', lw=2)
    pylab.ylim(0, ymax)
    pylab.savefig(plot_path)
    
def MDM_genome_all_energy():
  
    calmode = load_design_energy('/home/bartolo/web/statium/MDM/mdx_3fdo') 
    ewt = statium_energy_calc(calmode, 'LTFEHYWAQLTS', 0.0)
    seq_data = lines2list('/home/bartolo/web/statium/MDM_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/MDM_names.txt')
    shared_data = lines2list('/home/bartolo/web/statium/MDM_INhomolr.txt')
    al2 = lines2list('/home/bartolo/web/statium/MDM_shared.txt')
    names = []
    e_hist = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        names.append(namex)

        
    low_unique = [[], [], 0, 0]
    all_unique = [[], [], 0, 0]
    high_unique = [[], [], 0, 0]
    shared_unique1 = [[], [], 0, 0]
    shared_unique2 = [[], [], 0, 0]
    for i in range(len(seq_data)):
    #if i % 1000 == 0 and i > 0: print float(i) / float(len(seq_data))
    if not names[i] in all_unique[0]:
        all_unique[0].append(names[i])
        all_unique[1].append(shared_data[i][0])
        if shared_data[i][0] == 1.0: all_unique[2] += 1
        all_unique[3] += 1

        seq = seq_data[i][0]
        try: e = statium_energy_calc(calmode, seq, 0.0)
        except: continue
        e_hist.append(e)
        if True:
        if not names[i] in high_unique[0]:
            high_unique[0].append(names[i])
            high_unique[1].append(shared_data[i][0])
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: high_unique[2] += 1
            if al2[i][0] > 0.0: high_unique[3] += 1
            
    if e <= -45.0:
        if not names[i] in low_unique[0]:
            low_unique[0].append(names[i])
            low_unique[1].append(shared_data[i][0])
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: low_unique[2] += 1
            if al2[i][0] > 0.0: low_unique[3] += 1
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0: print seq, e, names[i]
        else:
            if shared_data[i][0] == 1.0 and al2[i][0] > 0.0:
            print seq, e, names[i]

    if all_unique[3] > 0: print float(all_unique[2]) / float(all_unique[3])
    if high_unique[3] > 0: print float(high_unique[2]) / float(high_unique[3])
    if low_unique[3] > 0:print float(low_unique[2]) / float(low_unique[3])
    print
    
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        
    pylab.hist(pylab.array(e_hist), normed=False, facecolor='white', edgecolor='black', lw=2)
    pylab.savefig('/home/bartolo/web/statium/MDM_mdm_3fdo_dist.png')
    
def network_dictionaries():
  
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    return [sl_dict, ls_dict]
    
def Calmodulin_network_analysis():

    base = 2

    seq_data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_names.txt')
    homol_data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_INhomolr.txt')
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    names = []
    full_names = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        full_names.append(string.join(namex.split('_'), ' ').strip())
        try: names.append(ls_dict[string.join(namex.split('_'), ' ').strip()])
    except: names.append('')

    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    calnet = retrieve_network(interactions, 'CALM1', 2)
    from_struc = ['Sodium channel, voltage gated, type 5, alpha subunit', 'CaMK II delta subunit', 'CaM kinase II beta subunit', 'Solute carrier family 9, isoform A1', 'Calcium channel, voltage dependent, L type, alpha 1C subunit', 'CaMK II alpha subunit', 'Myosin 6', 'Calcium channel, voltage-dependent, L type, alpha-1S subunit', 'Myosin light chain kinase 2', 'Myosin 5A', 'Nitric oxide synthase 3']
    from_struc_short = []
    for namex in from_struc:
        try: shortname = ls_dict[namex]
    except: shortname = ''
    from_struc_short.append(shortname)
    print len(calnet)
    for namex in from_struc_short:
        if not namex in calnet: calnet.append(namex)
    calnet2 = retrieve_network(interactions, 'CALM2', 2)
    for namex in calnet2:
        if not namex in calnet: calnet.append(namex)
    calnet3 = retrieve_network(interactions, 'CALM3', 2)
    for namex in calnet3:
        if not namex in calnet: calnet.append(namex)
        

    
    for i in range(len(homol_data)):

        if homol_data[i][0] == 1.0 and not names[i] in calnet: calnet.append(names[i])

    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break

    for thing in calnet: print thing
    print len(calnet)

    shared = []
    alreadyfound = [[], []]
    for i in range(len(names)):
        if i % 1000 == 0: print float(i) / float(len(names))
        if names[i] in alreadyfound[0]:
        shared.append(alreadyfound[1][alreadyfound[0].index(names[i])])
    else:
            try: flat_target = retrieve_network(interactions, names[i], base)
            except: flat_target = []
        
            if len(flat_target) > 0:
            try:
            sharing = network_shared(calnet, flat_target)
            sval = sharing[0]
            if names[i] in calnet: sval = 1.0
                shared.append(sval)
            except: shared.append(-1.0)
            #print full_names[i], sharing[0]
            #if 'CALM1' in flat_target: shared.append(1.0)
            #else: shared.append(0.0)
            else: shared.append(-1.0)
            
            #if len(flat_target) > 0:
            #sharing = network_shared(calnet, flat_target)
            #if len(sharing[1]) > 1: shared.append(1.0)
            #else: shared.append(0.0)
            #else: shared.append(-1.0)
            
            alreadyfound[1].append(shared[-1])
            alreadyfound[0].append(names[i])
        
        
    of = open('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_shared.txt', 'w')
    for i in range(len(shared)): of.write(str(shared[i]) + '\n')
    of.close()
    
def CAMP_network_analysis():

    base = 2

    seq_data = lines2list('/home/bartolo/web/statium/CAMP/CAMP_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/CAMP/CAMP_names.txt')
    homol_data = lines2list('/home/bartolo/web/statium/CAMP/CAMP_INhomolr.txt')
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    names = []
    full_names = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        full_names.append(string.join(namex.split('_'), ' ').strip())
        try: names.append(ls_dict[string.join(namex.split('_'), ' ').strip()])
    except: names.append('')

    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    calnet = retrieve_network(interactions, 'PRKACA', 2)
    
    for i in range(len(homol_data)):

        if homol_data[i][0] == 1.0 and not names[i] in calnet: calnet.append(names[i])

    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break

    #for thing in calnet: print thing
    #print len(calnet)

    shared = []
    alreadyfound = [[], []]
    for i in range(len(names)):
        if i % 1000 == 0: print float(i) / float(len(names))
        if names[i] in alreadyfound[0]:
        shared.append(alreadyfound[1][alreadyfound[0].index(names[i])])
    else:
            try: flat_target = retrieve_network(interactions, names[i], base)
            except: flat_target = []
        
            if len(flat_target) > 0:
            try:
            sharing = network_shared(calnet, flat_target)
            sval = sharing[0]
            if names[i] in calnet: sval = 1.0
                shared.append(sval)
            except: shared.append(-1.0)
            #print full_names[i], sharing[0]
            #if 'CALM1' in flat_target: shared.append(1.0)
            #else: shared.append(0.0)
            else: shared.append(-1.0)
            
            #if len(flat_target) > 0:
            #sharing = network_shared(calnet, flat_target)
            #if len(sharing[1]) > 1: shared.append(1.0)
            #else: shared.append(0.0)
            #else: shared.append(-1.0)
            
            alreadyfound[1].append(shared[-1])
            alreadyfound[0].append(names[i])
        
        
    of = open('/home/bartolo/web/statium/CAMP/CAMP_shared.txt', 'w')
    for i in range(len(shared)): of.write(str(shared[i]) + '\n')
    of.close()
    
def GAI1_network_analysis():

    base = 2

    seq_data = lines2list('/home/bartolo/web/statium/GAI1/GAI1_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/GAI1/GAI1_names.txt')
    homol_data = lines2list('/home/bartolo/web/statium/GAI1/GAI1_INhomolr.txt')
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    names = []
    full_names = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        full_names.append(string.join(namex.split('_'), ' ').strip())
        try: names.append(ls_dict[string.join(namex.split('_'), ' ').strip()])
    except: names.append('')

    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    calnet = retrieve_network(interactions, 'GNAI1', 2)
    
    for i in range(len(homol_data)):

        if homol_data[i][0] == 1.0 and not names[i] in calnet: calnet.append(names[i])

    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break

    #for thing in calnet: print thing
    #print len(calnet)

    shared = []
    alreadyfound = [[], []]
    for i in range(len(names)):
        if i % 1000 == 0: print float(i) / float(len(names))
        if names[i] in alreadyfound[0]:
        shared.append(alreadyfound[1][alreadyfound[0].index(names[i])])
    else:
            try: flat_target = retrieve_network(interactions, names[i], base)
            except: flat_target = []
        
            if len(flat_target) > 0:
            try:
            sharing = network_shared(calnet, flat_target)
            sval = sharing[0]
            if names[i] in calnet: sval = 1.0
                shared.append(sval)
            except: shared.append(-1.0)
            #print full_names[i], sharing[0]
            #if 'CALM1' in flat_target: shared.append(1.0)
            #else: shared.append(0.0)
            else: shared.append(-1.0)
            
            #if len(flat_target) > 0:
            #sharing = network_shared(calnet, flat_target)
            #if len(sharing[1]) > 1: shared.append(1.0)
            #else: shared.append(0.0)
            #else: shared.append(-1.0)
            
            alreadyfound[1].append(shared[-1])
            alreadyfound[0].append(names[i])
        
        
    of = open('/home/bartolo/web/statium/GAI1/GAI1_shared.txt', 'w')
    for i in range(len(shared)): of.write(str(shared[i]) + '\n')
    of.close()

def MDM_network_analysis():

    base = 2

    seq_data = lines2list('/home/bartolo/web/statium/MDM_seq.txt')
    names_data = readlines('/home/bartolo/web/statium/MDM_names.txt')
    homol_data = lines2list('/home/bartolo/web/statium/MDM_INhomolr.txt')
    
    interact_path = '/home/bartolo/web/FLAT_FILES_072010/BINARY_PROTEIN_PROTEIN_INTERACTIONS.txt'
    translate_path = '/home/bartolo/web/FLAT_FILES_072010/HPRD_ID_MAPPINGS.txt'
    ontology_path = '/home/bartolo/web/FLAT_FILES_072010/GENE_ONTOLOGY.txt'

    ontlines = readlines(ontology_path)
    localizations = []
    for line in ontlines:
        items = line.split('\t')
        prot = items[3]
        locs = items[-2].split(';')
        loc_str = ''
        for loc in locs:
        loc_str += loc.split('(')[0].strip() + '; '
    loc_str = loc_str[0:len(loc_str)-2]
    localizations.append([prot, loc_str])
    local_dict = dict(localizations)
       
    tlines = readlines(translate_path)
    sl_vec = []
    ls_vec = []
    names = []
    for line in tlines:
        items = line.strip().split()
        if items[1] == '-': continue
       # print items[1]
        names.append(items[1])
        full_name = ''
        for i in range(7, len(items)): full_name += items[i] + ' '
        sl_vec.append((items[1], full_name.strip()))
        ls_vec.append((full_name.strip(), items[1]))
    sl_dict = dict(sl_vec)
    ls_dict = dict(ls_vec)
    
    names = []
    full_names = []
    for i in range(len(names_data)):
        name = ''
        name0 = names_data[i].strip().split()
        for j in range(len(name0) - 1): name += name0[j] + '_'
        name += name0[-1]
        pipe_idx = 0
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        full_names.append(string.join(namex.split('_'), ' ').strip())
        try: names.append(ls_dict[string.join(namex.split('_'), ' ').strip()])
    except: names.append('')

    
    interactions = []
    ilines = readlines(interact_path)
    for line in ilines:
        items = line.strip().split()
        interactions.append([items[0], items[3]])
        
    calnet = retrieve_network(interactions, 'MDM2', 2)
    #from_struc = ['Sodium channel, voltage gated, type 5, alpha subunit', 'CaMK II delta subunit', 'CaM kinase II beta subunit', 'Solute carrier family 9, isoform A1', 'Calcium channel, voltage dependent, L type, alpha 1C subunit', 'CaMK II alpha subunit', 'Myosin 6', 'Calcium channel, voltage-dependent, L type, alpha-1S subunit', 'Myosin light chain kinase 2', 'Myosin 5A', 'Nitric oxide synthase 3']
    #from_struc_short = []
    #for namex in from_struc:
        #try: shortname = ls_dict[namex]
    #except: shortname = ''
    #from_struc_short.append(shortname)
    #print len(calnet)
    #for namex in from_struc_short:
        #if not namex in calnet: calnet.append(namex)
    calnet2 = retrieve_network(interactions, 'MDM4', 2)
    for namex in calnet2:
        if not namex in calnet: calnet.append(namex)
    #calnet3 = retrieve_network(interactions, 'CALM3', 2)
    #for namex in calnet3:
        #if not namex in calnet: calnet.append(namex)
    for i in range(len(homol_data)):

        if homol_data[i][0] == 1.0 and not names[i] in calnet: calnet.append(names[i])

    while True:
        found = False
        for i in range(len(calnet)):
        if calnet[i] == '' or calnet[i] == '-':
            found = True
            del calnet[i]
            break
    if not found: break

    for thing in calnet: print thing
    print len(calnet)

    shared = []
    alreadyfound = [[], []]
    for i in range(len(names)):
        if i % 1000 == 0: print float(i) / float(len(names))
        if names[i] in alreadyfound[0]:
        shared.append(alreadyfound[1][alreadyfound[0].index(names[i])])
    else:
            try: flat_target = retrieve_network(interactions, names[i], base)
            except: flat_target = []
        
            if len(flat_target) > 0:
            try:
            sharing = network_shared(calnet, flat_target)
            sval = sharing[0]
            if names[i] in calnet: sval = 1.0
                shared.append(sval)
            except: shared.append(-1.0)
            #print full_names[i], sharing[0]
            #if 'CALM1' in flat_target: shared.append(1.0)
            #else: shared.append(0.0)
            else: shared.append(-1.0)
            
            #if len(flat_target) > 0:
            #sharing = network_shared(calnet, flat_target)
            #if len(sharing[1]) > 1: shared.append(1.0)
            #else: shared.append(0.0)
            #else: shared.append(-1.0)
            
            alreadyfound[1].append(shared[-1])
            alreadyfound[0].append(names[i])
        
        
    of = open('/home/bartolo/web/statium/MDM_shared.txt', 'w')
    for i in range(len(shared)): of.write(str(shared[i]) + '\n')
    of.close()


def Calih_coyote():
  
    data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_seq.txt')
    
    size = int(float(len(data)) / 100.0)
    
    tmp_list = []
    job = 0
    for i in range(len(data)):
        seq = data[i][0]
        tmp_list.append(seq)
        if len(tmp_list) == size or i == len(data) - 1:
       job += 1
       outf = '/home/bartolo/web/calih_IN_' + str(job) + '.txt'
       seqp = '/home/bartolo/web/calih_seq_' + str(job) + '.txt'
       seqf = open(seqp, 'w')
       for j in range(len(tmp_list)): seqf.write(tmp_list[j] + '\n')
       seqf.close()
       jobp = '/home/bartolo/web/calih_job_' + str(job) + '.sh'
       jobf = open(jobp, 'w')
       jobf.write('#PBS -S /bin/sh\n')
       jobf.write('/home/bartolo/web/build.py -calih ' + seqp + ' ' + outf + '\n')
       jobf.close()
       os.system('chmod u+x ' + jobp)
       os.system('qsub -q short ' + jobp)
       tmp_list = []
       
def calih_collect():
    
    print 'collecting...'
    total = []
    count = 0
    for i in range(105):
        count += 1
        path = '/home/bartolo/web/calih_IN_' + str(count) + '.txt'
        if not os.path.exists(path):
        if i < 100:
            print 'missing file: ', path
            return
        else: break
        seqs = lines2list(path)
        for j in range(len(seqs)): total.append(str(seqs[j][0]))
    of = open('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_INhomol.txt', 'w')
    for i in range(len(total)):
        of.write(total[i] + '\n')
    of.close()
    
def calih_overlap():
  
    namesd = readlines('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_names.txt')
    data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_INhomol.txt')
    
    print 'calih overlap'
    
    vals = []
    names = []
    for i in range(len(data)):
        vals.append(data[i][0])
        names.append(namesd[i].strip())
        
    for i in range(len(vals)):
        if i % 1000 == 0.0: print i
        if vals[i] == 1.0:
        name = names[i]
        fn = names.index(name)
        for j in range(fn, len(vals)):
            if names[j] != name: break
            if names[j] == name and vals[j] == 0.0: vals[j] = 1.0
            
            
    of = open('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_INhomolr.txt', 'w')
    for i in range(len(vals)): of.write(str(vals[i]) + '\n')
    of.close()
        

def Calmodulin_interaction_homology(seq_path, outp):

    seq_data = lines2list(seq_path)
    
    IP_seq_data = lines2list('/home/bartolo/web/statium/calmodulin/Calmodulin1cdl_IN_seq.txt')
    
    shared = []
    for i in range(len(seq_data)):
        if i % 1000 == 0: print float(i) / float(len(seq_data))
        seq = seq_data[i][0]
        found = False
        for j in range(len(IP_seq_data)):
        IP_seq = IP_seq_data[j][0]
        same = 0
        for k in range(len(seq)):
            if seq[k] == IP_seq[k]: same += 1
        if float(same) / float(len(seq)) >= 0.6:
            found = True
            break
    if found:
        shared.append(1.0)
    else: shared.append(0.0)
    
    of = open(outp, 'w')
    for i in range(len(shared)): of.write(str(shared[i]) + '\n')
    of.close()

def process_array4():
  
    seq_data = lines2list('/home/bartolo/web/statium/Array4/final_sequences.txt')
    sig_data = lines2list('/home/bartolo/web/statium/Array4/array4_quants.txt')
    
    count = 0
    mwtsig = sig_data[249][2]
    for i in range(0, 261):
        if i == 0 or i % 3 == 0:
        count += 1
        print seq_data[i][0][2:25], round(sig_data[i][2] / mwtsig, 2), round(sig_data[i + 1][2] / mwtsig, 2), round(sig_data[i + 2][2] / mwtsig, 2)
            #import pylab
        #pylab.rcParams['xtick.labelsize'] = '16'
        #pylab.rcParams['ytick.labelsize'] = '16'
        #pylab.rcParams['savefig.dpi'] = '300'
        #pylab.rcParams['xtick.major.pad']='12'
        #pylab.rcParams['ytick.major.pad']='12'
        #pylab.rcParams['axes.linewidth'] = 3.0
        #fig = pylab.figure()    # Create a figure
        #ax = fig.gca()
        #for tick in ax.xaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #for tick in ax.yaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #labels = ['WT', '3aD', '3eL']
        #xs = pylab.arange(3)
        #ys = pylab.array([round(sig_data[i][2] / mwtsig, 2), round(sig_data[i + 1][2] / mwtsig, 2), round(sig_data[i + 2][2] / mwtsig, 2)])
        #pylab.bar(xs, ys, 0.35, color='r', align='center')
        #pylab.xticks(xs, labels)
        ##pylab.ylim(0.0, 1.0)
        #pylab.savefig('/home/bartolo/web/statium/Array4/bars/' + str(count) + '_MCL1.png')
        #pylab.close()
        
    #count = 0
    #xwtsig = sig_data[510][2]
    #for i in range(261, 519):
        #if i == 0 or i % 3 == 0:
        #count += 1
        #print seq_data[i][0][2:25], round(sig_data[i][2] / xwtsig, 2), round(sig_data[i + 1][2] / xwtsig, 2), round(sig_data[i + 2][2] / xwtsig, 2)
            #import pylab
        #pylab.rcParams['xtick.labelsize'] = '16'
        #pylab.rcParams['ytick.labelsize'] = '16'
        #pylab.rcParams['savefig.dpi'] = '300'
        #pylab.rcParams['xtick.major.pad']='12'
        #pylab.rcParams['ytick.major.pad']='12'
        #pylab.rcParams['axes.linewidth'] = 3.0
        #fig = pylab.figure()    # Create a figure
        #ax = fig.gca()
        #for tick in ax.xaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #for tick in ax.yaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #labels = ['WT', '3aD', '3eL']
        #xs = pylab.arange(3)
        #ys = pylab.array([round(sig_data[i][2] / xwtsig, 2), round(sig_data[i + 1][2] / xwtsig, 2), round(sig_data[i + 2][2] / xwtsig, 2)])
        #pylab.bar(xs, ys, 0.35, color='r', align='center')
        #pylab.xticks(xs, labels)
        ##pylab.ylim(0.0, 1.0)
        #pylab.savefig('/home/bartolo/web/statium/Array4/bars/' + str(count) + '_BCLXL.png')
        #pylab.close()

    #for i in range(2):
        #import pylab
        #if True:
        #if i == 0:
            #ys = pylab.array([1.41, 0.53, 0.49])
            #p = '/home/bartolo/web/statium/Array4/bars/Bad_BCLXL.png'
        #else:
            #ys = pylab.array([0.93, 0.29, 0.42])
            #p = '/home/bartolo/web/statium/Array4/bars/Bad_BCLXL_norm.png'
        ##print seq_data[i][0], round(sig_data[i][2] / xwtsig, 2), round(sig_data[i + 1][2] / xwtsig, 2), round(sig_data[i + 2][2] / xwtsig, 2)
            #import pylab
        #pylab.rcParams['xtick.labelsize'] = '16'
        #pylab.rcParams['ytick.labelsize'] = '16'
        #pylab.rcParams['savefig.dpi'] = '300'
        #pylab.rcParams['xtick.major.pad']='12'
        #pylab.rcParams['ytick.major.pad']='12'
        #pylab.rcParams['axes.linewidth'] = 3.0
        #fig = pylab.figure()    # Create a figure
        #ax = fig.gca()
        #for tick in ax.xaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #for tick in ax.yaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
        #labels = ['WT', '3aD', '3eL']
        #xs = pylab.arange(3)
        ##ys = pylab.array([round(sig_data[i][2] / xwtsig, 2), round(sig_data[i + 1][2] / xwtsig, 2), round(sig_data[i + 2][2] / xwtsig, 2)])
        #pylab.bar(xs, ys, 0.35, color='r', align='center')
        #pylab.xticks(xs, labels)
        ##if i == 1: pylab.ylim(0.0, 1.0)
        #pylab.savefig(p)
        #pylab.close()
        
def add_control_data():
  
    xctrl = [[], [], [], []]
    mctrl = [[], [], [], []]
    
    master = readlines('/home/bartolo/web/statium/all_array_analysis/All_arrays_tagged.txt')
    
    data = lines2list('/home/bartolo/web/statium/Array5/Array5_results_labelled_noF.txt')
    for i in range(len(data)):
        xctrl[0].append(data[i][0])
        xctrl[1].append(data[i][1])
        xctrl[2].append(data[i][2])
        xctrl[3].append(data[i][3])
        
        mctrl[0].append(data[i][0])
        mctrl[1].append(data[i][4])
        mctrl[2].append(data[i][5])
        mctrl[3].append(data[i][6])
        
    data = lines2list('/home/bartolo/web/statium/ArrayIII/signal23noU.txt')
    for i in range(len(data)):
        if i <= 68:
            xctrl[0].append(data[i][0])
            xctrl[1].append(data[i][1])
            xctrl[2].append(data[i][2])
            xctrl[3].append(data[i][4])
        else:
            mctrl[0].append(data[i][0])
            mctrl[1].append(data[i][1])
            mctrl[2].append(data[i][2])
            mctrl[3].append(data[i][4])
            
    data = lines2list('/home/bartolo/web/statium/Array4/X_signal_control.txt')
    for i in range(len(data)):
        xctrl[0].append(data[i][0])
        xctrl[1].append(data[i][1])
        xctrl[2].append(data[i][2])
        xctrl[3].append(data[i][3])
        
    data = lines2list('/home/bartolo/web/statium/Array4/M_signal_control.txt')
    for i in range(len(data)):
        mctrl[0].append(data[i][0])
        mctrl[1].append(data[i][1])
        mctrl[2].append(data[i][2])
        mctrl[3].append(data[i][3])
        
    for line in master:
        items = line.split()
        seq = items[1]
        R = items[0]
        found = False
        if R == 'X':
        if seq in xctrl[0]:
            idx = xctrl[0].index(seq)
            print R, seq, xctrl[1][idx], xctrl[2][idx], xctrl[3][idx], items[3], items[4], items[5],
            found = True
            if len(items) == 7: print items[-1]
            else: print '0'
        if R == 'M':
        if seq in mctrl[0]:
            idx = mctrl[0].index(seq)
            print R, seq, mctrl[1][idx], mctrl[2][idx], mctrl[3][idx], items[3], items[4], items[5],
            found = True
            if len(items) == 7: print items[-1]
            else: print '0'
    if not found:
        print R, seq, items[2], items[3], items[4], items[5],
        if len(items) == 7: print items[-1]
        else: print '0'
            
def process_array2():
  
    seq_data = lines2list('/home/bartolo/web/statium/ArrayII_data/X_sequences.txt')
    sig_data = lines2list('/home/bartolo/web/statium/ArrayII_data/quant/X_arrayII_data_210.txt')
    
    wtsig = (sig_data[0][2] + sig_data[19][2]) / 2.0
    for i in range(len(seq_data)):
        print seq_data[i][0][2:25], round(sig_data[i][2] / wtsig, 2)
            

def process_SAPE():
  
    seq_data = lines2list('/home/bartolo/web/statium/Array4/final_sequences.txt')
    seqs = []
    for i in range(522, 561): seqs.append(seq_data[i][0])
    
    spot_data = lines2list('/home/bartolo/web/statium/Array4/SAPE/run_50u__400pmt_081412_quants.txt')
    
    sigs = []
    for i in range(len(spot_data)): sigs.append(spot_data[i][2])
    
    bim_sig = sigs[27]
    
    orig_sig = [0.25, 0.03, 0.1, 0.89, 1.2, 0.46, 0.56, 0.22, 0.33, 0.33, 0.08, 0.18, 0.84, 0.56, 0.42, 0.4, 0.04, 0.19, 0.34, 0.03, 0.18, 0.05, 0.16, 0.02, 1.18, 1.08, 0.54, 1.0, 0.09, 0.1, 0.77, 0.05, 0.19, 1.41, 0.53, 0.49, 0.45, 0.01, 0.02 ]
    
    correct = []
    for i in range(len(sigs)):
        correct.append(sigs[i] / bim_sig)

    for i in range(len(correct)):
        print seqs[i], orig_sig[i], orig_sig[i] / correct[i]
    
def blast_hprd(rang):
  
    rang0 = int(rang.split(',')[0])
    rang1 = int(rang.split(',')[1])
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    
    L = len(bim)
    
    seqs = []
    paths = []
    fasta = []
    scripts = []
    seq_lines = readlines(seq_path)
    count = 0
    found = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        found += 1
        prot = line.strip()
        seqs.append(prot)
        paths.append('/net/crate-03/data/keating/bionet/homedirs/bartolo/web/BLAST/hprd_blasted/hprd_' + str(found) + '.out')
        fasta.append('/home/bartolo/web/BLAST/hprd_blasted/fasta/hprd_' + str(found) + '.fasta')
        scripts.append('/home/bartolo/web/BLAST/hprd_blasted/scripts/hprd_' + str(found) + '.sh')


    for i in range(rang0, rang1):
        #print i
        if os.path.exists(paths[i]):
        datai = readlines(paths[i])
        if len(datai) > 0: continue
        
        if seqs.index(seqs[i]) < i:
        if os.path.exists(paths[seqs.index(seqs[i])]):
            os.system('cp ' + paths[seqs.index(seqs[i])] + ' ' + paths[i])
            continue
        
        f = open(fasta[i], 'w')
        f.write('> blast\n' + seqs[i] + '\n')
        f.close()
        
        s = open(scripts[i], 'w')
        s.write('cd /home/bartolo/web/BLAST/ncbi-blast-2.2.26+/bin\n/home/bartolo/web/BLAST/ncbi-blast-2.2.26+/bin/blastp -query ' + fasta[i] + ' -db nr -out ' + paths[i] + '\n')
    s.close()
    os.system('chmod u+x ' + scripts[i])
    #os.system(scripts[i])
    if coyote_count_jobs('short') < 20:
        os.system('qsub -q short ' + scripts[i])
        time.sleep(6)
    else: time.sleep(6)
    
def mammalia_list():
  
    lines = readlines('/home/bartolo/web/BLAST/taxonomy.txt')
    for line in lines:
        if '(' in line and ')' in line:
        items = line.split()
        if len(items) > 2:
            if items[2][0] == '(':
            print items[0], items[1]
        elif len(items) > 3:
            if items[3][0] == '(':
                print items[0], items[1], items[2]

def hprd_align_all():
   
    indir = '/home/bartolo/web/BLAST/hprd_blasted'
    inlist = os.listdir(indir)
    outdir = '/home/bartolo/web/BLAST/hprd_align'
    
    for p in inlist:
        in_path = os.path.join(indir, p)
        out_path = os.path.join(outdir, p)
        if os.path.exists(out_path): continue
    try: hprd_alignment(in_path, out_path)
    except: continue
    
def hprd_align_all_back():
   
    indir = '/home/bartolo/web/BLAST/hprd_blasted'
    inlist = os.listdir(indir)
    outdir = '/home/bartolo/web/BLAST/hprd_align'
    
    for i in range(len(inlist)):
        p = inlist[i * -1]
        in_path = os.path.join(indir, p)
        out_path = os.path.join(outdir, p)
        if os.path.exists(out_path): continue
    try: hprd_alignment(in_path, out_path)
    except: continue
    
def hprd_alignment(blast_path, outpath):
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        prot = line.strip()
        seqs.append(prot)
        
    hprd_seq = seqs[int(os.path.split(blast_path)[1].split('_')[1].split('.')[0]) - 1]
    mammals_list = readlines('/home/bartolo/web/BLAST/mammals.txt')
    mammals = []
    for i in range(len(mammals_list)): mammals.append(mammals_list[i].strip())
  
    entries = []
    lines = readlines(blast_path)
    start = False
    for i in range(len(lines)):
        line = lines[i]
        items = line.split()
        if len(items) > 0:
        if items[0] == '>':
            start = True
            entries.append([])
            entries[-1].append(line)
        else:
            if start:
            entries[-1].append(line)
            
    mam_list = []
    seq_list = []
    for i in range(len(entries)):
        header = ''
        try:
        for j in range(len(entries[i])):
        items = entries[i][j].split()
        if items[0][0:6] != 'Length': header += entries[i][j].strip() + ' '
        else: break
        subject_idx = []
        sbj_hold = 0
        for j in range(len(entries[i])):
        items = entries[i][j].split()
        if items[0] == 'Sbjct':
            if int(items[1]) > sbj_hold:
            sbj_hold = int(items[1])
            subject_idx.append([int(items[1]) - 1, int(items[3]) - 1, items[2]])
            else: break
        query_idx = []
        qry_hold = 0
        for j in range(len(entries[i])):
        items = entries[i][j].split()
        if items[0] == 'Query':
            if int(items[1]) > qry_hold:
            qry_hold = int(items[1])
            query_idx.append([int(items[1]) - 1, int(items[3]) - 1, items[2]])
            else: break
        
        L = len(hprd_seq)
        subject_seq = ''
        for k in range(0, query_idx[0][0]): subject_seq += '-'
        for j in range(len(query_idx)):
        for k in range(len(query_idx[j][2])):
            if query_idx[j][2][k] != '-': subject_seq += subject_idx[j][2][k]
        if j < len(query_idx) - 1:
            for k in range(query_idx[j][1] + 1, query_idx[j + 1][0]):
            subject_seq += '-'
        else:
            for k in range(query_idx[-1][1] + 1, L): subject_seq += '-'

        missing = 0
        for j in range(len(subject_seq)):
        if subject_seq[j] == '-': missing += 1
        percent_missing = float(missing) / float(len(subject_seq))
        #print header
        hitems = header.split()
        mams = []
        for j in range(len(hitems)):
        mam = ''
        if hitems[j][0] == '[':
            mam += hitems[j][1:len(hitems[j])] + ' '
            for k in range(j + 1, len(hitems)):
            if hitems[k][-1] == ']':
                mam += hitems[k][0:len(hitems[k]) - 1]
                break
            if not mam in mams: mams.append(mam)
            
        unique_mam = []
        already_found = False
        for mam in mams:
        if mam in mam_list:
            already_found = True
            break
        else: unique_mam.append(mam)
        if not already_found:
        for mam in unique_mam:
            if mam in mammals:
            mam_list.append(mam)
            seq_list.append(subject_seq)
            #print percent_missing
    except: continue
        
    #for mam in mam_list: print mam
    #print len(mam_list)
    of = open(outpath, 'w')
    for seq in seq_list: of.write(seq + '\n')
    of.close()
        
def FP_conc():
  
  start = 0.85333333
  print start * 0.75 * 1000,
  for i in range(1, 12):
      start = start * 0.4
      print start * 0.75 * 1000,
      
def conc_grad(start, dilex, filex):
  
    print start * filex,
    for i in range(1, 12):
        start = start * dilex
        print start * filex,   
    
def conc_grad6(start, dilex, filex):
  
    print start * filex,
    for i in range(1, 6):
        start = start * dilex
        print start * filex,   
      
def plate_line(path, line_num, exp):

    data = lines2list(path)
    
    line = data[2 + line_num]
    if line_num == 1:
        start = 1
        end = 13
    else:
        start = 0
        end = 12
    vals = []
    for i in range(start, end): vals.append(line[i])
    for val in vals: print val,
    
def scan_sort():
  
    data = lines2list('/home/bartolo/web/SCAN_human.pfam')
    
    seqs = []
    for i in range(len(data)):
        if not data[i][1] in seqs:
        seqs.append(data[i][1])
        print data[i][0] + '\t' + data[i][1]

def process_fersht():
  
    data = lines2list('/home/bartolo/web/statium/BarnstarBarnase/Fersht_data.txt')
    for i in range(len(data)):
        barn_pos = int(data[i][0][1:len(data[i][0]) - 1]) - 2
        barst_pos = int(data[i][1][1:len(data[i][1]) - 1]) + 109
        print str(barn_pos) + '\t' + str(barst_pos)
        #print str(barn_pos) + '\t' + str(barst_pos) + '\t' + data[i][0][0] + data[i][0][-1] + '\t' + data[i][1][0] + data[i][1][-1] + '\t' + str(data[i][6]) + '\t' + str(data[i][7])

def process_gideon():
  
    data = lines2list('/home/bartolo/web/statium/TEM1/points.txt')
    for i in range(len(data)):
        if data[i][1] == 'WT':
            pos0 = int(data[i][0][1:len(data[i][0])]) - 25
            print str(pos0) + '\t' + data[i][0][0] + '\t' + str(data[i][-1])
        else:
        pos1 = int(data[i][1][1:len(data[i][1])]) + 262
        print str(pos1) + '\t' + data[i][1][0] + '\t' + str(data[i][-1])

def Barnase_Barnstar():
  
    data = lines2list('/home/bartolo/web/statium/BarnstarBarnase/Fersht_data_format.txt')
    toplot = [[], []]
    for i in range(len(data)):
        stat_path = os.path.join('/home/bartolo/web/statium/BarnstarBarnase/BB_2za4', str(int(data[i][0])) + '_' + str(int(data[i][1])) + '_probs.txt')
        #print stat_path
        if os.path.exists(stat_path):
        statmat = lines2list(stat_path)
        idxs0 = [AAChar_int(data[i][2][0]) + 1, AAChar_int(data[i][3][0]) + 1]
        idxs1 = [AAChar_int(data[i][2][1]) + 1, AAChar_int(data[i][3][1]) + 1]
        
        #for j in range(len(data[i])):
            #print str(data[i][j]) + '\t',
        chg = statmat[idxs0[0]][idxs0[1]]
        toplot[0].append(data[i][-2])
        toplot[1].append(chg)
    import pylab
    pylab.scatter(toplot[1], toplot[0])
    pylab.savefig('/home/bartolo/web/test.png')

def BB_energy():

    BB_stat = load_design_energy('/home/bartolo/web/statium/BarnstarBarnase/BB_2za4')
     
    wt = readline('/home/bartolo/web/statium/BarnstarBarnase/BB_2za4.fasta', 1)
    wte = statium_energy_calc(BB_stat, wt, 0.0)
    print wte

    toplot = [[], []]
    
    data = lines2list('/home/bartolo/web/statium/BarnstarBarnase/Fersht_data_format.txt')
    for i in range(len(data)):
        seq = []
        for j in range(len(wt)): seq.append(wt[j])
        try: 
        idx0 = int(data[i][0]) - 1
        seq[idx0] = data[i][2][1]
    except: love = True
        try: 
        idx1 = int(data[i][1]) - 1
        seq[idx1] = data[i][3][1]
    except: love = True
    seq_str = ''
    for j in range(len(seq)): seq_str += seq[j]
    seq_e = statium_energy_calc(BB_stat, seq_str, 0.0)
    for j in range(len(data[i])):
        print str(data[i][j]) + '\t',
    print seq_e - wte
    toplot[0].append(seq_e - wte)
    if len(data[i]) == 7: toplot[1].append(data[i][-2])
    else: toplot[1].append(data[i][-1])

    L = len(wt)
    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(BB_stat, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/Group_101912/BB_hist.png')
        pylab.close()
        print 'done'
        
def CAMP_energy():

    CAMP_stat = load_design_energy('/home/bartolo/web/statium/CAMP/mask/camp_4dg2')
     
    wt = readline('/home/bartolo/web/statium/CAMP/camp_4dg2.fasta', 1)
    wte = statium_energy_calc(CAMP_stat, wt, 0.0)
    print wte

    L = len(wt)
    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(CAMP_stat, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/CAMP/mask/CAMP_hist.png')
        pylab.close()
        print 'done'

def GAI1_energy():

    stat = load_design_energy('/home/bartolo/web/statium/GAI1/mask/gai1_4g5q')
     
    wt = readline('/home/bartolo/web/statium/GAI1/gai1_4g5q.fasta', 1)
    wte = statium_energy_calc(stat, wt, 0.0)
    print wte
    
    #seq = []
    #for i in range(len(wt)): seq.append(wt[i])
    #seq[325] = 'E'
    #seq_str = ''
    #for i in range(len(seq)): seq_str += seq[i]
    #print statium_energy_calc(stat, seq_str, 0.0)
    #return

    L = len(wt)
    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(stat, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/GAI1/mask/GAI1_hist.png')
        pylab.close()
        print 'done'

def TEM1_energy():

    TEM1_stat = load_design_energy('/home/bartolo/web/statium/TEM1/tem1_1jtg')
     
    wt = readline('/home/bartolo/web/statium/TEM1/tem1_1jtg.fasta', 1)
    wte = statium_energy_calc(TEM1_stat, wt, 0.0)
    print wte

    toplot = [[], []]
    
    data = lines2list('/home/bartolo/web/statium/TEM1/points_format.txt')
    for i in range(len(data)):
        seq = []
        for j in range(len(wt)): seq.append(wt[j])
        idx0 = int(data[i][0]) - 1
    seq[idx0] = 'A'
    seq_str = ''
    for j in range(len(seq)): seq_str += seq[j]
    seq_e = statium_energy_calc(TEM1_stat, seq_str, 0.0)
    #for j in range(len(data[i])):
        #print str(data[i][j]) + '\t',
    #print seq_e - wte
    toplot[0].append(seq_e - wte)
    toplot[1].append(float(data[i][-1]))

    #import pylab
    #pylab.scatter(toplot[0], toplot[1])
    #pylab.savefig('/home/bartolo/web/test.png')

    L = len(wt)
    tlib = []
    e_min = 0.0
    for i in range(1000000):
        e = statium_energy_calc(TEM1_stat, random_seq(L), 0.0)
        if e < e_min:
        e_min = e
        print e
        tlib.append(e)
        #tlib.append(statium_energy_calc(scan_stat, random_seq_from_list(seq_list, L), 0.0))
        
        if i % 1000 == 0:
        print 'plotting...',
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
        #pylab.hist(pylab.array(e_vec), normed=True, facecolor='white', edgecolor='blue', lw=2)
        pylab.hist(pylab.array(tlib), facecolor='gray', edgecolor='black', alpha=0.45, lw=2)
       # pylab.yticks([])
       # pylab.xticks([])
        pylab.savefig('/home/bartolo/web/statium/Group_101912/TEM1_hist.png')
        pylab.close()
        print 'done'
        
def array1_flow():

    data = lines2list('/home/bartolo/web/statium/genome_screen_results.txt')
    seqs = []
    for i in range(len(data)):
        seq = data[i][0][2:25]
        if not seq in seqs and not seq[8] == 'D':
        seqs.append(seq)
        print seq
        
def array2_flow():

    data = lines2list('/home/bartolo/web/statium/genome_screen_results.txt')
    data2 = lines2list('/home/bartolo/web/statium/genome/pred_energies.txt')
    data3 = lines2list('/home/bartolo/web/statium/ArrayIII/signal_UM.txt')
    seqs = []
    for i in range(len(data2)):
        seq = data2[i][0]
        found = False
        for j in range(len(data)):
        if found: break
        seqj = data[j][0][2:25]
        seqjUM = ''
        for k in range(len(seqj)):
            if seqj[k] == 'U': seqjUM += 'M'
            else: seqjUM += seqj[k]
        if seq == seqjUM:
            found = True
        pstr = ''
        for l in range(len(data2[i])): pstr += str(data2[i][l]) + '\t'
        for l in range(1, 6): pstr += str(round(data[j][l], 2)) + '\t'
            for k in range(len(data3)):
            if data3[k][0][2:25] == seq:
            pstr += str(data3[k][1]) + '\t'
            pstr += str(data3[k][2]) + '\t'
            pstr += str(data3[k][4])
            break
            gotit = True
        print pstr
    
def array3_flow():
  
    pxmax = 0.89
    pmmax = 1.65
    #sxmax = 2.13
    sxmax = -5.1
    smmax = -10.5
    #smmax = -4.19
    
    smax = 0.2

    data = lines2list('/home/bartolo/web/statium/genome/pred_sorts.txt')
    
    tp = 0.0
    fp = 0.0
    etp = 0.0
    efp = 0.0
    for i in range(len(data)):
        if (data[i][1] < sxmax or data[i][2] < smmax) and (data[i][3] < pxmax or data[i][4] < pmmax):
        #if (data[i][1] >= sxmax and data[i][2] >= smmax) and (data[i][3] >= pxmax and data[i][4] >= pmmax):
        if data[i][5] > smax or data[i][6] > smax:
            etp += 1.0
            #print data[i][0]
        else: efp += 1.0
    
    if data[i][5] > smax or data[i][6] > smax: tp += 1.0
    else: fp += 1.0
    
    print 'both potentials', etp / (etp + efp), etp + efp

    tp = 0.0
    fp = 0.0
    etp = 0.0
    efp = 0.0
    for i in range(len(data)):
        if (data[i][1] < sxmax or data[i][2] < smmax) and (data[i][3] >= pxmax and data[i][4] >= pmmax):
        if data[i][5] > smax or data[i][6] > smax:
            etp += 1.0
            #print data[i][0]
        else: efp += 1.0
    if data[i][5] > smax or data[i][6] > smax: tp += 1.0
    else: fp += 1.0
    
    print 'STATIUM only', etp / (etp + efp), etp + efp
    
    tp = 0.0
    fp = 0.0
    etp = 0.0
    efp = 0.0
    for i in range(len(data)):
        if (data[i][1] >= sxmax and data[i][2] >= smmax) and (data[i][3] < pxmax or data[i][4] < pmmax):
        if data[i][5] > smax or data[i][6] > smax:
            etp += 1.0
            #print data[i][0]
        else: efp += 1.0
    if data[i][5] > smax or data[i][6] > smax: tp += 1.0
    else: fp += 1.0
    
    print 'PSSM only', etp / (etp + efp), etp + efp   
    
    tp = 0.0
    fp = 0.0
    etp = 0.0
    efp = 0.0
    for i in range(len(data)):
        if ((data[i][1] >= sxmax and data[i][2] >= smmax) and (data[i][3] < pxmax or data[i][4] < pmmax)) or ((data[i][1] < sxmax or data[i][2] < smmax) and (data[i][3] >= pxmax and data[i][4] >= pmmax)):
        if data[i][5] > smax or data[i][6] > smax:
            etp += 1.0
            #print data[i][0]
        else: efp += 1.0
    if data[i][5] > smax or data[i][6] > smax: tp += 1.0
    else: fp += 1.0
    
    print 'either or', etp / (etp + efp), etp + efp  
    
    etp = 0.0
    efp = 0.0
    count = 0
    for i in range(len(data)):
        if ((data[i][1] >= sxmax and data[i][2] >= smmax) and (data[i][3] < pxmax or data[i][4] < pmmax)) or ((data[i][1] < sxmax or data[i][2] < smmax) and (data[i][3] >= pxmax and data[i][4] >= pmmax)) or ((data[i][1] < sxmax or data[i][2] < smmax) and (data[i][3] < pxmax or data[i][4] < pmmax)):
        count += 1
    else:
        if data[i][5] > smax or data[i][6] > smax:
            etp += 1.0
            #print data[i][0]
        else: efp += 1.0
    
    print 'all else', etp / (etp + efp), etp + efp
    print count, tp + fp

def ave_stat():
  
    data = lines2list('/home/bartolo/web/statium/genome/BH3_energies_XM.txt')
    x = 0.0
    xc = 0.0
    m = 0.0
    mc = 0.0
    for i in range(len(data)):
        if data[i][5] == 1.0:
        x += data[i][1]
        xc += 1.0
        if data[i][6] == 1.0:
        m += data[i][2]
        mc += 1.0
    x += -3.93
    xc += 1.0
    print x / xc, m/mc
    
    x = 0.0
    xc = 0.0
    m = 0.0
    mc = 0.0
    for i in range(len(data)):
        if data[i][5] == 1.0:
        x += data[i][3]
        xc += 1.0
        if data[i][6] == 1.0:
        m += data[i][4]
        mc += 1.0
    print x / xc, m/mc
    
def maka_da_pie(plot_path, val):
 
    import matplotlib
    matplotlib.use( 'Agg' )
 
    import pylab
    
    #pylab.rcParams['xtick.labelsize'] = '4'
    #pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    #pylab.rcParams['xtick.major.pad']='12'
    #pylab.rcParams['ytick.major.pad']='12'
    #pylab.rcParams['axes.linewidth'] = 3.0
    #fig = pylab.figure()    # Create a figure
    #ax = fig.gca()
    #for tick in ax.xaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
    #for tick in ax.yaxis.get_major_ticks():
        #tick.label1.set_fontsize('15')
        #tick.label1.set_fontweight('bold')
    #label = [str(round(val * 100, 1)) + '%', '']
    label = ['', '']
    pylab.pie([val, 1 - val], explode=[0.05, 0.0], labels=label, colors=['r', 'b'], autopct=None, shadow=True)

    pylab.savefig(plot_path)

def all_bcl2_energies(seq_path):
  
    data = lines2list(seq_path)

    xmode_sidechain = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    xmode = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    SPOT_vec = PSSM5()
    
    deepxa = deepe_matrix_coupling('xa')
    
    for i in range(len(data)):
      
        seq = data[i][0]

        penergy = pssm_energy10(SPOT_vec, seq)
        pssme = penergy[0]
        deepe = deepe_calc_coupling([deepxa, 'xa'], seq, 1.0, 0.0)
        xe = statium_energy_calc(xmode, seq, 0.0)
        xes = statium_energy_calc_sidechain(xmode_sidechain, seq, 0.0)
        
        print str(xes) + '\t' + str(xe) + '\t' + str(pssme) + '\t' + str(deepe)
    
def bcl2_sidechain_genome_energies():
  
    seqs = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt')
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')  
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')

    SPOT_vec = PSSM5() 

    outs = []
    for i in range(len(seqs)):
        if i > 0 and i % 10000 == 0: print float(i) / float(len(seqs))
        seq = seqs[i][0]
        try:
            penergy = pssm_energy10_buried_penal(SPOT_vec, seq)
            px = penergy[0]
        pm = penergy[1]
        pf = penergy[3]
        p2 = penergy[4]
              ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
        eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
        outs.append(str(px) + '\t' + str(pm) + '\t' + str(pf) + '\t' + str(p2) + '\t' + str(ex) + '\t' + str(em) + '\t' + str(ef) + '\t' + str(eb) + '\n')
    except: outs.append('NO DICE\n')

    of = open('/home/bartolo/web/statium_sidechain/bcl2_expand_energies_opt.txt', 'w')
    for i in range(len(outs)): of.write(outs[i])
    of.close()
    
def MSA_BH3(p, frame):
  
    data = lines2list(p)
    seqs = []
    for i in range(len(data)):
        seq = ''
        valid = True
        for j in range(23):
        aa = AAChar_int(data[i][0][frame + j])
        if aa >= 20: valid = False
        seq += data[i][0][frame + j]
    if not valid: continue
    seqs.append(seq)
    return seqs
    
def bcl2_sidechain_genome_energies_MSA():
  
    seqs = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt')
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')  
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')

    SPOT_vec = PSSM5() 

    outs = []
    for i in range(len(seqs)):
        if i > 0 and i % 1000 == 0: print float(i) / float(len(seqs))
        fam_seqs = MSA_BH3('/home/bartolo/web/BLAST/hprd_align/hprd_' + str(int(seqs[i][1])) + '.out', int(seqs[i][2]) - 1) 
        try:
        ev = [[], [], [], [], [], [], [], []]
        for seq in fam_seqs:
                penergy = pssm_energy10(SPOT_vec, seq)
                ev[0].append(penergy[0])
            ev[1].append(penergy[1])
            ev[2].append(penergy[3])
            ev[3].append(penergy[4])
                  ev[4].append(statium_energy_calc_sidechain(xmode, seq, 0.0))
            ev[5].append(statium_energy_calc_sidechain(mmode, seq, 0.0))
            ev[6].append(statium_energy_calc_sidechain(fmode, seq, 0.0))
            ev[7].append(statium_energy_calc_sidechain(bmode, seq, 0.0))
        for j in range(len(ev)): ev[j].sort()
        for j in range(len(ev)):
            del ev[j][-1]
            del ev[j][-1]
        rstr = ''
        for j in range(len(ev)): rstr += str(mean(ev[j])) + '\t'
        rstr += '\n'
        outs.append(rstr)
    except: outs.append('NO DICE\n')

    of = open('/home/bartolo/web/statium_sidechain/bcl2_expand_energies_MSA.txt', 'w')
    for i in range(len(outs)): of.write(outs[i])
    of.close()
    
def bcl2_sidechain_genome_entropies():
  
    seqs = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt')
    
    entropies = []
    for i in range(len(seqs)):
        #if i > 0 and i % 1000 == 0: print i, entropies[-1]
        if i > 0: print i, entropies[-1], 
        path = '/home/bartolo/web/BLAST/hprd_align/hprd_' + str(int(seqs[i][1])) + '.out'
        frame = int(seqs[i][2] - 1)
        if i > 0: print i, entropies[-1], frame, path
    try: entropies.append(BH3_entropy_value(path, frame))
    except: entropies.append(-1.0)
    
    of = open('/home/bartolo/web/statium_sidechain/bcl2_expand_entropies.txt', 'w')
    for i in range(len(entropies)): of.write(str(entropies[i]) + '\n')
    of.close()    
    
def natural_pssm_position():
  
    seqs = lines2list('/home/bartolo/web/statium/BH3_natural.txt')
    SPOT_vec = PSSM5()
    
    for i in range(len(seqs)):
        seq = seqs[i][0]
        name = seqs[i][1]
        penergy = pssm_energy10_pos(SPOT_vec, seq)
        
        print name
        print seq
        for j in range(5):
        if j == 2: continue
        for val in penergy[j]: print round(val, 2),
        print
    print
    print
   
def bcl2_sidechain_genome_analysis():
  
    seqs = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt')
    names = readlines('/home/bartolo/web/statium_sidechain/bcl2_expand_names.txt')
    tested_lines = readlines('/home/bartolo/web/statium/aleady_tested_short.txt')
    tested = []
    for i in range(len(tested_lines)):
    th = tested_lines[i].strip()
    if not th in tested and th[8] != 'D' and th[12] != 'L' and th[0:4] != 'PEIW': tested.append(tested_lines[i].strip())
    energies = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_energies.txt')
    energies_MSA = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_energies_MSA.txt')

    xpcut = 0.9
    mpcut = 1.4
    bpcut = 0.35
    fpcut = 0.3

    count = 0
    count2 = 0
    xsort = []
    msort = []
    for i in range(len(energies)):
        if len(energies[i]) < 4: continue
        if len(energies_MSA[i]) < 4: continue
        
        seq = seqs[i][0]
        
        px = energies[i][0]
        pm = energies[i][1]
        pf = energies[i][2]
        p2 = energies[i][3]
    ex = energies[i][4]
    em = energies[i][5]
    ef = energies[i][6]
    eb = energies[i][7]
    
        px_MSA = energies_MSA[i][0]
        pm_MSA = energies_MSA[i][1]
        pf_MSA = energies_MSA[i][2]
        p2_MSA = energies_MSA[i][3]
    ex_MSA = energies_MSA[i][4]
    em_MSA = energies_MSA[i][5]
    ef_MSA = energies_MSA[i][6]
    eb_MSA = energies_MSA[i][7]

        #if seqs[i][0][13] != 'D' or not seqs[i][0][12] in 'ASCG': continue
        #pro = False
        #for j in [6, 10]:
        #if seqs[i][0][j] == 'P': pro = True
    #if pro: continue
    #pc = 0
    #for j in range(len(seqs[i][0])):
        #if seqs[i][0][j] == 'P': pc += 1
    #if pc > 2: continue
    #gc = 0
    #for j in range(len(seqs[i][0])):
        #if seqs[i][0][j] == 'G': gc += 1
    #if gc > 3: continue
    
        #if ef < -15.0 and pf >= 0.3 and pf < 1.3:
        if ex < -6.0 and em < -6.0 and ef < -6.0 and eb < -6.0 and (px < 1.9 or pm < 2.4 or pf < 1.3):
        drop = False
        for test in tested:
        comp = 0
        for j in range(len(seq)):
            if seq[j] == test[j]: comp += 1
        if comp > 18:
            drop = True
            break
        if drop: continue
        count += 1
        name_str = names[i].strip()
        for j in range(len(name_str)):
            if name_str[j] == '|': idx = j
        name = ''
        for j in range(idx, len(name_str)): name += name_str[j]
        rstr = seqs[i][0] + '\t' + str(round(ex, 1)) + '\t' + str(round(em, 1)) + '\t' + str(round(ef, 1)) + '\t' + str(round(eb, 1)) + '\t' +  name
        print rstr.strip()
        #if px < 2.0: xsort.append([ex, rstr])
        #if pm < 2.0: msort.append([em, rstr])

    #xsort.sort()
    #msort.sort()
    #of = open('/home/bartolo/web/xsort.txt', 'w')
    #for i in range(len(xsort)): of.write(xsort[i][1] + '\n')
    #of.close()

    #of = open('/home/bartolo/web/msort.txt', 'w')
    #for i in range(len(msort)): of.write(msort[i][1] + '\n')
    #of.close()

    print count
    
def array5_seq():
    
    xlines = readlines('/home/bartolo/web/xsort.txt')
    mlines = readlines('/home/bartolo/web/msort.txt')

    xdata = lines2list('/home/bartolo/web/xsort.txt')
    mdata = lines2list('/home/bartolo/web/msort.txt')


    seqs = []
    xonly = []
    monly = []
    both = []
    for i in range(len(mdata)):
    if not mdata[i] in seqs:
        seqs.append(mdata[i])
        if mdata[i][1] > 5.0: monly.append(mlines[i])
        else: both.append(mlines[i])
        if (len(both) * 2 + len(xonly) + len(monly)) > 380: break
        if not xdata[i] in seqs:
            seqs.append(xdata[i])
            if xdata[i][2] > 5.0: xonly.append(xlines[i])
            else: both.append(xlines[i])
        if (len(both) * 2 + len(xonly) + len(monly)) > 380: break
    print 'TEST WITH MCL1 AND BCLXL'
    for i in range(len(both)): print both[i].strip()
    print


    print 'TEST WITH MCL1'
    for i in range(len(monly)): print monly[i].strip()
    print

    print 'TEST WITH BCLXL'
    for i in range(len(xonly)): print xonly[i].strip()
    print
    
def bcl2_spot200_corr():
  
    import pylab
  
    rvec = ['x', 'm', 'w', 'f', '2']

    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    evec = []
    evec.append(load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8'))
    evec.append(load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1'))
    evec.append([])
    evec.append(load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp'))
    evec.append(load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2'))

    idx_vec = [2, 3, 4, 5, 6]

    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == 'PEIWIAQELRRIGDEFNAYYARR':
            wt200_count += 1.0
            wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    print 'SPOT200 specificity...'
    print
    
    spot200_spec = []
    for i in range(len(idx_vec)):
        spot200_spec.append([])
        for j in range(len(idx_vec)): spot200_spec[i].append([])
        
    spot200_spec_corr = []
    for i in range(len(idx_vec)):
        spot200_spec_corr.append([])
        for j in range(len(idx_vec)): spot200_spec_corr[i].append([[], []])

    for i in range(5):
    idxi = idx_vec[i]
    for j in range(i + 1, 5):
        idxj = idx_vec[j]
        if idxi == 4 or idxj == 4: continue
            for row in SPOT200:
                seq = row[0][0:23]
                dsigi = -1.0 * math.log10(row[idxi] / wt_vec[i])
                dsigj = -1.0 * math.log10(row[idxj] / wt_vec[j])
                ei = statium_energy_calc(evec[i], seq, 0.0)
                ej = statium_energy_calc(evec[j], seq, 0.0)
                spot200_spec[i][j].append([dsigi - dsigj, ei - ej, seq, dsigi, dsigj])
            spot200_spec[i][j].sort()
        
    for i in range(5):
        for j in range(i + 1, 5):
        if i == 2 or j == 2: continue
            L = len(spot200_spec[i][j])
        for k in range(L):
            if spot200_spec[i][j][k][3] <= 0.0 or spot200_spec[i][j][k][4] <= 0.0:
            spot200_spec_corr[i][j][0].append(spot200_spec[i][j][k][0])
            spot200_spec_corr[i][j][1].append(spot200_spec[i][j][k][1])
        print rvec[i], rvec[j], round(pylab.corrcoef(pylab.array(spot200_spec_corr[i][j][0]), pylab.array(spot200_spec_corr[i][j][1]))[0][1], 2), len(spot200_spec_corr[i][j][0])


def bcl2_sidechain_spot200_corr():
  
    import pylab
  
    rvec = ['x', 'm', 'w', 'f', '2']

    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
    evec = []
    evec.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8'))
    evec.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1'))
    evec.append([])
    evec.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp'))
    evec.append(load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2'))

    idx_vec = [2, 3, 4, 5, 6]

    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == 'PEIWIAQELRRIGDEFNAYYARR':
            wt200_count += 1.0
            wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    print 'SPOT200 specificity...'
    print
    
    spot200_spec = []
    for i in range(len(idx_vec)):
        spot200_spec.append([])
        for j in range(len(idx_vec)): spot200_spec[i].append([])
        
    spot200_spec_corr = []
    for i in range(len(idx_vec)):
        spot200_spec_corr.append([])
        for j in range(len(idx_vec)): spot200_spec_corr[i].append([[], []])

    for i in range(5):
    idxi = idx_vec[i]
    for j in range(i + 1, 5):
        idxj = idx_vec[j]
        if idxi == 4 or idxj == 4: continue
            for row in SPOT200:
                seq = row[0][0:23]
                dsigi = -1.0 * math.log10(row[idxi] / wt_vec[i])
                dsigj = -1.0 * math.log10(row[idxj] / wt_vec[j])
                ei = statium_energy_calc_sidechain(evec[i], seq, 0.0)
                ej = statium_energy_calc_sidechain(evec[j], seq, 0.0)
                spot200_spec[i][j].append([dsigi - dsigj, ei - ej, seq, dsigi, dsigj])
            spot200_spec[i][j].sort()
        
    for i in range(5):
        for j in range(i + 1, 5):
        if i == 2 or j == 2: continue
            L = len(spot200_spec[i][j])
        for k in range(L):
            if spot200_spec[i][j][k][3] <= 0.0 or spot200_spec[i][j][k][4] <= 0.0:
            spot200_spec_corr[i][j][0].append(spot200_spec[i][j][k][0])
            spot200_spec_corr[i][j][1].append(spot200_spec[i][j][k][1])
        print rvec[i], rvec[j], round(pylab.corrcoef(pylab.array(spot200_spec_corr[i][j][0]), pylab.array(spot200_spec_corr[i][j][1]))[0][1], 2), len(spot200_spec_corr[i][j][0])

def compile_all_arrays(ipath):
  
    data = lines2list(ipath)
    
    SPOT_vec = PSSM5()
  
    zstd = [10.5046784969, 9.06295607193]
    zmean = [14.0549828438, 11.1706832649]

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')

    for i in range(len(data)):
        seq = data[i][0]
        sig = data[i][1]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        epssm = energy_pssm[0]
        e = statium_energy_calc_sidechain(xmode, seq, 0.0)
        z = (e - zmean[0]) / zstd[0]
        print 'X' + '\t' + seq + '\t' + str(sig) + '\t' + str(round(z, 2)) + '\t' + str(round(epssm, 2))

def compile_array5():
  
    data = lines2list('/home/bartolo/web/statium/Array5/Array5_results_labelled_noF.txt')
    
    SPOT_vec = PSSM5()
  
    zstd = [10.5046784969, 9.06295607193]
    zmean = [14.0549828438, 11.1706832649]

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')

    for i in range(len(data)):
        seq = data[i][0]
        #p = 0
        #for j in range(len(seq)):
        #if seq[j] in 'RK': p += 1
        #if seq[j] in 'ED': p -= 1
        sig = data[i][1]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        epssm = energy_pssm[0]
        e = statium_energy_calc_sidechain(xmode, seq, 0.0)
        z = (e - zmean[0]) / zstd[0]
        print 'X' + '\t' + seq + '\t' + str(sig) + '\t' + str(round(z, 2)) + '\t' + str(round(epssm, 2))

def compile_array_all():
  
    data = lines2list('/home/bartolo/web/All_arrays.txt')
    
    SPOT_vec = PSSM5()
  
    zstd = [10.5046784969, 9.06295607193]
    zmean = [14.0549828438, 11.1706832649]
    
    zstdp = [0.957525719117, 0.917711243381]
    zmeanp = [3.98243723171, 4.41547882232]

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')

    for i in range(len(data)):
        seq = data[i][1]
        #p = 0
        #for j in range(len(seq)):
        #if seq[j] in 'RK': p += 1
        #if seq[j] in 'ED': p -= 1
        sig = data[i][2]
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        if data[i][0] == 'M':
            epssm = energy_pssm[1]
            e = statium_energy_calc_sidechain(mmode, seq, 0.0)
            z = (e - zmean[1]) / zstd[1]
            print 'M' + '\t' + seq + '\t' + str(sig) + '\t' + str(round(z, 2)) + '\t' + str(round(epssm, 2))
        if data[i][0] == 'X':
            epssm = energy_pssm[0]
            e = statium_energy_calc_sidechain(xmode, seq, 0.0)
            z = (e - zmean[0]) / zstd[0]
            print 'X' + '\t' + seq + '\t' + str(sig) + '\t' + str(round(z, 2)) + '\t' + str(round(epssm, 2))

def SPOT_prediction():
  
    init = 0.8
    for i in range(30):
        print init, compile_array_charge(init)
        init -= 0.2
        
def genome_histogrammies():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/X_energies.txt')
    hd = []
    for i in range(len(data)): hd.append(round(data[i][0], 1))
  
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    

    pylab.hist(pylab.array(hd), normed=False, facecolor='white', edgecolor='black', lw=2)
    pylab.xlim(-40.0, 80.0)
    pylab.ylim(0, 200000)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/X_hist.png')


def SPOT_prediction_PLOT():
  
    #comb_data = lines2list('/home/bartolo/web/statium/all_array_analysis/SPOT_pred_combined.txt')
    #stat_data = lines2list('/home/bartolo/web/statium/all_array_analysis/SPOT_pred_STATIUM.txt')
    #pssm_data = lines2list('/home/bartolo/web/statium/all_array_analysis/SPOT_pred_PSSM.txt')
    
    #comb = [[], []]
    #for i in range(len(comb_data)):
        #comb[0].append(comb_data[i][0])
        #comb[1].append(comb_data[i][1])

    #stat = [[], []]
    #for i in range(len(stat_data)):
        #stat[0].append(stat_data[i][0])
        #stat[1].append(stat_data[i][1])
        
    #pssm = [[], []]
    #for i in range(len(pssm_data)):
        #pssm[0].append(pssm_data[i][0])
        #pssm[1].append(pssm_data[i][1])
        
    rocs = compile_array_charge()
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')

    pylab.plot(rocs[0][0][0], rocs[0][0][1], 'b', label='high-res PDB library', lw=2)
    pylab.plot(rocs[1][0][0], rocs[1][0][1], 'r', label='high-res PDB library', lw=2)
    pylab.plot(rocs[2][0][0], rocs[2][0][1], 'k', label='high-res PDB library', lw=2)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/SPOT_prediction_lines.png')

def flart():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/flart.txt')

    count = 0
    for i in range(len(data)):
        stat_pass = data[i][1] <= -1.5 or data[i][2] <= -1.5 or data[i][3] <= -1.5 or data[i][4] <= -1.5 or data[i][-1] == 'AII'
        pssm_pass = data[i][5] <= 1.9 or data[i][6] <= 2.4
        if not stat_pass and pssm_pass:
        print data[i][0]
        count += 1
    print count
    
def array_filter_analysis():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/All_arrays_nofunction.txt')

    hit = 0
    miss = 0
    seqs = []
    reg = [[], []]
    cnt = [[], []]
    for i in range(len(data)):
        rec = data[i][0]
        seq = data[i][1]
        
        if not seq in cnt[0]:
        cnt[0].append(seq)
        cnt[1].append(1)
        else:
        idx = cnt[0].index(seq)
            cnt[1][idx] += 1
            
    print len(cnt[0])
    return
            
    for i in range(len(data)):
        rec = data[i][0]
        seq = data[i][1]
        sig = data[i][8]
        
        ex = data[i][2]
        em = data[i][3]
        ex_sc = data[i][4]
        em_sc = data[i][5]
        px = data[i][6]
        pm = data[i][7]
        #if sig > 1.0:
        
        if (rec == 'M' and (em_sc <= -1.5 and pm > 2.4)) or (rec == 'X' and (ex_sc <= -1.5 and px > 1.9)):
            #
            if not seq in reg[0]:
            reg[1].append(1)
            reg[0].append(seq)
        else:
            idx = reg[0].index(seq)
            reg[1][idx] += 1
            
    for i in range(len(reg[0])):
    seq = reg[0][i]
    seq_cnt = cnt[1][cnt[0].index(seq)]
    if reg[1][i] == 0: continue
    if not seq in seqs: seqs.append(seq)
        
            #continue
            #if sig < 0.03: miss += 1
            #controls = False
            #if len(data[i]) == 11:
            #controls = True
            #c1 = data[i][-2]
            #c2 = data[i][-1]
            #if sig > 0.05 and c1 > 0.3 and c2 > 0.3:
                #hit += 1
    
    #print float(hit) / float(hit + miss), hit + miss
    print len(seqs)
        

def compile_array_charge2(neg_cut, pos_cut, cntrl_cut, algorithm, px_cut, pm_cut, func):
  
    SPOT_vec = PSSM5()
    M_consmat = load_BH3_conserve_matrix('/home/bartolo/web/statium/all_array_analysis/known_binder_align_M.txt')
    X_consmat = load_BH3_conserve_matrix('/home/bartolo/web/statium/all_array_analysis/known_binder_align_X.txt')
 
  
    zstd = [7.82148011783, 8.42545057961]
    zmean = [8.88202577979, 3.59344777264]
    
    zstd_sc = [10.5046784969, 9.06295607193]
    zmean_sc = [14.0549828438, 11.1706832649]
    
    zstdo_aff = [63.5242791301, 69.6244743843]
    zmeano_aff = [68.2460060157, 67.0483148038]
    
    zstdp = [0.957525719117, 0.917711243381]
    zmeanp = [3.98243723171, 4.41547882232]
    
    zstd_cons = [1.08475303172, 1.20537614547]
    zmean_cons = [5.71152314753, 5.76638548017]

    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
  
    data = readlines('/home/bartolo/web/statium/all_array_analysis/All_arrays_tagged_controls.txt')

    seqs = []
    rec = []
    
    good_by_both = readlines('statium/all_array_analysis/good_by_both.txt')
    gbb = []                  
    for line in good_by_both:gbb.append(line.strip())
    
    pos = 0
    neg = 0
    tot = 0
    preddy = [[], []]
    for line in data:
    items = line.strip().split()
    seq = items[1]
    sig = float(items[2])
    sig_str = str(sig)
    controls = False
    if len(items) == 9:
        controls = True
        m3a = float(items[3])
        m3e = float(items[4])
        
        m3a_red = str(1.0 - (m3a / sig))
        m3e_red = str(1.0 - (m3e / sig))
        sig_str += ' ' + m3a_red + ' ' + m3e_red
    energy_pssm = pssm_energy10(SPOT_vec, seq)
    energy_pssm_lim = pssm_energy10_lim(SPOT_vec, seq)
    exo = statium_energy_calc(xorig, seq, 5.0)
    emo = statium_energy_calc(morig, seq, 5.0)
    ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    zxo = round((exo - zmeano_aff[0]) / zstdo_aff[0], 2)
    zmo = round((emo - zmeano_aff[1]) / zstdo_aff[1], 2)
    zx = round((ex - zmean_sc[0]) / zstd_sc[0], 2)
    zm = round((em - zmean_sc[1]) / zstd_sc[1], 2)
    px = energy_pssm[0]
    pm = energy_pssm[1]
    px_lim = energy_pssm_lim[0]
    zpx_lim = round((px_lim - zmeanp[0]) / zstdp[0], 2)
    zpx = round((px - zmeanp[0]) / zstdp[0], 2)
    zpm = round((pm - zmeanp[1]) / zstdp[1], 2)
    
    X_cons = BH3_conserve_score(X_consmat, seq)
    M_cons = BH3_conserve_score(M_consmat, seq)

    zconsX = (X_cons - zmean_cons[0]) / zstd_cons[0]
    zconsM = (M_cons - zmean_cons[1]) / zstd_cons[1]
    
    if (zxo > -1.5 and zmo > -1.5 and zx > -1.5 and zm > -1.5 and px > 1.9 and pm > 2.4): continue

        #if algorithm == 'both_bad': 
        #if items[0] == 'M':
        #if zm > -1.5 and pm > pm_cut: go = True
        #else: continue
        #if items[0] == 'X':
        #if zx > -1.5 and px > px_cut: go = True
        #else: continue
        
        #if algorithm == 'pssm_good':
        #if items[0] == 'M':
        #if pm <= pm_cut: go = True
        #else: continue
        #if items[0] == 'X':
        #if px <= px_cut: go = True
        #else: continue
        
        #if algorithm == 'stat_good':
        #if items[0] == 'M':
        #if zm <= -1.5: go = True
        #else: continue
        #if items[0] == 'X':
        #if zx <= -1.5: go = True
        #else: continue
        
        #if algorithm == 'both_good':
        #if items[0] == 'M':
        #if zm <= -1.5 and pm <= pm_cut: go = True
        #else: continue
        #if items[0] == 'X':
        #if zx <= -1.5 and px <= px_cut: go = True
        #else: continue

        #if algorithm == 'stat_plus':
        #if items[0] == 'M':
        #if zm <= -2.5 and pm <= pm_cut: go = True
        #else: continue
        #if items[0] == 'X':
        #if zx <= -2.5 and px <= px_cut: go = True
        #else: continue


        
    
    
    #if seq in gbb: continue
    #if items[-2] != 'AIV': continue
    
    #zpx = zpx_lim
    
    tot += 1
    score = 1.0
    if func == 'zm_zpm':
        score = zpm + zm
        if items[0] != 'M': continue
        elif func == 'zm':
        score = zm
        if items[0] != 'M': continue
        elif func == 'zpm':
        score = zpm
        if items[0] != 'M': continue        
    elif func == 'zx_zpx':
        score = zpx + zx
        if items[0] != 'X': continue
        elif func == 'zx':
        score = zx
        if items[0] != 'X': continue
        elif func == 'zpx':
        score = zpx
        if items[0] != 'X': continue
        elif func == 'zcx':
        score = zconsX
        if items[0] != 'X': continue
        elif func == 'zcm':
        score = zconsM
        if items[0] != 'M': continue
    elif func == 'zm_zcm':
        score = zconsM + zm
        if items[0] != 'M': continue
    elif func == 'zx_zcx':
        score = zconsX + zx
        if items[0] != 'X': continue
    elif func == 'zm_zpm_zcm':
        score = zconsM + zm + zpm
        if items[0] != 'M': continue
    elif func == 'zx_zpx_zcx':
        score = zconsX + zx + zpx
        if items[0] != 'X': continue
    elif func == 'zpm_zcm':
        score = zconsM + zpm
        if items[0] != 'M': continue
    elif func == 'zpx_zcx':
        score = zconsX + zpx
        if items[0] != 'X': continue
    if sig <= neg_cut:
        neg += 1.0
        preddy[0].append(1)
        preddy[1].append(score)

    if controls:
        if float(m3a_red) > cntrl_cut and float(m3e_red) > cntrl_cut and sig > pos_cut:
            pos += 1.0
            preddy[0].append(0)
            preddy[1].append(score)

            if not seq in seqs:
            seqs.append(seq)
            rec.append([items[0]])
        else:
            idx = seqs.index(seq)
            rec[idx].append(items[0])
           
        
        elif (float(m3a_red) < 0.0 and float(m3e_red) < 0.0) and sig > pos_cut:
            #if not seq in seqs: seqs.append(seq)
            #tot += 1
        neg += 1.0
        
            preddy[0].append(1)
            preddy[1].append(score)


    #print algorithm, pos, neg, pos / (pos + neg)
    for i in range(len(seqs)): print seqs[i], rec[i]
    roc_pred = pyroc(preddy)
    print roc_pred[1]
    print len(seqs)
    return roc_pred[0]
    
def array4paper():
  
    data = readlines('/home/bartolo/web/statium/all_array_analysis/All_arrays_tagged_controls.txt')

    seqs = [[], [], [], []]

    zstd = [12.5964280762, 9.59343423497, 11.751603669, 11.8554232701, 10.1877121464]
    zmean = [19.1906407971, 14.274283119, 20.6483026992, 22.0019210125, 17.3106609485]

    zstdp = [0.957525719117, 0.917711243381, 0.518798747972, 0.948616660627, 0.635063414077]
    zmeanp = [3.98243723171, 4.41547882232, 1.69542278603, 2.94382294585, 2.62386345361]
 
    zstdo = [7.82148011783, 8.42545057961, 7.8113492244, 8.06076907477, 9.56253284139]
    zmeano = [8.88202577979, 3.59344777264, 16.9838604234, 13.6195053537, 12.9646255606]   
 
    zstdo_aff = [63.5242791301, 69.6244743843, 47.2824198646, 62.6257663696, 64.9647511437]
    zmeano_aff = [68.2460060157, 67.0483148038, 64.3481389591, 78.5934248038, 72.6519383473]
    
    SPOT_vec = PSSM5()
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    
    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    worig = load_design_energy('/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3')
    borig = load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2')
    forig = load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp')

    pos = 0
    neg = 0
    tot = 0
    for line in data:
    items = line.strip().split()
    seq = items[1]
    if seq in seqs[0]: continue

        energy_pssm = pssm_energy10(SPOT_vec, seq)

        px = energy_pssm[0]
        pm = energy_pssm[1]
        pf = energy_pssm[3]
        pw = energy_pssm[2]
        pb = energy_pssm[4]
    
        exo_aff = statium_energy_calc(xorig, seq, 5.0)
    emo_aff = statium_energy_calc(morig, seq, 5.0)
        ewo_aff = statium_energy_calc(worig, seq, 5.0)
        ebo_aff = statium_energy_calc(borig, seq, 5.0)
        efo_aff = statium_energy_calc(forig, seq, 5.0)

        exo = statium_energy_calc(xorig, seq, 0.0)
        emo = statium_energy_calc(morig, seq, 0.0)
        ewo = statium_energy_calc(worig, seq, 0.0)
        ebo = statium_energy_calc(borig, seq, 0.0)
        efo = statium_energy_calc(forig, seq, 0.0)

        ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
    eb = statium_energy_calc_sidechain(fmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(bmode, seq, 0.0)

    zx = (ex - zmean[0]) / zstd[0]
    zm = (em - zmean[1]) / zstd[1]
        zw = (ew - zmean[2]) / zstd[2]
        zb = (eb - zmean[3]) / zstd[3]
        zf = (ef - zmean[4]) / zstd[4]

        zxo = (exo - zmeano[0]) / zstdo[0]
        zmo = (emo - zmeano[1]) / zstdo[1]
        zwo = (ewo - zmeano[2]) / zstdo[2]
        zbo = (ebo - zmeano[3]) / zstdo[3]
        zfo = (efo - zmeano[4]) / zstdo[4]

        zxo_aff = (exo_aff - zmeano_aff[0]) / zstdo_aff[0]
        zmo_aff = (emo_aff - zmeano_aff[1]) / zstdo_aff[1]
        zwo_aff = (ewo_aff - zmeano_aff[2]) / zstdo_aff[2]
        zbo_aff = (ebo_aff - zmeano_aff[3]) / zstdo_aff[3]
        zfo_aff = (efo_aff - zmeano_aff[4]) / zstdo_aff[4]

        zpx = (px - zmeanp[0]) / zstdp[0]
        zpm = (pm - zmeanp[1]) / zstdp[1]
        zpw = (pw - zmeanp[2]) / zstdp[2]
        zpb = (pb - zmeanp[3]) / zstdp[3]
        zpf = (pf - zmeanp[4]) / zstdp[4]

    zp_vec = [zpx, zpm, zpw, zpb, zpf]
    z_vec = [zx, zm, zw, zb, zf]
    zo_vec = [zxo, zmo, zwo, zbo, zfo]
    #zoa_vec = [zxo_aff, zmo_aff, zwo_aff, zbo_aff, zfo_aff]

    ep = False
    ez = False
    ezo = False
    for j in range(len(zp_vec)):
        if zp_vec[j] < -1.5: ep = True
    for j in range(len(z_vec)):
        if z_vec[j] < -1.5: ez = True
    for j in range(len(zo_vec)):
        if zo_vec[j] < -1.5: ezo = True

    if ep and ez:
        seqs[0].append(seq)
        seqs[1].append(0)
        seqs[2].append([-1000.0, -1000.0, -1000.0])
        seqs[3].append([-1000.0, -1000.0, -1000.0])
   
    for line in data:
    items = line.strip().split()
    seq = items[1]
    if not seq in seqs[0]: continue
    seq_idx = seqs[0].index(seq)    
    sig = float(items[2])
    if items[0] == 'X':
        seqs[2][seq_idx][0] = sig
    if items[0] == 'M':
        seqs[3][seq_idx][0] = sig
    if len(items) == 9:
        m3a = float(items[3])
        m3e = float(items[4])
        
        m3a_red = float(1.0 - (m3a / sig))
        m3e_red = float(1.0 - (m3e / sig))
        #if sig >= 0.05 and (m3a_red >= 0.1 and m3e_red >= 0.1): print line.strip(), m3a_red, m3e_red

        if items[0] == 'X':
        seqs[2][seq_idx][1] = m3a_red
        seqs[2][seq_idx][2] = m3e_red
        if items[0] == 'M':
        seqs[3][seq_idx][1] = m3a_red
        seqs[3][seq_idx][2] = m3e_red

    tot = 0
    tot2 = 0
    tot3 = 0
    tot4 = 0
    for i in range(len(seqs[1])):
    if (seqs[2][i][0] >= 0.05 and seqs[2][i][1] >= 0.3 and seqs[2][i][2] >= 0.3) or (seqs[3][i][0] >= 0.05 and seqs[3][i][1] >= 0.3 and seqs[3][i][2] >= 0.3): tot += 1
    for i in range(len(seqs[1])):
    if (seqs[2][i][0] >= 0.05 or seqs[3][i][0] >= 0.05): tot3 += 1
    for i in range(len(seqs[1])):
    if seqs[2][i][1] == -1000.0 and seqs[3][i][1] == -1000.0: tot2 += 1
    for i in range(len(seqs[1])):
    if (seqs[2][i][0] >= 0.05 and seqs[2][i][1] != -1000.0) or (seqs[3][i][0] >= 0.05 and seqs[3][i][1] != -1000.0): tot4 += 1
    print len(seqs[0]), tot, tot3, tot2, tot4
    
def test_array_parameters(neg_cut, pos_cut, cntrl_cut, px_cut, pm_cut):
  
    alg_vec = ['all', 'both_bad', 'pssm_good', 'stat_good', 'both_good', 'stat_plus']
    rocs = []
    for func in ['zx', 'zpx', 'zcx', 'zx_zpx', 'zx_zcx']:
        rocy = compile_array_charge2(neg_cut, pos_cut, cntrl_cut, 'all', px_cut, pm_cut, func)
        rocs.append(rocy)
        return
        
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    #pylab.scatter(preds[0], preds[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
    cvec = ['b', 'r', 'g', 'k', 'm']
    for i in range(len(rocs)):
        roc = rocs[i]
        pylab.plot(roc[0], roc[1], cvec[i], lw=2)
    pylab.plot([0.0, 1.0], [0.0, 1.0], '--', color='k', lw=1)
    pylab.xlim(-0.005, 1.0)
    pylab.ylim(0.0, 1.005)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/pie_rocs/x_data.png')
    
def compile_array_charge():
  
    data = readlines('/home/bartolo/web/statium/all_array_analysis/All_arrays_tagged_controls.txt')

    seqs = []
    pos = 0.0
    neg = 0.0
    tot = 0
    ac = 0
    for line in data:
        tot += 1
        items = line.strip().split()
        seq = items[1]
        array = items[-1]
        if not seq in seqs:
        ac += 1
        seqs.append(seq)

        p = 0
        for j in range(len(seq)):
        if seq[j] in 'RK': p += 1
        if seq[j] in 'ED': p -= 1
    if p < 0 and float(items[2]) > 0.1: print seq
    if items[-1] == 'A':
        sigA.append(float(items[2]))
        chargeA.append(p)
    if items[-1] == 'X' and items[0] == 'X':
        sigX.append(float(items[2]))
        chargeX.append(p)
    if items[-1] == 'M' and items[0] == 'M':
        #print seq, p
        sigM.append(float(items[2]))
        chargeM.append(p)
    else:
            sig.append(float(items[2]))
            charge.append(p)
        #zcut = -2.5
        #mp = 1.4
        #xp = 0.9
        ##if (items[0] == 'X' and float(items[4]) < xp and float(items[3]) < -2.0) or (items[0] == 'M' and float(items[4]) < mp and float(items[3]) < zcut):
        ##if (items[0] == 'X' and float(items[4]) < xp and float(items[3]) >= zcut) or (items[0] == 'M' and float(items[4]) < mp  and float(items[3]) >= zcut):
    ##if (items[0] == 'X' and float(items[4]) < xp and float(items[3]) >= zcut and float(items[3]) < -1.5) or (items[0] == 'M' and float(items[4]) < mp  and float(items[3]) >= zcut  and float(items[3]) < -1.5):
        ##Low STATIUM, ok PSSM
        #if (items[0] == 'X' and float(items[3]) < zcut and float(items[4]) >= xp  and float(items[4]) < 1.9) or (items[0] == 'M' and float(items[3]) < zcut and float(items[4]) >= mp and float(items[4]) < 2.4):
        ##Low PSSM, ok STATIUM
##        if (items[0] == 'X' and float(items[3]) < -1.5 and float(items[4]) >= xp  and float(items[4]) < 1.9) or (items[0] == 'M' and float(items[3]) < zcut and float(items[4]) >= mp and float(items[4]) < 2.4):
        ##if (items[0] == 'X' and float(items[3]) < zcut and float(items[4]) >= xp) or (items[0] == 'M' and float(items[3]) < zcut and float(items[4]) >= mp):    
    ##if (items[0] == 'X' and float(items[3]) >= zcut and float(items[4]) >= xp) or (items[0] == 'M' and float(items[3]) >= zcut and float(items[4]) >= mp):
        ##if True:
        ##if (items[0] == 'X' and float(items[4]) < 0.9 and float(items[3]) < zcut) or (items[0] == 'M' and float(items[4]) < 1.4 and float(items[3]) < zcut):
        #if not seq in seqs:
            #print line.strip()
            #seqs.append(seq)
        #if float(items[2]) <= 0.05: neg += 1.0
        #else: pos += 1.0
        ##if float(items[2]) < 0.15:
            ##rocp[0].append(1)
            ##rocp[1].append(float(items[4]))
            ##roct[0].append(1)
            ##roct[1].append(float(items[3]))
            ##rocb[0].append(1)
            ##rocb[1].append(float(items[3]) + float(items[4]))
        ##else:
            ##rocp[0].append(0)
            ##rocp[1].append(float(items[4]))
            ##roct[0].append(0)
            ##roct[1].append(float(items[3]))
            ##rocb[0].append(0)
            ##rocb[1].append(float(items[3]) + float(items[4]))
        ##print line.strip()
        ##if not seq in seqs:
            ##print line.strip()
            ##seqs.append(seq)
    #print (pos / (pos + neg)), pos + neg, len(seqs)
    #print tot

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')

    pylab.scatter(pylab.array(charge), pylab.array(sig), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    pylab.scatter(pylab.array(chargeA), pylab.array(sigA), c='r', marker='o', s=10, facecolor='none', edgecolors='r')
    pylab.scatter(pylab.array(chargeX), pylab.array(sigX), c='b', marker='o', s=10, facecolor='none', edgecolors='b')
    pylab.scatter(pylab.array(chargeM), pylab.array(sigM), c='m', marker='o', s=10, facecolor='none', edgecolors='m')
    #pylab.ylim(0.0, 1.0)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/charge_div.png')

def compile_arrayI():
  
    data = lines2list('/home/bartolo/web/statium/genome_screen_results.txt')
    
    SPOT_vec = PSSM5()
  
    zstd = [10.5046784969, 9.06295607193]
    zmean = [14.0549828438, 11.1706832649]

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')

    for i in range(len(data)):
        seq0 = data[i][0][2:25]
        seq = ''
        for j in range(len(seq0)):
        if seq0[j] == 'U': seq += 'M'
        else: seq += seq0[j]
        #p = 0
        #for j in range(len(seq)):
        #if seq[j] in 'RK': p += 1
        #if seq[j] in 'ED': p -= 1
        sig = round(data[i][2], 2)
        energy_pssm = pssm_energy10(SPOT_vec, seq)
        epssm = energy_pssm[1]
        e = statium_energy_calc_sidechain(mmode, seq, 0.0)
        z = (e - zmean[1]) / zstd[1]
        print seq
        #print 'M' + '\t' + seq + '\t' + str(sig) + '\t' + str(round(z, 2)) + '\t' + str(round(epssm, 2))

def bcl2_logos():
  
    expressing_data = lines2list('/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt')
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')

    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')

    yeast_fullx = []
    yeast_fullm = []
    for i in range(len(expressing_data)):
        if i % 10000 == 0: print i
        seq = expressing_data[i][0]
        yeast_fullx.append(statium_energy_calc(xorig, seq, 0.0))
        yeast_fullm.append(statium_energy_calc(morig, seq, 0.0))
             
    x2sort = []
    m2sort = []
    xm2sort = []
    mx2sort = []
    for i in range(len(yeast_fullx)):
        seq = expressing_data[i][0]
        xm2sort.append([yeast_fullx[i], yeast_fullm[i], seq])
        mx2sort.append([yeast_fullm[i], yeast_fullx[i], seq])
        x2sort.append(yeast_fullx[i])
        m2sort.append(yeast_fullm[i])
        
    x2sort.sort()
    m2sort.sort()
    mx2sort.sort()
    xm2sort.sort()
        
    xspec_pred = []
    mspec_pred = []
    L = len(yeast_fullx)
    for i in range(L):
        if i % 10000 == 0: print i
        percentile = float(i + 1) / float(L)
        if percentile > 0.1: break
        mpercentile = float(m2sort.index(xm2sort[i][1])) / float(L)
        xpercentile = float(x2sort.index(mx2sort[i][1])) / float(L)
        
        #xspec_pred.append(xm2sort[i][2])
        #mspec_pred.append(mx2sort[i][2])
        #continue
    
        if mpercentile > 0.35: xspec_pred.append(xm2sort[i][2])
        if xpercentile > 0.35: mspec_pred.append(mx2sort[i][2])
    xf = open('/home/bartolo/web/supertest/xspec_pred_expressing_orig1.txt', 'w')
    for i in range(len(xspec_pred)): xf.write(str(xspec_pred[i]) + '\n')
    xf.close()
    mf = open('/home/bartolo/web/supertest/mspec_pred_expressing_orig1.txt', 'w')
    for i in range(len(mspec_pred)): mf.write(str(mspec_pred[i]) + '\n')
    mf.close()
    
def BHLH_newpartners():
  
    myci = []
    data = lines2list('/home/bartolo/web/CC/MYC2/biogrid/MYC_alone.txt')
    for i in range(len(data)): myci.append(data[i][0])
    maxi = []
    data = lines2list('/home/bartolo/web/CC/MYC2/biogrid/MAX_alone.txt')
    for i in range(len(data)): maxi.append(data[i][0])
    madi = []
    data = lines2list('/home/bartolo/web/CC/MYC2/biogrid/MXD1_alone.txt')
    for i in range(len(data)): madi.append(data[i][0])
    myod1i = []
    data = lines2list('/home/bartolo/web/CC/MYC2/biogrid/MYOD1_alone.txt')
    for i in range(len(data)): myod1i.append(data[i][0])
    tcf3i = []
    data = lines2list('/home/bartolo/web/CC/MYC2/biogrid/TCF3_alone.txt')
    for i in range(len(data)): tcf3i.append(data[i][0])
    
    inet = [myci, maxi, madi, myod1i, tcf3i]
    
    network_dicts = network_dictionaries()
  
    genome_data = lines2list('/home/bartolo/web/CC/MYC2/fullmyc/BHLHplus_seq.txt')
    names_data = readlines('/home/bartolo/web/CC/MYC2/fullmyc/BHLHplus_names.txt')

    mode_vec = []
    labels = ['myc', 'max', 'mad', 'myod1', 'tcf3']
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/myc_1nkp'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/max_1nkp'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/mad_1nlw'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/myod1_1myd'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/tcf3_2ql2'))

    hist_vec = []
    evec = []
    part = []
    tot = []
    total = 0
    for i in range(len(genome_data)):
      
        seq = genome_data[i][0][0:29]
        
    namex = names_data[i].strip()

    ls_dict = network_dicts[1]
    try: shortname = ls_dict[namex]
    except: shortname = '??'
    
    use = False
    evec = []
    for x in range(len(mode_vec)):
        e = statium_energy_calc_sidechain(mode_vec[x], seq, 0.0)
        evec.append(e)
    if evec[0] < -15.0: use = True
        
    hist_vec.append(evec[0])
        
    if not use: continue
    
    partner = False
    for j in range(len(inet)):
        if shortname in inet[j]:
        partner = True
        print labels[j] + ',',
    if partner: print 'partner'
    #else: continue
    print namex
    print shortname
    print seq
    for x in range(len(mode_vec)):
        print labels[x], evec[x]
    print
        ##
    ##print mean(evec), std(evec)
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    

    pylab.hist(pylab.array(hist_vec), normed=False, facecolor='white', edgecolor='black', lw=2)
    ##pylab.xlim(-40.0, 80.0)
    ##pylab.ylim(0, 200)
    
    pylab.savefig('/home/bartolo/web/CC/MYC2/fullmyc/myc_hist.png')
    
def MYC_search():
  
    myci = []
    data = lines2list('/home/bartolo/web/biogrid/MYC_interactors.txt')
    for i in range(len(data)): myci.append(data[i][0])
    maxi = []
    data = lines2list('/home/bartolo/web/biogrid/MAX_interactors.txt')
    for i in range(len(data)): maxi.append(data[i][0])
    madi = []
    data = lines2list('/home/bartolo/web/biogrid/MAD_interactors.txt')
    for i in range(len(data)): madi.append(data[i][0])
    network_dicts = network_dictionaries()
  
    genome_data = lines2list('/home/bartolo/web/CC/MYC2/MycMax_seq.txt')
    names_data = readlines('/home/bartolo/web/CC/MYC2/MycMax_names.txt')
    
    max_wt = 'RAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRAL'
    mad_wt = 'TLSLLTKAKLHIKKLEDCDRKAVHQIDQLQREQRHLKRQLEKL'
    myc_wt = 'KVVILKKATAYILSVQAEEQKLISEEDLLRKRREQLKHKLEQL'
    
    
    myc ='KVVILKKATAYILSVQAEEQKLISEEDLLRKRREQLKHKLEQL'
    nmyc='KVVILKKATEYVHSLQAEEHQLLLEKEKLQARQQQLLKKIEHA'
    lmyc='KVVILSKALEYLQALVGAEKRMATEKRQLRCRQQQLQKRIAYL'
    max_seq = 'RAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRAL'
    mad3='TLSLLRRARMHIQKLEDQEQRARQLKERLRSKQQSLQRQLEQL'
    mxi1='TLGLLNKAKAHIKKLEEAERKSQHQLENLEREQRFLKWRLEQL'
    mad4='TLSLLKRAKVHIKKLEEQDRRALSIKEQLQQEHRFLKRRLEQL'
    mad ='TLSLLTKAKLHIKKLEDCDRKAVHQIDQLQREQRHLKRQLEKL'
    mnt ='NLSVLRTALRYIQSLKRKEKEYEHEMERLAREKIATQQRLAEL'
    mga ='KSLILTRAFSEIQGLTDQADKLIGQKNLLTRKRNILIRKVSSL'
    mlx ='KAIVLQKTIDYIQFLHKEKKKQEEEVSTLRKDVTALKIMKVNY'
    mond='HAITLQKTVEYITKLQQERGQMQEEARRLREEIEELNATIISC'
    mxp1='KATTLQKTAEYILMLQQERAGLQEEAQQLRDEIEELNAAINLC'

    myc_mode = load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/myc_1nkp')
    max_mode = load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/max_1nkp')
    mad_mode = load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/mad_1nkp')

    seqs_v = [myc, nmyc, lmyc, max_seq, mad3, mxi1, mad4, mad, mnt, mga, mlx, mond, mxp1]
    names = ['c-Myc', 'N-Myc', 'L-Myc', 'Max', 'Mad3', 'Mxi1', 'Mad4', 'Mad1', 'Mnt', 'Mga', 'Mlx', 'MondoA', 'WBSCR14']
    for i in range(len(seqs_v)):
        seq = seqs_v[i]
        print names[i],
        #print round((statium_energy_calc_sidechain(myc_mode, seq, 0.0) - 9.18666668867) / 10.6546058449, 1),
        #print round((statium_energy_calc_sidechain(max_mode, seq, 0.0) - 7.98837104535) / 8.90274319346, 1),
        #print round((statium_energy_calc_sidechain(mad_mode, seq, 0.0) - 4.90271814709) / 8.92328366074, 1)

        print round(statium_energy_calc_sidechain(myc_mode, seq, 0.0), 1),
        print round(statium_energy_calc_sidechain(max_mode, seq, 0.0), 1),
        print round(statium_energy_calc_sidechain(mad_mode, seq, 0.0), 1)
    
    #return
    evec = []
    part = []
    tot = []
    total = 0
    for i in range(len(genome_data)):
        seq = genome_data[i][0]
        try:
            e_myc = statium_energy_calc_sidechain(myc_mode, seq, 0.0)
            e_max = statium_energy_calc_sidechain(max_mode, seq, 0.0)
            e_mad = statium_energy_calc_sidechain(mad_mode, seq, 0.0)
        except: continue
        
        name = names_data[i].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
    
    ls_dict = network_dicts[1]
    try: shortname = ls_dict[namex]
    except: shortname = '??'
    
    myc_partner = False
    if shortname in myci: myc_partner = True
    max_partner = False
    if shortname in maxi: max_partner = True
    mad_partner = False
    if shortname in madi: mad_partner = True
        
        #if 'eratin' in name: continue
        #if 'yosin' in name: continue
        #if 'inesin' in name: continue
        evec.append(e_mad)
        #if e_myc > -5.0 and e_max > -5.0 and e_mad > -5.0: continue
        #if not myc_partner and not max_partner and not mad_partner: continue
        #print namex
    #print shortname
    #print seq
    #print e_myc, e_max, e_mad
    #if myc_partner: print 'myc_partner'
    #if max_partner: print 'max_partner'
    #if mad_partner: print 'mad_partner'
    #print
    #print mean(evec), std(evec)
    #import matplotlib
    #matplotlib.use( 'Agg' )
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '16'
    #pylab.rcParams['ytick.labelsize'] = '16'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.rcParams['xtick.major.pad']='12'
    #pylab.rcParams['ytick.major.pad']='12'
    #pylab.rcParams['axes.linewidth'] = 3.0
    #fig = pylab.figure()    # Create a figure
    #ax = fig.gca()
    #for tick in ax.xaxis.get_major_ticks():
    #tick.label1.set_fontsize('15')
    #tick.label1.set_fontweight('bold')
    #for tick in ax.yaxis.get_major_ticks():
    #tick.label1.set_fontsize('15')
    #tick.label1.set_fontweight('bold')
    

    #pylab.hist(pylab.array(evec), normed=False, facecolor='white', edgecolor='black', lw=2)
    ##pylab.xlim(-40.0, 80.0)
    #pylab.ylim(0, 200)
    
    ##pylab.savefig('/home/bartolo/web/CC/MYC2/mad_hist.png')

def bcl2_sidechain():
  
    SPOT_vec = PSSM5()
  
    ndata = lines2list('/home/bartolo/web/statium/BH3_natural.txt')
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    jmb_xspec_data = lines2list('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_data = lines2list('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')
    genome_data = lines2list('/home/bartolo/web/statium_sidechain/bcl2_expand_seq_removeU.txt')
    #genome_data = lines2list('/home/bartolo/web/statium_sidechain_wGly/random_seq.txt')
    #yeast_full_data = lines2list('/home/bartolo/web/statium/data/yeast_full_lib.txt')
    #expressing_data = lines2list('/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt')

    #mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    #xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    #fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    #bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    #wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/mcl1/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bfl1/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bcl2/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclw/bclwmock')

    #mintra = load_intralocal_energy('/home/bartolo/web/statium_intrapep/mcl1/mcl1_3pk1')
    #xintra = load_intralocal_energy('/home/bartolo/web/statium_intrapep/bclxl/bclxl_3io8')
    #fintra = load_intralocal_energy('/home/bartolo/web/statium_intrapep/bfl1/bfl1_3mqp')
    #bintra = load_intralocal_energy('/home/bartolo/web/statium_intrapep/bcl2/bcl2')
    #wintra = load_intralocal_energy('/home/bartolo/web/statium_intrapep/bclw/bclwmock')

    mlocal = load_intralocal_energy('/home/bartolo/web/statium_local/mcl1/mcl1_3pk1')
    xlocal = load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3io8')
    flocal = load_intralocal_energy('/home/bartolo/web/statium_local/bfl1/bfl1_3mqp')
    blocal = load_intralocal_energy('/home/bartolo/web/statium_local/bcl2/bcl2')
    wlocal = load_intralocal_energy('/home/bartolo/web/statium_local/bclw/bclwmock')
    
    #hmode = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2XPX')
    #hmode2 = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2wh6')
    
    #morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    #xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    #worig = load_design_energy('/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3')
    #borig = load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2')
    #forig = load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp')
    
    #M_consmat = load_BH3_conserve_matrix('/home/bartolo/web/statium/all_array_analysis/known_binder_align_M.txt')
    #X_consmat = load_BH3_conserve_matrix('/home/bartolo/web/statium/all_array_analysis/known_binder_align_X.txt')
    
    #statium_energy_calc(xorig, seq, 0.0)

    zstd = [10.5046784969, 9.06295607193]
    zmean = [14.0549828438, 11.1706832649]

    #zstdp = [0.957525719117, 0.917711243381]
    #zmeanp = [4.48911224819, 3.07924842616]
    
    zstdp = [0.957525719117, 0.917711243381]
    zmeanp = [3.98243723171, 4.41547882232]
    
    zstdo = [7.82148011783, 8.42545057961]
    zmeano = [8.88202577979, 3.59344777264]
    
    zstdo_aff = [63.5242791301, 69.6244743843]
    zmeano_aff = [68.2460060157, 67.0483148038]

    zstd_cons = [1.08475303172, 1.20537614547]
    zmean_cons = [5.71152314753, 5.76638548017]

    random_intra_std = [7.70418151726, 5.78059263536, 7.46677253025, 7.81020285631, 7.72966275527]
    random_intra_mean = [-0.875225387163, -0.265750773926, 0.153171943343, -0.581716946878, -1.13145962804]

    random_local_std = [13.3321143776, 13.8552823075, 12.967359847, 12.9864209855, 12.7714219754]
    random_local_mean = [14.1516635011, 13.989978382, 13.4963068281, 13.5211368461, 12.9356205207]

    random_std = [11.4538210035, 7.84819464972, 11.0237445007, 11.3281197603, 9.35560384474]
    random_mean = [19.4989417646, 13.4309300271, 18.0077220911, 17.8041220898, 15.8442499168]

    #statium_pos_sidechain(fmode)
    #return
    puma = 'WAREIGAQLRRMADDLNAQYERR'
    pssm_puma = pssm_energy10(SPOT_vec, puma)
    x_puma  = pssm_puma[0]
    m_puma  = pssm_puma[1]
    
    #print (1.9 - zmeanp[0]) / zstdp[0]
    #print (2.4 - zmeanp[1]) / zstdp[1]
  
    for i in range(len(ndata)):
        seq = ndata[i][0]
        name = ndata[i][1]
        ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
    ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
    #eh = statium_energy_calc_sidechain(hmode, seq, 0.0)

    #exi = statium_energy_calc_intralocal(xintra, seq, 0.0, 'intra')
    #ebi = statium_energy_calc_intralocal(bintra, seq, 0.0, 'intra')
    #emi = statium_energy_calc_intralocal(mintra, seq, 0.0, 'intra')
    #efi = statium_energy_calc_intralocal(fintra, seq, 0.0, 'intra')
    #ewi = statium_energy_calc_intralocal(wintra, seq, 0.0, 'intra')

    exl = statium_energy_calc_intralocal(xlocal, seq, 0.0, 'local')
    ebl = statium_energy_calc_intralocal(blocal, seq, 0.0, 'local')
    eml = statium_energy_calc_intralocal(mlocal, seq, 0.0, 'local')
    efl = statium_energy_calc_intralocal(flocal, seq, 0.0, 'local')
    ewl = statium_energy_calc_intralocal(wlocal, seq, 0.0, 'local')

    #eh2 = statium_energy_calc_sidechain(hmode2, seq, 0.0)
          #exo = statium_energy_calc(xorig, seq, 0.0)
    #emo = statium_energy_calc(morig, seq, 0.0)
    #ewo = statium_energy_calc(worig, seq, 0.0)
    #efo = statium_energy_calc(forig, seq, 0.0)
    #ebo = statium_energy_calc(borig, seq, 0.0)
          #exo_aff = statium_energy_calc(xorig, seq, 5.0)
    #emo_aff = statium_energy_calc(morig, seq, 5.0)
    energy_pssm = pssm_energy10(SPOT_vec, seq)
    zx = (ex - zmean[0]) / zstd[0]
    zm = (em - zmean[1]) / zstd[1]
    #zxo = (exo - zmeano[0]) / zstdo[0]
    #zmo = (emo - zmeano[1]) / zstdo[1]
    
    #X_cons = BH3_conserve_score(X_consmat, seq)
    #M_cons = BH3_conserve_score(M_consmat, seq)

    #zconsX = (X_cons - zmean_cons[0]) / zstd_cons[0]
    #zconsM = (M_cons - zmean_cons[1]) / zstd_cons[1]

    #zxo_aff = (exo_aff - zmeano_aff[0]) / zstdo_aff[0]
    #zmo_aff = (emo_aff - zmeano_aff[1]) / zstdo_aff[1]
    px = energy_pssm[0]
    pm = energy_pssm[1]
    pf = energy_pssm[3]
    pw = energy_pssm[2]
    pb = energy_pssm[4]
    zpx = (energy_pssm[0] - zmeanp[0]) / zstdp[0]
    zpm = (energy_pssm[1] - zmeanp[1]) / zstdp[1]
    combx = zx + zpx
    combm = zm + zpm

    zx = (ex - random_mean[0]) / random_std[0]
    zm = (em - random_mean[1]) / random_std[1]
    zw = (ew - random_mean[2]) / random_std[2]
    zb = (eb - random_mean[3]) / random_std[3]
    zf = (ef - random_mean[4]) / random_std[4]

    #zxi = (exi - random_intra_mean[0]) / random_intra_std[0]
    #zmi = (emi - random_intra_mean[1]) / random_intra_std[1]
    #zwi = (ewi - random_intra_mean[2]) / random_intra_std[2]
    #zbi = (ebi - random_intra_mean[3]) / random_intra_std[3]
    #zfi = (efi - random_intra_mean[4]) / random_intra_std[4]

    zxl = (exl - random_local_mean[0]) / random_local_std[0]
    zml = (eml - random_local_mean[1]) / random_local_std[1]
    zwl = (ewl - random_local_mean[2]) / random_local_std[2]
    zbl = (ebl - random_local_mean[3]) / random_local_std[3]
    zfl = (efl - random_local_mean[4]) / random_local_std[4]
    #print seq + '\t' + name + '\t' + str(((zx + zpx) / 2.0) - ((zm + zpm) / 2.0)) + '\t' + str((zx)- (zm)) + '\t' + str((zpx)-(zpm))
    #print name, str(round(exo - emo, 2)) + '\t' + str(round(ex - em, 2)) + '\t' + str(round(px - pm, 2)) + '\t' + str(round(zxo - zmo, 2)) + '\t' + str(round(zx - zm, 2)) + '\t' + str(round(zpx - zpm, 2)) + '\t' + str(round(zx + zpx - zm - zpm, 2)) + '\t' + str(round(zxo + zpx - zmo - zpm, 2)) + '\t' + str(round(zx + zxo - zm - zmo, 2)) + '\t' + str(round(zx + zxo + zpx - zm - zmo - zpm, 2))
    #print seq + '\t' + name + '\t' + str(energy_pssm[0]) + '\t' + str(energy_pssm[1])
#    print seq + '\t' + name + '\t' + str(combm - combx) + '\t' + str(em - ex) + '\t' + str(energy_pssm[1] - energy_pssm[0])
    #print seq + '\t' + name + '\t' + str(exo + ex) + '\t' + str(emo + em)
    #print seq + '\t' + name + '\t' + str(px) + '\t' + str(pm) + '\t' + str(zx) + '\t' + str(zm)
    #print seq + '\t' + name + '\t' + str(px) + '\t' + str(pm) + '\t' + str(pf)
    #print seq + '\t' + name + '\t' + str(zconsX) + '\t' + str(zconsM)


    print name + '\t' + seq + '\t' + str(round(zm, 2))  + '\t' + str(round(zml, 2))
    #print str(round(zx, 2))  + '\t' + str(round(zm, 2)) + '\t' + str(round(zw, 2)) + '\t' + str(round(zb, 2)) + '\t' + str(round(zf, 2))
    #print str(round(zxi, 2))  + '\t' + str(round(zmi, 2)) + '\t' + str(round(zwi, 2)) + '\t' + str(round(zbi, 2)) + '\t' + str(round(zfi, 2))
    #print str(round(zxl, 2)) + '\t' + str(round(zml, 2)) + '\t' + str(round(zwl, 2)) + '\t' + str(round(zbl, 2)) + '\t' + str(round(zfl, 2))
    return
    
    #yeast_fullx = []
    #yeast_fullm = []
    #for i in range(len(expressing_data)):
        #seq = expressing_data[i][0]
        #yeast_fullx.append(statium_energy_calc_sidechain(xmode, seq, 0.0))
        #yeast_fullm.append(statium_energy_calc_sidechain(mmode, seq, 0.0))
        
    #yeast_fullx = statium_evec(xorig, '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt', 0.0)
    #yeast_fullm = statium_evec(morig, '/home/bartolo/web/statium/deepseq/nonredundant/allowed/expressing.txt', 0.0)
        
    #x2sort = []
    #m2sort = []
    #xm2sort = []
    #mx2sort = []
    #for i in range(len(yeast_fullx)):
        #seq = expressing_data[i][0]
        #xm2sort.append([yeast_fullx[i], yeast_fullm[i], seq])
        #mx2sort.append([yeast_fullm[i], yeast_fullx[i], seq])
        #x2sort.append(yeast_fullx[i])
        #m2sort.append(yeast_fullm[i])
        
    #x2sort.sort()
    #m2sort.sort()
    #mx2sort.sort()
    #xm2sort.sort()
        
    #xspec_pred = []
    #mspec_pred = []
    #L = len(yeast_fullx)
    #for i in range(L):
        #if i % 10000 == 0: print i
        #percentile = float(i + 1) / float(L)
        #if percentile > 0.0005: break
        #mpercentile = float(m2sort.index(xm2sort[i][1])) / float(L)
        #xpercentile = float(x2sort.index(mx2sort[i][1])) / float(L)
        
        #xspec_pred.append(xm2sort[i][2])
        #mspec_pred.append(mx2sort[i][2])
        #continue
    
        #if mpercentile > 0.35: xspec_pred.append(xm2sort[i][2])
        #if xpercentile > 0.35: mspec_pred.append(mx2sort[i][2])
    #xf = open('/home/bartolo/web/statium_sidechain/figures/xspec_pred_expressing_orig.txt', 'w')
    #for i in range(len(xspec_pred)): xf.write(str(xspec_pred[i]) + '\n')
    #xf.close()
    #mf = open('/home/bartolo/web/statium_sidechain/figures/mspec_pred_expressing_orig.txt', 'w')
    #for i in range(len(mspec_pred)): mf.write(str(mspec_pred[i]) + '\n')
    #mf.close()
    
    #xm_360spec = [[], []]
    #for i in range(len(SPOT360)):
        #seq = SPOT360[i][0]
        #xsig = SPOT360[i][2]
        #msig = SPOT360[i][3]
        #if xsig < 0.5 or msig < 0.5:
        #xm_360spec[0].append(xsig - msig)
        #ex = statium_energy_calc_sidechain(xmode, seq, 0.0) + 10 * statium_energy_calc(xorig, seq, 0.0)
        #em = statium_energy_calc_sidechain(mmode, seq, 0.0) + 10 * statium_energy_calc(morig, seq, 0.0)
        #xm_360spec[1].append(ex - em)
    
    #import pylab
    #print pylab.corrcoef(pylab.array(xm_360spec[0]), pylab.array(xm_360spec[1]))[0][1]   

    #ofile = open('/home/bartolo/web/statium/all_array_analysis/all_seq_XMenergies.txt', 'w')

    xgenome = []
    mgenome = []
    wgenome = []
    bgenome = []
    fgenome = []
    for i in range(len(genome_data)):
    if i > 0 and i % 5000 == 0:
            print '[' + str(std(xgenome)) + ', ' + str(std(mgenome)) + ', ' + str(std(wgenome)) + ', ' + str(std(bgenome)) + ', ' + str(std(fgenome)) + ']'
            print '[' + str(mean(xgenome)) + ', ' + str(mean(mgenome)) + ', ' + str(mean(wgenome)) + ', ' + str(mean(bgenome)) + ', ' + str(mean(fgenome)) + ']'
        seq = genome_data[i][0]
        #energy_pssm = pssm_energy10(SPOT_vec, seq)
        #ex = energy_pssm[0]
        #em = energy_pssm[1]
        #ef = energy_pssm[3]
        #ew = energy_pssm[2]
        #eb = energy_pssm[4]
        try: ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        except: ex = 0.0
        try: em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        except: em = 0.0
        try: ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
        except: ew = 0.0
        try: eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
        except: eb = 0.0
        try: ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
        except: ef = 0.0

    #X_cons = BH3_conserve_score(X_consmat, seq)
    #M_cons = BH3_conserve_score(M_consmat, seq)
        
        #if ex > 0.65: print seq
    #zx = (ex - zmean[0]) / zstd[0]
    #zm = (em - zmean[1]) / zstd[1]
    #px = energy_pssm[0]
    #pm = energy_pssm[1]
    #if (px < 0.9 and zx < -2.5) or (pm < 1.4 and zm < -2.5): print seq
        xgenome.append(ex)
        mgenome.append(em)
    wgenome.append(ew)
    bgenome.append(eb)
    fgenome.append(ef)
        
        #ofile.write(seq + '\t' + str(ex) + '\t' + str(em) + '\n')
        
    #ofile.close()
    #return  
    #ofile = open('/home/bartolo/web/statium/all_array_analysis/X_energies_orig.txt', 'w')
    #for i in range(len(xgenome)): ofile.write(str(xgenome[i]) + '\n')
    #ofile.close()
    
    #ofile = open('/home/bartolo/web/statium/all_array_analysis/M_energies_orig.txt', 'w')
    #for i in range(len(mgenome)): ofile.write(str(mgenome[i]) + '\n')
    #ofile.close()

        
    import pylab
    xarray = pylab.array(xgenome)
    marray = pylab.array(mgenome)
    warray = pylab.array(wgenome)
    barray = pylab.array(bgenome)
    farray = pylab.array(fgenome)
    
    print '[' + str(std(xarray)) + ', ' + str(std(marray)) + ', ' + str(std(warray)) + ', ' + str(std(barray)) + ', ' + str(std(farray)) + ']'
    print '[' + str(mean(xarray)) + ', ' + str(mean(marray)) + ', ' + str(mean(warray)) + ', ' + str(mean(barray)) + ', ' + str(mean(farray)) + ']'
    
    return
        
    #jmb_xspec = []
    #for i in range(len(jmb_xspec_data)):
        #seq = jmb_xspec_data[i][0]
        #jmb_xspec.append(statium_energy_calc(xorig, seq, 0.0) - statium_energy_calc(morig, seq, 0.0))
        
    #jmb_mspec = []
    #for i in range(len(jmb_mspec_data)):
        #seq = jmb_mspec_data[i][0]
        #jmb_mspec.append(statium_energy_calc(xorig, seq, 0.0) - statium_energy_calc(morig, seq, 0.0))

    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(jmb_xspec), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.hist(pylab.array(jmb_mspec), normed=False, facecolor='white', edgecolor='red', lw=2, alpha=0.8)
    #pylab.ylim(0, 12)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium_sidechain/figures/jmb_yeast_spec_orig.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(xgenome), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium_sidechain/figures/fgenome.png')
    ##pylab.xticks([])
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.hist(pylab.array(mgenome), normed=False, facecolor='white', edgecolor='blue', lw=2, alpha=0.8)
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium_sidechain/figures/bgenome.png')
    ##pylab.xticks([])
    #pylab.close()
    
    #import pylab
    #pylab.rcParams['xtick.labelsize'] = '14'
    #pylab.rcParams['ytick.labelsize'] = '14'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.scatter(pylab.array(xm_360spec[1]), pylab.array(xm_360spec[0]), c='k', marker='o', s=10, facecolor='none', edgecolors='k')
    #pylab.yticks([])
    #pylab.savefig('/home/bartolo/web/statium_sidechain/figures/SPOT360_spec.png')
    ##pylab.yticks([])
    ##pylab.xticks([])
    #pylab.close()
    
def flat_list(p):
  
    data = lines2list(p)
    mem = []
    for i in range(len(data[0])): mem.append([])
    for i in range(len(data)):
        for j in range(len(data[i])):
        mem[j].append(data[i][j])
    return mem
    
def plot_genome_enrich():
  
    f1 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/all.txt')
    f2 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/sc_stat.txt')
    f3 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/sc_p.txt')
    f4 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/stat_p.txt')
    f5 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/stat.txt')
    f6 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/p.txt')
    f7 = flat_list('/home/bartolo/web/statium/all_array_analysis/ENRICH/sc.txt')
    
    dvec = [f1, f2, f3, f4, f5, f6, f7]

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    
    color_vec = ['blue', 'red', 'green', 'purple', 'yellow', 'magenta', 'cyan', 'orange']
    for i in range(len(dvec)):
        x = dvec[i][0]
        for k in range(len(x)): x[k] = x[k] * -1.0
        pylab.plot(x, dvec[i][1], lw=2, color=color_vec[i])
    #pylab.plot([0.0, 0.5, 1.0], [0.0, 0.5, 1.0], '--', lw=2, color='black')
    #pylab.legend(loc='lower right')

    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/ENRICH/enrich.png')

def plot_genome_roc():
  
    f1 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/all.txt')
    f2 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/both_stat.txt')
    f3 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/both_sc_p.txt')
    f4 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/both_stat_p.txt')
    f5 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/stat.txt')
    f6 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/p.txt')
    f7 = flat_list('/home/bartolo/web/statium/all_array_analysis/ROC/X/sc.txt')
    
    dvec = [f1, f2, f3, f4, f5, f6, f7]

    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    
    color_vec = ['blue', 'red', 'green', 'purple', 'yellow', 'magenta', 'cyan', 'orange']
    for i in range(len(dvec)):
        pylab.plot(dvec[i][0], dvec[i][1], lw=2, color=color_vec[i])
    pylab.plot([0.0, 0.5, 1.0], [0.0, 0.5, 1.0], '--', lw=2, color='black')
    #pylab.legend(loc='lower right')

    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/ROC/X_roc.png')
    
def genome_hit_corr(func):

    import pylab

    rvec = ['bclxl', 'mcl1', 'bclw', 'bcl2', 'bfl1']
    Edict = dict([['z', 'STATIUMsc'], ['zp', 'PSSMspot'], ['zo', 'STATIUM'], ['zoa', 'STATIUM'], ['zl', 'STATlocal']])
    func_lname = ''
    items = func.split('_')
    for item in items: func_lname += Edict[item] + ' + '
    func_lname = func_lname[0:len(func_lname)-3]

    xbind = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'AAQRYGRELRRMSDEFVDSFKKG', 'STKKLSECLKRIGDELDSNMELQ', 'GSDALALRLACIGDEMDVSLRAP', 'IIRNIARHLAQVGDSMDRSIPPG', 'AEVQIARKLQCIADQFHRLHVQQ', 'TMENLSRRLKVTGDLFDIMSGQT', 'AEVQIARKLQCIADQFHRLHVQQ']
    mbind = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'LEVECATQLRRFGDKLNFRQKLL', 'IIRNIARHLAQVGDSMDRSIPPG', 'AEVQIARKLQCIADQFHRLHVQQ', 'MTQEVGQLLQDMGDDVYQQYRSL', 'RLAEVCAVLLRLGDELEMIRPSV']
    wbind = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'AAQRYGRELRRMSDEFVDSFKKG', 'STKKLSECLKRIGDELDSNMELQ', 'GSDALALRLACIGDEMDVSLRAP', 'IIRNIARHLAQVGDSMDRSIPPG', 'AEVQIARKLQCIADQFHRLHVQQ']
    fbind = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'IIRNIARHLAQVGDSMDRSIPPG']
    bbind = ['WAREIGAQLRRMADDLNAQYERR', 'PEIWIAQELRRIGDEFNAYYARR', 'AAQRYGRELRRMSDEFVDSFKKG', 'STKKLSECLKRIGDELDSNMELQ', 'IIRNIARHLAQVGDSMDRSIPPG', 'AEVQIARKLQCIADQFHRLHVQQ']

    natvec = [xbind, mbind, wbind, bbind, fbind]

    zstd = [12.5964280762, 9.59343423497, 11.751603669, 11.8554232701, 10.1877121464]
    zmean = [19.1906407971, 14.274283119, 20.6483026992, 22.0019210125, 17.3106609485]

    zstdp = [0.957525719117, 0.917711243381, 0.518798747972, 0.948616660627, 0.635063414077]
    zmeanp = [3.98243723171, 4.41547882232, 1.69542278603, 2.94382294585, 2.62386345361]
 
    zstdo = [7.82148011783, 8.42545057961, 7.8113492244, 8.06076907477, 9.56253284139]
    zmeano = [8.88202577979, 3.59344777264, 16.9838604234, 13.6195053537, 12.9646255606]   
 
    zstdo_aff = [63.5242791301, 69.6244743843, 47.2824198646, 62.6257663696, 64.9647511437]
    zmeano_aff = [68.2460060157, 67.0483148038, 64.3481389591, 78.5934248038, 72.6519383473]

    random_local_std = [13.3321143776, 13.8552823075, 12.967359847, 12.9864209855, 12.7714219754]
    random_local_mean = [14.1516635011, 13.989978382, 13.4963068281, 13.5211368461, 12.9356205207]

    random_std = [11.4538210035, 7.84819464972, 11.0237445007, 11.3281197603, 9.35560384474]
    random_mean = [19.4989417646, 13.4309300271, 18.0077220911, 17.8041220898, 15.8442499168]

    natlist = lines2list('/home/bartolo/web/statium/all_array_analysis/binder_align_23mer.txt')
    natseq = []
    natname = []
    for i in range(len(natlist)):
    natseq.append(natlist[i][0])
    natname.append(natlist[i][1])
    
    SPOT_vec = PSSM5()
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/prediction/all5_binding_XMspec.txt')
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclwGA/bclwmock')

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/mcl1/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bfl1/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bcl2/bcl2')
    wmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclw/bclwmock')

    mlocal = load_intralocal_energy('/home/bartolo/web/statium_local/mcl1/mcl1_3pk1')
    xlocal = load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3io8')
    flocal = load_intralocal_energy('/home/bartolo/web/statium_local/bfl1/bfl1_3mqp')
    blocal = load_intralocal_energy('/home/bartolo/web/statium_local/bcl2/bcl2')
    wlocal = load_intralocal_energy('/home/bartolo/web/statium_local/bclw/bclwmock')

    
    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    worig = load_design_energy('/home/bartolo/web/statium_noref/bclw2/bclw_1ZY3')
    borig = load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2')
    forig = load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp')

    for i in range(len(natseq)):
    continue
    seq = natseq[i]
    name = natname[i]
        energy_pssm = pssm_energy10(SPOT_vec, seq)

        px = energy_pssm[0]
        pm = energy_pssm[1]
        pf = energy_pssm[3]
        pw = energy_pssm[2]
        pb = energy_pssm[4]
        exo_aff = statium_energy_calc(xorig, seq, 5.0)
    emo_aff = statium_energy_calc(morig, seq, 5.0)
        ewo_aff = statium_energy_calc(worig, seq, 5.0)
        ebo_aff = statium_energy_calc(borig, seq, 5.0)
        efo_aff = statium_energy_calc(forig, seq, 5.0)

        exo = statium_energy_calc(xorig, seq, 0.0)
        emo = statium_energy_calc(morig, seq, 0.0)
        ewo = statium_energy_calc(worig, seq, 0.0)
        ebo = statium_energy_calc(borig, seq, 0.0)
        efo = statium_energy_calc(forig, seq, 0.0)

        ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
    eb = statium_energy_calc_sidechain(fmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(bmode, seq, 0.0)

    zx = (ex - zmean[0]) / zstd[0]
    zm = (em - zmean[1]) / zstd[1]
        zw = (ew - zmean[2]) / zstd[2]
        zb = (eb - zmean[3]) / zstd[3]
        zf = (ef - zmean[4]) / zstd[4]

        zxo = (exo - zmeano[0]) / zstdo[0]
        zmo = (emo - zmeano[1]) / zstdo[1]
        zwo = (ewo - zmeano[2]) / zstdo[2]
        zbo = (ebo - zmeano[3]) / zstdo[3]
        zfo = (efo - zmeano[4]) / zstdo[4]

        zxo_aff = (exo_aff - zmeano_aff[0]) / zstdo_aff[0]
        zmo_aff = (emo_aff - zmeano_aff[1]) / zstdo_aff[1]
        zwo_aff = (ewo_aff - zmeano_aff[2]) / zstdo_aff[2]
        zbo_aff = (ebo_aff - zmeano_aff[3]) / zstdo_aff[3]
        zfo_aff = (efo_aff - zmeano_aff[4]) / zstdo_aff[4]

        zpx = (px - zmeanp[0]) / zstdp[0]
        zpm = (pm - zmeanp[1]) / zstdp[1]
        zpw = (pw - zmeanp[2]) / zstdp[2]
        zpb = (pb - zmeanp[3]) / zstdp[3]
        zpf = (pf - zmeanp[4]) / zstdp[4]

        print name, seq, zxo, zwo, zbo, zmo, zfo

    for i in range(len(natvec)):
    continue
    print rvec[i], 'STATIUM', 'STATIUMSC' 
    for j in range(len(natvec[i])):

        seq = natvec[i][j]
            exo_aff = statium_energy_calc(xorig, seq, 5.0)
        emo_aff = statium_energy_calc(morig, seq, 5.0)
            ewo_aff = statium_energy_calc(worig, seq, 5.0)
            ebo_aff = statium_energy_calc(borig, seq, 5.0)
            efo_aff = statium_energy_calc(forig, seq, 5.0)

            exo = statium_energy_calc(xorig, seq, 0.0)
            emo = statium_energy_calc(morig, seq, 0.0)
            ewo = statium_energy_calc(worig, seq, 0.0)
            ebo = statium_energy_calc(borig, seq, 0.0)
            efo = statium_energy_calc(forig, seq, 0.0)

            ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
        eb = statium_energy_calc_sidechain(fmode, seq, 0.0)
        ef = statium_energy_calc_sidechain(bmode, seq, 0.0)

        zx = (ex - zmean[0]) / zstd[0]
        zm = (em - zmean[1]) / zstd[1]
            zw = (ew - zmean[2]) / zstd[2]
            zb = (eb - zmean[3]) / zstd[3]
            zf = (ef - zmean[4]) / zstd[4]

            zxo = (exo - zmeano[0]) / zstdo[0]
            zmo = (emo - zmeano[1]) / zstdo[1]
            zwo = (ewo - zmeano[2]) / zstdo[2]
            zbo = (ebo - zmeano[3]) / zstdo[3]
            zfo = (efo - zmeano[4]) / zstdo[4]

            zxo_aff = (exo_aff - zmeano_aff[0]) / zstdo_aff[0]
            zmo_aff = (emo_aff - zmeano_aff[1]) / zstdo_aff[1]
            zwo_aff = (ewo_aff - zmeano_aff[2]) / zstdo_aff[2]
            zbo_aff = (ebo_aff - zmeano_aff[3]) / zstdo_aff[3]
            zfo_aff = (efo_aff - zmeano_aff[4]) / zstdo_aff[4]

          z_vec = [zx, zm, zw, zb, zf]
        zo_vec = [zxo, zmo, zwo, zbo, zfo]
        zoa_vec = [zxo_aff, zmo_aff, zwo_aff, zbo_aff, zfo_aff]

        print seq, zoa_vec[i], z_vec[i]
        print

    annotes = [[[], []], [[], []], [[], []], [[], []], [[], []]]
    bindt = 5000.0
    bind = 0
    for i in range(len(data)):
        #if i >= 48: continue
        seq = data[i][1]
    kd_vec = []
    for k in range(2):
        item = str(data[i][k + 2])
        if item.find(',') > -1: kd = math.log10(float(item.split(',')[0]))
        elif item[0] == '>': kd = float(item[-1])
        elif item[0] == 'X': kd = 6.0
        annotes[k][1].append(kd)

        energy_pssm = pssm_energy10(SPOT_vec, seq)

        px = energy_pssm[0]
        pm = energy_pssm[1]
        pf = energy_pssm[3]
        pw = energy_pssm[2]
        pb = energy_pssm[4]
    
        exo_aff = statium_energy_calc(xorig, seq, 5.0)
    emo_aff = statium_energy_calc(morig, seq, 5.0)
        ewo_aff = statium_energy_calc(worig, seq, 5.0)
        ebo_aff = statium_energy_calc(borig, seq, 5.0)
        efo_aff = statium_energy_calc(forig, seq, 5.0)

        exo = statium_energy_calc(xorig, seq, 0.0)
        emo = statium_energy_calc(morig, seq, 0.0)
        ewo = statium_energy_calc(worig, seq, 0.0)
        ebo = statium_energy_calc(borig, seq, 0.0)
        efo = statium_energy_calc(forig, seq, 0.0)

        ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ew = statium_energy_calc_sidechain(wmode, seq, 0.0)
    eb = statium_energy_calc_sidechain(fmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(bmode, seq, 0.0)

        exl = statium_energy_calc_intralocal(xlocal, seq, 0.0, 'local')
    eml = statium_energy_calc_intralocal(mlocal, seq, 0.0, 'local')
    ewl = statium_energy_calc_intralocal(wlocal, seq, 0.0, 'local')
    ebl = statium_energy_calc_intralocal(flocal, seq, 0.0, 'local')
    efl = statium_energy_calc_intralocal(blocal, seq, 0.0, 'local')

    zx = (ex - zmean[0]) / zstd[0]
    zm = (em - zmean[1]) / zstd[1]
        zw = (ew - zmean[2]) / zstd[2]
        zb = (eb - zmean[3]) / zstd[3]
        zf = (ef - zmean[4]) / zstd[4]

    zx = (ex - random_mean[0]) / random_std[0]
    zm = (em - random_mean[1]) / random_std[1]
        zw = (ew - random_mean[2]) / random_std[2]
        zb = (eb - random_mean[3]) / random_std[3]
        zf = (ef - random_mean[4]) / random_std[4]

    zxl = (exl - random_local_mean[0]) / random_local_std[0]
    zml = (eml - random_local_mean[1]) / random_local_std[1]
        zwl = (ewl - random_local_mean[2]) / random_local_std[2]
        zbl = (ebl - random_local_mean[3]) / random_local_std[3]
        zfl = (efl - random_local_mean[4]) / random_local_std[4]

        zxo = (exo - zmeano[0]) / zstdo[0]
        zmo = (emo - zmeano[1]) / zstdo[1]
        zwo = (ewo - zmeano[2]) / zstdo[2]
        zbo = (ebo - zmeano[3]) / zstdo[3]
        zfo = (efo - zmeano[4]) / zstdo[4]

        zxo_aff = (exo_aff - zmeano_aff[0]) / zstdo_aff[0]
        zmo_aff = (emo_aff - zmeano_aff[1]) / zstdo_aff[1]
        zwo_aff = (ewo_aff - zmeano_aff[2]) / zstdo_aff[2]
        zbo_aff = (ebo_aff - zmeano_aff[3]) / zstdo_aff[3]
        zfo_aff = (efo_aff - zmeano_aff[4]) / zstdo_aff[4]

        zpx = (px - zmeanp[0]) / zstdp[0]
        zpm = (pm - zmeanp[1]) / zstdp[1]
        zpw = (pw - zmeanp[2]) / zstdp[2]
        zpb = (pb - zmeanp[3]) / zstdp[3]
        zpf = (pf - zmeanp[4]) / zstdp[4]

    zp_vec = [zpx, zpm, zpw, zpb, zpf]
    z_vec = [zx, zm, zw, zb, zf]
    zl_vec = [zxl, zml, zwl, zbl, zfl]
    zo_vec = [zxo, zmo, zwo, zbo, zfo]
    zoa_vec = [zxo_aff, zmo_aff, zwo_aff, zbo_aff, zfo_aff]

    score_vec = [0.0, 0.0, 0.0, 0.0, 0.0]
    items = func.split('_')
    for item in items:
        itemv = eval(item + '_vec')
        for k in range(5): score_vec[k] += itemv[k]
    for k in range(5):
        annotes[k][0].append(score_vec[k])
    
    rank_ave = 0
    order_ave = 0
    r = [0, 0, 0, 0, 0]
    o = [0, 0, 0, 0, 0]
    tot = 0
    #print func_lname
    #for k in range(len(annotes[0][0])):
    #if data[k][0] in ['CCH', 'AGBL2', 'SYT1', 'NOXA', 'BAD', 'MULE', 'BOK', 'x', 'X']: continue
    #tot += 1
        #print data[k][0], data[k][1]
    #ev = []
    #for i in range(5):
        #print annotes[i][0][k],
     #   ev.append([annotes[i][0][k], i])
    #print
    #ev.sort()
     #kv = []
        #for i in range(5):
        #print annotes[i][1][k],
     #   kv.append([annotes[i][1][k], i])
    #print    
    #kv.sort()
    #rank1 = ev[0][1]
    #real1 = kv[0][1]
    #for i in range(5):
    #    if ev[i][1] == real1: ranki = i
    #    if kv[i][1] == rank1: reali = i
        #print 'rank of top binder', ranki + 1
    #print 'order of top rank', reali + 1
    #rank_ave += ranki + 1
    #order_ave += reali + 1
    #for i in range(5):
      #   if ranki == i: r[i] += 1
      #  if reali == i: o[i] += 1
    #print
    #print 'Average real rank of top prediction:', float(rank_ave) / float(tot)
    #print '\t number of each rank:', '1:', r[0], '2:', r[1], '3:', r[2], '4:', r[3], '5:', r[4]
    #print 'Average predicted rank of top binder:',  float(order_ave) / float(tot)
    #print '\t number of each rank:', '1:', o[0], '2:', o[1], '3:', o[2], '4:', o[3], '5:', o[4]
    #print
    #return []
    
    print func_lname
    pred = [[[], []], [[], []], [[], []], [[], []], [[], []]]
    rocs = []
    roc_ave = 0.0
    for i in range(2):
    if i == 0: continue
    for k in range(len(annotes[0][0])):
        #print data[k][0], rvec[i], annotes[i][0][k], annotes[i][1][k]
        pred[i][1].append(annotes[i][0][k])
        if annotes[i][1][k] > math.log10(1000): pred[i][0].append(1)
        else: pred[i][0].append(0)
        roc = pyroc(pred[i])
    rocs.append(roc[0])
    roc_ave += roc[1]
    print rvec[i], roc[1]
    print 'ave', roc_ave / 2.0    
    print

    return rocs

    spec = [[], []]

    print func
    count = 0
    roc_ave = 0.0

    for k in range(len(annotes[0][0])):
    kd_diff = (annotes[0][1][k] - annotes[1][1][k])
    if annotes[0][1][k] > math.log10(5000) and annotes[1][1][k] > math.log10(5000): continue
    if annotes[0][1][k] < math.log10(500) and annotes[1][1][k] < math.log10(500): continue
    if kd_diff < math.log10(5) and kd_diff > -1.0 * math.log10(5): continue
    spec[1].append(annotes[0][0][k] - annotes[1][0][k])
        if kd_diff > 0.0: spec[0].append(1)
        else: spec[0].append(0)
    spec_rocs = []
    roc = pyroc(spec)
    spec_rocs.append(roc[0])
    print 'XMspec', roc[1]
    print
    return spec_rocs
   
def test_pred_parameters():
  
    rocs = []
    funcl = ['z', 'zp', 'zoa', 'z_zp', 'z_zoa', 'zp_zoa', 'z_zp_zoa']
    #funcl = ['z_zp']
    for func in funcl:
        rocs = genome_hit_corr(func)
    continue
        import matplotlib
        matplotlib.use( 'Agg' )
        import pylab
        pylab.rcParams['xtick.labelsize'] = '16'
        pylab.rcParams['ytick.labelsize'] = '16'
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.rcParams['xtick.major.pad']='12'
        pylab.rcParams['ytick.major.pad']='12'
        pylab.rcParams['axes.linewidth'] = 3.0
        fig = pylab.figure()    # Create a figure
        ax = fig.gca()
        for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        #pylab.scatter(rocs[0], rocs[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
        cvec = ['b', 'r', 'g', 'k', 'm', 'p', 'y']
        for i in range(len(rocs)):
            roc = rocs[i]
            pylab.plot(roc[0][0], roc[0][1], cvec[i], lw=2)
        pylab.plot([0.0, 1.0], [0.0, 1.0], '--', color='k', lw=1)
        pylab.xlim(-0.005, 1.0)
        pylab.ylim(0.0, 1.005)
        pylab.savefig('/home/bartolo/web/statium/all_array_analysis/prediction/' + func + '_data.png')

def prep_data():

    data = lines2list('/home/bartolo/web/statium/all_array_analysis/All_arrays_tagged_controls.txt')

    for i in range(len(data)):
        if len(data[i]) == 7:
        for j in range(3): print str(data[i][j]) + '\t',
        print
        if len(data[i]) == 9:
        for j in range(5): print str(data[i][j]) + '\t',
        print

def test_pred_parameters2():
  
    rocs = []
    #funcl = ['z', 'zp', 'zo', 'zoa', 'z_zp', 'z_zo', 'z_zoa', 'zp_zo', 'zp_zoa', 'zo_zoa', 'z_zp_zo', 'z_zp_zoa', 'z_zo_zoa', 'zp_zo_zoa', 'z_zp_zo_zoa']
    funcl = ['z', 'zl', 'z_zl']
    for func in funcl:
        rocsi = genome_hit_corr(func)
    for roc in rocsi:
        rocs.append(roc)
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    #pylab.scatter(rocs[0], rocs[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
    #cvec = ['b', 'r', 'g', 'k', 'm', 'p', 'y']
    cvec = ['r', 'b', 'g', 'm', 'b', 'r', 'y']
    tvec = ['', '', '', '', '', '']
    for i in range(len(rocs)):
        roc = rocs[i]
    pylab.plot(roc[0], roc[1], tvec[i], color=cvec[i], lw=3)
    pylab.plot([0.0, 1.0], [0.0, 1.0], '--', color='k', lw=1)
    pylab.xlim(-0.005, 1.0)
    pylab.ylim(0.0, 1.005)
    pylab.savefig('/home/bartolo/web/statium_sidechain_wGly/group_010614/mcl1_roc.png')


def bcl2_analysis():
  
    SPOT360 = lines2list('/home/bartolo/web/statium/SPOT_360_logs.txt')
    jmb_xspec_data = lines2list('/home/bartolo/web/statium/data/jmb_bclxl_spec.txt')
    jmb_mspec_data = lines2list('/home/bartolo/web/statium/data/jmb_mcl1_spec.txt')

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')

    dxdata = lines2list('/home/bartolo/web/statium/data/deep_bclxl_spec_noinvitro.txt')
    dmdata = lines2list('/home/bartolo/web/statium/data/deep_mcl1_spec_noinvitro.txt')
    
    bxe = statium_energy_calc_sidechain(xmode, 'PEIWIAQELRRIGDEFNAYYARR', 0.0)
    bme = statium_energy_calc_sidechain(mmode, 'PEIWIAQELRRIGDEFNAYYARR', 0.0)

    #m_vmodel = statium_spec_vmodel('m')
    #x_vmodel = statium_spec_vmodel('x')

    m_vmodel_pair = statium_spec_vmodel_pair('m')
    x_vmodel_pair = statium_spec_vmodel_pair('x')

    deep_xs = deepe_matrix_single('x')
    deep_ms = deepe_matrix_single('m')

    bxe = statium_energy_calc(xorig, 'PEIWIAQELRRIGDEFNAYYARR', 0.0)
    bme = statium_energy_calc(morig, 'PEIWIAQELRRIGDEFNAYYARR', 0.0)
    
    #print bxe, bme

    dxe = []
    dme = []
    for i in range(len(jmb_xspec_data)):
        seq = dxdata[i][0]
        #ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    #em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        ex = statium_energy_calc(xorig, seq, 0.0) - bxe
    em = statium_energy_calc(morig, seq, 0.0) - bme
    dxe.append(ex - em)
    for i in range(len(jmb_mspec_data)):
    seq = dmdata[i][0]
        #ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    #em = statium_energy_calc_sidechain(mmode, seq, 0.0)
        ex = statium_energy_calc(xorig, seq, 0.0) - bxe
    em = statium_energy_calc(morig, seq, 0.0) - bme
    dme.append(ex - em)

    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['figure.figsize'] = (10, 8)
    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')

    pylab.hist(pylab.array(dxe), normed=0, facecolor='white', edgecolor='blue', lw=2, alpha=0.4)
    pylab.hist(pylab.array(dme), normed=0, facecolor='white', edgecolor='red', lw=2, alpha=0.4)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/svm/xmlib_statiumorig_hist.png')


    xm_360spec = [[], []]
    print 'SPOT library specificity...'
    print 'Signal diff, energy diff'
    for i in range(len(SPOT360)):
        seq = SPOT360[i][0]
        xsig = SPOT360[i][2]
        msig = SPOT360[i][3]
        if xsig < 0.5 or msig < 0.5:
        xm_360spec[1].append(xsig - msig)
        
        #ex = score_vmodel_pair(seq, x_vmodel_pair)
        #em = score_vmodel_pair(seq, m_vmodel_pair)
       
        #ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
        #em = statium_energy_calc_sidechain(mmode, seq, 0.0)

        ex = -1.0 * deepe_calc_single(deep_xs, seq)
        em = -1.0 * deepe_calc_single(deep_ms, seq)
        
        #ex = statium_energy_calc(xorig, seq, 0.0)
        #em = statium_energy_calc(morig, seq, 0.0)
        #print seq, ex, em
        xm_360spec[0].append(ex - em)
    


    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    
    print pylab.corrcoef(xm_360spec[0], xm_360spec[1])[0][1]

    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    pylab.scatter(xm_360spec[0], xm_360spec[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/svm/xm_spec_deep.png')

    return
    jmb_xspec = []
    for i in range(len(jmb_xspec_data)):
        seq = jmb_xspec_data[i][0]
        #xe = statium_energy_calc_sidechain(xmode, seq, 0.0)
        #me = statium_energy_calc_sidechain(mmode, seq, 0.0)
        xe = statium_energy_calc(xorig, seq, 0.0)
        me = statium_energy_calc(morig, seq, 0.0)
    jmb_xspec.append((xe - bxe) - (me - bme))
        #print statium_energy_calc_sidechain(xmode, seq, 0.0) - statium_energy_calc_sidechain(mmode, seq, 0.0), statium_energy_calc(jxorig, seq, 0.0), statium_energy_calc(xorig, seq, 0.0) - statium_energy_calc(jxorig, seq, 0.0)
        
    print
    print
    #print 'Energies of Mcl-1-specific yeast selected sequences...'
    jmb_mspec = []
    for i in range(len(jmb_mspec_data)):
        seq = jmb_mspec_data[i][0]
        #xe = statium_energy_calc_sidechain(xmode, seq, 0.0)
        #me = statium_energy_calc_sidechain(mmode, seq, 0.0)
        xe = statium_energy_calc(xorig, seq, 0.0)
        me = statium_energy_calc(morig, seq, 0.0)
        jmb_mspec.append((xe - bxe) - (me - bme))
        #print statium_energy_calc_sidechain(mmode, seq, 0.0) - statium_energy_calc_sidechain(xmode, seq, 0.0), statium_energy_calc(jxorig, seq, 0.0), statium_energy_calc(xorig, seq, 0.0) - statium_energy_calc(jxorig, seq, 0.0)

    import pylab
    pylab.hist(jmb_xspec)
    pylab.hist(jmb_mspec)
    pylab.savefig('/home/bartolo/web/blah.png')

def bcl2_analysis_bars():
   
    #mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    mmode = load_design_energy('/home/bartolo/web/curuksu/orig/c4')
    #xmode = load_design_energy('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    evec = [xorig, morig]
    rvec = ['xsc', 'morig']

    idx_vec = [2, 3, 4, 5, 6, 7, 8]
    SPOT200 = lines2list('/home/bartolo/web/statium/SPOT200.txt')
  
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(bim)
    
    wt_vec = []
    for idx in idx_vec:
        wt200_count = 0.0
        wt200 = 0.0
        for row in SPOT200:
            seq = row[0][0:23]
            if seq == bim:
            wt200_count += 1.0
            wt200 += row[idx]
        wt200 = wt200 / wt200_count
        wt_vec.append(wt200)

    full_vec = []
    for i in range(2):
        full_vec.append([])
        for j in range(10): full_vec[i].append([[], []])
    
    pos_vec = [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]
    for i in range(2):
        idx = idx_vec[i]
        for row in SPOT200:
            seq = row[0][0:23]
            pos = 0
            for j in range(len(seq)):
            if seq[j] != bim[j]: pos = pos_vec.index(j)
            dsig = -1.0 * math.log10(row[idx] / wt_vec[i])
            e = statium_energy_calc(evec[i], seq, 0.0)
            full_vec[i][pos][0].append(dsig)
            full_vec[i][pos][1].append(e)

    for i in range(len(full_vec)):
        import pylab
        pylab.rcParams['savefig.dpi'] = '300'
    
    barv = []
        for j in range(10): barv.append(round(pylab.corrcoef(pylab.array(full_vec[i][j][0]), pylab.array(full_vec[i][j][1]))[0][1], 2))
        pylab.bar(pylab.arange(len(barv)), pylab.array(barv), 0.35, color='r', align='center')
    pylab.xlim(-1, len(pylab.arange(len(barv))))
    pylab.ylim(-0.6, 1)
    pylab.xticks(pylab.arange(len(barv)), ('2d', '2e', '2g', '3a', '3b', '3d', '3e', '3f', '3g', '4a')) 
    pylab.savefig('/home/bartolo/web/curuksu/orig/statium_pos_bar_' + rvec[i] + '.png')
    pylab.close()

def statium_sidechain_design(epath, epath2, epath3, lib_path, specx, spec):

    specx = float(specx)
  
    mode = load_design_energy_sidechain(epath)
    mode2 = load_design_energy_sidechain(epath2)
    mode3 = load_design_energy_sidechain(epath3)
    #em1 = load_design_energy('/home/bartolo/web/statium/mcl1/mcl1_2pqk')
    sampler = lines2list(lib_path)
    N = len(sampler)
    
    #Generate initial random sequence
    while True:
        seq = []
        for i in range(N):
        #seq.append('E')
        #continue
            allowed = sampler[i][0]
            L = len(allowed)
            if L == 1: seq.append(allowed[0])
            else:
                randi = random.randint(0, L - 1)
                seq.append(allowed[randi])

        charge = 0
        for i in range(N):
            if seq[i] in 'DEHKNQRST': charge += 1

        arom = 0
        for i in range(N):
            if seq[i] in 'WFY': arom += 1
        
        if charge > 9 and arom < 4: break

    e1 = statium_energy_calc_sidechain(mode, join_str(seq), 0.0)
    
    e = e1
    
    desN = 0
    while True:
        
        rand_pos = random.randint(0, N - 1)
        allowed = sampler[rand_pos][0]
        if len(allowed) == 1: continue
        
        oldAA = seq[rand_pos]
        L = len(allowed)
        if L == 1: seq[rand_pos] = allowed[0]
        else:
            randi = random.randint(0, L - 1)
            seq[rand_pos] = allowed[randi]
        
        en1 = statium_energy_calc_sidechain(mode, join_str(seq), 0.0)
    en2 = statium_energy_calc_sidechain(mode2, join_str(seq), 0.0)
    en3 = statium_energy_calc_sidechain(mode3, join_str(seq), 0.0)

        score = en1
        
        charge = 0
        for i in range(N):
        if seq[i] in 'DEHKNQRST': charge += 1 

        arom = 0
        for i in range(N):
            if seq[i] in 'WFY': arom += 1

    if charge <= 9 or arom >= 4:
        seq[rand_pos] = oldAA
        continue
       
        desN += 1
        if score < e:
        if spec:
        if en2 - e > specx and en3 - e > specx:
                e = score
                desN = 0
            else: seq[rand_pos] = oldAA
        else:
            e = score
        desnN = 0
    else: seq[rand_pos] = oldAA
    
    if desN == 1000: return [join_str(seq), e, en2, en3]

def statium_sidechain_design2():

    lib_path = '/home/bartolo/web/statium_sidechain_wGly/lib.txt'
    SPOT_vec = PSSM5()
  
    #mode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/mcl1/mcl1_3pk1')
    #mode_l = load_intralocal_energy('/home/bartolo/web/statium_local/mcl1/mcl1_3pk1')
    mode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclxl/bclxl_3io8')
    mode_l = load_intralocal_energy('/home/bartolo/web/statium_local/bclxl/bclxl_3io8')
    #mode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bfl1/bfl1_3mqp')
    #mode_l = load_intralocal_energy('/home/bartolo/web/statium_local/bfl1/bfl1_3mqp')
    #mode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bcl2/bcl2')
    #mode_l = load_intralocal_energy('/home/bartolo/web/statium_local/bcl2/bcl2')
    #mode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain_wGly/bclw/bclwmock')
    #mode_l = load_intralocal_energy('/home/bartolo/web/statium_local/bclw/bclwmock')

    sampler = lines2list(lib_path)
    N = len(sampler)
    
    #Generate initial random sequence
    seq = []
    for i in range(N):
        allowed = sampler[i][0]
        L = len(allowed)
        if L == 1: seq.append(allowed[0])
        else:
            randi = random.randint(0, L - 1)
            seq.append(allowed[randi])

    tseq = 'PEIWIAQELARIGDEFNAYYARR'
    print statium_energy_calc_sidechain(mode, tseq, 0.0) + 0.01 * statium_energy_calc_intralocal(mode_l, tseq, 0.0, 'local')
    energy_pssm = pssm_energy10(SPOT_vec, tseq)
    print 'x', energy_pssm[0], 'm', energy_pssm[1], 'w', energy_pssm[2], 'f', energy_pssm[3], 'b', energy_pssm[4]
    return

    e1 = statium_energy_calc_sidechain(mode, join_str(seq), 0.0) + 0.1 * statium_energy_calc_intralocal(mode_l, join_str(seq), 0.0, 'local')
    
    e = e1
    
    desN = 0
    while True:
        
        rand_pos = random.randint(0, N - 1)
        allowed = sampler[rand_pos][0]
        if len(allowed) == 1: continue
        
        oldAA = seq[rand_pos]
        L = len(allowed)
        if L == 1: seq[rand_pos] = allowed[0]
        else:
            randi = random.randint(0, L - 1)
            seq[rand_pos] = allowed[randi]
        
        en1 = statium_energy_calc_sidechain(mode, join_str(seq), 0.0) + 0.1 * statium_energy_calc_intralocal(mode_l, join_str(seq), 0.0, 'local')

        score = en1
        
        charge = 0
        for i in range(N):
        if seq[i] in 'DEHKNQRST': charge += 1 

        arom = 0
        for i in range(N):
            if seq[i] in 'WFY': arom += 1

    #if charge <= 9 or arom >= 4:
     #   seq[rand_pos] = oldAA
      #  continue
       
        desN += 1
        if score < e:
        e = score
        desN = 0
            energy_pssm = pssm_energy10(SPOT_vec, seq)
        print join_str(seq), e
        print 'x', energy_pssm[0], 'm', energy_pssm[1], 'w', energy_pssm[2], 'f', energy_pssm[3], 'b', energy_pssm[4]
    else: seq[rand_pos] = oldAA
    
def bfl1_pssm_design():
  
    specx = 1.0
    SPOT_vec = PSSM5()

    sampler = lines2list('/home/bartolo/web/statium_sidechain/f_design_lib.txt')
    N = len(sampler)
    
    #Generate initial random sequence

    seq = []
    for i in range(N):
    #seq.append('E')
    #continue
    allowed = sampler[i][0]
    L = len(allowed)
    if L == 1: seq.append(allowed[0])
    else:
        randi = random.randint(0, L - 1)
        seq.append(allowed[randi])

    energy_pssm = pssm_energy10(SPOT_vec, join_str(seq))
    e1 = energy_pssm[3]
    print join_str(seq), e1
    
    e = e1
    
    desN = 0
    while True:
        
        rand_pos = random.randint(0, N - 1)
        allowed = sampler[rand_pos][0]
        if len(allowed) == 1: continue
        
        oldAA = seq[rand_pos]
        L = len(allowed)
        if L == 1: seq[rand_pos] = allowed[0]
        else:
            randi = random.randint(0, L - 1)
            seq[rand_pos] = allowed[randi]
        
        energy_pssm = pssm_energy10(SPOT_vec, join_str(seq))
        en1 = energy_pssm[3]
    en2 = energy_pssm[0]
    en3 = energy_pssm[1]
    en4 = energy_pssm[2]
    en5 = energy_pssm[4]

        score = en1
       
        desN += 1
        if score < e:
        if en2 - e > specx and en3 - e > specx and en4 - e > specx and en5 - e > specx:
        e = score
        desN = 0
        print join_str(seq), e, en2, en3, en4, en5
        else: seq[rand_pos] = oldAA
    else: seq[rand_pos] = oldAA
    
    if desN == 1000: print join_str(seq), e, en2, en3, en4, en5
        
def statium_sidechain_design_repeat(epath, epath2, epath3, lib_path, specx, spec):
    
    specx = float(specx)
    seqs = ['X']
    ev = [0.0]
    ev2 = [0.0]
    ev3 = [0.0]
    test = 0
    while True:
        test += 1
        data = statium_sidechain_design(epath, epath2, epath3, lib_path, specx, spec)
        seq = data[0]
        e = data[1]
        e2 = data[2]
        e3 = data[3]
        if not seq in seqs and e <= ev[-1] and e2 - e > specx and e3 - e > specx:
        #if not seq in seqs and e <= ev[-1]:
        test = 0
        seqs.append(seq)
        ev.append(e)
        ev2.append(e2)
        ev3.append(e)
        print seq, e, e2, e3
    if test == 100: return
    
def clean_array5_seq():
  
    lines = readlines('/home/bartolo/web/statium_sidechain/Array5.txt')
    
    seqs = []
    for line in lines:
        items = line.split()
        if len(items) > 0:
        if len(items[0]) == 23:
            if not items[0] in seqs:
            seqs.append(items[0])
            print line.strip()
        else: print line.strip()
    else: print line.strip()
    
def seq_comp(seq1, seq2):
  
    for i in range(len(seq1)):
        if seq1[i] != seq2[i]:
        if seq1[i] == 'A' and seq2[i] == 'C': continue
        else: return False
    return True
    
def seq_percid(seq1, seq2):
  
    match = 0.0
    for i in range(len(seq1)):
        aa1 = seq1[i]
        aa2 = seq2[i]
        if aa1 == aa2: match += 1.0
        #elif aa1 in 'KR' and aa2 in 'KR': match += 1.0
        #elif aa1 in 'DE' and aa2 in 'DE': match += 1.0
        #elif aa1 in 'LM' and aa2 in 'LM': match += 1.0
        #elif aa1 in 'FY' and aa2 in 'FY': match += 1.0
    return match / float(len(seq1))
    
def array5_analysis():
  
    Xdata = lines2list('/home/bartolo/web/statium/Array5/Array5_X_run_intensities_011613.txt')
    Mdata = lines2list('/home/bartolo/web/statium/Array5/Array5_M_run_intensities_011613.txt')
    Fdata = lines2list('/home/bartolo/web/statium/Array5/Array5_F_run_intensities_011613.txt')
    sequences = readlines('/home/bartolo/web/statium/Array5/Array5_test_sequences.txt')
    
    full_seq = readlines('/home/bartolo/web/statium_sidechain/bcl2_expand_seq.txt')
    full_names = readlines('/home/bartolo/web/statium_sidechain/bcl2_expand_names.txt')
    
    
    Xwt = (Xdata[0][2] + Xdata[378][2]) / 2.0
    Mwt = (Mdata[0][2] + Mdata[378][2]) / 2.0
    Fwt = (Fdata[0][2] + Fdata[378][2]) / 2.0
     
    for i in range(130):
      
        idx = i * 3
        
        seq = sequences[idx].strip()
      
        Xval = str(round(Xdata[idx][2] / Xwt, 2))
        Mval = str(round(Mdata[idx][2] / Mwt, 2))
        Fval = str(round(Fdata[idx][2] / Fwt, 2))
  
        Xval1 = str(round(Xdata[idx + 1][2] / Xwt, 2))
        Mval1 = str(round(Mdata[idx + 1][2] / Mwt, 2))
        Fval1 = str(round(Fdata[idx + 1][2] / Fwt, 2))

        Xval2 = str(round(Xdata[idx + 2][2] / Xwt, 2))
        Mval2 = str(round(Mdata[idx + 2][2] / Mwt, 2))
        Fval2 = str(round(Fdata[idx + 2][2] / Fwt, 2))
        
        for j in range(len(full_seq)):
        if not seq_comp(seq, full_seq[j].strip()): continue
        
        name_str = full_names[j].strip()
        for k in range(len(name_str)):
            if name_str[k] == '|': idx = k
        name = ''
        for k in range(idx + 1, len(name_str)): name += name_str[k]

        network_dicts = network_dictionaries()
        ls_dict = network_dicts[1]
        try: shortname = ls_dict[name]
        except: shortname = '??'
        break
        
        data_str = seq + '\t' + Xval + '\t' + Xval1 + '\t' + Xval2 + '\t' + Mval + '\t' + Mval1 + '\t' + Mval2 + '\t' + Fval + '\t' + Fval1 + '\t' + Fval2 + '\t' + shortname
        
        print data_str
   
def array5_bfl1():
  
    data = lines2list('/home/bartolo/web/statium/Array5/Array5_results_labelled.txt')
    SPOT_vec = PSSM5()
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    
    inv = []
    ouv = []
    for i in range(122):
        if len(data[i]) != 11: continue
    seq = data[i][0]
    energy_pssm = pssm_energy10(SPOT_vec, seq)
          ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
          pf = energy_pssm[3]
          if pf < 0.4: inv.append(data[i][7])
          if pf > 1.7: ouv.append(data[i][7])
    for i in range(len(inv)): print inv[i]
    print
    print
    for i in range(len(ouv)): print ouv[i]
          
    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['figure.figsize'] = (10, 8)
    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')

    pylab.hist(pylab.array(inv), bins=40, normed=0, facecolor='white', edgecolor='blue', lw=2, alpha=0.4)
    pylab.hist(pylab.array(ouv), bins=20, normed=0, facecolor='white', edgecolor='red', lw=2, alpha=0.4)
    pylab.savefig('/home/bartolo/web/bfl1.png')
    
def array5_barI():
  
    data = lines2list('/home/bartolo/web/statium/Array5/Array5_results.txt')
    out_dir = '/home/bartolo/web/statium/Array5/bar_plots'
    
    seq_labels = ['WT', '3aD', '3eL']
    seq_labels2 = ['WT', '3aD', '3eL', 'WT', '3aD', '3eL', 'WT', '3aD', '3eL']
    R_labels = ['Bcl-xL', 'Mcl-1', 'Bfl-1']
    
    for i in range(len(data)):
        print data[i][-1]
      
        for j in range(4):
    
        import matplotlib
        matplotlib.use( 'Agg' )
        import pylab
        pylab.rcParams['xtick.labelsize'] = '16'
        pylab.rcParams['ytick.labelsize'] = '16'
        pylab.rcParams['savefig.dpi'] = '300'
        pylab.rcParams['xtick.major.pad']='12'
        pylab.rcParams['ytick.major.pad']='12'
        pylab.rcParams['axes.linewidth'] = 3.0
        fig = pylab.figure()    # Create a figure
        ax = fig.gca()
        for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
        for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    
        if j in [0, 1, 2]:
            continue
         
            idx = j * 3 + 1
        
        xs = pylab.arange(3)
        ys = pylab.array([data[i][idx], data[i][idx + 1], data[i][idx + 2]])
        pylab.bar(xs, ys, 0.35, color='r', align='center')
        pylab.xticks(xs, seq_labels)
        pylab.title(data[i][-1] + ' and ' + R_labels[j] + '\n' + data[i][0], fontsize=15)
        path = os.path.join(out_dir, data[i][-1] + '_' + R_labels[j] + '.png')
        pylab.savefig(path)
            
        if j == 3:
            xs = pylab.arange(9)
        ys = pylab.array([data[i][1], data[i][2], data[i][3], data[i][4], data[i][5], data[i][6], data[i][7], data[i][8], data[i][9]])
        rects = pylab.bar(xs, ys, 0.35, color=['r', 'r', 'r', 'b', 'b', 'b', 'g', 'g', 'g',], align='center')
        for k in range(len(xs)):
            pylab.text(float(xs[k]), float(ys[k]) + 0.001, seq_labels2[k], ha='center', va='bottom')
        pylab.xticks(xs, ['', 'Bcl-xL', '', '', 'Mcl-1', '', '', 'Bfl-1', ''])
        pylab.title(data[i][-1] + '\n' + data[i][0], fontsize=15)
        pylab.ylim(0.0, max(ys) + 0.4 * max(ys))
        path = os.path.join(out_dir, data[i][-1] + '_all.png')
        pylab.savefig(path)
      
def random_library(e_path, wt, out_path, N):
  
    mode = load_design_energy_sidechain(e_path)
      
    L = len(wt)
    tlib = []
    for i in range(N):
        e = statium_energy_calc_sidechain(mode, random_seq(L), 0.0)
        tlib.append(e)
        
    ofile = open(out_path, 'w')
    for i in range(len(tlib)): ofile.write(str(tlib[i]) + '\n')
    ofile.close()
    
def random_library_jmb(e_path, wt, out_path, N):
  
    mode = load_design_energy(e_path)
      
    L = len(wt)
    tlib = []
    for i in range(N):
        e = statium_energy_calc(mode, random_seq(L), 0.0)
        tlib.append(e)
        
    ofile = open(out_path, 'w')
    for i in range(len(tlib)): ofile.write(str(tlib[i]) + '\n')
    ofile.close()
    
def IQ_list():
  
    data = lines2list('/home/bartolo/web/FLAT_FILES_072010/PROTEIN_ARCHITECTURE.txt')
    
    for i in range(len(data)):
        try:
            if data[i][4] == 'IQ' and data[i][5] == 'Domain' and data[i][8] == 'smart' and (int(data[i][7]) - int(data[i][6])) == 22:
            print data[i][3], int(data[i][6]), int(data[i][7])
    except: continue
    
def IQ_search():
  
    data = lines2list('/home/bartolo/web/statium_sidechain/IQ_list.txt')
    flex = [[], [], []]
    for i in range(len(data)):
        flex[0].append(data[i][0])
    flex[1].append([int(data[i][1]), int(data[i][2])])
    flex[2].append('')
    
    network_dicts = network_dictionaries()
    
    sl_dict = network_dicts[0]
    ls_dict = network_dicts[1]

    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    count = 0
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
        try: shortname = ls_dict[namex]
    except: continue
          
        prot_seq = seqs[i][0]
        for j in range(len(flex[0])):
            if flex[0][j] == shortname:
            if flex[2][j] != '': continue
            flex[2][j] = prot_seq
            count += 1
            
    for j in range(len(flex[0])):
    pos0 = flex[1][j][0] - 1
    try:
        iq_motif = ''
        for k in range(29): iq_motif += flex[2][j][pos0 - 4 + k]
        print iq_motif
    except: continue

def edex(idir, odir, start):

    if not os.path.exists(odir): os.mkdir(odir)
    for i in range(60):
        num0 = i + 1      
    num = start + i
        nums = str(num)
        numl = len(nums)
    pre = ''
        for j in range(4 - numl): pre += '0'
        nums0 = str(num0)
        numl0 = len(nums0)
        pre0 = ''
        for j in range(4 - numl0): pre0 += '0'

        fold = os.path.join(idir, 'mov' + pre0 + nums0 + '.png')
        fnew = os.path.join(odir, 'mov' + pre + nums + '.png')
        os.system('cp ' + fold + ' ' + fnew)
        #png_gif_single(fold, fnew)

def skip3(d1, d2):

    d1_list = os.listdir(d1)
    for i in range(720):
        num = i + 1
        nums = str(num)
        numl = len(nums)
        pre = ''
        for j in range(4 - numl): pre += '0'
    path = os.path.join(d1, 'mov' + pre + nums + '.gif')
    if i % 3 != 0: continue
        patho = os.path.join(d2, 'mov' + pre + nums + '.gif')
    os.system('cp ' + path + ' ' + patho)
    
def shortnames():

    network_dicts = network_dictionaries()
    ls_dict = network_dicts[1]

    lines = readlines('/home/bartolo/web/tmp.txt')
    for line in lines:
        name = line.strip()
    try: shortname = ls_dict[name]
    except: shortname = '??'
    print shortname
    
def Mikko_scan():
  
    lines0 = readlines('/home/bartolo/web/Gene_names.txt')
    lines1 = readlines('/home/bartolo/web/Mikko_cell_genes.txt')
    
    genes0 = []
    genes1 = []
    for line0 in lines0: genes0.append(line0.strip())
    for line1 in lines1: genes1.append(line1.strip())
    
    for gene in genes0:
        if gene in genes1: print gene
        
def paper_ArrayI():
  
    data = lines2list('/home/bartolo/web/ArrayI_unique.txt')
    
    bind = 0
    for i in range(len(data)):
      
        x = data[i][1]
        m = data[i][2]
        
        if x > 1.0 or m > 1.0: bind += 1
    print bind, len(data)
        
def paper_ArrayII():
  
    data = lines2list('/home/bartolo/web/ArrayII_unique_red.txt')
    
    a = []
    e = []
    bind = 0
    for i in range(len(data)):
      
        s = data[i][1]
        s1 = data[i][2]
        
        if s <= 0: a.append(s)
        if s1 <= 0: e.append(s1)
    import pylab
    print mean(pylab.array(a))
    print mean(pylab.array(e))
        
        
        
        #print data[i][0], ((s1 - s) / s) * 100.0, ((s2 - s) / s) * 100.0
        #if x > 1.0 or m > 1.0: bind += 1
    #print bind, len(data)      
    
def tag_all_arrays():
  
    da1x = readlines('/home/bartolo/web/statium/all_array_analysis/ArrayI_X.txt')
    da1m = readlines('/home/bartolo/web/statium/all_array_analysis/ArrayI_M.txt')
    da2x = readlines('/home/bartolo/web/statium/all_array_analysis/ArrayII_X.txt')
    da2m = readlines('/home/bartolo/web/statium/all_array_analysis/ArrayII_M.txt')
    da4x = readlines('/home/bartolo/web/statium/all_array_analysis/Array4_X.txt')
    da4m = readlines('/home/bartolo/web/statium/all_array_analysis/Array4_M.txt')
    da5x = readlines('/home/bartolo/web/statium/all_array_analysis/Array5_X.txt')
    da5m = readlines('/home/bartolo/web/statium/all_array_analysis/Array5_M.txt')
    
    for i in range(len(da1x)): print da1x[i].strip() + '\t' + 'AI'
    for i in range(len(da1m)): print da1m[i].strip() + '\t' + 'AI'
    for i in range(len(da2x)): print da2x[i].strip() + '\t' + 'AII'
    for i in range(len(da2m)): print da2m[i].strip() + '\t' + 'AII'
    for i in range(len(da4x)): print da4x[i].strip() + '\t' + 'AIV'
    for i in range(len(da4m)): print da4m[i].strip() + '\t' + 'AIV'
    for i in range(len(da5x)): print da5x[i].strip() + '\t' + 'AV'
    for i in range(len(da5m)): print da5m[i].strip() + '\t' + 'AV'
 
def trimage(idir, odir):
  
    ilist = os.listdir(idir)
    if not os.path.exists(odir): os.mkdir(odir)
    for file in ilist:
        ipath = os.path.join(idir, file)
        opath = os.path.join(odir, file)
        os.system('convert -trim ' + ipath + ' ' + opath)
        
def zcomp():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/old_new_z.txt')
    
    ov = []
    nv = []
    for i in range(len(data)):
        ov.append(data[i][0])
        nv.append(data[i][1])
    import pylab
    
    oarray = pylab.array(ov) 
    narray = pylab.array(nv)
    
    print std(oarray), std(narray)
    print mean(oarray), mean(narray)
    
def mean_and_error(ipath):
  
    import pylab
    data = lines2list(ipath)
    
    vals = []
    for i in range(len(data)): vals.append(data[i][0])
    a = pylab.array(vals)
    print mean(a), std(a)

def natural_library():
  
    data = lines2list('/home/bartolo/web/statium/binder_lib.txt')
    for i in range(23):
        frak = ''
        for j in range(len(data)):
        if not data[j][0][i] in frak: frak += data[j][0][i]
        print frak
        
def process_BHRF1_spots():
  
    SPOT_vec = PSSM5()
  
    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    
    hmode = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2XPX')
    hmode2 = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2wh6')

    data = lines2list('/home/bartolo/web/statium/BHRF1_pssm/raw2.txt')
    
    wt = [[], []]
    for i in range(len(data)):
        if data[i][0] == 'wt':
        wt[0].append(i)
        wt[1].append(data[i][1])
    
    import pylab
    wt_ave = pylab.mean(wt[1])
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bim_vec = []
    for i in range(len(bim)): bim_vec.append(bim[i])

    preds = [[], []]
    for i in range(len(data)):
        if i in wt[0]: continue
        if len(data[i][0]) > 1:
        sub = [[], []]
        idx = int(data[i][0][0:len(data[i][0])-1])
        aa = data[i][0][-1]
    else: aa = data[i][0]
    bim_vec[idx] = aa
    seq = ''
    for j in range(len(bim_vec)): seq += bim_vec[j]
    
    energy_pssm = pssm_energy10(SPOT_vec, seq)
    xp = energy_pssm[0]
    mp = energy_pssm[1]
    wp = energy_pssm[2]
    fp = energy_pssm[3]
    bp = energy_pssm[4]
    if fp == 0.0: continue
    bim_vec[idx] = bim[idx]
    eh_wt = statium_energy_calc_sidechain(hmode, bim, 0.0)
    eh = statium_energy_calc_sidechain(hmode, seq, 0.0)
    ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
    eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
    #if xp == 0.0: continue
    score = -1.0 * math.log10(data[i][1] / wt_ave)
    #if score < 0.1:
        #preds[0].append(0)
        #preds[1].append(eh)
    #elif score > 0.4:
        #preds[0].append(1)
        #preds[1].append(eh)
    #if bp == 0.0: continue
    preds[0].append(score)
    preds[1].append(fp)
    print seq, score, xp
    #print seq, score, eh
    #preds[0].append(eh - ex)
    #preds[1].append(score - xp)
    #print seq, preds[1][-1], preds[0][-1]
    #print pylab.corrcoef(preds[0], preds[1])[0][1]
    #roc = pyroc(preds)
    #print roc[0]
    #pylab.close()
    #import matplotlib
    #matplotlib.use( 'Agg' )
    import pylab
    #pylab.rcParams['xtick.labelsize'] = '16'
    #pylab.rcParams['ytick.labelsize'] = '16'
    #pylab.rcParams['savefig.dpi'] = '300'
    #pylab.rcParams['xtick.major.pad']='12'
    #pylab.rcParams['ytick.major.pad']='12'
    #pylab.rcParams['axes.linewidth'] = 3.0
    #fig = pylab.figure()    # Create a figure
    #ax = fig.gca()
    #for tick in ax.xaxis.get_major_ticks():
    #tick.label1.set_fontsize('15')
    #tick.label1.set_fontweight('bold')
    #for tick in ax.yaxis.get_major_ticks():
    #tick.label1.set_fontsize('15')
    #tick.label1.set_fontweight('bold')
    #pylab.scatter(preds[0], preds[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
    print pylab.corrcoef(preds[0], preds[1])[0][1]
    #pylab.savefig('/home/bartolo/web/statium/BHRF1_pssm/stat.png')

def process_compare_spots():
    import pylab
  
    SPOT_vec = PSSM5()

    morig = load_design_energy('/home/bartolo/web/statium_noref/mcl12/mcl1_3pk1')
    xorig = load_design_energy('/home/bartolo/web/statium_noref/bclxl2/bclxl_3io8')
    forig = load_design_energy('/home/bartolo/web/statium_noref/bfl12/bfl1_3mqp')
    borig = load_design_energy('/home/bartolo/web/statium_noref/bcl22/bcl2')
 

    mmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/mcl1GA/mcl1_3pk1')
    xmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bclxlGA/bclxl_3io8')
    fmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bfl1GA/bfl1_3mqp')
    bmode = load_design_energy_sidechain('/home/bartolo/web/statium_sidechain/bcl2GA/bcl2')
    
    hmode = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2XPX')
    hmode2 = load_design_energy_sidechain('/home/gmwink/statium_tutorial/bhrf1/bhrf1_2wh6')

    data = lines2list('/home/bartolo/web/test.txt')
    
    bim = 'PEIWIAQELRRIGDEFNAYYARR'
    bim_vec = []
    for i in range(len(bim)): bim_vec.append(bim[i])

    preds = [[], []]
    for i in range(len(data)):
        seq = data[i][0]
    
    energy_pssm = pssm_energy10(SPOT_vec, seq)
    xp = energy_pssm[0]
    mp = energy_pssm[1]
    wp = energy_pssm[2]
    fp = energy_pssm[3]
    bp = energy_pssm[4]
    eh_wt = statium_energy_calc_sidechain(hmode, bim, 0.0)
    eh = statium_energy_calc_sidechain(hmode, seq, 0.0)
    ex = statium_energy_calc_sidechain(xmode, seq, 0.0)
    em = statium_energy_calc_sidechain(mmode, seq, 0.0)
    ef = statium_energy_calc_sidechain(fmode, seq, 0.0)
    eb = statium_energy_calc_sidechain(bmode, seq, 0.0)
    
    exo = statium_energy_calc(xorig, seq, 0.0)
    emo = statium_energy_calc(morig, seq, 0.0)
    efo = statium_energy_calc(forig, seq, 0.0)
    ebo = statium_energy_calc(borig, seq, 0.0)
    preds[0].append(mp)
    preds[1].append(em)
    print pylab.corrcoef(preds[0], preds[1])[0][1]
    pylab.close()
    import matplotlib
    matplotlib.use( 'Agg' )
    import pylab
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
    tick.label1.set_fontsize('15')
    tick.label1.set_fontweight('bold')
    pylab.scatter(preds[0], preds[1], c='k', marker='o', s=30, facecolor='none', edgecolors='k')
    #print pylab.corrcoef(preds[0], preds[1])[0][1]
    pylab.savefig('/home/bartolo/web/Bstat.png')
    
def BmyoS2():
  
    wt = 'ASMKEEFTRLKEALEKSEARRKELEEKMVSLLQEKNDLQLQVQAEQDNLADAEERCDQLIKNKIQLEAKVKEMNERLEDEEEMNAELTAKKRKLEDECSELKRDIDDLELTL'
    mode = load_design_energy_sidechain('/home/bartolo/web/CC/BmyoS2_2fxm')
    
    print statium_energy_calc_sidechain(mode, wt, 0.0)
    
    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq.txt')
    names = readlines('/home/bartolo/web/CC/BmyoS2_names.txt')
    for i in range(len(data)):
        seq = data[i][0]
    e = statium_energy_calc_sidechain(mode, seq, 0.0)
    if e < -10.0:
        print e
        print names[i]
        print seq
        
def BmyoS2_matrix():

    wt = 'ASMKEEFTRLKEALEKSEARRKELEEKMVSLLQEKNDLQLQVQAEQDNLADAEERCDQLIKNKIQLEAKVKEMNERLEDEEEMNAELTAKKRKLEDECSELKRDIDDLELTL'
    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq_allL_ordered.txt')
    for i in range(len(data)):
        
        res_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '.cfg')
        preset_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1))
        coyote_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '_coyote')
    counts_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '_coyote_counts')
        #os.system('cp /home/bartolo/web/CC/BmyoS2_2fxm.cfg ' + res_path)
        #os.system('/home/bartolo/web/build.py -statium_sidechain_coyote ' + preset_path + ' ' + coyote_path + ' REG 600')
    #os.system('/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path)
        #continue
        
        seq1 = data[i][0]
        sstr1 = ''
        for j in range(len(seq1)):
        if seq1[j] == wt[j]:
            sstr1 += seq1[j].lower()
        else: sstr1 += seq1[j]
    for k in range(len(data)):    
        seq2 = data[k][0]
        sstr2 = ''
        for l in range(len(seq2)):
        if seq2[l] == wt[l]:
            sstr2 += seq2[l].lower()
        else: sstr2 += seq2[l]    
        path = os.path.join('/home/bartolo/web/CC/dfire/seq', str(i + 1) + '_' + str(k + 1) + '.txt')
        of = open(path, 'w')
        of.write(sstr1 + sstr2)
        of.close()
        pdb_path = os.path.join('/home/bartolo/web/CC/dfire/pdb', str(i + 1) + '_' + str(k + 1) + '.pdb')
        print pdb_path
        #print '/home/potapov/bin/scwrl4/Scwrl4 -i /home/bartolo/web/CC/2FXM.pdb -o ' + pdb_path + ' -s ' + path

def BmyoS2_matrix_dfire():

    wt = 'ASMKEEFTRLKEALEKSEARRKELEEKMVSLLQEKNDLQLQVQAEQDNLADAEERCDQLIKNKIQLEAKVKEMNERLEDEEEMNAELTAKKRKLEDECSELKRDIDDLELTL'
    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq_allL_ordered.txt')
    for i in range(len(data)):
        
        res_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '.cfg')
        preset_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1))
        coyote_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '_coyote')
    counts_path = os.path.join('/home/bartolo/web/CC/matrix/pdb', 'BmyoS2_' + str(i + 1) + '_coyote_counts')
        #os.system('cp /home/bartolo/web/CC/BmyoS2_2fxm.cfg ' + res_path)
        #os.system('/home/bartolo/web/build.py -statium_sidechain_coyote ' + preset_path + ' ' + coyote_path + ' REG 600')
    #os.system('/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path)
        #continue
        
        seq1 = data[i][0]
        sstr1 = ''
        for j in range(len(seq1)):
        if seq1[j] == wt[j]:
            sstr1 += seq1[j].lower()
        else: sstr1 += seq1[j]
    for k in range(len(data)):    
        seq2 = data[k][0]
        sstr2 = ''
        for l in range(len(seq2)):
        if seq2[l] == wt[l]:
            sstr2 += seq2[l].lower()
        else: sstr2 += seq2[l]    
        path = os.path.join('/home/bartolo/web/CC/dfire/seq', str(i + 1) + '_' + str(k + 1) + '.txt')
        of = open(path, 'w')
        of.write(sstr1 + sstr2)
        of.close()
        pdb_path = os.path.join('/home/bartolo/web/CC/dfire/pdb', str(i + 1) + '_' + str(k + 1) + '.pdb')
        print pdb_path
        #print '/home/potapov/bin/scwrl4/Scwrl4 -i /home/bartolo/web/CC/2FXM.pdb -o ' + pdb_path + ' -s ' + path

def BmyoS2_matrix_ideal():

    wt = 'ASMKEEFTRLKEALEKSEARRKELEEKMVSLLQEKNDLQLQVQAEQDNLADAEERCDQLIKNKIQLEAKVKEMNERLEDEEEMNAELTAKKRKLEDECSELKRDIDDLELTL'
    wta = ''
    for i in range(len(wt)): wta += 'A'
    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq_allL_ordered.txt')
    for i in range(len(data)):
        
        res_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1) + '.res')
        cfg_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1) + '.cfg')
        preset_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1))
        coyote_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1) + '_coyote')
    counts_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1) + '_coyote_counts')
        #os.system('cp /home/bartolo/web/CC/BmyoS2_2fxm.cfg ' + cfg_path)
        #os.system('cp /home/bartolo/web/CC/BmyoS2_2fxm.res ' + res_path)
        #os.system('/home/bartolo/web/build.py -statium_sidechain_coyote ' + preset_path + ' ' + coyote_path + ' REG 600')
    #os.system('/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path)
        s = '/home/bartolo/web/build.py -statium_sidechain_coyote_compile ' + coyote_path + ' ' + counts_path + '\n' + '/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path + ' A\n'
        sh_path = os.path.join(coyote_path, 'compile.sh')
        of = open(sh_path, 'w')
        of.write(s)
        of.close()
        os.system('chmod u+x ' + sh_path)
        os.system(sh_path)
        continue
        
        seq1 = data[i][0]
        #sstr1 = ''
        #for j in range(len(seq1)):
        
        #if seq1[j] == wt[j]:
            #sstr1 += seq1[j].lower()
        #else: sstr1 += seq1[j]

    path = os.path.join('/home/bartolo/web/CC/ideal/seq', str(i + 1) + '.txt')
    of = open(path, 'w')
    of.write(seq1 + wta)
    of.close()
    pdb_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1) + '.pdb')
    #print pdb_path
    print '/home/potapov/bin/scwrl4/Scwrl4 -i /home/bartolo/web/CC/2zta_idealized_r.pdb -o ' + pdb_path + ' -s ' + path



def kinesin_matrix_ideal():

    wt = 'EQWKKKYEKEKEKNKILRNTIQWLENELNRWR'
    wta = ''
    for i in range(len(wt)): wta += 'A'
    data = lines2list('/home/bartolo/web/CC/kinesin/kinesin_seq_reorder.txt')
    for i in range(len(data)):
        
        res_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1) + '.res')
        cfg_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1) + '.cfg')
        preset_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1))
        coyote_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1) + '_coyote')
    counts_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1) + '_coyote_counts')
        #os.system('cp /home/bartolo/web/CC/kin_ideal.cfg ' + cfg_path)
        #os.system('cp /home/bartolo/web/CC/kin_ideal.res ' + res_path)
        #os.system('/home/bartolo/web/build.py -statium_sidechain_coyote ' + preset_path + ' ' + coyote_path + ' REG 200')
        #while True:
            #njobs = coyote_count_jobs('speedy')
            #if njobs < 400: break
            #else: time.sleep(10)
    #os.system('/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path)
        s = '/home/bartolo/web/build.py -statium_sidechain_coyote_compile ' + coyote_path + ' ' + counts_path + '\n' + '/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path + ' A\n'
        sh_path = os.path.join(coyote_path, 'compile.sh')
        of = open(sh_path, 'w')
        of.write(s)
        of.close()
        os.system('chmod u+x ' + sh_path)
        os.system('qsub -q speedy ' + sh_path)
        continue
        
        seq1 = data[i][0]
        #sstr1 = ''
        #for j in range(len(seq1)):
        
        #if seq1[j] == wt[j]:
            #sstr1 += seq1[j].lower()
        #else: sstr1 += seq1[j]

    path = os.path.join('/home/bartolo/web/CC/kinesin/seq', str(i + 1) + '.txt')
    of = open(path, 'w')
    of.write(seq1 + wta)
    of.close()
    pdb_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1) + '.pdb')
    #print pdb_path
    print '/home/potapov/bin/scwrl4/Scwrl4 -i /home/bartolo/web/CC/kin_ideal_r.pdb -o ' + pdb_path + ' -s ' + path

def tropo_matrix_ideal():

    wt = 'ERTEERAELAESKCSELEEELKNVTNNLKSLEAQAEKYSQKEDKYEEEIKILTDKLKEAETRAEFAERSVAKLEKTIDDLEDELYAQKLKYKAISEELDHALND'
    wta = ''
    for i in range(len(wt)): wta += 'A'
    data = lines2list('/home/bartolo/web/CC/tropomyosin/tropomyosin_seq_reordered.txt')
    for i in range(len(data)):
        res_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1) + '.res')
        cfg_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1) + '.cfg')
        preset_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1))
        coyote_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1) + '_coyote')
    counts_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1) + '_coyote_counts')
        #os.system('cp /home/bartolo/web/CC/tropo_ideal_r.cfg ' + cfg_path)
        #os.system('cp /home/bartolo/web/CC/tropo_ideal_r.res ' + res_path)
        os.system('/home/bartolo/web/build.py -statium_sidechain_coyote ' + preset_path + ' ' + coyote_path + ' REG 200')
        while True:
            njobs = coyote_count_jobs('speedy')
            if njobs < 400: break
            else: time.sleep(10)
    #os.system('/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path)
        #s = '/home/bartolo/web/build.py -statium_sidechain_coyote_compile ' + coyote_path + ' ' + counts_path + '\n' + '/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path + ' A\n'
        #sh_path = os.path.join(coyote_path, 'compile.sh')
        #of = open(sh_path, 'w')
        #of.write(s)
        #of.close()
        #os.system('chmod u+x ' + sh_path)
        #os.system('qsub -q speedy ' + sh_path)
        continue
        
        seq1 = data[i][0]
        #sstr1 = ''
        #for j in range(len(seq1)):
        
        #if seq1[j] == wt[j]:
            #sstr1 += seq1[j].lower()
        #else: sstr1 += seq1[j]

    path = os.path.join('/home/bartolo/web/CC/tropomyosin/seq', str(i + 1) + '.txt')
    of = open(path, 'w')
    of.write(seq1 + wta)
    of.close()
    pdb_path = os.path.join('/home/bartolo/web/CC/tropomyosin/pdb', 'tropomyosin_' + str(i + 1) + '.pdb')
    #print pdb_path
    print '/home/potapov/bin/scwrl4/Scwrl4 -i /home/bartolo/web/CC/tropo_ideal_r.pdb -o ' + pdb_path + ' -s ' + path

def BmyoS2_energy():
    
    ddata = lines2list('/home/bartolo/web/CC/dfire/energy.txt')

    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq_allL_ordered.txt')
    count = 0
    for i in range(len(data)):
        idxi = str(int(data[i][1]))
        preset_path = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1))
    mode = load_design_energy_sidechain(preset_path)
    seqi = data[i][0]
    for j in range(len(data)):
        seq = data[j][0]
        idxj = str(int(data[j][1]))
        e = statium_energy_calc_sidechain(mode, seq, 0.0)
        preset_pathj = os.path.join('/home/bartolo/web/CC/ideal/pdb', 'BmyoS2_' + str(i + 1))
        modej = load_design_energy_sidechain(preset_pathj)
        ej = statium_energy_calc_sidechain(modej, seqi, 0.0)
        etot = e + ej
        print i + 1, j + 1, etot
    print

def kinesin_energy():
    
    ddata = lines2list('/home/bartolo/web/CC/dfire/energy.txt')

    data = lines2list('/home/bartolo/web/CC/kinesin/kinesin_seq_reorder.txt')
    count = 0
    for i in range(len(data)):
        #idxi = str(int(data[i][1]))
        preset_path = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(i + 1))
    mode = load_design_energy_sidechain(preset_path)
    seqi = data[i][0]
    for j in range(len(data)):
        seq = data[j][0]
        #idxj = str(int(data[j][1]))
        e = statium_energy_calc_sidechain(mode, seq, 0.0)
        preset_pathj = os.path.join('/home/bartolo/web/CC/kinesin/pdb', 'kinesin_' + str(j + 1))
        modej = load_design_energy_sidechain(preset_pathj)
        ej = statium_energy_calc_sidechain(modej, seqi, 0.0)
        etot = e + ej
        print i + 1, j + 1, etot
    print

def BmyoS2_reorder():
  
    data = lines2list('/home/bartolo/web/CC/tropomyosin/tropomyosin_seq.txt')
    
    seqs = []
    seqs.append(data[0][0])
    

    while True:
        prcidG = 0.0
        find = ''
    for i in range(len(data)):
      
        seq = data[i][0]
        if seq in seqs: continue
        mtch = 0.0
        for j in range(len(seq)):
        if seq[j] == seqs[-1][j]: mtch += 1.0
        prcid = mtch / float(len(seq))
        if prcid > prcidG:
        find = seq
        prcidG = prcid
    seqs.append(find)
    if len(seqs) == len(data): break

    for i in range(len(seqs)): print seqs[i]

def bzip_aligns():
  
    data = lines2list('/home/bartolo/web/CC/unique_sequences.txt')
    
    for i in range(len(data)):
        L = len(data[i][1])
        name = data[i][0]
        
        preset_path = '/home/bartolo/web/CC/bzip/' + name
        coyote_path = '/home/bartolo/web/CC/bzip/' + name + '_coyote'
        counts_path = '/home/bartolo/web/CC/bzip/' + name + '_coyote_counts'
        s = '/home/bartolo/web/build.py -statium_sidechain_coyote_compile ' + coyote_path + ' ' + counts_path + '\n' + '/home/bartolo/web/build.py -convert_counts_sidechain ' + counts_path + ' ' + preset_path + ' A\n'
        sh_path = os.path.join(coyote_path, 'compile.sh')
        of = open(sh_path, 'w')
        of.write(s)
        of.close()
        os.system('chmod u+x ' + sh_path)
        os.system('qsub -q speedy ' + sh_path)
        continue
        statium_sidechain_coyote(preset_path, coyote_path, 'REG', 200, '/home/bartolo/web/build.py')
        while True:
            njobs = coyote_count_jobs('speedy')
            if njobs < 400: break
            else: time.sleep(60)
        continue
        pdb_path = '/net/crate-04/data/keating/potapov/structures/HPSC/' + name + '_' + name + '/backbone_scrwl.pdb'
        renumber_path = '/home/bartolo/web/CC/bzip/' + name + '.pdb'
        cfg_path = '/home/bartolo/web/CC/bzip/' + name + '.cfg'
        res_path = '/home/bartolo/web/CC/bzip/' + name + '.res'
    Renumber(1, 1, pdb_path, renumber_path)
    res_file(L + 1, L + L, res_path)
    of = open(cfg_path, 'w')
    of.write(str(L + 1) + '=0')
    of.close()
    
def bzip_energy():

    data = lines2list('/home/bartolo/web/CC/unique_sequences.txt')
    
    for i in range(len(data)):
        name1 = data[i][0]
        seq1 = data[i][1]
        L1 = len(seq1)
        preset_path1 = '/home/bartolo/web/CC/bzip/' + name1
        mode1 = load_design_energy_sidechain(preset_path1)
    for j in range(len(data)):
        name2 = data[j][0]
        seq2 = data[j][1]
        L2 = len(seq2)
        preset_path2 = '/home/bartolo/web/CC/bzip/' + name2
        #if not os.path.exists(preset_path2):
            #print 'no ' + name2
            #continue
        mode2 = load_design_energy_sidechain(preset_path2)
        seqe1 = ''
        for k in range(L1):
            try: seqe1 += seq2[k]
            except: seqe1 += 'X'
        seqe2 = ''
        for k in range(L2):
            try: seqe2 += seq1[k]
            except: seqe2 += 'X'
        e1 = statium_energy_calc_sidechain(mode1, seqe1, 0.0)
        e2 = statium_energy_calc_sidechain(mode2, seqe2, 0.0)
        print name1, name2, e1 + e2
        
        

def BmyoS2_energy_orig():

    preset_path = os.path.join('/home/bartolo/web/CC/orig/REG_CC', 'BmyoS2_2fxm')
    data = lines2list('/home/bartolo/web/CC/BmyoS2_seq_allL_ordered.txt')
    mode = load_design_energy(preset_path)
    for i in range(len(data)):
        seqi = data[i][0]
    for j in range(len(data)):
        seqj = data[j][0]
        e = statium_energy_calc_fullsequence(mode, seqi + seqj, 0.0)
        e2 = statium_energy_calc_fullsequence(mode, seqj + seqi, 0.0)
        print i + 1, j + 1, e + e2
    print

def MYC_energy():

    wt = 'RAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRALEKA'
    mode = load_design_energy_sidechain('/home/bartolo/web/CC/MYC/myc_1nkp')
    print statium_energy_calc_sidechain(mode, wt, 0.0)
    
def JF_energy():
    cc = 'fgabcdefgabcdefgabcdefgabcdefgabcdebcdefgafgabcdefgabcdefgabcdefgabcdefgabcdebcdefga'
    ps = 'ELTDTLQAETDQLEDEKSALQTEIANLLKEKEKLEFILAAHRELTDTLQAETDQLEDEKSALQTEIANLLKEKEKLEFILAAHR'
    wt = 'ERIARLEEKVKTLKAQNSELASTANMLREQVAQLKQKVMNHV'
    fos ='ELTDTLQAETDQLEDEKSALQTEIANLLKEKEKLEFILAAHR'
    mode = load_design_energy_sidechain('/home/bartolo/web/CC/bzip/FOS')
    print statium_energy_calc_sidechain(mode, fos, 0.0)

def libsize(p):
  
   data = lines2list(p)
   s = 1
   for i in range(len(data)):
       L = len(data[i][0])
       s = s * L
   print s
   
def natural_space():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/binder_align.txt')

    posy = []
    for i in range(23):
        posy.append([])
        for j in range(len(data)):
        if not data[j][0][i + 2] in posy[i]: posy[i].append(data[j][0][i + 2])

    size = 1
    for j in range(len(posy)):
        size = size * len(posy[j])
    print size
    
def biogrid(ipath, name, match_list):
  
    data = lines2list(ipath)
    ilist = []
    for i in range(len(data)):
        if data[i][7] == name:
        if data[i][8] in match_list and not data[i][8] in ilist:
            ilist.append(data[i][8])
    if data[i][8] == name:
        if data[i][7] in match_list and not data[i][7] in ilist:
            ilist.append(data[i][7])
            
    return ilist
    
def biogrid_alone(ipath, name):
  
    data = lines2list(ipath)
    ilist = []
    for i in range(len(data)):
        if data[i][7] == name:
        if not data[i][8] in ilist:
            ilist.append(data[i][8])
    if data[i][8] == name:
        if not data[i][7] in ilist:
            ilist.append(data[i][7])
    for name in ilist:
        print name
         
            
def biogrid_files():
  
    data = lines2list('/home/bartolo/web/CC/MYC2/BHLH_HUMAN_fullnr.txt')
    flist = []
    fseq = []
    for i in range(len(data)):
        flist.append(data[i][1])
        fseq.append(data[i][0])
    for i in range(len(flist)):
        name = flist[i]
        opath = os.path.join('/home/bartolo/web/CC/MYC2/biogrid/', name + '.txt')
        os.system('grep ' + name + ' /home/bartolo/web/biogrid/BIOGRID-ALL-3.2.100.tab2.txt > ' + opath)
        
        ilist = biogrid(opath, name, flist)
        istr = ''
        for thing in ilist: istr += thing + ','
        print fseq[i] + '\t' + flist[i] + '\t' + istr

def read_stat():

    data = lines2list('/home/bartolo/web/STATIUM_PAIR_DISTANCES.txt')

def BHLH_energy():
  
    data = lines2list('/home/bartolo/web/CC/MYC2/BHLH_HUMAN_fullnrIXNS.txt')
    mode_vec = []
    labels = ['MYC', 'MAX', 'MXD1', 'MYOD1', 'TCF3']
    wts = ['ELKRSFFALRDQIKVVILKKATAYILSVQAEEQKLISEEDLLRKRREQLKHKLEQL', 'HIKDSFHSLRDSVRAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRAL', 'HLRLCLEKLKGLVTLSLLTKAKLHIKKLEDCDRKAVHQIDQLQREQRHLKRQLEKL', 'KVNEAFETLKRCTKVEILRNAIRYIEGLQALLRDQDAAPPGAAAAFYAPGPLPPGR', 'DINEAFKELGRMCKLLILHQAVSVILNLEQQVRERNLNPKAACLKRREEEKVSGVV']
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/myc_1nkp'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/max_1nkp'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/mad_1nlw'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/myod1_1myd'))
    mode_vec.append(load_design_energy_sidechain('/home/bartolo/web/CC/MYC2/fullmyc/tcf3_2ql2'))

    mine = []
    maxe = []
    for i in range(len(mode_vec)): mine.append(1000.0)
    for i in range(len(mode_vec)): maxe.append(-1000.0)

    seqs = []
    names = []
    for i in range(len(data)):
        seq = data[i][0]
        for j in range(len(mode_vec)):
            e = statium_energy_calc_sidechain(mode_vec[j], seq, 0.0)
            if e < mine[j]: mine[j] = e
            if e > maxe[j]: maxe[j] = e

    for i in range(len(data)):
        seq = data[i][0]
        #if not data[i][1] in ['MGA', 'MAX', 'MXD1', 'MYCN', 'MYCL1', 'MXD4', 'MYC', 'MLX', 'MXI1', 'MXD3', 'MNT']
    
    try: x = data[i][2]
        except: continue
    print data[i][1]
    print data[i][2]
        print data[i][0]
        for j in range(len(mode_vec)):
            e = statium_energy_calc_sidechain(mode_vec[j], seq, 0.0)
            if data[i][1] in labels:
            idx = labels.index(data[i][1])
            self_seq = wts[j]
            eot = statium_energy_calc_sidechain(mode_vec[idx], self_seq, 0.0)
            e = (e + eot) / 2.0
            norm = (e - mine[j]) / (maxe[j] - mine[j])
            e_norm = -1.0 + norm * 2.0
            if j == len(mode_vec) - 1:
            print labels[j], str(round(e, 1)) + '  '
        else: print labels[j], str(round(e, 1)) + '  ',
        print
        
def BHLH_search():
  
    seq_path = '/home/bartolo/web/FLAT_FILES_072010/PROTEIN_SEQUENCES.txt'
    
    network_dicts = network_dictionaries()
    
    cc = '             defgabcdefgabcdefgabcdefgabcdefgabcdefgabcd'
    wt = 'RAQILDKATEYIQYMRRKNHTHQQDIDDLKRQNALLEQQVRAL'
  
    data = lines2list('/home/bartolo/web/CC/MYC2/BHLH_HUMAN_nr.txt')

    
    comp = []
    for i in range(len(data)):
        comp.append([data[i][1], [], []])

    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    for i in range(len(seqs)):
      
        #if i % 100 == 0: print float(i) / float(len(seqs)), 'finished.'
      
        name = seq_lines[seqs[i][1] - 2].strip()
        for j in range(len(name)):
        if name[j] == '|': pipe_idx = j
    namex = ''
    for j in range(pipe_idx + 1, len(name)): namex += name[j]
    
    ls_dict = network_dicts[1]
    try: shortname = ls_dict[namex]
    except: shortname = '??'
    
    prot_seq = seqs[i][0]
    for j in range(len(comp)):
        tseq = comp[j][0]
        found = False
        if tseq[0:13] in prot_seq and tseq[13:26] in prot_seq: found = True
        if not found: continue
        fin_idx = prot_seq.find(tseq[13:26])
        try: fseq = tseq[0:13] + prot_seq[fin_idx:fin_idx + 43]
        except: continue
        if len(fseq) != 56: continue
        if not fseq in comp[j][1]:
            comp[j][1].append(fseq)
            comp[j][2].append([shortname])
        else:
            if not shortname in comp[j][2][comp[j][1].index(fseq)]:
            comp[j][2][comp[j][1].index(fseq)].append(shortname)
    
    for i in range(len(comp)):
        for j in range(len(comp[i][1])):
        print comp[i][1][j],
        for k in range(len(comp[i][2][j])):
            print comp[i][2][j][k],
        print
        
def chimerize(idir, odir, n1, n2):
  
    ilist = os.listdir(idir)
    for name in ilist:
        numx = name.split('.')[0].split('_')[-3]
        numy = name.split('.')[0].split('_')[-2]
        if numy == n1:
        newp = os.path.join(odir, numx + '_' + n2 + '_probs.txt')
        oldp = os.path.join(idir, name)
        os.system('cp ' + oldp + ' ' + newp)
        
def load_BH3_conserve_matrix(align_path):
  
    data = lines2list(align_path)
    seqs = []
    for i in range(len(data)): seqs.append(data[i][0])
   
    matrix = []
    for i in range(len(seqs[0])):
        matrix.append([[], 0, 0.0])
        for j in range(20): matrix[i][0].append(0)
   
    for i in range(len(seqs)):
        seq = seqs[i]
        for j in range(len(seq)):
        aa = seq[j]
        if aa == 'C': aa = 'A'
        matrix[j][0][AAChar_int(aa)] += 1
        matrix[j][1] += 1
    
    for i in range(len(matrix)):
        for j in range(20):
        P = float(matrix[i][0][j]) / float(matrix[i][1])
        if P > 0.0: matrix[i][2] += -1.0 * P * math.log10(P)
    
    return matrix

def load_BH3_conserve_matrix2(align_path):
  
    data = lines2list(align_path)
    seqs = []
    for i in range(len(data)): seqs.append(data[i][0])
   
    matrix = []
    for i in range(len(seqs[0])):
        matrix.append([[], 0, 0.0])
        for j in range(20): matrix[i][0].append(0)
   
    for i in range(len(seqs)):
        seq = seqs[i]
        for j in range(len(seq)):
        aa = seq[j]
        matrix[j][0][AAChar_int(aa)] += 1
        matrix[j][1] += 1
    
    for i in range(len(matrix)):
        for j in range(20):
        P = float(matrix[i][0][j]) / float(matrix[i][1])
        if P > 0.0: matrix[i][2] += matrix[i][0][j]
    
    return matrix
        
def BH3_conserve_score(matrix, seq):
  
    score = 0
    for i in range(len(seq)):
        if not i in [4, 5, 7, 8, 9, 11, 12, 13, 14, 15]: continue
        aa = seq[i]
        if aa == 'C': aa = 'A'
        count = matrix[i][0][AAChar_int(aa)]
        P = float(count) / float(matrix[i][1])
        S = matrix[i][2]
        #print S
        if P > 0.0: score += 0.0#-1.0 * math.log10(P)
        else: score += 1 * (1.3 - S) 
        #if count > 0: score -= count
        #else: score += 5
        
    return float(score)
    
def BH3_conserve_score2(matrix, seq):
  
    score = 0
    for i in range(len(seq)):
        aa = seq[i]
        count = matrix[i][0][AAChar_int(aa)]
        P = float(count) / float(matrix[i][1])
        if P > 0.0: score += 1.0
        
    return float(score)
    
def process_mikko_cell():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/Mikko_data/X_raw.txt')

    vals = [[], [], [], []]
    
    for i in range(len(data)):
        for j in range(4):
        vals[j].append(data[i][1 + j])

    import pylab
    arrays = [pylab.array(vals[0]), pylab.array(vals[1]), pylab.array(vals[2]), pylab.array(vals[3])]

    ms = []
    for i in range(4): ms.append(mean(arrays[i]))
    ss = []
    for i in range(4): ss.append(std(arrays[i]))
    
    for i in range(len(data)):
        print data[i][0], '\t\t',
        for j in range(4):
        print round((data[i][1 + j] - ms[j]) / ss[j], 1), '\t',
    print

def process_mikko_cell2():
  
    data1 = lines2list('/home/bartolo/web/statium/all_array_analysis/Mikko_data/Xz_raw.txt')
    data2 = lines2list('/home/bartolo/web/statium/all_array_analysis/Mikko_data/Mz_raw.txt')

    for i in range(len(data1)):
        x = []
        for j in range(4): x.append(data1[i][1 + j])
        x.sort()
        xsc = (x[-1] + x[-2]) / 2.0
        m = []
        for j in range(4): m.append(data2[i][1 + j])
        m.sort()
        msc = (m[-1] + m[-2]) / 2.0
        
        print data1[i][0], '\t\t', round(xsc, 1), '\t', round(msc, 1)
        
def BH3_library():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/binder_align_tight.txt')

    pl = ['1g', '2a', '2b', '2c', '2d', '2e', '2f', '2g', '3a', '3b', '3c', '3d', '3e', '3f', '3g', '4a', '4b', '4c', '4d', '4e', '4f', '4g', '5a']

    v = []
    for i in range(23):
        v.append([])
        for j in range(20): v[i].append(0.0)
        
    for i in range(len(data)):
        for j in range(len(data[i][0])):
        aai = AAChar_int(data[i][0][j])
        v[j][aai] += 1.0

    s = 'pos' + '\t'
    for i in range(20): s += str(AAChar_fasta(i)) + '\t'
    s += '\n'
    for i in range(23):
        s += pl[i] + '\t'
        tot = 0.0
        for j in range(20): tot += v[i][j]
        for j in range(20):
        P = str(round(v[i][j] / tot, 2))
        s += P + '\t'
    s += '\n'
    
    print s
    
def plot_mikko():
  
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/Mikko_data/M_raw.txt')
    
    raw = []
    for i in range(len(data) - 1):
        #raw.append(data[i][1])
        #raw.append(data[i][2])
        raw.append((data[i][3] - 14.12) / 0.6551)
        raw.append((data[i][4] - 14.12) / 0.6551)

    import matplotlib
    matplotlib.use( 'Agg' )      
    import pylab
    
    pylab.rcParams['xtick.labelsize'] = '16'
    pylab.rcParams['ytick.labelsize'] = '16'
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('15')
        tick.label1.set_fontweight('bold')
    #pylab.xlim(-1.7, 7.25)  
    pylab.hist(raw, normed=True, facecolor='white', edgecolor='black', lw=2)
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/Mikko_data/plotM.png')
    
def raw_fluor(p1, num, lab):
  
    data = lines2list(p1)
    count = 0
    for i in range(len(data)):
        try:
            if data[i][0][0:4] == 'Temp':
            for j in range(num):
            print 'PERP' + lab + ':',
                for k in range(12):
               # print math.sqrt(data[i + 1 + (j * 2)][k] ** 2 + data[i + 1 + (j * 2) + 1][k] ** 2),
                print data[i + 1 + (j * 2)][k],
            print
                    print 'PARA' + lab + ':',
                    for k in range(12):        
            print data[i + 1 + (j * 2) + 1][k],
            print
            print
    except: continue
       
def luther_comp():

    import pylab
    pylab.rcParams['savefig.dpi'] = '300'
    pylab.rcParams['figure.figsize'] = (10, 8)
    pylab.rcParams['xtick.labelsize'] = '18'
    pylab.rcParams['ytick.labelsize'] = '18'
    pylab.rcParams['xtick.major.pad']='12'
    pylab.rcParams['ytick.major.pad']='12'
    pylab.rcParams['axes.linewidth'] = 3.0
    
    fig = pylab.figure()    # Create a figure
    ax = fig.gca()
    for tick in ax.xaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    for tick in ax.yaxis.get_major_ticks():
        tick.label1.set_fontsize('18')
        tick.label1.set_fontweight('bold')
    
    data = lines2list('/home/bartolo/web/statium/all_array_analysis/luther_comp.txt')
    x = []
    y = []
    for i in range(len(data)):
    x.append(math.log10(data[i][0]))
    y.append(math.log10(data[i][1]))
    pylab.xlim(0.2, 6.0)
    pylab.ylim(0.2, 4.0)
    pylab.scatter(x, y, c='k', marker='o', s=100, facecolor='none', edgecolors='k')
    pylab.plot([0.0, 6.0], [0.0, 6.0], '--', color='b', lw=1)

    
    pylab.savefig('/home/bartolo/web/statium/all_array_analysis/luther_comp.png')

def score_worm():
    
    egl1 = 'IAYEIASKLAAMCDDFDAQMMSY'

    ced9 = load_design_energy_sidechain('/home/bartolo/web/statium/worm/ced9_1ty4')

    wte = statium_energy_calc_sidechain(ced9, egl1, 0.0)

    data = lines2list('/home/bartolo/web/statium/worm/seq.txt')
    names = readlines('/home/bartolo/web/statium/worm/names.txt')

    for i in range(len(data)):
    if i % 20000 == 0: print float(i) / float(len(data))
    seq = data[i][0]
    e = statium_energy_calc_sidechain(ced9, seq, 0.0)
    if e < -10.0 and seq[13] == 'E':
        print seq, e
        print names[i].strip()

def process_worm():

    lines = readlines('/home/bartolo/web/statium/worm/c_elegans.PRJNA13758.WS237.protein.fa')
    of = open('/home/bartolo/web/statium/worm/c_elegans_proteins_nr.txt', 'w')
    start = False
 
    s = []   

    for line in lines:
    line = line.strip()
        if line[0] == '>':
        if start:
        if not seq in s:
            s.append(seq)
                of.write(name + '\n' + seq + '\n')
        start = True
        name = line
        seq = ''
    else: seq += line
    of.close()

def worm_peptides():

    seq_path = '/home/bartolo/web/statium/worm/c_elegans_proteins_nr.txt'
    
    wt = 'PEIWIAQELRRIGDEFNAYYARR'
    L = len(wt)
    
    seqs = []
    seq_lines = readlines(seq_path)
    count = 0
    for line in seq_lines:
        count += 1
        if count % 2 == 0:
        sub = []
        prot = line.strip()
        sub.append(prot)
        sub.append(count)
        seqs.append(sub)
    
    sout_path = '/home/bartolo/web/statium/worm/seq.txt'
    nout_path = '/home/bartolo/web/statium/worm/names.txt'
    soutfile = open(sout_path, 'w')
    noutfile = open(nout_path, 'w')
    
    seq_vec = []
    locs_vec = []
    for i in range(len(seqs)):
          
        prot_seq = seqs[i][0]
        if i % 100 == 0 and i > 0:
        print float(i) / float(len(seqs)), 'finished.', len(seq_vec), 'found.'
        
        seqL = len(prot_seq)
        for j in range(0, seqL - L + 1):
        seq = ''
        for k in range(L):
            aa = prot_seq[j + k]
            seq += aa
        
            chg = 0
            for k in range(len(wt)):
            if seq[k] in 'DEHKNQRST':
                chg += 1
        if chg < 8: continue
        
        if not seq[8] in 'FILVYWM': continue
        if not seq[12] in 'ACGS': continue
        
        if not seq in seq_vec:
            seq_vec.append(seq)
            else: continue
            
        soutfile.write(seq + '\t' + str(i + 1) + '\t' + str(j + 1) + '\n')
        noutfile.write(seq_lines[seqs[i][1] - 2].strip() + '\n')
    soutfile.close()
    noutfile.close()

def getprc():

    data = lines2list('/home/bartolo/web/statium/all_array_analysis/conservation/tally_ave.txt')

    for i in range(len(data)):
        if len(data[i]) == 2:
        print data[i - 1][0]
        print data[i][0], data[i][1] / data[i][0]
        print data[i + 1][0], (data[i][0] - data[i + 1][0]) / data[i + 1][0]
        print
    
def unique_file():

    data = lines2list('/home/bartolo/web/test.txt')
    unique = []
    for i in range(len(data)):
        name = data[i][0]
        if not name in unique: unique.append(name)
    for name in unique: print name

def search_COSMIC():

    data = lines2list('/home/bartolo/web/points_only.txt')

    found = [[], []]
    
    print 'Searching...'
    for i in range(len(data)):
    #if i % 1000 == 0: print float(i) / float(len(data))
    use = False
        for j in range(len(data[i])):
        try:
            if data[i][j].split('.')[0] == 'p' and AAChar_int(data[i][j].split('.')[1][0]) < 20 and AAChar_int(data[i][j].split('.')[1][-1]) < 20 and int(data[i][j].split('.')[1][1:len(data[i][j].split('.')[1])-1]) > -1:
            use = True
            mut = data[i][j].split('.')[1]
            gene = data[i][j - 4]
            if len(gene.split('_')) > 2: gene = data[i][j - 3]
            if len(gene.split('_')) == 2: gene = gene.split('_')[0]
            
            if not gene in found[0]:
            found[0].append(gene)
                found[1].append([mut])
            else:
            idx = found[0].index(gene)
            if not mut in found[1][idx]:
                found[1][idx].append(mut)
            break
            
        except: continue

    for i in range(len(found[0])):
    print found[0][i],
    for j in range(len(found[1][i])): print found[1][i][j],
    print

def matrix_correlation(p1, p2):

    d1 = lines2list(p1)   
    d2 = lines2list(p2)

    v1 = []
    v2 = []

    for i in range(20):
        for j in range(20):
        v1.append(d1[i + 1][j + 1])
        v2.append(d2[i + 1][j + 1])

    import pylab
    print pylab.corrcoef(pylab.array(v1), pylab.array(v2))[0][1]

def main():
    
    l = len(sys.argv)
    for i in range(0, l):
        if 0 < i:
        if sys.argv[i] == '-helix_probs': helix_probabilities()
        if sys.argv[i] == '-statium_sidechain_design2': statium_sidechain_design2()
        if sys.argv[i] == '-matrix_correlation':
            p1 = sys.argv[i + 1]
        p2 = sys.argv[i + 2]
        matrix_correlation(p1, p2)
        if sys.argv[i] == '-bcl2_random_peptides': bcl2_random_peptides()
        if sys.argv[i] == '-process_ipres': process_ipres()
        if sys.argv[i] == '-search_cosmic': search_COSMIC()
        if sys.argv[i] == '-unique_file': unique_file()
        if sys.argv[i] == '-array4paper': array4paper()
        if sys.argv[i] == '-getprc': getprc()
        if sys.argv[i] == '-worm_peptides': worm_peptides()
        if sys.argv[i] == '-score_worm': score_worm()
        if sys.argv[i] == '-process_worm': process_worm()
        if sys.argv[i] == '-spec_vmodel': statium_spec_vmodel()
        if sys.argv[i] == '-bcl2_svm': bcl2_svm()
        if sys.argv[i] == '-statium_svm': statium_svm()
        if sys.argv[i] == '-statium_spec_svm': statium_spec_svm()
        if sys.argv[i] == '-statium_spec_svm_orig': statium_spec_svm_orig()
        if sys.argv[i] == '-bcl2_simplest_peptides': bcl2_simplest_peptides()
        if sys.argv[i] == '-prep_data':
            prep_data()
        if sys.argv[i] == '-raw_fluor':
            p1 = sys.argv[i + 1]
        p2 = sys.argv[i + 2]
        lab = sys.argv[i + 3]
            raw_fluor(p1, int(p2), lab)
        if sys.argv[i] == '-structure_comp':
            residue_path = sys.argv[i + 1]
            pdb_path1 = sys.argv[i + 2]
            pdb_path2 = sys.argv[i + 3]
            structure_comp(residue_path, pdb_path1, pdb_path2)
        if sys.argv[i] == '-plot_mikko': plot_mikko()
        if sys.argv[i] == '-luther_comp': luther_comp()
        if sys.argv[i] == '-test_pred_parameters': test_pred_parameters()
        if sys.argv[i] == '-test_pred_parameters2': test_pred_parameters2()
        if sys.argv[i] == '-BH3_library': BH3_library()
        if sys.argv[i] == '-bcl2_end_peptides': bcl2_end_peptides()
        if sys.argv[i] == '-process_mikko_cell': process_mikko_cell2()
        if sys.argv[i] == '-measure': measure()
        if sys.argv[i] == '-biogrid_alone':
            ipath = sys.argv[i + 1]
            name = sys.argv[i + 2]
            biogrid_alone(ipath, name)
        if sys.argv[i] == '-chimerize':
            idir = sys.argv[i + 1]
            odir = sys.argv[i + 2]
            n1 = sys.argv[i + 3]
            n2 = sys.argv[i + 4]
            chimerize(idir, odir, n1, n2)
        if sys.argv[i] == '-BHLH_newpartners': BHLH_newpartners()
        if sys.argv[i] == '-BHLH_peptides': BHLH_peptides()
        if sys.argv[i] == '-biogrid_files': biogrid_files()
        if sys.argv[i] == '-BHLH_search': BHLH_search()
        if sys.argv[i] == '-BHLH_energy': BHLH_energy()
        if sys.argv[i] == '-read_stat': read_stat()
        if sys.argv[i] == '-MYC_peptides': MYC_peptides()
        if sys.argv[i] == '-biogrid': biogrid()
        if sys.argv[i] == '-MYC_search': MYC_search()
        if sys.argv[i] == '-sequence':
            p = sys.argv[i + 1]
            Sequence(p)
        if sys.argv[i] == '-tropo_matrix_ideal': tropo_matrix_ideal()
        if sys.argv[i] == '-natural_space': natural_space()
        if sys.argv[i] == '-kinesin_energy': kinesin_energy()
        if sys.argv[i] == '-libsize':
            p = sys.argv[i + 1]
            libsize(p)
        if sys.argv[i] == '-kinesin_peptides': kinesin_peptides2()
        if sys.argv[i] == '-JF_peptides': JF_peptides()
        if sys.argv[i] == '-JF_energy': JF_energy()
        if sys.argv[i] == '-MYC_energy': MYC_energy()
        if sys.argv[i] == '-kinesin_matrix_ideal': kinesin_matrix_ideal()
        if sys.argv[i] == '-BmyoS2_matrix_ideal': BmyoS2_matrix_ideal()
        if sys.argv[i] == '-bzip_energy': bzip_energy()
        if sys.argv[i] == '-bzip_aligns': bzip_aligns()
        if sys.argv[i] == '-BmyoS2_reorder': BmyoS2_reorder()
        if sys.argv[i] == '-BmyoS2_energy': BmyoS2_energy()
        if sys.argv[i] == '-BmyoS2_energy_orig': BmyoS2_energy_orig()
        if sys.argv[i] == '-BmyoS2_matrix': BmyoS2_matrix()
        if sys.argv[i] == '-BmyoS2_peptides': BmyoS2_sidechain_peptides()
        if sys.argv[i] == '-BmyoS2_peptides2': BmyoS2_sidechain_peptides2()
        if sys.argv[i] == '-BmyoS2': BmyoS2()
        if sys.argv[i] == '-process_compare_spots': process_compare_spots()
        if sys.argv[i] == '-process_BHRF1_spots': process_BHRF1_spots()
        if sys.argv[i] == '-plot_genome_enrich': plot_genome_enrich()
        if sys.argv[i] == '-plot_genome_roc': plot_genome_roc()
        if sys.argv[i] == '-natural_library': natural_library()
        if sys.argv[i] == '-genome_hit_corr': genome_hit_corr('zp')
        if sys.argv[i] == '-bfl1_pssm_design': bfl1_pssm_design()
        if sys.argv[i] == '-array_filter_analysis': array_filter_analysis()
        if sys.argv[i] == '-array5_bfl1': array5_bfl1()
        if sys.argv[i] == '-flart': flart()
        if sys.argv[i] == '-mean_error':
            ipath = sys.argv[i + 1]
            mean_and_error(ipath)
        if sys.argv[i] == '-zcomp': zcomp()
        if sys.argv[i] == '-bcl2_logos': bcl2_logos()
        if sys.argv[i] == '-trimage':
            idir = sys.argv[i + 1]
            odir = sys.argv[i + 2]
            trimage(idir, odir)
        if sys.argv[i] == '-add_control_data': add_control_data()
        if sys.argv[i] == '-tag_arrays': tag_all_arrays()
        if sys.argv[i] == '-paperAI': paper_ArrayI()
        if sys.argv[i] == '-paperAII': paper_ArrayII()
        if sys.argv[i] == '-deep_test':
            seq_path = sys.argv[i + 1]
            deep_test(seq_path)
        if sys.argv[i] == '-Mikko_scan': Mikko_scan()
        if sys.argv[i] == '-shortnames': shortnames()
        if sys.argv[i] == '-genome_histogrammies': genome_histogrammies()
        if sys.argv[i] == '-SPOT_prediction_plot': SPOT_prediction_PLOT()
        if sys.argv[i] == '-SPOT_prediction': SPOT_prediction()
        if sys.argv[i] == '-comp_array_all': compile_array_all()
        if sys.argv[i] == '-comp_array_charge': compile_array_charge()
        if sys.argv[i] == '-test_array_parameters':
            neg_cut = float(sys.argv[i + 1])
            pos_cut = float(sys.argv[i + 2])
            cntrl_cut = float(sys.argv[i + 3])
            px_cut = float(sys.argv[i + 4])
            pm_cut = float(sys.argv[i + 5])
            test_array_parameters(neg_cut, pos_cut, cntrl_cut, px_cut, pm_cut)
        if sys.argv[i] == '-comp_arrayI': compile_arrayI()
        if sys.argv[i] == '-comp_array5': compile_array5()
            if sys.argv[i] == '-comp_all_arrays':
                  ipath = sys.argv[i + 1]
              compile_all_arrays(ipath)
        if sys.argv[i] == '-bcl2_analysis': bcl2_analysis()
        if sys.argv[i] == '-bcl2_analysis_bars': bcl2_analysis_bars()
            if sys.argv[i] == '-skip3':
                  idir = sys.argv[i + 1]
                  odir = sys.argv[i + 2]
                  skip3(idir, odir)        
            if sys.argv[i] == '-edex':
                  idir = sys.argv[i + 1]
                  odir = sys.argv[i + 2]
                  start = int(sys.argv[i + 3])
                  edex(idir, odir, start)
        if sys.argv[i] == '-IQ_search': IQ_search()
        if sys.argv[i] == '-statium_sidechain_resopt':
            preset_dir = sys.argv[i + 1]
            out_dir = sys.argv[i + 2]
        statium_sidechain_resopt(preset_dir, out_dir)
        if sys.argv[i] == '-IQ_list': IQ_list()
        if sys.argv[i] == '-array5_barI': array5_barI()
        if sys.argv[i] == '-random_library':
              e_path = sys.argv[i + 1]
              wt = sys.argv[i + 2]
              out_path = sys.argv[i + 3]
              N = int(sys.argv[i + 4])
              random_library(e_path, wt, out_path, N)
        if sys.argv[i] == '-random_library_jmb':
              e_path = sys.argv[i + 1]
              wt = sys.argv[i + 2]
              out_path = sys.argv[i + 3]
              N = int(sys.argv[i + 4])
              random_library_jmb(e_path, wt, out_path, N)
        if sys.argv[i] == '-array5_analysis': array5_analysis()
        if sys.argv[i] == '-clean_array5_seq': clean_array5_seq()
        if sys.argv[i] == '-print_pssm': pssm_energy10_print_res()
        if sys.argv[i] == '-natural_pssm_position': natural_pssm_position()
        if sys.argv[i] == '-statium_calc':
            epath = sys.argv[i + 1]
            seq = sys.argv[i + 2]
            statiumcalc(epath, seq)
        if sys.argv[i] == '-statium_list_calc':
            epath = sys.argv[i + 1]
            seq_path = sys.argv[i + 2]
            statiumlistcalc(epath, seq_path)
        if sys.argv[i] == '-statium_calc_jmb':
            epath = sys.argv[i + 1]
            seq = sys.argv[i + 2]
            statiumcalc_jmb(epath, seq)
        if sys.argv[i] == '-statium_list_calc_jmb':
            epath = sys.argv[i + 1]
            seq_path = sys.argv[i + 2]
            statiumlistcalc_jmb(epath, seq_path)
        if sys.argv[i] == '-BH3_entropy_value':
            p = sys.argv[i + 1]
            frame = sys.argv[i + 2]
            print BH3_entropy_value(p, int(frame))
        if sys.argv[i] == '-bcl2_sidechain_peptides': bcl2_sidechain_peptides()
        if sys.argv[i] == '-hprd_align_all': hprd_align_all()
        if sys.argv[i] == '-hprd_align_all_back': hprd_align_all_back()
        if sys.argv[i] == '-bcl2_spot200_corr': bcl2_spot200_corr()
        if sys.argv[i] == '-bcl2_sidechain_spot200_corr': bcl2_sidechain_spot200_corr()
        if sys.argv[i] == '-statium_sidechain_design':
        epath = sys.argv[i + 1]
        epath2 = sys.argv[i + 2]
        epath3 = sys.argv[i + 3]
                lib_path = sys.argv[i + 4]
        specx = sys.argv[i + 5]
        specl = sys.argv[i + 6]
        if specl == 'True': spec = True
        else: spec = False
        statium_sidechain_design(epath, epath2, epath3, lib_path, specx, spec)
        if sys.argv[i] == '-statium_sidechain_design_repeat':
        epath = sys.argv[i + 1]
        epath2 = sys.argv[i + 2]
        epath3 = sys.argv[i + 3]
                lib_path = sys.argv[i + 4]
        specx = sys.argv[i + 5]
        specl = sys.argv[i + 6]
        if specl == 'True': spec = True
        else: spec = False
        statium_sidechain_design_repeat(epath, epath2, epath3, lib_path, specx, spec)
        if sys.argv[i] == '-array5_seq': array5_seq()
        if sys.argv[i] == '-bcl2_sidechain_genome_analysis': bcl2_sidechain_genome_analysis()
        if sys.argv[i] == '-bcl2_sidechain_genome_energies': bcl2_sidechain_genome_energies()
        if sys.argv[i] == '-bcl2_sidechain_genome_energies_MSA': bcl2_sidechain_genome_energies_MSA()
        if sys.argv[i] == '-bcl2_sidechain_genome_entropies': bcl2_sidechain_genome_entropies()
        if sys.argv[i] == '-cal_calc':
            epath = sys.argv[i + 1]
            seq = sys.argv[i + 2]
        calenergycalc(epath, seq)
        if sys.argv[i] == '-calhist':
            epath = sys.argv[i + 1]
            plot_path = sys.argv[i + 2]
        calhist(epath, plot_path)
        if sys.argv[i] == '-all_bcl2_energies':
            seq_path = sys.argv[i + 1]
            all_bcl2_energies(seq_path)
        if sys.argv[i] == '-bcl2_sidechain': bcl2_sidechain()
        if sys.argv[i] == '-infotest': info_test()
        if sys.argv[i] == '-store_pdb_info':
            pdb_path = sys.argv[i + 1]
        store_pdb_info(pdb_path)
        if sys.argv[i] == '-makadapie':
            plot_path = sys.argv[i + 1]
            val = float(sys.argv[i + 2])
            maka_da_pie(plot_path, val)
        if sys.argv[i] == '-ave_stat': ave_stat()
        if sys.argv[i] == '-array1_flow': array3_flow()
        if sys.argv[i] == '-mask':
            e_path = sys.argv[i + 1]
            ecut = float(sys.argv[i + 2])
        mask_pairs(e_path, ecut)
        if sys.argv[i] == '-GAI1_energy': GAI1_energy()
        if sys.argv[i] == '-calgenbar':
            e_path = sys.argv[i + 1]
            enrich_path = sys.argv[i + 2]
            plot_path = sys.argv[i + 3]
            Cal_genome_all_energy_bar(e_path, enrich_path, plot_path)
        if sys.argv[i] == '-campgenbar':
            e_path = sys.argv[i + 1]
            enrich_path = sys.argv[i + 2]
            plot_path = sys.argv[i + 3]
            CAMP_genome_all_energy_bar(e_path, enrich_path, plot_path)
        if sys.argv[i] == '-gai1genbar':
            epath = sys.argv[i + 1]
            enrich_path = sys.argv[i + 2]
            plot_path = sys.argv[i + 3]
            GAI1_genome_all_energy_bar(epath, enrich_path, plot_path)
        if sys.argv[i] == '-calgenhist':
            e_path = sys.argv[i + 1]
            plot_path = sys.argv[i + 2]
            elist_path = sys.argv[i + 3]
            Cal_genome_hist(e_path, plot_path, elist_path)
        if sys.argv[i] == '-TEM1_energy': TEM1_energy()
        if sys.argv[i] == '-CAMP_energy': CAMP_energy()
        if sys.argv[i] == '-process_gideon': process_gideon()
        if sys.argv[i] == '-BB_energy': BB_energy()
        if sys.argv[i] == '-Barnase_Barnstar': Barnase_Barnstar()
        if sys.argv[i] == '-process_fersht': process_fersht()
        if sys.argv[i] == '-scand_matrix': scand_matrix()
        if sys.argv[i] == '-scanergy': scanergy()
        if sys.argv[i] == '-scan_sort': scan_sort()
        if sys.argv[i] == '-cal_sim_lib': cal_sim_lib()
        if sys.argv[i] == '-conc_grad':
            start = float(sys.argv[i + 1])
            dilex = float(sys.argv[i + 2])
            filex = float(sys.argv[i + 3])
        conc_grad(start, dilex, filex)
        if sys.argv[i] == '-conc_grad6':
            start = float(sys.argv[i + 1])
            dilex = float(sys.argv[i + 2])
            filex = float(sys.argv[i + 3])
        conc_grad6(start, dilex, filex)
        if sys.argv[i] == '-plate_line':
            path = sys.argv[i + 1]
            line = int(sys.argv[i + 2])
            exp = sys.argv[i + 3]
            plate_line(path, line, exp)
        if sys.argv[i] == '-FP_conc': FP_conc()
        if sys.argv[i] == '-hprd_align':
            blast_path = sys.argv[i + 1]
            out_path = sys.argv[i + 2]
            hprd_alignment(blast_path, out_path)
        if sys.argv[i] == '-mammalia_list': mammalia_list()
        if sys.argv[i] == '-blast_hprd':
            rang = sys.argv[i + 1]
            blast_hprd(rang)
        if sys.argv[i] == '-process_sape': process_SAPE()
        if sys.argv[i] == '-process_array4': process_array4()
        if sys.argv[i] == '-process_array2': process_array2()
        if sys.argv[i] == '-mdmpep': MDM_get_proteome_peptides()
        if sys.argv[i] == '-mdxe': mdx_energy()
        if sys.argv[i] == '-mdme': mdm_energy()
        if sys.argv[i] == '-calpie': Calmodulin_pie()
        if sys.argv[i] == '-calscreen': Calmodulin_screening()
        if sys.argv[i] == '-calih_overlap': calih_overlap()
        if sys.argv[i] == '-calih_collect': calih_collect()
        if sys.argv[i] == '-calih_coyote': Calih_coyote()
        if sys.argv[i] == '-calih':
            p = sys.argv[i + 1]
            op = sys.argv[i + 2]
            Calmodulin_interaction_homology(p, op)
        if sys.argv[i] == '-calmodulin_network': Calmodulin_network_analysis()
        if sys.argv[i] == '-GAI1_network': GAI1_network_analysis()
        if sys.argv[i] == '-CAMP_network': CAMP_network_analysis()
        if sys.argv[i] == '-MDM_network': MDM_network_analysis()
        if sys.argv[i] == '-get_proteome_peptides':
        get_calmodulin_proteome_peptides()
        if sys.argv[i] == '-get_1cdlproteome_peptides':
        get_calmodulin1cdl_proteome_peptides()
        if sys.argv[i] == '-get_CAMP_proteome_peptides':
        get_CAMP_proteome_peptides()
        if sys.argv[i] == '-get_GAI1_proteome_peptides':
        get_GAI1_proteome_peptides()
        if sys.argv[i] == '-cal_genome_energy':
        Cal_genome_all_energy()
        if sys.argv[i] == '-MDM_genome_energy':
        MDM_genome_all_energy()
        if sys.argv[i] == '-calmode':
        calmodulin_energy()
        if sys.argv[i] == '-array4':
        array4()
        if sys.argv[i] == '-entropy_plot':
            p = sys.argv[i + 1]
            op = sys.argv[i + 2]
            frame0 = sys.argv[i + 3]
        r = sys.argv[i + 4]
        BH3_entropy_plot(p, op, int(frame0), r)
        if sys.argv[i] == '-general_entropy_plot':
            p = sys.argv[i + 1]
            op = sys.argv[i + 2]
            frame0 = sys.argv[i + 3]
        general_entropy_plot(p, op, int(frame0))
        if sys.argv[i] == '-BH3_entropies':
        BH3_entropies()
        if sys.argv[i] == '-screen_bar':
            idx = sys.argv[i + 1]
            path = sys.argv[i + 2]
            screen_bar(int(idx), path)
        if sys.argv[i] == '-uniprot_align':
            ip = sys.argv[i + 1]
            uniprot_align(ip)
        if sys.argv[i] == '-genome_ordering': genome_ordering()
        if sys.argv[i] == '-uniprot_blast':
            ip = sys.argv[i + 1]
            uniprot_blast(ip)
        if sys.argv[i] == '-uniprot': uniprot()
        if sys.argv[i] == '-pfam_uniprot': pfam_uniprot()
        if sys.argv[i] == '-screen_outnetwork': screen_outnetwork()
        if sys.argv[i] == '-complete_genome_sorting': complete_genome_sorting()
        if sys.argv[i] == '-score_genomic_bh3s': score_genomic_bh3s()
        if sys.argv[i] == '-bcl2_homology':
            bcl2_homology()
        if sys.argv[i] == '-FP_archives':
            query = sys.argv[i + 1]
            plot_path = sys.argv[i + 2]
            FP_archives(query, plot_path)
            if sys.argv[i] == '-FP_archivesL':
                query = sys.argv[i + 1]
        option = sys.argv[i + 2]
        FP_archivesL(query, option)
            if sys.argv[i] == '-FP_archivesBD':
                query = sys.argv[i + 1]
                FP_archivesBD(query)
        if sys.argv[i] == '-FP_archivesL_plot':
                query = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
                FP_archivesL_plot(query, out_path)
        if sys.argv[i] == '-direct_binding_anis': direct_binding_anis()
        if sys.argv[i] == '-test_fit': test_fit()
        if sys.argv[i] == '-deep_duplicates':
            deep_duplicates()
        if sys.argv[i] == '-analyze_bootstrap': analyze_bootstrap()
        if sys.argv[i] == '-analyze_bootstrap_enrich': analyze_bootstrap_enrich()
        if sys.argv[i] == '-bootstrap_auc':
            op = sys.argv[i + 1]
            nstraps = int(sys.argv[i + 2])
            vp = sys.argv[i + 3]
            val0 = float(sys.argv[i + 4])
            bootstrap_auc(op, nstraps, vp, val0)
        if sys.argv[i] == '-bootstrap_enrich':
            op = sys.argv[i + 1]
            nstraps = int(sys.argv[i + 2])
            vp = sys.argv[i + 3]
            val0 = float(sys.argv[i + 4])
            bootstrap_enrich(op, nstraps, vp, val0)
        if sys.argv[i] == '-R_hist': R_hist()
        if sys.argv[i] == '-genome_sorting2': genome_sorting2()
        if sys.argv[i] == '-find_interactions':
        receptor = sys.argv[i + 1]
        target = sys.argv[i + 2]
        base = int(sys.argv[i + 3])
            find_interactions(receptor, target, base)
        if sys.argv[i] == '-genome_sorting':
            ridx = int(sys.argv[i + 1])
            genome_sorting(ridx)
        if sys.argv[i] == '-pssm_affinity_pred': pssm_affinity_pred()
        if sys.argv[i] == '-deep_affinity_pred': deep_affinity_pred()
        if sys.argv[i] == '-statium_affinity_pred': statium_affinity_pred()
        if sys.argv[i] == '-pssm_enrich': pssm_enrich()
        if sys.argv[i] == '-statium_enrich': statium_enrich()
        if sys.argv[i] == '-deep_enrich': deep_enrich()
        if sys.argv[i] == '-mx_spec_express': mx_spec_express()
        if sys.argv[i] == '-mx_express': mx_express()
        if sys.argv[i] == '-w2express': w2express()
        if sys.argv[i] == '-fexpress': fexpress()
        if sys.argv[i] == '-w2_express': w2_express()
        if sys.argv[i] == '-f_express': f_express()
        if sys.argv[i] == '-pbn': PSSM_bad_noxa()
        if sys.argv[i] == '-fwhat': bfl1_what()
        if sys.argv[i] == '-sort_nir': sort_Nir()
        if sys.argv[i] == '-compo': compo()
        if sys.argv[i] == '-hd': hist_double()
        if sys.argv[i] == '-e9': E9_ILP()
        if sys.argv[i] == '-ipair':
        preset_path = sys.argv[i + 1]
        interacting_pairs(preset_path)
        if sys.argv[i] == '-genome_all': BH3_genome_all()
        if sys.argv[i] == '-genome_all_energy': BH3_genome_all_energy()
        if sys.argv[i] == '-genome_search': genome_search()
        if sys.argv[i] == '-allowedf': allowedf()
        if sys.argv[i] == '-sort_corr': sort_corr()
        if sys.argv[i] == '-seqint':
            p = sys.argv[i + 1]
            seqint(p)
        if sys.argv[i] == '-spec360_4plot': spec360_4plot()
        if sys.argv[i] == '-XM360_4plot': XM360_4plot()
        if sys.argv[i] == '-general_deep_sort': general_deep_sort()
        if sys.argv[i] == '-library_predict': library_predict()
        if sys.argv[i] == '-noxa_spots': noxa_spots()
        if sys.argv[i] == '-arrayIII_bar': arrayIII_bar()
        if sys.argv[i] == '-arrayIII': process_ArrayIII()
        if sys.argv[i] == '-print_pair':
        p = sys.argv[i + 1]
        a2 = sys.argv[i + 2]
        print_pair_energy(p, a2)
        if sys.argv[i] == '-coyote_convert_counts':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        ref_flag = sys.argv[i + 3]
        ncalc = int(sys.argv[i + 4])
        coyote_convert_counts(counts_dir, out_dir, ref_flag, ncalc, sys.argv[0])
        if sys.argv[i] == '-load_gen2_counts':
        counts_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        ref_flag = sys.argv[i + 3]
        load_gen2_counts(counts_path, out_path, ref_flag)
        if sys.argv[i] == '-delta_auc': delta_auc()
        if sys.argv[i] == '-plot_params': plot_params()
        if sys.argv[i] == '-w2_sort':
        p1 = sys.argv[i + 1]
        p2 = sys.argv[i + 2]
        op = sys.argv[i + 3]
            w2_sort(p1, p2, op)
        if sys.argv[i] == '-yeast_w2':
        ip = sys.argv[i + 1]
        op = sys.argv[i + 2]
        translate_w2_data(ip, op)
        if sys.argv[i] == '-structure_info':
        pdb_path = sys.argv[i + 1]
        seqdata_path = sys.argv[i + 2]
        structure_info(pdb_path, seqdata_path)
        if sys.argv[i] == '-fsort2':
        bfl1_seq_sort2()
        if sys.argv[i] == '-fsort':
        ip = sys.argv[i + 1]
        op = sys.argv[i + 2]
        bfl1_seq_sort(ip, op)
        if sys.argv[i] == '-deep_refine':
        PSSM_DEEP_refine()
        if sys.argv[i] == '-ccsort':
        ip = sys.argv[i + 1]
        op = sys.argv[i + 2]
        ccsort(ip, op)
        if sys.argv[i] == '-print_pw':
        pdb_path = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
        pw_matrix(pdb_info(pdb_path, seq_path))
        if sys.argv[i] == '-dup_seq':
        ip = sys.argv[i + 1]
        dup_seq(ip)
        if sys.argv[i] == '-compile_classy':
        sold = sys.argv[i + 1]
        lib_path = sys.argv[i + 2]
        rstr = sys.argv[i + 3]
        compile_classy(sold, lib_path, rstr)
        if sys.argv[i] == '-compile_classy_sidechain':
        sold = sys.argv[i + 1]
        lib_path = sys.argv[i + 2]
        rstr = sys.argv[i + 3]
        compile_classy_sidechain(sold, lib_path, rstr)
        if sys.argv[i] == '-config_classy':
        rstr = sys.argv[i + 1]
        lib_path = sys.argv[i + 2]
        odir = sys.argv[i + 3]
        run_str = sys.argv[i + 4]
        config_classy(rstr, lib_path, odir, run_str)
        if sys.argv[i] == '-config_classy_sidechain':
        rstr = sys.argv[i + 1]
        lib_path = sys.argv[i + 2]
        odir = sys.argv[i + 3]
        its = int(sys.argv[i + 4])
        gap = float(sys.argv[i + 5])
        localx = float(sys.argv[i + 6])
        config_classy_sidechain(rstr, lib_path, odir, its, gap, localx)
        if sys.argv[i] == '-combine_classy':
            in_dirs = []
        in_dirs.append(sys.argv[i + 1])
        in_dirs.append(sys.argv[i + 2])
        in_dirs.append(sys.argv[i + 3])
        in_dirs.append(sys.argv[i + 4])
        combine_classy(in_dirs, sys.argv[i + 5])
        if sys.argv[i] == '-delete_coyote': delete_coyote()
        if sys.argv[i] == '-analyze_classy':
        in_dir = sys.argv[i + 1]
            analyze_classy(in_dir)
        if sys.argv[i] == '-classy_sweep':
        rstr = sys.argv[i + 1]
        od = sys.argv[i + 2]
        q = sys.argv[i + 3]
        classy_sweep(rstr, od, q)
        if sys.argv[i] == '-plot_su':
        su = sys.argv[i + 1]
        sun = sys.argv[i + 2]
        stephanie(su, sun)
        if sys.argv[i] == '-plot_spec':
        in_path = sys.argv[i + 1]
        op = sys.argv[i + 2]
        plot_spec(in_path, op)
        if sys.argv[i] == '-plot_classy':
        in_path = sys.argv[i + 1]
        rstr = sys.argv[i + 2]
        op = sys.argv[i + 3]
        plot_classy(in_path, rstr, op)
        if sys.argv[i] == '-classy_config':
        preset = sys.argv[i + 1]
        print statium_classy_config(preset)
        if sys.argv[i] == '-libars':
        p1 = sys.argv[i + 1]
            libars(p1)
        if sys.argv[i] == '-libar':
        p1 = sys.argv[i + 1]
            libar(p1)
        if sys.argv[i] == '-compare_libs':
        lp = sys.argv[i + 1]
        compare_libs(lp)
        if sys.argv[i] == '-library_design':
        preset = sys.argv[i + 1]
        preset_spec = sys.argv[i + 2]
            sample_bh3_dna_library(preset, preset_spec)
        if sys.argv[i] == '-prot_bh3_library_design':
        preset = sys.argv[i + 1]
        preset_spec = sys.argv[i + 2]
            sample_bh3_prot_library(preset, preset_spec)
        if sys.argv[i] == '-bh3_natural':
        BH3_natural()
        if sys.argv[i] == '-fast_stat':
        preset = sys.argv[i + 1]
        fast_statium_energy(preset)
        if sys.argv[i] == '-stat_pos':
        preset = sys.argv[i + 1]
        statium_position_energy(preset)
        if sys.argv[i] == '-feather_nest':
        feather_nest2()
        if sys.argv[i] == '-seq2aaint':
        seq_path = sys.argv[i + 1]
        seqdata2AAint(seq_path)
        if sys.argv[i] == '-statium_config':
        preset = sys.argv[i + 1]
        statium_config(preset)
        if sys.argv[i] == '-statium_sidechain_config':
        preset = sys.argv[i + 1]
        statium_config_sidechain(preset)
        if sys.argv[i] == '-statium_general_config':
        preset = sys.argv[i + 1]
        statium_general_config(preset)
        if sys.argv[i] == '-statium_bench':
            opath = sys.argv[i + 1]
        statium_bench(opath)
        if sys.argv[i] == '-pssm_bench':
            opath = sys.argv[i + 1]
        pssm_bench(opath)
        if sys.argv[i] == '-deep_bench':
            opath = sys.argv[i + 1]
        deep_bench(opath)
        if sys.argv[i] == '-deep_cbench':
            opath = sys.argv[i + 1]
        deep_bench_coupling(opath)
        if sys.argv[i] == '-parse_fp_comp':
        ip = sys.argv[i + 1]
        cp = sys.argv[i + 2]
        rows = sys.argv[i + 3]
        pp = sys.argv[i + 4]
        parse_FP_comp(ip, cp, rows, pp)
        if sys.argv[i] == '-parse_fp_direct':
        ip = sys.argv[i + 1]
        cp = sys.argv[i + 2]
        rows = sys.argv[i + 3]
        pp = sys.argv[i + 4]
        parse_FP_direct(ip, cp, rows, pp)
        if sys.argv[i] == '-fp_conc': 
        start_nm = float(sys.argv[i + 1])
        points = int(sys.argv[i + 2])
        FP_comp_concentration(start_nm, points)
        if sys.argv[i] == '-bh3_pi':      
        in_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        BH3_PI(in_path, out_path)
        if sys.argv[i] == '-stat_pos_eval':      
        rdir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
            STATIUM_position_eval(rdir, seq_path, out_dir)
        if sys.argv[i] == '-arrayII':
        arrayII()
        if sys.argv[i] == '-bh3_hist':      
        p1 = sys.argv[i + 1]
        p2 = sys.argv[i + 2]
        BH3_hist(p1, p2)
        if sys.argv[i] == '-spot_ratio':      
        p1 = sys.argv[i + 1]
        r = sys.argv[i + 2]
        SPOT_ratio(p1, r)
        if sys.argv[i] == '-BH3_design':
        BH3_statium_design()
        if sys.argv[i] == '-BH3_spec_design':
            rstr = sys.argv[i + 1]
        specx = float(sys.argv[i + 2])
        op = sys.argv[i + 3]
        BH3_spec_sample(rstr, specx, op)
        if sys.argv[i] == '-design_sample':      
        p1 = sys.argv[i + 1]
        design_sampler(p1)
        if sys.argv[i] == '-BH3_search':      
        o = sys.argv[i + 1]
        search_BH3_list(o)
        if sys.argv[i] == '-xm_pred':      
        p1 = sys.argv[i + 1]
            XMpred(p1)
        if sys.argv[i] == '-glenna_test':
        seq = sys.argv[i + 1]
        print glenna_test(seq)
        if sys.argv[i] == '-spot_log_plot':      
        p1 = sys.argv[i + 1]
            SPOT_log_plot(p1)
        if sys.argv[i] == '-spot_log':      
        p1 = sys.argv[i + 1]
        r = sys.argv[i + 2]
        stat_dir = sys.argv[i + 3]
        names = sys.argv[i + 4]
        op = sys.argv[i + 5]
        SPOT_log(p1, r, stat_dir, names, op)
        if sys.argv[i] == '-tempf':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        tempf(n1, n2)
        if sys.argv[i] == '-tempf2':
        p1 = sys.argv[i + 1]
        tempf2(p1)
        if sys.argv[i] == '-tempf3':
        p1 = sys.argv[i + 1]
        tempf3(p1)
        if sys.argv[i] == '-combine_compare':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        combine_compare(n1, n2)        
        if sys.argv[i] == '-roc_plots':
        ROC_plots()
        if sys.argv[i] == '-roc_plot':
        ROC_plot()
        if sys.argv[i] == '-stat_spot':
        stat_spot()
        if sys.argv[i] == '-card_hist':
        CARD_hist()
        if sys.argv[i] == '-card_2face':
        CARD_2face()
        if sys.argv[i] == '-spot_file':
        op = sys.argv[i + 1]
        SPOT_file(op)
        if sys.argv[i] == '-spot360_file':
        op = sys.argv[i + 1]
        SPOT360_file(op)
        if sys.argv[i] == '-spot_corr':
        op = sys.argv[i + 1]
        SPOT_correlation(op)
        if sys.argv[i] == '-spot_convert':
        op = sys.argv[i + 1]
        spot_convert(op)
        if sys.argv[i] == '-append_column':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        n3 = sys.argv[i + 3]
        append_column(n1, n2, n3)
        if sys.argv[i] == '-card_card':
        CARD_CARD_energies()
        if sys.argv[i] == '-card_dimers':
        CARD_dimers()
        if sys.argv[i] == '-kill_coyote':
        kill_coyote()
        if sys.argv[i] == '-orr_cpl':
        Orr_cpl()
        if sys.argv[i] == '-orr_cple':
        n1 = sys.argv[i + 1]
        Orr_cple(n1)
        if sys.argv[i] == '-orr_process':
        n1 = sys.argv[i + 1]
        Orr_process(n1)
        if sys.argv[i] == '-orr_energy':
        Orr_energy()
        if sys.argv[i] == '-orr_submit':
        Orr_submit()
        if sys.argv[i] == '-stat_ref':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        stat_ref(n1, n2)
        if sys.argv[i] == '-orr_energies':
        n1 = sys.argv[i + 1]
        Orr_energies(n1)
        if sys.argv[i] == '-orr_align':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        n3 = sys.argv[i + 3]
        n4 = sys.argv[i + 4]
        Orr_align(n1, n2, n3, n4)
        if sys.argv[i] == '-png_gif':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        png_gif(n1, n2)
        if sys.argv[i] == '-resnum':
        n1 = sys.argv[i + 1]
        n2 = sys.argv[i + 2]
        op = sys.argv[i + 3]
        res_file(n1, n2, op)
        if sys.argv[i] == '-gamma':
        n = float(sys.argv[i + 1])
        gamma(n)
        if sys.argv[i] == '-rink':
        ifi = sys.argv[i + 1]
        ofi = sys.argv[i + 2]
        rink(ifi, ofi)
        if sys.argv[i] == '-pearsonp':
        r = float(sys.argv[i + 1])
        n = float(sys.argv[i + 2])
        pearsonP(r, n)
        if sys.argv[i] == '-linenum':
        ifi = sys.argv[i + 1]
        ofi = sys.argv[i + 2] 
        line_num(ifi, ofi)
        if sys.argv[i] == '-cdp':
        d = sys.argv[i + 1]
        p = sys.argv[i + 2] 
        comp_deepe_pssm(d, p)
        if sys.argv[i] == '-unsampled_yeast':
        unsampled_yeast()
        if sys.argv[i] == '-deep_total':
        in_dir = sys.argv[i + 1]
        out_path = sys.argv[i + 2] 
        deep_total_nr(in_dir, out_path)
        if sys.argv[i] == '-phelix': Phelix()
        if sys.argv[i] == '-redund':
        ini = sys.argv[i + 1]
        oti = sys.argv[i + 2] 
            non_redundant(ini, oti)
        if sys.argv[i] == '-yes':
        p1 = sys.argv[i + 1]
        e1 = sys.argv[i + 2] 
        p2 = sys.argv[i + 3]
        e2 = sys.argv[i + 4]
        o = sys.argv[i + 5] 
        yeast_comp_scatter(p1, e1, p2, e2, o)
        if sys.argv[i] == '-ave_en':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]  
        op = sys.argv[i + 3]  
        average_energies(f1, f2, op)
        if sys.argv[i] == '-normalize':
        ip = sys.argv[i + 1]
        op = sys.argv[i + 2] 
        normalize_data(ip, op)
        if sys.argv[i] == '-combine_lines':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]  
        op = sys.argv[i + 3]  
        combine_lines(f1, f2, op)
        if sys.argv[i] == '-filter_lists':
        l1p = sys.argv[i + 1]
        l2p = sys.argv[i + 2]  
        l3p = sys.argv[i + 3]  
        op = sys.argv[i + 4]  
            filter_lists(l1p, l2p, l3p, op)
        if sys.argv[i] == '-deep_coupling':
        seq_path = sys.argv[i + 1]
        eval_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        deep_coupling(seq_path, eval_path, out_path)
        if sys.argv[i] == '-find_forbid':
        stat = sys.argv[i + 1]
        pssm = sys.argv[i + 2]
        find_forbidden(stat, pssm)
        if sys.argv[i] == '-deep_spec':
        mpath = sys.argv[i + 1]
        xpath = sys.argv[i + 2]
        deep_spec_search(mpath, xpath)
        if sys.argv[i] == '-deep_affin':
        mpath = sys.argv[i + 1]
        xpath = sys.argv[i + 2]
        deep_affin_search(mpath, xpath)
        if sys.argv[i] == '-deep_forbid_spec':
        mpath = sys.argv[i + 1]
        xpath = sys.argv[i + 2]
        deep_forbid_spec_search(mpath, xpath)
        if sys.argv[i] == '-yeast_allowed_loop':
        idir = sys.argv[i + 1]
        odir = sys.argv[i + 2]
        yeast_allowed_loop(idir, odir)
        if sys.argv[i] == '-yeast_not_allowed_loop':
        idir = sys.argv[i + 1]
        odir = sys.argv[i + 2]
        yeast_not_allowed_loop(idir, odir)
        if sys.argv[i] == '-yeast_allowed':
        inf = sys.argv[i + 1]
        ouf = sys.argv[i + 2]
        r = sys.argv[i + 3]
        yeast_allowed(inf, ouf, r)
        if sys.argv[i] == '-pdz_energy':
        preset_dir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        PDZ_energy(preset_dir, seq_path, out_path)
        if sys.argv[i] == '-deep_search':
        ipath = sys.argv[i + 1]
        idir = sys.argv[i + 2]
        bcl2_deep_search(ipath, idir)
        if sys.argv[i] == '-bcl2_deep':
        inf = sys.argv[i + 1]
        of = sys.argv[i + 2]
        r = sys.argv[i + 3]
        bcl2_deep_sequencing(inf, of, r)
        if sys.argv[i] == '-dfire_spot':
        dfire_path = sys.argv[i + 1]
        data_path = sys.argv[i + 2]
        r = sys.argv[i + 3]
        dfire_spot200(dfire_path, data_path, r)
        if sys.argv[i] == '-get_features':
        tools_path = sys.argv[i + 1]
        pdb_path = sys.argv[i + 2]
        opath = sys.argv[i + 3]
        general_trim_dssp(tools_path, pdb_path, opath)
        if sys.argv[i] == '-trim_dssp':
        pdb_path = sys.argv[i + 1]
        opath = sys.argv[i + 2]
        trim_dssp(pdb_path, opath)
        if sys.argv[i] == '-info2':
        pdb_path = sys.argv[i + 1]
        seqdata_path = sys.argv[i + 2]
            print pdb_info2(pdb_path, seqdata_path)
        if sys.argv[i] == '-statium_coils':
        preset_dir = sys.argv[i + 1]
        statium_coils(preset_dir)
        if sys.argv[i] == '-statium_pdz':
        preset_dir = sys.argv[i + 1]
        statium_PDZ(preset_dir)    
        if sys.argv[i] == '-coil_pdb':
        idir = sys.argv[i + 1]
        odir = sys.argv[i + 2]
        coil_pdb(idir, odir)
        if sys.argv[i] == '-yeast_full':
        infile = sys.argv[i + 1]
        yeast_full_spec(infile)
        if sys.argv[i] == '-yeast_hist':
        m = sys.argv[i + 1]
        b = sys.argv[i + 2]
        c1 = sys.argv[i + 3]
        c2 = sys.argv[i + 4]
        o = sys.argv[i + 5]
        r = sys.argv[i + 6]
        yeast_hist(m, b, c1, c2, o, r)
        if sys.argv[i] == '-simulate_yeast':
        simulate_yeast()
        if sys.argv[i] == '-simulate_fyeast':
        simulate_bfl1_library()
        if sys.argv[i] == '-simulate_w2yeast': simulate_w2_library()
        if sys.argv[i] == '-yeast_scatter':
        m = sys.argv[i + 1]
        b = sys.argv[i + 2]
        o = sys.argv[i + 3]
            luther_yeast_scatter(m, b, o)
        if sys.argv[i] == '-yeast_dir':
        d = sys.argv[i + 1]
        o = sys.argv[i + 2]
            yeast_dir(d, o)
        if sys.argv[i] == '-dfire_yeast':
        mm = sys.argv[i + 1]
        mb = sys.argv[i + 2]
        bm = sys.argv[i + 3]
        bb = sys.argv[i + 4]
        dfire_yeast(mm, mb, bm, bb)
        if sys.argv[i] == '-name_yeast':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]
            name_yeast(f1, f2)
        if sys.argv[i] == '-bcl2_scan':
        seq_path = sys.argv[i + 1]
            bcl2_scan(seq_path)
        if sys.argv[i] == '-bcl2_search':
        seq_path = sys.argv[i + 1]
            bcl2_search(seq_path)
        if sys.argv[i] == '-dfire':
        pdb_path = sys.argv[i + 1]
        print DFIRE(pdb_path)
        if sys.argv[i] == '-luther_yeast':
        m = sys.argv[i + 1]
        b = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        luther_yeast(m, b, out_path)
        if sys.argv[i] == '-find_bh3':
        in_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        find_BH3(in_path, out_path)
        if sys.argv[i] == '-luther':
        data_path = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        luther(data_path, out_dir)
        if sys.argv[i] == '-luther_pos':
        data_path = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        luther_pos(data_path, out_dir)
        if sys.argv[i] == '-bcl2_listing':
        data_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        bcl2_listing(data_path, out_path)
        if sys.argv[i] == '-bcl2_list':
        data_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        bcl2_list(data_path, out_path)
        if sys.argv[i] == '-bcl2_sort':
        data_path = sys.argv[i + 1]
        header_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        bcl2_sort(data_path, header_path, out_path)
        if sys.argv[i] == '-design_list':
        preset_dir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
        opath = sys.argv[i + 3]
            design_list_calc(preset_dir, seq_path, opath)
        if sys.argv[i] == '-general_design_list':
        preset_dir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
        opath = sys.argv[i + 3]
            general_design_list_calc(preset_dir, seq_path, opath)
        if sys.argv[i] == '-combine_columns':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]
        opath = sys.argv[i + 3]
            combine_columns(f1, f2, opath)
        if sys.argv[i] == '-parse_pfam':
        fpath = sys.argv[i + 1]
        opath = sys.argv[i + 2]
        parse_pfam(fpath, opath)
        if sys.argv[i] == '-sort_pfam':
        ipath = sys.argv[i + 1]
        name = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        sort_pfam(ipath, name, out_path)
        if sys.argv[i] == '-search_pfam':
        fpath = sys.argv[i + 1]
        opath = sys.argv[i + 2]
        search_pfam(fpath, opath)
        if sys.argv[i] == '-convert_counts':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        ref_flag = sys.argv[i + 3]
            convert_counts(counts_dir, out_dir, ref_flag)
        if sys.argv[i] == '-convert_counts_intra':
        preset = sys.argv[i + 1]
        convert_counts_intra(preset)
            if sys.argv[i] == '-convert_counts_local':
                preset = sys.argv[i + 1]
                convert_counts_local(preset)
        if sys.argv[i] == '-convert_counts_sidechain':
        preset = sys.argv[i + 1]
            convert_counts_sidechain(preset)
        if sys.argv[i] == '-convert_countst':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        ref_flag = sys.argv[i + 3]
            convert_countst(counts_dir, out_dir, ref_flag)
        if sys.argv[i] == '-convert_counts_noref':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
            convert_counts_noref(counts_dir, out_dir)
        if sys.argv[i] == '-statium_bind':
            preset_dir = sys.argv[i + 1]
        counts_dir = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
            statium_bind_conversion(preset_dir, counts_dir, out_dir)
        if sys.argv[i] == '-bimref':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        seq_path = sys.argv[i + 3]
            BimRef(counts_dir, out_dir, seq_path)
        if sys.argv[i] == '-convert_statium':
        counts_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
            convert_statium(counts_dir, out_dir)
        if sys.argv[i] == '-design_counts':
        counts_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        load_design_counts(counts_path, out_path)
        if sys.argv[i] == '-spot_exclude':
        SPOT_exluded_residues()
        if sys.argv[i] == '-bcl2_char':
        preset_list = sys.argv[i + 1]
            bcl2_character(preset_list)
        if sys.argv[i] == '-spot_compare':
        pdir1 = sys.argv[i + 1]
        pdir2 = sys.argv[i + 2]
        data_path = sys.argv[i + 3]
        r1 = sys.argv[i + 4]
        r2 = sys.argv[i + 5]
            SPOT_comparison(pdir1, pdir2, data_path, r1, r2)
        if sys.argv[i] == '-spot360_compare':
        pdir1 = sys.argv[i + 1]
        pdir2 = sys.argv[i + 2]
        data_path = sys.argv[i + 3]
        r1 = sys.argv[i + 4]
        r2 = sys.argv[i + 5]
            SPOT360_comparison(pdir1, pdir2, data_path, r1, r2)
        if sys.argv[i] == '-pcolor':
        fpath = sys.argv[i + 1]
        lpath = sys.argv[i + 2]
            pcoloring(fpath, lpath)
        if sys.argv[i] == '-parse_yeast2':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]
        f3 = sys.argv[i + 3]
        parse_yeast2(f1, f2, f3)
        if sys.argv[i] == '-parse_yeast':
        f1 = sys.argv[i + 1]
        f2 = sys.argv[i + 2]
        f3 = sys.argv[i + 3]
        out_path = sys.argv[i + 4]
            parse_yeast(f1, f2, f3, out_path)
        if sys.argv[i] == '-yeast':
            yeast_data_analysis()
        if sys.argv[i] == '-sequence_search':
        preset_dir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
            sequence_library_energy_search(preset_dir, seq_path)
        if sys.argv[i] == '-bh3_mode':
            BH3_mode()
        if sys.argv[i] == '-sequence_scan':
        preset_dir = sys.argv[i + 1]
        seq_path = sys.argv[i + 2]
            sequence_energy_scan(preset_dir, seq_path)
        if sys.argv[i] == '-design_energy':
            design_energy_calc()
        if sys.argv[i] == '-natural_pssm':
            natural_pssm()
        if sys.argv[i] == '-entropy':
        path1 = sys.argv[i + 1]
        path2 = sys.argv[i + 2]
            bcl2_entropy_plots(path1, path2)
        if sys.argv[i] == '-parse_sanjib':
        in_path = sys.argv[i + 1]
        parse_sanjib_lib(in_path)
        if sys.argv[i] == '-sequence_entropy':
        in_path = sys.argv[i + 1]
        sequence_entropy(in_path)
        if sys.argv[i] == '-coyote':
        cmd_path = sys.argv[i + 1]
        name_path = sys.argv[i + 2]
        cmd_lines = readlines(cmd_path)
        cmd = ''
        for line in cmd_lines: cmd += line
        coyote_job(cmd, str(random.randint(0, 100000)))
        if sys.argv[i] == '-model_bcl2':
        wt_pdb_path = sys.argv[i + 1]
        res_path = sys.argv[i + 2]
        data_path = sys.argv[i + 3]
        model_bcl2(wt_pdb_path, res_path, data_path)
        if sys.argv[i] == '-bcl2_spec':
        data1_path = sys.argv[i + 1]
        data2_path = sys.argv[i + 2]
        bcl2_specificity(data1_path, data2_path)
        if sys.argv[i] == '-automodel':
            fasta_path = sys.argv[i + 1]
        pdb_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        break_pos = int(sys.argv[i + 4])
            sequence = readline(fasta_path, 2)
            modeller_automodel(sequence, pdb_path, out_path, break_pos)
        if sys.argv[i] == '-clear_dir':
            dir_path = sys.argv[i + 1]
            ClearDirectory(dir_path)
        if sys.argv[i] == '-update_refine_status':
        update_refine_job_status()
        if sys.argv[i] == '-aa_comp':
        AA_comp()
        if sys.argv[i] == '-coil_orient':
            coil_orient()
        if sys.argv[i] == '-refine_ssq':
        pdb_path = sys.argv[i + 1]
        print get_refine_ssq(pdb_path)
        if sys.argv[i] == '-run_refine':
        rand_label = sys.argv[i + 1]
        run_refine(rand_label)
        if sys.argv[i] == '-submit_design':
        preset_dir = sys.argv[i + 1]
        pdb_path = sys.argv[i + 2]
        seqdata_path = sys.argv[i + 3]
        param_path = sys.argv[i + 4]
        submit_dir = sys.argv[i + 5]
        submit_design(preset_dir, pdb_path, seqdata_path, param_path, submit_dir)
        if sys.argv[i] == '-bayes_preset':
        preset_dir = sys.argv[i + 1]
        pdb_path = sys.argv[i + 2]
        seqdata_path = sys.argv[i + 3]
        param_path = sys.argv[i + 4]
        out_path = sys.argv[i + 5]
        bayesian_preset(preset_dir, pdb_path, seqdata_path, param_path, out_path)
        if sys.argv[i] == '-spot_analysis':
            preset_dir = sys.argv[i + 1]
        pdb_path = sys.argv[i + 2]
        seq_path = sys.argv[i + 3]
        res_path = sys.argv[i + 4]
        data_path = sys.argv[i + 5]
        out_path = sys.argv[i + 6]
        data_ref = int(sys.argv[i + 7])
        SPOT_analysis(preset_dir, pdb_path, seq_path, res_path, data_path, out_path, data_ref)
        if sys.argv[i] == '-parse_data':
        path1 = sys.argv[i + 1]
        path2 = sys.argv[i + 2]
        parse_data(path1, path2)
        if sys.argv[i] == '-plot_helix':
        plot_helix()
            if sys.argv[i] == '-bayesian_ppdesign':
            pdb_path = sys.argv[i + 1]
        seqdata_path = sys.argv[i + 2]
        bayesian_design_psi_phi(pdb_path, seqdata_path)
        if sys.argv[i] == '-bayesian_design':
        pdb_path = sys.argv[i + 1]
        seqdata_path = sys.argv[i + 2]
        bayesian_design(pdb_path, seqdata_path)
        if sys.argv[i] == '-design':
        preset_dir = sys.argv[i + 1]
        residue_specific_design(preset_dir)
        if sys.argv[i] == '-statium':
        preset_dir = sys.argv[i + 1]
        seqdata_list = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        num = sys.argv[i + 4]
        statium(preset_dir, seqdata_list, out_dir, num)
        if sys.argv[i] == '-statium_sidechain':
        preset_dir = sys.argv[i + 1]
        pdb_paths = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        num = sys.argv[i + 4]
        statium_sidechain(preset_dir, pdb_paths, out_dir, num)
        if sys.argv[i] == '-statium_sidechain_intrapep':
        preset_dir = sys.argv[i + 1]
        pdb_paths = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        num = sys.argv[i + 4]
        statium_sidechain_intrapep(preset_dir, pdb_paths, out_dir, num)
        if sys.argv[i] == '-statium_sidechain_local':
        preset_dir = sys.argv[i + 1]
        pdb_paths = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        num = sys.argv[i + 4]
        statium_sidechain_local(preset_dir, pdb_paths, out_dir, num)
        if sys.argv[i] == '-statiumt':
        preset_dir = sys.argv[i + 1]
        seqdata_list = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        num = sys.argv[i + 4]
        statiumt(preset_dir, seqdata_list, out_dir, num)
        if sys.argv[i] == '-statium_coyote':
        preset = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        runf = sys.argv[i + 3]
        ns = int(sys.argv[i + 4])
                statium_coyote(preset, out_dir, runf, ns, sys.argv[0])
        if sys.argv[i] == '-build_statium':
        preset = sys.argv[i + 1]
                statium_sidechain_coyote(preset, 'REG', 5000, sys.argv[0])
                statium_sidechain_coyote_compile(preset)
        convert_counts_sidechain(preset)
        if sys.argv[i] == '-statium_intrapep_coyote':
        preset = sys.argv[i + 1]
        runf = sys.argv[i + 2]
        ns = int(sys.argv[i + 3])
                statium_intrapep_coyote(preset, runf, ns, sys.argv[0])
        if sys.argv[i] == '-build_statium_local':
        preset = sys.argv[i + 1]
                statium_local_coyote(preset, 'REG', 1000, sys.argv[0])
        if sys.argv[i] == '-statium_compile_matrix':
        preset = sys.argv[i + 1]
                statium_coyote_compile(preset)
        if sys.argv[i] == '-compile_statium':
        preset = sys.argv[i + 1]
                statium_sidechain_coyote_compile(preset)
        convert_counts_sidechain(preset)
        if sys.argv[i] == '-statium_coyote_compilet':
        compile_dir = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
                statium_coyote_compilet(compile_dir, out_dir)
        if sys.argv[i] == '-vector_angle':
        print math.degrees(vector_angle())
        if sys.argv[i] == '-casp_search':
        casp_search()
        if sys.argv[i] == '-unzip_pdb':
        unzip_pdb()
            if sys.argv[i] == '-neighbor_prob':
        neighbor_probability()
            if sys.argv[i] == '-helix_pos_prob':
        helix_position_prob()
        if sys.argv[i] == '-plot_tsp_record':
        plot_tsp_records()
        if sys.argv[i] == '-pdb_get_info':
        pdb_path = sys.argv[i + 1]
        print PDB_get_info(pdb_path)
        if sys.argv[i] == '-mass_frags':
        fasta_path = sys.argv[i + 1]
        mass_spec_analysis(fasta_path)
        if sys.argv[i] == '-run_platinum':
            run_tsp_platinum()
        if sys.argv[i] == '-tsp_platinum':
        pdb_path = sys.argv[i + 1]
        tsp_path = sys.argv[i + 2]
            TSP_platinum(pdb_path, tsp_path)
        if sys.argv[i] == '-pdb_info':
        pdb_path = sys.argv[i + 1]
        seqdata_path = sys.argv[i + 2]
        pdb_info(pdb_path, seqdata_path)
        if sys.argv[i] == '-tsp_records':
        tsp_records()
        if sys.argv[i] == '-tsp_records_scatter':
        tsp_records_scatter()
        if sys.argv[i] == '-noops_energy_sort':
        in_path = sys.argv[i + 1]
        noops_energy_sort(in_path)
        if sys.argv[i] == '-noops_energy':
        log_path = sys.argv[i + 1]
        noops_log_energy(log_path)
        if sys.argv[i] == '-noops':
        start_path = sys.argv[i + 1]
        number = int(sys.argv[i + 2])
        noops(start_path, number)
        if sys.argv[i] == '-run_noops':
        start_path = sys.argv[i + 1]
        run_noops(start_path)
        if sys.argv[i] == '-process_topologies':
        traj_path = sys.argv[i + 1]
        energy_path = sys.argv[i + 2]
        rmsd_path = sys.argv[i + 3]
        process_toplogies(traj_path, energy_path, rmsd_path)
        if sys.argv[i] == '-phi_psi_diff':
        pred_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        position_phi_psi_diff(pred_path, native_path)
        if sys.argv[i] == '-max_sasa':
        max_SASA()
        if sys.argv[i] == '-comp_sim':
        matrix_path = sys.argv[i + 1]
        fasta_path = sys.argv[i + 2]
        compare_similarity(matrix_path, fasta_path)
        if sys.argv[i] == '-sblast':
        blast_path = sys.argv[i + 1]
        search_blast(blast_path)
        if sys.argv[i] == '-blastp':
        fasta_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
                blast(fasta_path, out_path)
        if sys.argv[i] == '-error_plots':
        in_dir = sys.argv[i + 1]
        dssp_path = sys.argv[i + 2]
        error_plots(in_dir, dssp_path)
        if sys.argv[i] == '-position_error':
        pred_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        CA_dist_error(pred_path, native_path)
        if sys.argv[i] == '-cluster_SecStr':
        cluster_path = sys.argv[i + 1]
        cluster_int = int(sys.argv[i + 2])        
        cluster_SecStr(cluster_path, cluster_int)
        if sys.argv[i] == '-cluster_std':
        cluster_path = sys.argv[i + 1]
        cluster_int = int(sys.argv[i + 2])    
        cluster_std(cluster_path, cluster_int)
        if sys.argv[i] == '-rmsd':
        pdb1_path = sys.argv[i + 1]
        pdb2_path = sys.argv[i + 2]
        print rmsd(pdb1_path, pdb2_path)
        if sys.argv[i] == '-coyote_rmsd':
        pdb1_path = sys.argv[i + 1]
        pdb2_path = sys.argv[i + 2]
        print coyote_rmsd(pdb1_path, pdb2_path)
        if sys.argv[i] == '-rmsd_error':
        cluster_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        cluster_int = int(sys.argv[i + 3])
        rmsd_error(cluster_path, native_path, cluster_int)
        if sys.argv[i] == '-tot_trimers':
        rama_path = sys.argv[i + 1]
        tot_trimers(rama_path)
        if sys.argv[i] == '-try_count':
        log_dir = sys.argv[i + 1]
        total_radial_tries(log_dir)
        if sys.argv[i] == '-rama_dist_comp':
        rama_dist_comp()
        if sys.argv[i] == '-pcount':
        MSA_path = sys.argv[i + 1]
        Pcount(MSA_path)
        if sys.argv[i] == '-percent_below_plot':
        in_dir = sys.argv[i + 1]
        percent_below_plot(in_dir)
        if sys.argv[i] == '-cluster_analysis':
        dir_path = sys.argv[i + 1]
        cluster_analysis(dir_path)
        if sys.argv[i] == '-parse_clusters':
        clus_dir = sys.argv[i + 1]
        parse_clusters(clus_dir)
        if sys.argv[i] == '-phi_psi_rmsd':
        pdb_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]    
        print PhiPsi_rmsd(pdb_path, native_path)
        if sys.argv[i] == '-michael_unfold':
        fasta_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        Michael_Unfolded(fasta_path, out_path)
        if sys.argv[i] == '-find_hairpin':
        traj_dir = sys.argv[i + 1]
        secseq_path = sys.argv[i + 2]
        find_hairpin(traj_dir, secseq_path)
        if sys.argv[i] == '-log_SecStr':
        log_path = sys.argv[i + 1]
        print SecStr_from_log(log_path)
        if sys.argv[i] == '-switch_core':
        alignment_path = sys.argv[i + 1]
        fasta_path = sys.argv[i + 2]
        sasa_path = sys.argv[i + 3]
        switch_core(alignment_path, fasta_path, sasa_path)
        if sys.argv[i] == '-rama_allowed':
        seqdata_dir = sys.argv[i + 1]
        pickle_path = sys.argv[i + 2]
        rama_allowed(seqdata_dir, pickle_path)
        if sys.argv[i] == '-rama_violations':
        pdb_dir = sys.argv[i + 1]
        pickle_path = sys.argv[i + 2]
        native_path = sys.argv[i + 3]
        rama_violations(pdb_dir, pickle_path, native_path)
            if sys.argv[i] == '-remake_rama':
                in_path = sys.argv[i + 1]
                out_path = sys.argv[i + 2]
            remake_rama_file(in_path, out_path)
            if sys.argv[i] == '-speed_comparison':
                pw_path = sys.argv[i + 1]
                aa1 = sys.argv[i + 2]
        aa2 = sys.argv[i + 3]
        speed_path = sys.argv[i + 4]
        pos1 = sys.argv[i + 5]
        pos2 = sys.argv[i + 6]
        bin_size = sys.argv[i + 7]
        speed_comparison(pw_path, aa1, aa2, speed_path, pos1, pos2, bin_size)
            if sys.argv[i] == '-general_rama':
                seqdata_dir = sys.argv[i + 1]
                pickle_dir = sys.argv[i + 2]
        general_rama_bins(seqdata_dir, pickle_dir)
            if sys.argv[i] == '-omega_probs':
                seqdata_dir = sys.argv[i + 1]
                omega_path = sys.argv[i + 2]
        omega_probs(seqdata_dir, omega_path)
            if sys.argv[i] == '-average_rmsd':
                pred_path = sys.argv[i + 1]
                percent = sys.argv[i + 2]
                average_rmsd(pred_path, percent)
            if sys.argv[i] == '-average_energy':
                pred_path = sys.argv[i + 1]
                percent = sys.argv[i + 2]
                average_energy(pred_path, percent)
            if sys.argv[i] == '-percent_below':
                pred_path = sys.argv[i + 1]
                rmsd_cutoff = sys.argv[i + 2]
                print percent_below(pred_path, rmsd_cutoff)
            if sys.argv[i] == '-psi_phi_violations':
                pdb_path = sys.argv[i + 1]
        psi_phi_violations(pdb_path)
            if sys.argv[i] == '-violations':
                pdb_path = sys.argv[i + 1]
        violations(pdb_path)
            if sys.argv[i] == '-psi_phi_contour':
                aa0 = sys.argv[i + 1]
                aa1 = sys.argv[i + 2]
        gif_path = sys.argv[i + 3]
        data_path = sys.argv[i + 4]
        log_path = sys.argv[i + 5]
        psi_phi_contour_plot_PYLAB(aa0, aa1, gif_path, data_path, log_path)
            if sys.argv[i] == '-psi_phi_rama':
                seqdata_dir = sys.argv[i + 1]
                pickle_dir = sys.argv[i + 2]
        psi_phi_rama_bins(seqdata_dir, pickle_dir)
            if sys.argv[i] == '-predict_strand':
                fasta_path = sys.argv[i + 1]
                par_path = sys.argv[i + 2]
        StrandPredictor(fasta_path, par_path)
            if sys.argv[i] == '-predict_strand_compare':
                native_path = sys.argv[i + 1]
                predict_path = sys.argv[i + 2]
        StrandPredictorCompare(native_path, predict_path)
            if sys.argv[i] == '-predict_strand_speed':
                fasta_path = sys.argv[i + 1]
                par_path = sys.argv[i + 2]
        StrandPredictorSPEED(fasta_path, par_path)
            if sys.argv[i] == '-RCO':
                pdb_path = sys.argv[i + 1]
        print RCO(pdb_path)
            if sys.argv[i] == '-log_minima':
                log_path = sys.argv[i + 1]
        print log_minima(log_path)
            if sys.argv[i] == '-pull_model':
                pdt_path = sys.argv[i + 1]
                model_num = int(sys.argv[i + 2])
                pdb_path = sys.argv[i + 3]
        pull_model(pdt_path, model_num, pdb_path)
            if sys.argv[i] == '-speed_profile':
                alignment_path = sys.argv[i + 1]
                par_path = sys.argv[i + 2]
                pos1 = sys.argv[i + 3]
                pos2 = sys.argv[i + 4]
                atom1 = sys.argv[i + 5]
                atom2 = sys.argv[i + 6]
                bin_size = sys.argv[i + 7]
                gif_path = sys.argv[i + 8]
        DOPE_SPEED_profile(alignment_path, par_path, pos1, pos2, atom1, atom2, bin_size, gif_path)
            if sys.argv[i] == '-speed_sampling':
                alignment_path = sys.argv[i + 1]
                secseq_path = sys.argv[i + 2]
                out_path = sys.argv[i + 3]
        SPEED_sampling_profile(alignment_path, secseq_path, out_path)
            if sys.argv[i] == '-speed_sampling2':
                alignment_path = sys.argv[i + 1]
                prev_secseq_path = sys.argv[i + 2]
        new_secseq_path = sys.argv[i + 3]
        prev_lib_path = sys.argv[i + 4]
                out_path = sys.argv[i + 5]
        SPEED_sampling_profile2(alignment_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path)
            if sys.argv[i] == '-homology_free_sampling':
                fasta_path = sys.argv[i + 1]
                prev_secseq_path = sys.argv[i + 2]
        new_secseq_path = sys.argv[i + 3]
        prev_lib_path = sys.argv[i + 4]
                out_path = sys.argv[i + 5]
        native_path = sys.argv[i + 6]
        homology_free_sampling_profile(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path)
        #rama_maps10x10(out_path, native_path, os.path.split(out_path)[0])
            if sys.argv[i] == '-custom_sub':
                fasta_path = sys.argv[i + 1]
        subs_path = sys.argv[i + 2]
                prev_secseq_path = sys.argv[i + 3]
        new_secseq_path = sys.argv[i + 4]
        prev_lib_path = sys.argv[i + 5]
                out_path = sys.argv[i + 6]
        homology_free_sampling_profile_custom_subs(fasta_path, subs_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path)
            if sys.argv[i] == '-homology_free_sampling_no_sub':
                fasta_path = sys.argv[i + 1]
                prev_secseq_path = sys.argv[i + 2]
        new_secseq_path = sys.argv[i + 3]
        prev_lib_path = sys.argv[i + 4]
                out_path = sys.argv[i + 5]
        homology_free_sampling_profile_no_sub(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path)
            if sys.argv[i] == '-hfree_rama':
                fasta_path = sys.argv[i + 1]
                prev_secseq_path = sys.argv[i + 2]
        new_secseq_path = sys.argv[i + 3]
        prev_lib_path = sys.argv[i + 4]
                out_path = sys.argv[i + 5]
        native_path = sys.argv[i + 6]
        hfree_rama_dist(fasta_path, prev_secseq_path, new_secseq_path, prev_lib_path, out_path)
        rama_maps10x10(out_path, native_path, os.path.split(out_path)[0])
            if sys.argv[i] == '-speed_par':
                profile_path = sys.argv[i + 1]
                probs_out_path = sys.argv[i + 2]
                index_out_path = sys.argv[i + 3]        
        SPEED_sampling_par(profile_path, probs_out_path, index_out_path)
            if sys.argv[i] == '-dope_speed':
                fasta_path = sys.argv[i + 1]
                alignment_path = sys.argv[i + 2]
                par_path = sys.argv[i + 3]
                out_path = sys.argv[i + 4]
        DOPE_SPEED(fasta_path, alignment_path, par_path, out_path)
            if sys.argv[i] == '-histogram':
                data_path = sys.argv[i + 1]
        total_bins = int(sys.argv[i + 2])
        histogram(data_path, total_bins)
            if sys.argv[i] == '-average':
                data_path = sys.argv[i + 1]        
            Average(data_path)
            if sys.argv[i] == '-print_fasta':
                pdb_path = sys.argv[i + 1]
        print FASTA_from_structure(pdb_path)
            if sys.argv[i] == '-phi_psi_verify':
                model_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        out_name = sys.argv[i + 3]
        PhiPsi_verify(model_path, native_path, out_name)
            if sys.argv[i] == '-phi_psi_verify_dir':
                model_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        PhiPsi_verify_dir(model_dir, native_path, out_path)
            if sys.argv[i] == '-assign_SecStr':
                pdb_path = sys.argv[i + 1]
        dssp_out_path = sys.argv[i + 2]
        AssignSecStr(pdb_path, dssp_out_path)
            if sys.argv[i] == '-SASAfromDSSP':
                pdb_path = sys.argv[i + 1]
        SASAfromDSSP(pdb_path)
            if sys.argv[i] == '-burial_energy':
                pdb_path = sys.argv[i + 1]
                res_path = sys.argv[i + 2]
        print buried_apolar_SA(pdb_path, res_path)
            if sys.argv[i] == '-print_dssp':
                pdb_path = sys.argv[i + 1]
        print ReturnDSSP(pdb_path)
            if sys.argv[i] == '-back_renumber':
                back_path = sys.argv[i + 1]
        renumber_path = sys.argv[i + 2]
        back_renumber(back_path, renumber_path)
            if sys.argv[i] == '-renumber':
                pdb_path = sys.argv[i + 1]
        renumber_path = sys.argv[i + 2]
        start_res_num = 1
        start_atom_num = 1
        Renumber(start_res_num, start_atom_num, pdb_path, renumber_path)
        if sys.argv[i] == '-cluster_seq':
            data_path = sys.argv[i + 1]
        cluster_sequences(data_path)
            if sys.argv[i] == '-renumberA':
                pdb_path = sys.argv[i + 1]
        renumber_path = sys.argv[i + 2]
        start_res_num = 1
        start_atom_num = 1
        RenumberChnA(start_res_num, start_atom_num, pdb_path, renumber_path)
            if sys.argv[i] == '-renumberAB':
                pdb_path = sys.argv[i + 1]
        renumber_path = sys.argv[i + 2]
        start_res_num = 1
        start_atom_num = 1
        chainbreak = int(sys.argv[i + 3])
        RenumberChnAB(start_res_num, start_atom_num, pdb_path, renumber_path, chainbreak)
        if sys.argv[i] == '-trj_analysis':
        trj_dir_path = sys.argv[i + 1]
        native_fn = sys.argv[i + 2]
        TrajectoryAnalysis(trj_dir_path, native_fn)
        if sys.argv[i] == '-circ_perm':
        pdb_path = sys.argv[i + 1]
        circ_perm_path = sys.argv[i + 2]
        cut_pos = int(sys.argv[i + 3])
        CircularPermutate(pdb_path, circ_perm_path, cut_pos)
        if sys.argv[i] == '-truncate':
        pdb_path = sys.argv[i + 1]
        truncate_path = sys.argv[i + 2]
        Truncate(pdb_path, truncate_path)
        if sys.argv[i] == '-scwrl':
        final_dir = sys.argv[i + 1]
        side_chain_dir = sys.argv[i + 2]
        AddSideChains(final_dir, side_chain_dir)
        if sys.argv[i] == '-circ_perm_traj':
        traj_path = sys.argv[i + 1]
        circ_perm_traj_path = sys.argv[i + 2]
        cut_pos = int(sys.argv[i + 3])
        CircularPermutateTrajectory(traj_path, circ_perm_traj_path, cut_pos)
        if sys.argv[i] == '-ave_comp':
            matrix_path = sys.argv[i + 1]
        ave_composition(matrix_path)
        if sys.argv[i] == '-SecStr_dir':
            SecStr_consensus_dir = sys.argv[i + 1]
        SecStrConsenus(SecStr_consensus_dir)
        if sys.argv[i] == '-SecStr_align':
            SecStr_align_path = sys.argv[i + 1]
        SecStrAlign(SecStr_align_path)
        if sys.argv[i] == '-split_traj':
            split_trj_path = sys.argv[i + 1]
        split_dir_path = sys.argv[i + 2]
        cluster_out_path = sys.argv[i + 3]
        TrajectoryCluster(split_trj_path, split_dir_path, cluster_out_path)
        if sys.argv[i] == '-contact_compare':
            model1_path = sys.argv[i + 1]
        model2_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        ContactMapComp(model1_path, model2_path, out_path)
        if sys.argv[i] == '-contact_compare_CB':
            model1_path = sys.argv[i + 1]
        model2_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        ContactMapCompCB(model1_path, model2_path, out_path)
        if sys.argv[i] == '-contact_format':
            model1_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        ContactFormat(model1_path, out_path)
        if sys.argv[i] == '-contact_movie':
            traj_path = sys.argv[i + 1]
        model_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        ContactMovie(traj_path, model_path, out_path)
        if sys.argv[i] == '-contact_sequence':
            traj_path = sys.argv[i + 1]
        unit_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        ContactSequencePlot(traj_path, unit_path, out_path)
        if sys.argv[i] == '-average_contact_sequence':
            traj_dir_path = sys.argv[i + 1]
        unit_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]        
        AverageContactSequencePlot(traj_dir_path, unit_path, out_path)
        if sys.argv[i] == '-SecStr_R0':
        SecStr_lib_path = sys.argv[i + 1]
        native_dssp_path = sys.argv[i + 2]
        Round0_SecStr_prediction(native_dssp_path, SecStr_lib_path)
        if sys.argv[i] == '-final_structures':
        in_path = sys.argv[i + 1]
        GetStructures(in_path)
        if sys.argv[i] == '-RG':
        pdb_path = sys.argv[i + 1]
        print RGcalc(pdb_path)
        if sys.argv[i] == '-hydrophobic_RG':
        pdb_path = sys.argv[i + 1]
        print hydrophobic_RGcalc(pdb_path)
        if sys.argv[i] == '-hydrophilic_RG':
        pdb_path = sys.argv[i + 1]
        print hydrophilic_RGcalc(pdb_path)
        if sys.argv[i] == '-RU':
        pdb_path = sys.argv[i + 1]
        print RUcalc(pdb_path)
        if sys.argv[i] == '-CC':
        pdb_path = sys.argv[i + 1]
        print CCcalc(pdb_path)
        if sys.argv[i] == '-RG_scatter':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_path = sys.argv[i + 3]    
        RGScatter(pdb_dir, native_path, gif_path)
        if sys.argv[i] == '-cis_stats':
        pdb_dir = sys.argv[i + 1]        
        CisStats(pdb_dir)
        if sys.argv[i] == '-average_contacts':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_out_path = sys.argv[i + 3]            
        AverageContacts(pdb_dir, native_path, gif_out_path)
        if sys.argv[i] == '-average_contacts_CB':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_out_path = sys.argv[i + 3]    
        AverageContactsCB(pdb_dir, native_path, gif_out_path)
        if sys.argv[i] == '-scatter':
        final_dir = sys.argv[i + 1]
        native_fn = sys.argv[i + 2]        
            StandardScatterPlot(final_dir, native_fn)
        if sys.argv[i] == '-py_scatter':
        data1_path = sys.argv[i + 1]
        data2_path = sys.argv[i + 2]
        title = sys.argv[i + 3]
        x_label = sys.argv[i + 4]
        y_label = sys.argv[i + 5]
        gif_path = sys.argv[i + 6]
            PY_scatterplot(data1_path, data2_path, title, x_label, y_label, gif_path)
        if sys.argv[i] == '-energy_rmsd':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]    
        EnergyRmsdPlot(pdb_dir, native_path)
        if sys.argv[i] == '-rco_rmsd':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_path = sys.argv[i + 3]    
        RCORmsdPlot(pdb_dir, native_path, gif_path)
        if sys.argv[i] == '-ru_rmsd':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_path = sys.argv[i + 3]    
        RUrmsdPlot(pdb_dir, native_path, gif_path)
        if sys.argv[i] == '-RG_sort':
        pdb_dir = sys.argv[i + 1]
        RGsort(pdb_dir)
        if sys.argv[i] == '-SecStr_align_final':
        pdb_dir = sys.argv[i + 1]        
        SecStrAlignFinal(pdb_dir)
        if sys.argv[i] == '-phi_psi_list':
        pdb_path = sys.argv[i + 1]
        phi_psi_path = sys.argv[i + 2]
        AA_path = sys.argv[i + 3]
        label_path = sys.argv[1 + 3]
        phi_psi_list(pdb_path, phi_psi_path, AA_path, label_path)
        if sys.argv[i] == '-contact_sequence_trajectory':
            traj_path = sys.argv[i + 1]
        unit_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        ContactSequencePlotTrajectory(traj_path, unit_path, out_path)
        if sys.argv[i] == '-pathway_analysis':
            traj_dir_path = sys.argv[i + 1]
        unit_path = sys.argv[i + 2]
        native_path = sys.argv[i + 3]
        out_path = sys.argv[i + 4]            
        AveragePathwayPlot(traj_dir_path, unit_path, native_path, out_path)
        if sys.argv[i] == '-hairpin':
            pdb_dir = sys.argv[i + 1]
        secseq_path = sys.argv[i + 2]
        HPContacts(pdb_dir, secseq_path)
        if sys.argv[i] == '-refine':
        process_refine()
        if sys.argv[i] == '-split':
            traj_path = sys.argv[i + 1]
        out_dir = sys.argv[i + 2]
        SplitTrajectory(traj_path, out_dir)
        if sys.argv[i] == '-pathway_order':
            traj_dir_path = sys.argv[i + 1]
        unit_path = sys.argv[i + 2]
        CB_unit_path = sys.argv[i + 3]
        native_path = sys.argv[i + 4]
        out_path = sys.argv[i + 5]
        tm_out_path = sys.argv[i + 6]        
        OrderedPathwayPlot(traj_dir_path, unit_path, CB_unit_path, native_path, out_path, tm_out_path)
        if sys.argv[i] == '-SecStr_plot':
            SecStr_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        SecStrProbsPlot(SecStr_path, out_path)
        if sys.argv[i] == '-tm_score':
            model1_path = sys.argv[i + 1]
        model2_path = sys.argv[i + 2]        
        print TMScore(model1_path, model2_path)    
        if sys.argv[i] == '-tm_average':
            pdb_dir_path = sys.argv[i + 1]    
            native_path = sys.argv[i + 2]
        print AverageTMScore(pdb_dir_path, native_path)
        if sys.argv[i] == '-prediction':
            rmsd_energy_path = sys.argv[i + 1]            
        PredictionStats(rmsd_energy_path)
        if sys.argv[i] == '-tm_rmsd':
            rmsd_energy_path = sys.argv[i + 1]
            native_path = sys.argv[i + 2]
            rmsd_tm_path = sys.argv[i + 3]        
        TMscoreRMSD(rmsd_energy_path, native_path, rmsd_tm_path)
        if sys.argv[i] == '-gdt_plot':
            model_dir = sys.argv[i + 1]
        native_fn = sys.argv[i + 2]        
        GDT(model_dir, native_fn)
        if sys.argv[i] == '-final_structure':
            pdt_path = sys.argv[i + 1]
            pdb_path = sys.argv[i + 2]        
        FinalStructure(pdt_path, pdb_path)
        if sys.argv[i] == '-all_structures':
            trajectories_path = sys.argv[i + 1]
            native_path = sys.argv[i + 2]    
        TotalStructureAnalysis(trajectories_path, native_path)
        if sys.argv[i] == '-homology_average':
            sub_matrix_path = sys.argv[i + 1]    
        HomologyAveSubs(sub_matrix_path)
        if sys.argv[i] == '-SecStr_analysis':
            SecStr_in_dir = sys.argv[i + 1]
        write_secseq = 'N'
        if l > 3:
            if sys.argv[i + 2] == '-write_secseq': write_secseq = 'Y'
        print_probs = 'Y'
        NewSecseq(SecStr_in_dir, write_secseq, print_probs)
        if sys.argv[i] == '-GNU_scatter':
            data_path = sys.argv[i + 1]
            column1 = sys.argv[i + 2]
            column2 = sys.argv[i + 3]
            xminimum = sys.argv[i + 4]        
            xmaximum = sys.argv[i + 5]
            yminimum = sys.argv[i + 6]        
            ymaximum = sys.argv[i + 7]
            xlabel = sys.argv[i + 8]        
            ylabel = sys.argv[i + 9]
            gif_out_path = sys.argv[i + 10]
        GNUPLOT_scatter(data_path, column1, column2, xminimum, xmaximum, yminimum, ymaximum, xlabel, ylabel, gif_out_path)
        if sys.argv[i] == '-SecStr_accuracy':
            Name = sys.argv[i + 1]
        round_sub_dir = sys.argv[i + 2]
        accuracy_path = sys.argv[i + 3]
        SecStrAccuracyFile(Name, round_sub_dir, native_dssp, accuracy_path)
        if sys.argv[i] == '-ItFix_analysis':
            rounds_dir_path = sys.argv[i + 1]
            native_path = sys.argv[i + 2]
            web_dir_path = sys.argv[i + 3]
        ItFixAnalysis(rounds_dir_path, native_path, web_dir_path)
        if sys.argv[i] == '-R0_secseq':
        lib_probs_path = sys.argv[i + 1]
            native_dssp_path = sys.argv[i + 2]
            new_secseq_path = sys.argv[i + 3]
        print_probs = 'Y'
        LibProbsSecseq(native_dssp_path, print_probs, lib_probs_path, new_secseq_path)
        if sys.argv[i] == '-run_oops':
        project_dir = sys.argv[i + 1]
        run_oops(project_dir)
        if sys.argv[i] == '-run_itfix':
        project_dir = sys.argv[i + 1]
        run_itfix(project_dir)
        if sys.argv[i] == '-unfolded':
        process_unfolded()
        if sys.argv[i] == '-rama_bin':
        aa0 = int(sys.argv[i + 1])
        aa1 = int(sys.argv[i + 2])
        aa2 = int(sys.argv[i + 3])
        seqdata_dir = sys.argv[i + 4]
        pickle_dir = sys.argv[i + 5]
        rama_bins(aa0, aa1, aa2, seqdata_dir, pickle_dir)
        if sys.argv[i] == '-rama_script':
        script_dir = sys.argv[i + 1]
        seqdata_dir = sys.argv[i + 2]
        pickle_dir = sys.argv[i + 3]
        rama_script(script_dir, seqdata_dir, pickle_dir)
        if sys.argv[i] == '-cull_matrix':
        matrix_path = sys.argv[i + 1]
        redund_cutoff = sys.argv[i + 2]
        out_matrix_path = sys.argv[i + 3]    
        CullMatrix(matrix_path, redund_cutoff, out_matrix_path)
        if sys.argv[i] == '-rama_contour':
        secseq0 = sys.argv[i + 1]
        secseq1 = sys.argv[i + 2]
        secseq2 = sys.argv[i + 3]
        res = sys.argv[i + 4]
        pickle_path = sys.argv[i + 5]
        gif_out_path = sys.argv[i + 6]
        data_path = sys.argv[i + 7]
        log_path = sys.argv[i + 8]
        rama_contour_plot_PYLAB(secseq0, secseq1, secseq2, res, pickle_path, gif_out_path, data_path, log_path)
        if sys.argv[i] == '-rama_contour_all':
        secseq0 = sys.argv[i + 1]
        secseq1 = sys.argv[i + 2]
        secseq2 = sys.argv[i + 3]
        pickle_path = sys.argv[i + 4]
        gif_path = sys.argv[i + 5]
        data_path = sys.argv[i + 6]
        log_path = sys.argv[i + 7]
        rama_contour_plot_PYLAB_all(secseq0, secseq1, secseq2, 10, pickle_path, gif_path, data_path, log_path)
        if sys.argv[i] == '-rama_maps':
        rama_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]        
        rama_maps10x10(rama_path, native_path, out_path)
        if sys.argv[i] == '-rama_energy':
        rama_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]    
        rama_energy(rama_path, native_path)
        if sys.argv[i] == '-tsp_hist':
        tsp_dir = sys.argv[i + 1]
        out_list_path = sys.argv[i + 2]        
        Histogram_TSP_data(tsp_dir, out_list_path)
        if sys.argv[i] == '-tsp_scatter':
        label_path = sys.argv[i + 1]
        name = sys.argv[i + 2]
        TSP_scatterplot(label_path, name)
        if sys.argv[i] == '-email':
        email_address = sys.argv[i + 1]
        message_path = sys.argv[i + 2]
        subject = sys.argv[i + 3]
        send_email(email_address, message_path, subject)
        if sys.argv[i] == '-scatter_plot':
        data_path = sys.argv[i + 1]
        gif_path = sys.argv[i + 2]
        PYLAB_scatterplot(data_path, gif_path)
        if sys.argv[i] == '-file2string':
        file_path = sys.argv[i + 1]
        print file_to_string(file_path)
        if sys.argv[i] == '-rama_page':
        root_label = sys.argv[i + 1]    
        display_page(rama_comp_str(root_label), root_label, 'test', 'test')
        if sys.argv[i] == '-superpose':
        f1_path = sys.argv[i + 1]
        f2_path = sys.argv[i + 2]        
        superpose_structures(f1_path, f2_path)
        if sys.argv[i] == '-validate':
        pdb1_path = sys.argv[i + 1]
                pdb2_path = sys.argv[i + 2]
        name1 = sys.argv[i + 3]
        name2 = sys.argv[i + 4]
        print StructuresValidation(pdb1_path, pdb2_path, name1, name2)
        if sys.argv[i] == '-print_probs':
        SecStr_path = sys.argv[i + 1]
        SecStr_dssp_path = sys.argv[i + 2]
                old_secseq_path = sys.argv[i + 3]
        new_secseq_path = sys.argv[i + 4]
                dssp_path = sys.argv[i + 5]
        PrintSecStrProbs(SecStr_path, SecStr_dssp_path, old_secseq_path, new_secseq_path, dssp_path)
        if sys.argv[i] == '-new_secseq':
        SecStr_path = sys.argv[i + 1]
        fasta_path = sys.argv[i + 2]
                old_secseq_path = sys.argv[i + 3]
        new_secseq_path = sys.argv[i + 4]
                dssp_path = sys.argv[i + 5]
        new_secseq(SecStr_path, fasta_path, old_secseq_path, new_secseq_path, dssp_path)
        if sys.argv[i] == '-RU_stats':
        list_path = sys.argv[i + 1]        
        RU_stats(list_path)
        if sys.argv[i] == '-mse_to_met':
        pdb_path = sys.argv[i + 1]
                renumber_path = sys.argv[i + 2]
        MSE_to_MET(pdb_path, renumber_path)
        if sys.argv[i] == '-chain_break':
        pdb_path = sys.argv[i + 1]
                out_path = sys.argv[i + 2]
        find_chain_breaks(pdb_path, out_path)
        if sys.argv[i] == '-qsub_dope_speed':
        fasta_path = sys.argv[i + 1]
        alignment_path = sys.argv[i + 2]
                out_dir = sys.argv[i + 3]
        QSUB_DOPE_SPEED(fasta_path, alignment_path, out_dir)
        if sys.argv[i] == '-py_hist':
        data1_path = sys.argv[i + 1]
        data2_path = sys.argv[i + 2]
                gif_path = sys.argv[i + 3]
        pyHistogram(data1_path, data2_path, gif_path)
        if sys.argv[i] == '-R2':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
                gif_path = sys.argv[i + 3]
        EnergyRmsdPlot2Round(pdb_dir, native_path, gif_path)
        if sys.argv[i] == '-consensus_sequence':
        alignment_path = sys.argv[i + 1]
        fasta_path = sys.argv[i + 2]
        subs_path = sys.argv[i + 3]
        consensus_sequence(alignment_path, fasta_path, subs_path)
        if sys.argv[i] == '-total_rmsd':
        trj_dir_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]        
        TotalRMSDAnalysis(trj_dir_path, native_path)
        if sys.argv[i] == '-lowest_rmsd':
        rmsd_path = sys.argv[i + 1]
        lowest_rmsd(rmsd_path)
        if sys.argv[i] == '-hydro_sphere':
        pdb_path = sys.argv[i + 1]
        print hydro_sphere(pdb_path)
        if sys.argv[i] == '-hydro_sphere_dir':
        pdb_dir = sys.argv[i + 1]
        hydro_sphere_dir(pdb_dir)
        if sys.argv[i] == '-general_color_scatterplot':
        data1_path = sys.argv[i + 1]
        data2_path = sys.argv[i + 2]
        data3_path = sys.argv[i + 3]
        name = sys.argv[i + 4]
        gif_path = sys.argv[i + 5]
        general_color_scatterplot(data1_path, data2_path, data3_path, name, gif_path)
        if sys.argv[i] == '-RG_screen':
        dir1_path = sys.argv[i + 1]
        dir2_path = sys.argv[i + 2]
        RG_screen(dir1_path, dir2_path)
        if sys.argv[i] == '-pyhist':
        data_path = sys.argv[i + 1]
        png_path = sys.argv[i + 2]
        pyhist(data_path, png_path)
        if sys.argv[i] == '-burial_ratio':
        pdb_path = sys.argv[i + 1]
        print burial_ratio(pdb_path)
        if sys.argv[i] == '-burial_count':
        pdb_path = sys.argv[i + 1]
        burial_count(pdb_path)
        if sys.argv[i] == '-radial_analysis':
        pdb_dir = sys.argv[i + 1]
        radial_analysis2(pdb_dir)
        if sys.argv[i] == '-burial_sphere':
        pdb_path = sys.argv[i + 1]
        print burial_sphere(pdb_path)
        if sys.argv[i] == '-hydrophobic_sasa':
        pdb_path = sys.argv[i + 1]        
        print hydrophobic_sasa(pdb_path)
        if sys.argv[i] == '-tree_pack':
        pdb_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]        
        tree_pack(pdb_path, out_path)
        if sys.argv[i] == '-dope_energy_log':
        pred_path = sys.argv[i + 1]        
        DOPE_energy_log(pred_path)
        if sys.argv[i] == '-quick':
        path = sys.argv[i + 1]    
        quick_script(path)
        if sys.argv[i] == '-RG2':
        pdb_path = sys.argv[i + 1]
        print RGcalc2(pdb_path)
        if sys.argv[i] == '-RG3':
        pdb_path = sys.argv[i + 1]
        print RGcalc3(pdb_path)
        if sys.argv[i] == '-thread':
        pdb_path = sys.argv[i + 1]
        sequence_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        thread(pdb_path, sequence_path, out_path)
        if sys.argv[i] == '-quick_prediction':
        pdb_dir = sys.argv[i + 1]
        native_path = sys.argv[i + 2]        
        quick_prediction(pdb_dir, native_path)
        if sys.argv[i] == '-cluster':
        pdb_dir = sys.argv[i + 1]        
        cluster(pdb_dir)
        if sys.argv[i] == '-model_correlation':
        model1_path = sys.argv[i + 1]
        model2_path = sys.argv[i + 2]    
        model_correlation(model1_path, model2_path)
        if sys.argv[i] == '-match':
        pdb_dir = sys.argv[i + 1]    
        match(pdb_dir)
        if sys.argv[i] == '-total_traj':
        final_dir = sys.argv[i + 1]    
        total_traj(final_dir)
        if sys.argv[i] == '-br':
        pdb_path = sys.argv[i + 1]
        BRcalc(pdb_path)
        if sys.argv[i] == '-search_clusters':
        cluster_path = sys.argv[i + 1]        
        search_clusters(cluster_path)
        if sys.argv[i] == '-CC_list':
        pdb_dir = sys.argv[i + 1]    
        CClist(pdb_dir)
        if sys.argv[i] == '-sort_lists':
        pdb_dir = sys.argv[i + 1]    
        SortLists(pdb_dir)
        if sys.argv[i] == '-total_list':
        final_dir = sys.argv[i + 1]
        list_path = sys.argv[i + 2]
        total_traj_list(final_dir, list_path)
        if sys.argv[i] == '-isolated_strand':
        pdb_path = sys.argv[i + 1]
        secseq_path = sys.argv[i + 2]
        print IsolatedStrand(pdb_path, secseq_path)
        if sys.argv[i] == '-list_repeats':
        list_path = sys.argv[i + 1]
        list_repeats(list_path)
        if sys.argv[i] == '-stripH':
        in_path = sys.argv[i + 1]
                out_path = sys.argv[i + 2]
        stripH(in_path, out_path)
        if sys.argv[i] == '-rmsd_matrix':
        in_dir = sys.argv[i + 1]
        rmsd_matrix(in_dir)
        if sys.argv[i] == '-cluster_traj':
        pdb_path = sys.argv[i + 1]
                list_path = sys.argv[i + 2]
        out_path = sys.argv[i + 3]
        cluster_traj(pdb_path, list_path, out_path)
        if sys.argv[i] == '-pred_parse':
        pred_path = sys.argv[i + 1]        
        pred_parse(pred_path)
        if sys.argv[i] == '-distance_matrix_cluster':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])
        distance_matrix_cluster(in_dir, cluster_int)
        if sys.argv[i] == '-cce':
        cce_path = sys.argv[i + 1]
                native_path = sys.argv[i + 2]
        print cluster_contact_energy(cce_path, native_path)
        if sys.argv[i] == '-cluster_cce':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])
        cluster_cce(in_dir, cluster_int)
        if sys.argv[i] == '-cluster_prediction':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])
        cluster_prediction(in_dir, cluster_int)
        if sys.argv[i] == '-choose_directions':
        profile_path = sys.argv[i + 1]
                out_dir = sys.argv[i + 2]
        choose_directions(profile_path, out_dir)
        if sys.argv[i] == '-refine_cluster':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])
        start_int = int(sys.argv[i + 3])
        refine_clusters(in_dir, cluster_int, start_int)
        if sys.argv[i] == '-cluster_ave_rmsd':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])        
        cluster_ave_rmsd(in_dir, cluster_int)
        if sys.argv[i] == '-analyze_refine':
        in_dir = sys.argv[i + 1]        
        cluster_int = int(sys.argv[i + 2])
        pred_path = sys.argv[i + 3]
        analyze_refined_cluster(in_dir, cluster_int, pred_path)
        if sys.argv[i] == '-rama_bar':
        in_dir = sys.argv[i + 1]    
        rama_bar(in_dir)
        if sys.argv[i] == '-cluster_contacts':
        in_dir = sys.argv[i + 1]
                native_path = sys.argv[i + 2]
        cluster_contacts(in_dir, native_path)
        if sys.argv[i] == '-cluster_contacts2':
        in_dir = sys.argv[i + 1]
        cluster_int = int(sys.argv[i + 2])
                native_path = sys.argv[i + 3]
        cluster_contacts2(in_dir, cluster_int, native_path)
        if sys.argv[i] == '-cond_msa':
        alignment_path = sys.argv[i + 1]
        pos0 = int(sys.argv[i + 2]) - 1
        pos1 = int(sys.argv[i + 3]) - 1
                aa_str = sys.argv[i + 4]
        conditional_MSA(alignment_path, pos0, pos1, aa_str)
        if sys.argv[i] == '-msa_contacts':
        alignment_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        gif_path = sys.argv[i + 3]
        MSA_contacts(alignment_path, native_path, gif_path)
        if sys.argv[i] == '-pos_bar':
        hfree_rama_path = sys.argv[i + 1]
        speed_rama_path = sys.argv[i + 2]
        native_path = sys.argv[i + 3]
        fasta_path = sys.argv[i + 4]
        dssp_path = sys.argv[i + 5]
        out_path = sys.argv[i + 6]
        pos_bar(hfree_rama_path, speed_rama_path, native_path, fasta_path, dssp_path, out_path)
        if sys.argv[i] == '-fold_pos_bar':
        model_dir = sys.argv[i + 1]
        speed_rama_path = sys.argv[i + 2]
        native_path = sys.argv[i + 3]
        fasta_path = sys.argv[i + 4]
        dssp_path = sys.argv[i + 5]
        out_path = sys.argv[i + 6]
        fold_pos_bar(model_dir, speed_rama_path, native_path, fasta_path, dssp_path, out_path)
        if sys.argv[i] == '-radial_stats':
        log_dir = sys.argv[i + 1]
        radial_stats(log_dir)
        if sys.argv[i] == '-bmk_contacts':
        pdb_path = sys.argv[i + 1]
        gif_path = sys.argv[i + 2]
        name = sys.argv[i + 3]
        BMK_contacts(pdb_path, gif_path, name)
        if sys.argv[i] == '-rama_hist':
        gif_path = sys.argv[i + 1]
        rama_hist(gif_path)
        if sys.argv[i] == '-bottom_half':
        pdb_dir = sys.argv[i + 1]
        secseq_path = sys.argv[i + 2]
        bottom_half(pdb_dir, secseq_path)
        if sys.argv[i] == '-energy_distribution':
        pred_path = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        N_std = float(sys.argv[i + 3])
        energy_distribution(pred_path, out_path, N_std)
        if sys.argv[i] == '-bfactor_subs':
        pdb_path = sys.argv[i + 1]
        pdb_out_path = sys.argv[i + 2]
        subs_data_path = sys.argv[i + 3]
        BFactorSubstitution(pdb_path, pdb_out_path, subs_data_path)
        if sys.argv[i] == '-rama_AA':
        seqdata_dir = sys.argv[i + 1]
        rama_bins_AA1(seqdata_dir)
        if sys.argv[i] == '-psi_phi_rama_maps':
        fasta_path = sys.argv[i + 1]
        native_path = sys.argv[i + 2]
        out_dir = sys.argv[i + 3]
        psi_phi_rama_maps(fasta_path, native_path, out_dir)
        if sys.argv[i] == '-smitfix':
        pdb_dir = sys.argv[i + 1]
        out_path = sys.argv[i + 2]
        smitfix(pdb_dir, out_path)
        if sys.argv[i] == '-native_contacts':
        native_path = sys.argv[i + 1]
        native_contacts(native_path)
        if sys.argv[i] == '-dope_cb_profile':
        par_path = sys.argv[i + 1]
        aa1 = sys.argv[i + 2]
        aa2 = sys.argv[i + 3]
        atom1 = sys.argv[i + 4]
        atom2 = sys.argv[i + 5]
        aa11 = sys.argv[i + 6]
        aa12 = sys.argv[i + 7]
        atom11 = sys.argv[i + 8]
        atom12 = sys.argv[i + 9]
        DOPE_CB_PROFILE(par_path, aa1, aa2, atom1, atom2, aa11, aa12, atom11, atom12)
        if sys.argv[i] == '-dope_pw_profile':
        par_path = sys.argv[i + 1]
        aa1 = sys.argv[i + 2]
        aa2 = sys.argv[i + 3]
        atom1 = sys.argv[i + 4]
        atom2 = sys.argv[i + 5]
        aa11 = sys.argv[i + 6]
        aa12 = sys.argv[i + 7]
        atom11 = sys.argv[i + 8]
        atom12 = sys.argv[i + 9]
        DOPE_PW_PROFILE(par_path, aa1, aa2, atom1, atom2, aa11, aa12, atom11, atom12)
        if sys.argv[i] == '-cd_plot':
        x1 = sys.argv[i + 1]
        y1 = sys.argv[i + 2]
        x2 = sys.argv[i + 3]
        y2 = sys.argv[i + 4]
        x3 = sys.argv[i + 5]
        y3 = sys.argv[i + 6]
        CD_PLOT(x1, y1, x2, y2, x3, y3)
       
main()
